---
title: PHP基础整理（PHP手册版）
date: 2018-01-31 17:45:30
categories:
- PHP
tags:
- PHP知识点
- PHP
---
#### PHP概述：
PHP（“PHP: Hypertext Preprocessor”，超文本预处理器的字母缩写）是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML中，尤其适合 web 开发。
PHP常用于服务端脚本和命令行脚本。
服务端脚本。是 PHP 最传统，也是最主要的目标领域。开展这项工作需要具备以下三点：PHP 解析器（CGI 或者服务器模块）、web 服务器和 web 浏览器。需要在运行 web 服务器时，安装并配置 PHP，然后，可以用 web 浏览器来访问 PHP 程序的输出，即浏览服务端的 PHP 页面。一般做 web 开发和 api 开发。
命令行脚本。可以编写一段 PHP 脚本，并且不需要任何服务器或者浏览器来运行它。通过这种方式，仅仅只需要 PHP 解析器来执行。这种用法对于依赖 cron（Unix 或者 Linux 环境）或者 Task Scheduler（Windows 环境）的日常运行的脚本来说是理想的选择。这些脚本也可以用来处理简单的文本。
<!--more-->

#### 基础语法：
##### 1、PHP标记：
普通：<?php ?> 
短标记：<? ?> 通过 php.ini 配置中的 short_open_tag 开启即可。

##### 2、注释
单行：//
多行：/*  */

##### 3、变量
###### （1）基础
PHP 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。
变量名与 PHP 中其它的标签一样遵循相同的规则。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。

变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。
PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用（换言之，"成为其别名" 或者 "指向"）了原始变量。改动新的变量将影响到原始变量，反之亦然。 
使用引用赋值，简单地将一个 & 符号加到将要赋值的变量前（源变量）。

虽然在 PHP 中并不需要初始化变量，但对变量进行初始化是个好习惯。未初始化的变量具有其类型的默认值 - 布尔类型的变量默认值是 FALSE，整形和浮点型变量默认值是零，字符串型变量（例如用于 echo 中）默认值是空字符串以及数组变量的默认值是空数组。 

###### （2）变量范围：
变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的 PHP 变量只有一个单独的范围。这个单独的范围跨度同样包含了 include 和 require 引入的文件。

局部变量：局部函数内部的变量将被限制在局部函数范围内。
全局变量：PHP 中全局变量在函数中使用时必须声明为 global。
超全局变量：PHP自定义特殊的数组。$GLOBALS、$_POST、$_GET、$_REQUEST、$_COOKIE。
静态变量：静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。

###### （3）可变变量：
有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置，例如： 
```
<?php
$a = 'hello';
?> 
```

一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。在上面的例子中 hello 使用了两个美元符号（$）以后，就可以作为一个可变变量的变量了。例如： 

```
<?php
$$a = 'world';
?> 
```

这时，两个变量都被定义了：$a 的内容是"hello"并且 $hello 的内容是"world"。

要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下 $$a[1] 时，解析器需要知道是想要 $a[1] 作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 [1] 的值。解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1]。 
类的属性也可以通过可变属性名来访问。可变属性名将在该调用所处的范围内被解析。例如，对于 $foo->$bar 表达式，则会在本地范围来解析 $bar 并且其值将被用于 $foo 的属性名。对于 $bar 是数组单元时也是一样。 
也可使用花括号来给属性名清晰定界。最有用是在属性位于数组中，或者属性名包含有多个部分或者属性名包含有非法字符时。
**（注意，在 PHP 的函数和类的方法中，超全局变量不能用作可变变量。$this 变量也是一个特殊变量，不能被动态引用。）**


##### 5、常量
常量是一个简单值的标识符（名字）。如同其名称所暗示的，在脚本执行期间该值不能改变（除了所谓的魔术常量，它们其实不是常量）。常量默认为大小写敏感。传统上常量标识符总是大写的。 
常量名和其它任何 PHP 标签遵循同样的命名规则。合法的常量名以字母或下划线开始，后面跟着任何字母，数字或下划线。
###### （1）语法
可以用 define() 函数来定义常量，在 PHP 5.3.0 以后，可以使用 const 关键字在类定义之外定义常量。一个常量一旦被定义，就不能再改变或者取消定义。如果只想检查是否定义了某常量，用 defined() 函数。

常量只能包含标量数据（boolean，integer，float 和 string）。可以定义 resource 常量，但应尽量避免，因为会造成不可预料的结果。 

可以简单的通过指定其名字来取得常量的值，与变量不同，不应该在常量前面加上 $ 符号。如果常量名是动态的，也可以用函数 constant() 来获取常量的值。用 get_defined_constants() 可以获得所有已定义的常量列表。 
**（注: 常量和（全局）变量在不同的名字空间中。这意味着例如 TRUE 和 $TRUE 是不同的。）**

如果使用了一个未定义的常量，PHP 假定想要的是该常量本身的名字，如同用字符串调用它一样（CONSTANT 对应 "CONSTANT"）。此时将发出一个 E_NOTICE 级的错误。参见手册中为什么 $foo[bar] 是错误的（除非事先用 define() 将 bar 定义为一个常量）。 

**常量和变量有如下不同： **
* 常量前面没有美元符号（$）；  
* 常量只能用 define() 函数定义，而不能通过赋值语句；  
* 常量可以不用理会变量的作用域而在任何地方定义和访问；  
* 常量一旦定义就不能被重新定义或者取消定义；  
* 常量的值只能是标量。

**define() 与 const 区别：**
和使用 define() 来定义常量相反的是，使用 const 关键字定义常量必须处于最顶端的作用区域，因为用此方法是在编译时定义的。这就意味着不能在函数内，循环内以及 if 语句之内用 const 来定义常量。

###### （2）魔术常量
PHP 向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。 
有八个魔术常量它们的值随着它们在代码中的位置改变而改变。例如 __LINE__ 的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下： 

几个 PHP 的"魔术常量"
<style type="text/css">
	table th:first-of-type{
		width: 100px;
	}
</style>

名称                 |             说明
---------------------|----------------------------
__LINE__    |  文件中的当前行号。  
__FILE__    |  文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，__FILE__ 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。  
__DIR__     |  文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(__FILE__)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增） =  
__FUNCTION__ | 函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。  
__CLASS__   |  类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 __CLASS__ 对 trait 也起作用。当用在 trait 方法中时，__CLASS__ 是调用 trait 方法的类的名字。  
__TRAIT__   |  Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4 起此常量返回 trait 被定义时的名字（区分大小写）。Trait 名包括其被声明的作用区域（例如 Foo\Bar）。  
__METHOD__  |  类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。  
__NAMESPACE__ | 当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。 


##### 6、运算符
运算符优先级

结合方向  |   运算符        |            附加信息
----------|-----------------|-------------------------------------
无        |  clone new      |            clone 和 new 
左        |   [             |            array() 
右        |   **            |            算术运算符 
右        |  ++ -- ~ (int) (float) (string) (array) (object) (bool) @  |  类型和递增／递减  
无        |  instanceof     |             类型  
右        | !               |    逻辑运算符  
左        | * / %           |    算术运算符  
左        | + - .           |    算术运算符和字符串运算符 
左        | << >>           |    位运算符  
无        | < <= > >=       |    比较运算符  
无        | == != === !== <> <=>  | 比较运算符  
左        | &               |  位运算符和引用 
左        | ^               |  位运算符  
左        | &#124;               |  位运算符  
左        | &&              |  逻辑运算符  
左        | &#124;&#124;              |  逻辑运算符  
左        | ??              |  比较运算符  
左        | ? :             |     ternary  
右        | = += -= *= **= /= .= %= &= &#124;= ^= <<= >>=  |  赋值运算符  
左        | and             |  逻辑运算符  
左        | xor             |  逻辑运算符  
左        | or              |  逻辑运算符  


##### 7、流程控制
###### （1）条件判断
**if语句：**
单分支if语句：if(){}else{}
多分支if语句：if(){}elseif(){}else{}
分支嵌套语句：if(){if(){}}else{}

**switch语句：**
switch(expr){
	case 0:
		statement
		break;
	case 1:
		statement
		break;
	default:
		statement
		break;
}

###### （2）循环判断
**for循环：**
for(expr1; expr2; expr3){
	
}

**foreach循环：**
仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。
foreach(array_expression as $value){
	statement
}
foreach(array_expression as $key=>$value){
	statement
}

**while循环：**
while(){
	
}

**do-while循环：**
do{
	
}while();

###### （3）中止语句
跳出循环语句：break;
跳出本次循环，执行下一个循环：continue;
结束函数的执行并将它的值返回：return;

###### （4）加载语句
require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include 只产生警告（E_WARNING），脚本会继续运行。 
require：
include：
唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。
require_once：
include_once：