---
title: Flask 基础模块 - 数据库概述
date: 2018-03-05 16:02:31
categories: 
 - Python
 - Flask
tags:
- Flask
- Python
---
数据库按照一定规则保存程序数据，程序再发起查询取回所需的数据。Web 程序最常用基于关系模型的数据库，这种数据库也称为SQL 数据库，因为它们使用结构化查询语言。不过最近几年文档数据库和键值对数据库成了流行的替代选择，这两种数据库合称NoSQL数据库。

#### 1、SQL数据库
关系型数据库把数据存储在表中，表模拟程序中不同的实体。例如，订单管理程序的数据库中可能有表customers、products 和orders。
<!--more-->
表的列数是固定的，行数是可变的。列定义表所表示的实体的数据属性。例如，customers表中可能有name、address、phone 等列。表中的行定义各列对应的真实数据。

表中有个特殊的列，称为主键，其值为表中各行的唯一标识符。表中还可以有称为外键的列，引用同一个表或不同表中某行的主键。行之间的这种联系称为关系，这是关系型数据库模型的基础。

图5-1 展示了一个简单数据库的关系图。这个数据库中有两个表，分别存储用户和用户角色。连接两个表的线代表两个表之间的关系。
![](/uploads/2018/03/flask_database_sql.JPG '图5-1　关系型数据库示例')

在这个数据库关系图中，roles 表存储所有可用的用户角色，每个角色都使用一个唯一的id 值（即表的主键）进行标识。users 表包含用户列表，每个用户也有唯一的id 值。除了id 主键之外，roles 表中还有name 列，users 表中还有username 列和password 列。users表中的role_id 列是外键，引用角色的id，通过这种方式为每个用户指定角色。

从这个例子可以看出，关系型数据库存储数据很高效，而且避免了重复。将这个数据库中的用户角色重命名也很简单，因为角色名只出现在一个地方。一旦在roles 表中修改完角色名，所有通过role_id 引用这个角色的用户都能立即看到更新。

但从另一方面来看，把数据分别存放在多个表中还是很复杂的。生成一个包含角色的用户列表会遇到一个小问题，因为在此之前要分别从两个表中读取用户和用户角色，再将其联结起来。关系型数据库引擎为联结操作提供了必要的支持。

#### 2、NoSQL数据库
所有不遵循上节所述的关系模型的数据库统称为NoSQL 数据库。NoSQL 数据库一般使用集合代替表，使用文档代替记录。NoSQL 数据库采用的设计方式使联结变得困难，所以大多数数据库根本不支持这种操作。对于结构如图5-1 所示的NoSQL 数据库，若要列出各用户及其角色，就需要在程序中执行联结操作，即先读取每个用户的role_id，再在roles表中搜索对应的记录。

NoSQL 数据库更适合设计成如图5-2 所示的结构。这是执行反规范化操作得到的结果，它减少了表的数量，却增加了数据重复量。
![](/uploads/2018/03/flask_database_nosql.JPG '图5-2　NoSQL 数据库示例')

这种结构的数据库要把角色名存储在每个用户中。如此一来，将角色重命名的操作就变得很耗时，可能需要更新大量文档。

使用NoSQL 数据库当然也有好处。数据重复可以提升查询速度。列出用户及其角色的操作很简单，因为无需联结。

#### 3、使用SQL还是使用NoSQL
SQL 数据库擅于用高效且紧凑的形式存储结构化数据。这种数据库需要花费大量精力保证数据的一致性。NoSQL 数据库放宽了对这种一致性的要求，从而获得性能上的优势。

对不同类型数据库的全面分析、对比待续。对中小型程序来说，SQL 和NoSQL数据库都是很好的选择，而且性能相当。

#### 4、Python数据库框架
大多数的数据库引擎都有对应的Python 包，包括开源包和商业包。Flask 并不限制你使用何种类型的数据库包，因此可以根据自己的喜好选择使用MySQL、Postgres、SQLite、Redis、MongoDB 或者CouchDB。

如果这些都无法满足需求，还有一些数据库抽象层代码包供选择，例如SQLAlchemy 和MongoEngine。你可以使用这些抽象包直接处理高等级的Python 对象，而不用处理如表、文档或查询语言此类的数据库实体。

选择数据库框架时，你要考虑很多因素。

**易用性**
如果直接比较数据库引擎和数据库抽象层，显然后者取胜。抽象层，也称为对象关系映射（Object-Relational Mapper，ORM） 或对象文档映射（Object-Document Mapper，ODM），在用户不知觉的情况下把高层的面向对象操作转换成低层的数据库指令。

**性能**
ORM 和ODM 把对象业务转换成数据库业务会有一定的损耗。大多数情况下，这种性能的降低微不足道，但也不一定都是如此。一般情况下，ORM 和ODM 对生产率的提升远远超过了这一丁点儿的性能降低，所以性能降低这个理由不足以说服用户完全放弃ORM 和ODM。真正的关键点在于如何选择一个能直接操作低层数据库的抽象层，以防特定的操作需要直接使用数据库原生指令优化。

**可移植性**
选择数据库时，必须考虑其是否能在你的开发平台和生产平台中使用。例如，如果你打算利用云平台托管程序，就要知道这个云服务提供了哪些数据库可供选择。
可移植性还针对ORM 和ODM。尽管有些框架只为一种数据库引擎提供抽象层，但其他框架可能做了更高层的抽象，它们支持不同的数据库引擎，而且都使用相同的面向对象接口。SQLAlchemy ORM 就是一个很好的例子，它支持很多关系型数据库引擎，包括流行的MySQL、Postgres 和SQLite。

**FLask集成度**
选择框架时，你不一定非得选择已经集成了Flask 的框架，但选择这些框架可以节省你编写集成代码的时间。使用集成了Flask 的框架可以简化配置和操作，所以专门为Flask 开发的扩展是你的首选。

基于以上因素，选择使用的数据库框架是Flask-SQLAlchemy（http://pythonhosted.org/Flask-SQLAlchemy/），这个Flask 扩展包装了SQLAlchemy（http://www.sqlalchemy.org/）框架。