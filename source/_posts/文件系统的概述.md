---
title: 文件系统的概述
date: 2017-12-26 17:39:48
categories:
- 书籍
- 《鸟哥的Linux私房菜基础篇（第三版）》
tags:
- 书籍
- 计算机系统
---
由此文Get到的知识点：
inode 是什么？
　　记录档案的号码。
inode 有什么作用？
　　记录档案的属性，一个档案占用一个inode，同时记录此档案的数据所在的block号码（通过inode可查找block的位置）。通过`ls -i`指令可查询到档案对应的inode号码。
block 是什么？
　　存储档案内容的内存块，且每块block都对应一个号码。支持的block大小有1k、2k和4k。
block 有什么作用？
　　存储档案内容，且如果档案太大，会占用多个block。
<!--more-->
## 一、文件系统特性
我们都知道磁盘分区完毕后还需要进行格式化(format)，之后操作系统才能够使用这个分割槽。为什么需要进行【格式化】呢？这是因为每种操作系统所设定的文件属性/权限并不相同， 为了存放这些档案所需的数据，因此就需要将分割槽进行格式化，以成为操作系统能够利用的【文件系统格式(filesystem)】。

传统的磁盘与文件系统在应用中，一个分割槽就是只能够被格式化成为一个文件系统，所以我们可以说一个 filesystem 就是一个 partition。但是由于新技术的利用，例如我们常听到的LVM 与软件磁盘阵列(software raid)， 这些技术可以将一个分割槽格式化为多个文件系统(例如LVM)，也能够将多个分割槽合成一个文件系统(LVM, RAID)！ 所以说，目前我们在格式化时已经不再说成针对 partition 来格式化了， 通常我们可以称呼一个可被挂载的数据为一个文件系统而不是一个分割槽。

由于操作系统的档案数据含有非常多的属性，例如 Linux 操作系统的档案权限(rwx)与文件属性(拥有者、群组、时间参数等)。文件系统通常会将这两部分的数据分别存放在不同的区块，权限与属性放置到 inode中，至于实际数据则放置到data block 区块中。 另外，还有一个超级区块 (superblock) 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。

每个 inode 与 block 都有编号，至于这三个数据的意义可以简略说明如下：
> ① superblock：记录此 filesystem 的整体信息，包括inode/block 的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；
> ② <font color="red">inode：记录档案的属性，一个档案占用一个inode，同时记录此档案的数据所在的 block 号码；</font>
> ③ <font color="red">block：实际记录档案的内容，若档案太大时，会占用多个 block 。</font>

由于每个 inode 与 block 都有编号，而每个档案都会占用一个 inode ，inode 内则有档案数据放置的block 号码。 因此，我们可以知道的是，如果能够找到档案的 inode 的话，那么自然就会知道这个档案所放置数据的 block 号码， 当然也就能够读出该档案的实际数据了。

我们将 inode 与 block 区块用图解来说明一下，如下图所示，文件系统先格式化出 inode 与 block 的区块，假设某一个档案的属性与权限数据是放置到 inode 4 号(下图较小方格内)，而这个 inode 记录了档案数据的实际放置点为 2, 7, 13, 15 这四个 block 号码，此时我们的操作系统就能够据此来排列磁盘的阅读顺序，可以一口气将四个 block 内容读出来！ 那么数据的读取就如同下图中的箭头所指定的模样了。
![](/uploads/2017/12/linux_inode_block.JPG)

这种数据存取的方法我们称为索引式文件系统(indexed allocation)。 还有其他的惯用文件系统，例如随身碟(闪存)，随身碟使用的文件系统一般为 FAT 格式。FAT这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个档案的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中， 他的读取方式有点像底下这样：
![](/uploads/2017/12/linux_fat.JPG)

上图中我们假设档案的数据依序写入1->7->4->15 号这四个 block 号码中， 但这个文件系统没有办法一口气就知道四个 block 的号码，他得要一个一个的将 block 读出后，才会知道下一个 block 在何处。 如果同一个档案数据写入的 block 分散的太过厉害时，则我们的磁盘读取头将无法在磁盘转一圈就读到所有的数据， 因此磁盘就会多转好几圈才能完整的读取到这个档案的内容！

常常会听到所谓的【碎片整理】吧？ 需要碎片整理的原因就是档案写入的 block 太过于离散了，此时档案读取的效能将会变的很差。 这个时候可以透过碎片整理将同一个档案所属的 blocks 汇整在一起，这样数据的读取会比较容易。


## 二、EXT2文件系统：
如上所知，inode 的内容在记录档案的权限与相关属性，至于 block 区块则是在记录档案的实际内容。 而且文件系统一开始就将 inode 与 block 规划好了，除非重新格式化(或者利用resize2fs 等指令变更文件系统大小)，否则 inode 与 block 固定后就不再变动。但是如果仔细考虑一下，如果我的文件系统高达数百GB 时，那么将所有的 inode 与 block 通通放置在一起将是很不智的决定，因为 inode 与 block 的数量太庞大，不容易管理。

为此之故，因此 Ext2 文件系统在格式化的时候基本上是区分为多个区块群组 (block group) 的，每个区块群组都有独立的 inode/block/superblock 系统。感觉上就好像我们在当兵时，一个营里面有分成数个连，每个连有自己的联络系统， 但最终都向营部回报连上最正确的信息一般！这样分成一群群的比较好管理！整个来说，Ext2 格式化后有点像底下这样：
![](/uploads/2017/12/linux_ext2.JPG)

在整体的规划当中，文件系统最前面有一个启动扇区(boot sector)，这个启动扇区可以安装开机管理程序， 这是个非常重要的设计，因为如此一来我们就能够将不同的开机管理程序安装到个别的文件系统最前端，而不用覆盖整颗硬盘唯一的 MBR（主要开机区，Master boot record, MBR）， 这样也才能够制作出多重引寻的环境！至于每一个区块群组(block group)的六个主要内容说明如下：

（1）data block (资料区块)
data block 是用来放置档案内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K三种而已。在格式化时 block 的大小就固定了，且每个 block 都有编号，以方便 inode 的记录。 不过要注意的是，由于 block 大小的差异，会寻致该文件系统能够支持的最大磁盘容量与最大单一档案容量并不相同。 因为 block 大小而产生的 Ext2 文件系统限制如下：

Block 大小 			| 1KB |	2KB | 4KB
--------------------|-----|-----|------------------
最大单一档案限制 	| 16GB|256GB| 2TB
最大文件系统总容量 	| 2TB |	8TB | 16TB
*（注：在进行文件系统的格式化之前，要想好该文件系统预计使用的情况来选择 Block 大小。过大会产生较严重的磁盘容量浪费，较小则大型档案会占用数量更多的block，而inode也要记录更多的block号码，将可能导致文件系统不良的读写效能。）*

（2）inode table (inode 表格)
如前所述 inode 的内容在记录档案的属性以及该档案实际数据是放置在哪几号 block 内。基本上，inode 记录的档案数据至少有以下这些：

	该档案的存取模式(read/write/excute)；
	该档案的拥有者与群组(owner/group)；
	该档案的容量；
	该档案建立或状态改变的时间(ctime)；
	最近一次的读取时间(atime)；
	最近修改的时间(mtime)；
	定义档案特性的旗标(flag)，如 SetUID...；
	该档案真正内容的指向 (pointer)；
inode 的数量与大小也是在格式化时就已经固定了，除此之外 inode 还有些什么特色呢？

	每个 inode 大小均固定为 128 bytes；
	每个档案都仅会占用一个 inode 而已；
	承上，因此文件系统能够建立的档案数量与 inode 的数量有关；
	系统读取档案时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够开始实际读取 block 的内容。
inode 要记录的数据非常多，但偏偏又叧有 128bytes 而已， 而 inode 记录一个 block 号码要花掉 4byte ，假设我一个档案有 400MB 且每个block 为 4K 时， 那么至少也要十万笔 block 号码的记录呢！inode 哪有这么多可记录的信息？为此我们的系统很聪明的将 inode 记录 block 号码的区域定义为12 个直接，一个间接, 一个双间接与一个三间接记录区。这是啥？我们将 inode 的结构画一下好了。
![](/uploads/2017/12/linux_inode.JPG)

上图最左边为 inode 本身 (128 bytes)，里面有 12 个直接指向 block 号码的对照，这 12 笔记录就能够直接取得 block 号码。 至于所谓的间接就是再拿一个 block 来当作记录 block 号码的记录区，如果档案太大时， 就会使用间接的 block 来记录编号。如上图，当中间接只是拿一个 block 来记录额外的号码而已。 同理，如果档案持续长大，那么就会利用所谓的双间接，第一个 block 仅再指出下一个记录编号的 block 在哪里， 实际记录的在第二个 block 当中。依此类推，三间接就是利用第三层block 来记录编号。

这样子 inode 能够指定多少个 block 呢？我们以较小的 1K block 来说明好了，可以指定的情况如下：

    12 个直接指向： 12*1K=12K
	　由于是直接指向，所以总共可记录 12 笔记录，因此总额大小为如上所示；
	间接： 256*1K=256K
	　每笔 block 号码的记录会花去 4bytes，因此 1K 的大小能够记录 256 笔记录，因此一个间接可以记录的档案大小如上；
	双间接： 256*256*1K=2562K
	　第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个号码，因此总额大小如上；
	三间接： 256*256*256*1K=2563K
	　第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个第三层，每个第三层可以指定256 个号码，因此总额大小如上；
	总额：将直接、间接、双间接、三间接加总，得到 12 + 256 + 256*256 + 256*256*256 (K) =16GB

此时我们知道当文件系统将 block 格式化为 1K 大小时，能够容纳的最大档案为 16GB，比较一下文件系统限制表的结果可发现是一致的！但这个方法不能用在 2K 及 4K block 大小的计算中， 因为大于2K 的 block 将会受到 Ext2 文件系统本身的限制，所以计算的结果会不太符合。

（3）Superblock (超级区块)
Superblock 是记录整个 filesystem 相关信息的地方，没有 Superblock ，就没有这个 filesystem了。他记录的信息主要有：

	block 与 inode 的总量；
	未使用与已使用的 inode / block 数量；
	block 与 inode 的大小 (block 为 1, 2, 4K，inode 为 128 bytes)；
	filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 (fsck) 的时间等文件系统的相关信息；
	一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为1 。

Superblock 是非常重要的，因为我们这个文件系统的基本信息都写在这里，因此，如果 superblock死掉了， 你的文件系统可能就需要花费很多时间去挽救。一般来说， superblock 的大小为1024bytes。相关的 superblock 信息可以使用 dumpe2fs 指令来查看。
此外，每个 block group 都可能含有 superblock 。但是我们也说一个文件系统应该仅有一个superblock 而已，那是怎么回事？ 事实上除了第一个 block group 内会含有 superblock 之外，后续的 block group 不一定含有 superblock ， 而若含有 superblock 则该 superblock 主要是做为第一个 block group 内 superblock 的备份，这样可以进行 superblock 的救援。

（4）Filesystem Description (文件系统描述说明)
这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段 (superblock,bitmap, inodemap, data block) 分别介于哪一个 block 号码之间。这部分也能够用 dumpe2fs 来查看。

（5）block bitmap (区块对照表)
如果你想要新增档案时会用到 block，那你要使用那个 block 来记录呢？当然是选择【空的block】来记录新档案的数据。 那你怎么知道那个 block 是空的？这就得要透过 block bitmap 的辅助。从 block bitmap 当中可以知道哪些 block 是空的，因此我们的系统就能够很快速的找到可使用的空间来处置新档案。
同样的，如果你删除某些档案时，那么那些档案原本占用的 block 号码就得要释放出来， 此时在block bitmpap 当中相对应到该 block 号码的标志就得要修改为【未使用中】。这就是 bitmap的功能。

（6）inode bitmap (inode 对照表)
这个其实与 block bitmap 是类似的功能，只是 block bitmap 记录的是使用与未使用的 block 号码，至于 inode bitmap 则是记录使用与未使用的 inode 号码。


**每个区段与 superblock 的信息都可以使用 dumpe2fs 这个指令来查询的，查询的方法与实际的观察如下：**
dumpe2fs [-bh] 装置文件名
选项与参数：
-b ：列出保留为坏轨的部分(一般用不到！？)
-h ：仅列出 superblock 的数据，不会列出其他的区段内容！