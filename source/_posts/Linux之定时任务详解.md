---
title: Linux之定时任务详解
date: 2018-01-04 14:17:53
categories:
- 书籍
- 《鸟哥的Linux私房菜基础篇（第三版）》
tags:
- 书籍
- Crontab
- Linux
---
### 1、Linux 工作排程的种类： at, cron
1. at ：at 是个可以处理仅执行一次就结束排程的指令，不过要执行 at 时，必须要有 atd 这个服务的支援才行。在某些新版的 distributions 中，atd 可能预设并没有启动，那么 at 这个指令就会失效！不过我们的 CentOS 预设是启动的。
2. crontab ：crontab 这个指令所设定的工作将会循环的一直进行下去！可循环的时间为分钟、小时、每周、每月或每年等。crontab 除了可以使用指令执行外，亦可编辑 /etc/crontab 来支持。至于让 crontab 可以生效的服务则是 crond 这个服务。
<!--more-->

### 2、atd 的启动与 at 运作的方式
要使用单一工作排程时，我们的 Linux 系统上面必须要有负责这个排程的服务，那就是 atd ！不过并非所有的 Linux distributions 都预设会把他打开的，所以，某些时刻我们必须要手动将他启用才行。启用的方法很简单，就是这样：
```
[root@www ~]# /etc/init.d/atd restart
正在停止 atd: [ 确定 ]
正在激活 atd: [ 确定 ]
# 再设定一下开机时就启动这个服务，免得每次重新启动都得再来一次！
[root@www ~]# chkconfig atd on
```
#### （1）at 的运作方式
既然是工作排程，那么应该会有产生工作的方式，并且将这些工作排进行程表中！那么产生工作的方式是怎么进行的？事实上，我们使用 at 这个指令来产生所要运作的工作，并将这个工作以文本文件的方式写入 /var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与执行了。就这么简单。
不过，并不是所有的人都可以进行 at 工作排程！为什么？因为安全的理由，很多主机被所谓的【绑架】后，最常发现的就是他们的系统当中多了很多的怪客程序 (cracker program)， 这些程序非常可能运用工作排程来执行或搜集系统信息，并定时的回报给怪客团体！所以，除非是你认可的账号，否则先不要让他们使用 at ！那怎么达到使用 at 的列管呢？
我们可以利用 /etc/at.allow 与 /etc/at.deny 这两个档案来进行 at 的使用限制！加上这两个档案后，at 的工作情况其实是这样的：
1. 先找寻 /etc/at.allow 这个档案，写在这个档案中的使用者才能使用 at ，没有在这个档案中的使用者则不能使用 at (即使没有写在 at.deny 当中)；
2. 如果 /etc/at.allow 不存在，就寻找 /etc/at.deny 这个档案，若写在这个 at.deny 的使用者则不能使用at ，而没有在这个 at.deny 档案中的使用者，就可以使用 at ；
3. 如果两个档案都不存在，那么只有 root 可以使用 at 这个指令。

透过这个说明，我们知道 /etc/at.allow 是管理较为严格的方式，而 /etc/at.deny 则较为松散 (因为账号没有在该档案中，就能够执行 at 了)。在一般的 distributions 当中，由于假设系统上的所有用户都是可信任的，因此系统通常会保留一个空的 /etc/at.deny 档案，意思是允讲所有人使用 at 指令的意思 (您可以自行检查一下该档案)。不过，万一你不希望有某些使用者使用 at 的话，将那个使用者的账号写入 /etc/at.deny 即可！一个账号写一行。

#### （2）实际运作单一工作排程
基本的语法如下：
```
[root@www ~]# at [-mldv] TIME
[root@www ~]# at -c 工作号码
选项与参数：
-m ：当 at 的工作完成后，即使没有输出讯息，亦以 email 通知使用者该工作已完成。
-l ：at -l 相当于 atq，列出目前系统上面的所有该用户的 at 排程；
-d ：at -d 相当于 atrm ，可以取消一个在 at 排程中的工作；
-v ：可以使用较明显的时间格式栏出 at 排程中的任务栏表；
-c ：可以列出后面接的该项工作的实际指令内容。
TIME：时间格式，这里可以定义出【什么时候要进行 at 这项工作】的时间，格式有：
HH:MM ex> 04:00
在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此工作。
HH:MM YYYY-MM-DD ex> 04:00 2009-03-17
强制规定在某年某月的某一天的特殊时刻进行该工作！
HH:MM[am|pm] [Month] [Date] ex> 04pm March 17
也是一样，强制在某年某月某日的某时刻进行！
HH:MM[am|pm] + number [minutes|hours|days|weeks]
ex> now + 5 minutes ex> 04pm + 3 days
就是说，在某个时间点【再加几个时间后】才进行。
```
老实说，这个 at 指令的下达最重要的地方在于【时间】的指定了！一般使用【 now + ... 】的方式来定义现在过多少时间再进行工作，但有时也需要定义特定的时间点来进行！底下的范例先看看：
```
范例一：再过五分钟后，将 /root/.bashrc 寄给 root 自己
[root@www ~]# at now + 5 minutes <==记得单位要加 s
at> /bin/mail root -s "testing at job" < /root/.bashrc
at> <EOT> <==这里输入 [ctrl] + d 就会出现 <EOF> 的字样！代表结束！
job 4 at 2009-03-14 15:38
# 上面这行信息在说明，第 4 个 at 工作将在 2009/03/14 的 15:38 进行！
# 而执行 at 会进入所谓的 at shell 环境，让你下达多重指令等待运作！
范例二：将上述的第 4 项工作内容列出来查阅
[root@www ~]# at -c 4
#!/bin/sh <==就是透过 bash shell 
# atrun uid=0 gid=0
# mail root 0
umask 22
....(中间省略许多的环境变量项目)....
cd /root || { <==可以看出，会到下达 at 时的工作目录去执行指令
echo 'Execution directory inaccessible' >&2
exit 1
}
/bin/mail root -s "testing at job" < /root/.bashrc
# 你可以看到指令执行的目录 (/root)，还有多个环境变量与实际的指令内容
范例三：由于机房预计于 2009/03/18 停电，我想要在 2009/03/17 23:00 关机？
[root@www ~]# at 23:00 2009-03-17
at> /bin/sync
at> /bin/sync
at> /sbin/shutdown -h now
at> <EOT>
job 5 at 2009-03-17 23:00
# at 还可以在一个工作内输入多个指令
```
事实上，当我们使用 at 时会进入一个 at shell 的环境来让用户下达工作指令，此时，建议你最好使用绝对路径来下达你的指令，比较不会有问题！由于指令的下达与 PATH 变量有关，同时与当时的工作目录也有关连(如果有牵涉到档案的话)，因此使用绝对路径来下达指令，会是比较一劳永逸的方法。

at 有另外一个很棒的优点，那就是【背景执行】的功能！由于 at 工作排程的使用上，系统会将该项 at 工作独立出你的 bash 环境中，直接交给系统的 atd 程序来接管，因此，当你下达了 at 的工作之后就可以立刻脱机了，剩下的工作就完全交给 Linux 管理即可！所以，如果有长时间的网络工作时，使用 at 可以让你免除网络断线后的困扰！

### 3、循环执行的例行性工作排程
相对于 at 是仅执行一次的工作，循环执行的例行性工作排程则是由 cron (crond) 这个系统服务来控制的。刚刚谈过 Linux 系统上面原本就有非常多的例行性工作，因此这个系统服务是默认启动的。另外，由于使用者自己也可以进行例行性工作排程，所以，Linux 也提供使用者控制例行性工作排程的指令(crontab)。底下我们分别来聊一聊：

#### （1）使用者的设定
使用者想要建立循环型工作排程时，使用的是 crontab 这个指令。不过，为了安全性的问题，与 at 同样的，我们可以限制使用 crontab 的使用者账号！使用的限制数据有：
* /etc/cron.allow：将可以使用 crontab 的账号写入其中，若不在这个档案内的使用者则不可使用 crontab；
* /etc/cron.deny：将不可以使用 crontab 的账号写入其中，若未记录到这个档案当中的使用者，就可以使用crontab 。

与 at 很像。同样的，以优先级来说，/etc/cron.allow 比 /etc/cron.deny 要优先，而判断上面，这两个档案只选择一个来限制而已，因此，建议你只要保留一个即可，免得影响自己在设定上面的判断！一般来说，系统默认是保留 /etc/cron.deny，你可以将不想让他执行 crontab 的那个使用者写入 /etc/cron.deny 当中，一个账号一行！

当用户使用 crontab 这个指令来建立工作排程之后，该项工作就会被记录到 /var/spool/cron/ 里面去，而且是以账号来作为判别的。举例来说，dmtsai 使用 crontab 后，他的工作会被记录到 /var/spool/cron/dmtsai 里头去！但请注意，不要使用 vi 直接编辑该档案，因为可能由于输入语法错误，会导致无法执行 cron 。另外，cron 执行的每一项工作都会被记录到 /var/log/cron 这个登录档中，所以，如果你的 Linux 不知道有否被植入木马时，也可以搜寻一下 /var/log/cron 这个登录档！

#### （2）crontab 的语法：
```
[root@www ~]# crontab [-u username] [-l|-e|-r]
选项与参数：
-u ：只有 root 才能进行这个任务，亦即帮其他使用者建立/移除 crontab 工作排程；
-e ：编辑 crontab 的工作内容
-l ：查阅 crontab 的工作内容
-r ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。
范例一：用 dmtsai 的身份在每天的 12:00 发信给自己
[dmtsai@www ~]$ crontab -e
# 此时会进入 vi 的编辑画面让您编辑工作！注意到，每项工作都是一行。
0 12 * * * mail dmtsai -s "at 12:00" < /home/dmtsai/.bashrc
#分 时 日 月 周 |<==============指令串========================>|
```
预设情况下，任何使用者只要不被列入 /etc/cron.deny 当中，那么他就可以直接下达【 crontab -e 】去编辑自己的例行性命令。整个过程就如同上面提到的，会进入 vi 的编辑画面，然后以一个工作一行来编辑，编辑完毕之后输入【 :wq 】储存后离开 vi 就可以了。而每项工作 (每行) 的格式都是具有六个字段，这六个字段的意义为：
![](/uploads/2018/01/linux_crontab_01.png)
比较有趣的是那个【周】，周的数字为 0 或 7 时，都代表【星期天】的意思！另外，还有一些辅助的字符，大概有底下这些：
![](/uploads/2018/01/linux_crontab_02.png)
**（注：那个 crontab 每个人都只有一个档案存在，就是在 /var/spool/cron 里面！还有建议：【指令下达时，最好使用绝对路径，这样比较不会找不到执行档。】）**

#### （3）系统的配置文件： /etc/crontab
如果是【系统的例行性任务】时，你只要编辑 /etc/crontab 这个档案就可以。有一点需要特别注意！那就是 crontab -e 这个 crontab 其实是 /usr/bin/crontab 这个执行档，但是 /etc/crontab 可是一个【纯文本档】。你可以 root 的身份编辑一下这个档案。
基本上， cron 这个服务的最低侦测限制是【分钟】，所以【 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron 里面的数据内容 】，因此，只要你编辑完 /etc/crontab 这个档案，并且将他储存之后，那么 cron 的设定就自动的会来执行了。

下面是 /etc/crontab 的内容：
```
[root@www ~]# cat /etc/crontab
SHELL=/bin/bash 	<==使用哪种 shell 接口
PATH=/sbin:/bin:/usr/sbin:/usr/bin 	<==执行文件搜寻路径
MAILTO=root 	<==若有额外STDOUT，以 email 将数据送给谁
HOME=/ 	<==默认此 shell 的家目录所在
# run-parts
01 * * * * root run-parts /etc/cron.hourly <==每小时
02 4 * * * root run-parts /etc/cron.daily <==每天
22 4 * * 0 root run-parts /etc/cron.weekly <==每周日
42 4 1 * * root run-parts /etc/cron.monthly <==每个月 1 号
分 时 日 月 周 执行者身份 指令串
```
看到这个档案的内容你大概就了解了吧。这个档案与将刚刚我们下达 crontab -e 的内容几乎完全一模一样！只是有几个地方不太相同：
>**MAILTO=root：**
	这个项目是说，当 /etc/crontab 这个档案中的例行性工作的指令发生错误时，或者是该工作的执行结果有 STDOUT/STDERR 时，会将错误讯息或者是屏幕显示的讯息传给谁？默认当然是由系统直接寄发一封 mail 给 root。不过，由于 root 并无法在客户端中以 POP3 之类的软件收信，因此，通常都将这个 e-mail 改成自己的账号，好随时了解系统的状况！例如：MAILTO=dmtsai@my.host.name
>**PATH=....：**
	在 BASH 当中一直提到的执行文件路径问题。这里就是输入执行文件的搜寻路径！使用默认的路径设定就已经很足够了。
>**01 * * * * root run-parts /etc/cron.hourly：**
	这个 /etc/crontab 里面默认定义出四项工作任务，分别是每小时、每天、每周及每个月分别进行一次的工作！但是在五个字段后面接的并不是挃令，而是一个新的字段，那就是【执行后面那串指令的身份】为何。这不使用者的 crontab -e 不相同。由于使用者自己的 crontab 并不需要指定身份，但 /etc/crontab 里面当然要指定身份。以上表的内容来说，系统默认的例行性工作是以 root 的身份来进行的。
	那么后面那串指令是什么呢？你可以使用【 which run-parts 】搜寻看看，其实那是一个 bash script！如果你直接进入 /usr/bin/run-parts 去看看，会发现这支指令会将后面接的【目录】内的所有档案捉出来执行！这也就是说【如果你想让系统每小时主动帮你执行某个指令，将该指令写成 script，并将该档案放置到 /etc/cron.hourly/ 目录下即可】的意思。
	现在你知道系统是如何进行他默认的一堆例行性工作排程了吗？如果你下达【 ll /etc/cron.daily 】就可以看到一堆档案，那些档案就是系统提供的 script ，而这堆 scripts 将会在每天的凌晨 4:02 开始运作！这也是为啥如果你是夜猫族，就会发现奇怪的是，Linux 系统为何早上 4:02 开始会很忙碌的发出一些硬盘跑动的声音！因为他必须要进行 makewhatis,pdatedb, rpm rebuild 等等的任务。

由于 CentOS 提供的 run-parts 这个 script 的辅助，因此 /etc/crontab 这个档案里面支持两种下达指令的方式，一种是直接下达指令，一种则是以目录来规划，例如：
> **指令型态**
`01 * * * * dmtsai mail -s "testing" kiki < /home/dmtsai/test.txt`
以 dmtsai 这个使用者的身份，在每小时执行一次 mail 指令。
> **目录规划**
`*/5 * * * * root run-parts /root/runcron`
建立一个 /root/runcron 的目录，将要每隔五分钟执行的【可执行文件】都写到该目录下，就可以让系统每五分钟执行一次该目录下的所有可执行文件。

### 4、一些注意事项：
#### （1）资源分配不均的问题
如果每个流程都在同一个时间启动的话，那么在某个时段时，我的系统会变的相当的繁忙，所以，这个时候就必须要分别设定。我可以这样做：
```
[root@www ~]# vi /etc/crontab
1,6,11,16,21,26,31,36,41,46,51,56 * * * * root CMD1
2,7,12,17,22,27,32,37,42,47,52,57 * * * * root CMD2
3,8,13,18,23,28,33,38,43,48,53,58 * * * * root CMD3
4,9,14,19,24,29,34,39,44,49,54,59 * * * * root CMD4
```
看到了没？那个【 , 】分隔的时候，请注意，不要有空格符！（连续的意思）如此一来，则可以将每五分钟工作的流程分别在不同的时刻来工作！则可以让系统的执行较为顺畅！

#### （2）取消不要的输出项目
另外一个困扰发生在【 当有执行成果或者是执行的项目中有输出的数据时，该数据将会 mail 给 MAILTO 设定的账号 】，那么当有一个排程一直出错（例如 DNS 的侦测系统当中，若 DNS 上层主机挂掉，那么你就会一直收到错误讯息！）怎么办？可以使用数据流重导向直接以【命令重导向】将输出的结果输出到 /dev/null 这个垃圾桶当中就好了！

#### （3）安全的检验
很多时候被植入木马都是以例行命令的方式植入的，所以可以藉由检查 /var/log/cron 的内容来视察是否有【非您设定的 cron 被执行了？】这个时候就需要小心一点！

#### （4）周与日月不可同时并存
另一个需要注意的地方在于：【你可以分别以周或者是日月为单位作为循环，但你不可使用「几月几号且为星期几」的模式工作】。这个意思是说，你不可以这样编写一个工作排程：
	30 12 11 9 5 root echo "just test" <==这是错诨癿写法
本来你以为九月十一号且为星期五才会进行这项工作，无奈的是，系统可能会判定每个星期五作一次，或每年的 9 月 11 号分别进行，如此一来与你当初的规划就不一样了。所以，得要注意这个地方！上述的写法是不对的！