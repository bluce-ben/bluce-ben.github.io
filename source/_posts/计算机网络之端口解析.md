---
title: 计算机网络之端口解析
date: 2018-12-17 16:26:03
categories:
- 计算机网络
tags:
- 计算机网络
---
#### 1、端口概述
在Internet上，各主机间通过TCP/TP协议发送和接收数据报，各个数据报根据其目的主机的ip地址来进行互联网络中的路由选择。可见，把数据报顺利的传送到目的主机是没有问题的。问题出在哪里呢?我们知道大多数操作系统都支持多程序（进程）同时运行，那么目的主机应该把接收到的数据报传送给众多同时运行的进程中的哪一个呢？显然这个问题有待解决，端口机制便由此被引入进来。
>请注意，端口号只具有本地意义（即只对本地机器来说才有意义），它只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口。

<!--more-->
本地操作系统会给那些有需求的进程分配协议端口 （protocal port，即我们常说的端口），每个协议端口由一个正整数标识，如：80，139，445，等等。当目的主机接收到数据报后，将根据报文首部的目的端口号，把数据发送到相应端口，而与此端口相对应的那个进程将会领取数据并等待下一组数据的到来。

端口其实就是队，操作系统为各个进程分配了不同的队，数据报按照目的端口被推入相应的队中，等待被进程取用，在极特殊的情况下，这个队也是有可能溢出的，不过操作系统允许各进程指定和调整自己的队的大小。

不光接受数据报的进程需要开启它自己的端口，发送数据报的进程也需要开启端口，这样，数据报中将会标识有源端口，以便接受方能顺利的回传数据报到这个端口。
>传输层标识的端口号用16位来表示，说明只能允许有65535（2^16-1）个不同的端口号。


#### 2、端口分类
##### （1）服务器端使用的端口号
这里又分为两类，最重要的一类叫做熟知端口号（well-known port number）或系统端口号，数值为0~1023。可在网址 www.iana.org查到。
IANA把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道。下面给出一些常用的熟知端口号：

应用程序   | FTP | TELNET | SMTP | DNS | TFTP | HTTP | SNMP | SNMP(trap)
-----------|-----|--------|------|-----|------|------|------|------------
熟知端口号 |  21 |   23   |  25  |  53 |  69  |  80  |  161 |   162

另一类叫做登记端口号，数值为 1024~49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。

##### （2）客户端使用的端口号数值为 49152~65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。

>短暂端口（ephemeral port）表示这种端口的存在时间是短期的。客户进程并不在意操作系统给它分配的是哪一个端口号，因为客户进程之所以必须有一个端口号（在本地主机中必须是唯一的），是为了让传输层的实体能够找到自己。这和熟知端口不同。服务器机器一接通电源，服务器程序就运行起来。为了让因特网上所有的客户程序都能够找到服务器程序，服务器程序所使用的端口（即熟知端口）就必须是固定的，并且是众所周知的。


#### 端口在入侵中的作用
有人曾经把服务器比作房子，而把端口比作通向不同房间（服务）的门，如果不考虑细节的话，这是一个不错的比喻。入侵者要占领这间房子，势必要破门而入（物理入侵另说），那么对于入侵者来说，了解房子开了几扇门，都是什么样的门，门后面有什么东西就显得至关重要。
　 入侵者通常会用扫描器对目标主机的端口进行扫描，以确定哪些端口是开放的，从开放的端口，入侵者可以知道目标主机大致提供了哪些服务，进而猜测可能存在的漏洞，因此对端口的扫描可以帮助我们更好的了解目标主机，而对于管理员，扫描本机的开放端口也是做好安全防范的第一步。


#### 端口大小设置
>端口大小需要先了解MTU是什么？
MTU是Maximum Transmission Unit的缩写，意思是网络上传送的最大数据包，它的的单位是字节。

>大部分网络设备都是1500。如果本机的MTU比网关的MTU大，大的数据包就会被拆开来传送，这样会产生很多数据包碎片，增加丢包率，降低网络速度。把本机的MTU设成比网关的MTU小或相同，就可以减少丢包 。通俗的说也就是，如果你上传一个大的文件，速度非常慢，可能就是这种原因，当你把MTU值改小时，就可以解决。

**查看本机的mtu ：** `netstat -i`

**设置本机的mtu ：** `echo "1450" > /sys/class/net/eth0/mtu` 或直接编辑eth1网卡配置文件。

>扩展：不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。

在应用程序中我们用到的Data的长度最大是多少，直接取决于底层的限制。
我们从下到上分析一下：
1. 在链路层，由以太网的物理特性决定了数据帧的长度为(46＋18)－(1500＋18)，其中的18是数据帧的头和尾，也就是说数据帧的内容最大为1500(不包括帧头和帧尾)，即MTU(Maximum Transmission Unit)为1500；
2. 在网络层，因为IP包的首部要占用20字节，所以这的MTU为1500－20＝1480；
3. 在传输层，对于UDP包的首部要占用8字节，所以这的MTU为1480－8＝1472；（注：TCP的首部要占用20字节）　　

所以，在应用层，你的Data最大长度为1472。当我们的UDP包中的数据多于MTU(1472)时，发送方的IP层需要分片fragmentation进行传输，而在接收方IP层则需要进行数据报重组，由于UDP是不可靠的传输协议，如果分片丢失导致重组失败，将导致UDP数据包被丢弃。

>![](/uploads/2018/12/network_mtu_001.jpg)
由于以太网EthernetII最大的数据帧是1518Bytes这样，刨去以太网帧的帧头（DMAC目的MAC地址48bits=6Bytes+SMAC源MAC地址48bits=6Bytes+Type域2Bytes）14Bytes和帧尾CRC校验部分4Bytes那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值我们就把它称之为MTU。

>如果我们定义的TCP和UDP包没有超过范围，那么我们的包在IP层就不用分包了，这样传输过程中就避免了在IP层组包发生的错误；如果超过范围，既IP数据报大于1500字节，发送方IP层就需要将数据包分成若干片，而接收方IP层就需要进行数据报的重组。更严重的是，如果使用UDP协议，当IP层组包发生错误，那么包就会被丢弃。接收方无法重组数据报，将导致丢弃整个IP数据报。UDP不保证可靠传输；但是TCP发生组包错误时，该包会被重传，保证可靠传输。

UDP数据报的长度是指包括报头和数据部分在内的总字节数，其中报头长度固定，数据部分可变。数据报的最大长度根据操作环境的不同而各异。从理论上说，包含报头在内的数据报的最大长度为65535字节(64K)。
>注：此处的最大字节数，为系统内核缓存区大小。现在默认值已经不是65535字节，可依据机器查询。
`cat /proc/sys/net/core/rmem_max`	//读缓存区，单位字节
16777216
`cat /proc/sys/net/core/wmem_max`	//写缓存区，单位字节
16777216
`cat /proc/sys/net/core/rmem_default`	//默认读缓存区
8388608
`cat /proc/sys/net/core/wmem_default`	//默认写缓存区
8388608

我们在用Socket编程时，UDP协议要求包小于64K（需要减去IP头(20)+UDP头(8)=65507，否则用sendto函数发送数据会返回错误）。TCP没有限定，TCP包头中就没有“包长度”字段，而完全依靠IP层去处理分帧。这就是为什么TCP常常被称作一种“流协议”的原因，开发者在使用TCP服务的时候，不必去关心数据包的大小，只需讲SOCKET看作一条数据流的入口，往里面放数据就是了，TCP协议本身会进行拥塞/流量控制。


#### 端口阻塞问题？（自我理解，不一定正确。待后期确认）
端口号仅仅是为了区别本地机器的进程用的，并不会出现阻塞问题。出现阻塞问题，也都是一些TCP方面的，或者是IP层面的。

传输层或网络层的发送与接收缓存打满，导致阻塞丢失数据问题，出现阻塞。（这就是为什么TCP有拥塞控制。需要检测拥塞和减少包的发送率，降低拥塞，避免网络瘫痪。）

（注：一般不会说UDP会阻塞网络，因为UDP是不可靠的传输，因此如果有阻塞发生，UDP就会丢包，没有重传机制。造成阻塞的情况，可能就是源主机一直发送数据，导致拥塞，造成网络不能正常收发数据。）

还有就是进程阻塞问题。 一般不会说端口阻塞。端口只会被禁止，通过防火墙一类的限制。
