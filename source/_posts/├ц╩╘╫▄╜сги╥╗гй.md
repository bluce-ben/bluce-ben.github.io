---
title: 面试总结（一）
date: 2018-04-02 10:58:13
categories:
- 面试
tags:
- 面试
---
上周面试了一个公司，下面做一下总结。

#### 一、算法
1、斐波那契数列实现
```
斐波那契数列： 
1 1 2 3 5 8 13 21 34 55 …
概念： 
前两个值都为1，该数列从第三位开始，每一位都是当前位前两位的和 
规律公式为： 
Fn = F(n-1) + F(n-2) 
F：指当前这个数列 
n：指数列的下标
```
<!--more-->
**PHP代码实现：**
```
//非递归
function fbnq($n){
	if($n<=0){
		return 0;
	}
	$arr[1] = $arr[2] = 1;
	for($i=3; $i<=$n; $i++){
		$arr[$i] = $arr[$i-1] + $arr[$i-2];
	}
	return $arr;
}
//递归实现
function fbnq($n){
	if($n <= 0) return 0;
	static $arr;
	$arr[1] = $arr[2] = 1;
    if($n > 3){
    	fbnq($n-1);
    }
    $arr[$n] = $arr[$n-1] + $arr[$n-2];
    return $arr;
}
```

2、最大连续子数列乘积问题。
```
给出一个数列为：$arr = [2, 3, 0, -3, 3, -1, 0, 9];
求出最大连续子数列乘积。
结果为：[-3, 3, -1]
```
**PHP代码实现：**
```
function maxSubProduct($arr){
	$len = count($arr);
	$maxPro = 0;
	$thisPro = 1;
	for($i=0, $j=0; $j<$len; $j++){
		$thisPro *= $arr[$j];
		if($thisPro > $maxPro){
			$maxPro = $thisPro;
			$seqStart = $i;
			$seqEnd = $j;
		}else if($thisPro == 0){
			$thisPro = 1;
			$i = $j+1;
		}
	}
	$length = $seqEnd-$seqStart+1;
	return array_slice($arr, $seqStart, $length);
}
```

#### 二、PHP基础
##### 1、比较empty()、isset()两个函数的区别，对应给出如下示例：
```
$a = 0;
$b = '0';
$c = null;
$d = ' ';
var_dump(empty($a)); //1
var_dump(empty($b)); //1
var_dump(empty($c)); //1
var_dump(isset($c)); //0
var_dump(isset($d)); //1
var_dump($a == $b); //1
var_dump($a == $c); //1
```
**相关知识点介绍：**
>`bool isset ( mixed $var [, mixed $... ] ) — 检测变量是否已设置并且不是 NULL。`
返回值：如果 var 存在并且值不是 NULL 则返回 TRUE，否则返回 FALSE。
（注：isset() 只能用于变量，因为传递任何其它参数都将造成解析错误。若想检测常量是否已设置，可使用 defined() 函数。
因为是一个语言构造器而不是一个函数，不能被 可变函数 调用。）
>`bool empty ( mixed $var ) — 检查一个变量是否为空`
判断一个变量是否被认为是空的。当一个变量并不存在，或者它的值等同于FALSE，那么它会被认为不存在。如果变量不存在的话，empty()并不会产生警告。
返回值：
当var存在，并且是一个非空非零的值时返回 FALSE 否则返回 TRUE.
>>**以下的东西被认为是空的：**
"" (空字符串)
0 (作为整数的0)
0.0 (作为浮点数的0)
"0" (作为字符串的0)
NULL
FALSE
array() (一个空数组)
$var; (一个声明了，但是没有值的变量)
>（注：因为是一个语言构造器而不是一个函数，不能被 可变函数 调用。）

##### 2、数组方面，给出如下：
写出对应输出的结果，包括key=>value值。
```
$a = array( 2, 1, '3'=>2 );
$b = array( 2=>1, 4=>2, 5=>4 );
foreach( $a as &$k ){
    $k++;
}
foreach( $b as $k ){
    $k++;
}
var_dump($a); //0=>3, 1=>2, 3=>5
var_dump($b); //2=>1, 4=>2, 5=>3
var_dump($k); //5
```
**答案解析：**
>根据程序自上到下的执行顺序，可知道首先遍历$a数组，且要注意<font color="red">遍历只有值，没有key，仅仅只是名字而已。</font>此处，我就看错了。然后遍历$b数组，最后输出。
首先要知道的一点是：$a数组将值传引用了，因此后面对$k的值更改则会更改对应的值。
所以，$a的值相对应的都会+1，则其值为 0=>3,1=>2,3=>3。
下面，又再次对$b数组进行遍历，仅仅只是值传递。所以，对于$b数组未做改变，原样输出：2=>1,4=>2,5=>4。
虽然$b数组遍历未对数值的值进行改变，但是，对$k的值进行更改了。因此，$k的值再经过$b数组的遍历后为5，要注意，$k是传引用的，与$a数组中的最后一个值是引用关系。因此，$a数组中最后一个值现在变为5。且$k的值也是5。

**相关知识点介绍：**
此处，考的知识点比较多一些，比较容易混淆且不被发现。
首先是遍历的时候，命名问题容易让人产生是$key，没有值的幻觉，因此要注意看（面试官提醒了我好几次，最后还是看错了）。
再次，就是传值与传引用的知识点运用。其中涉及到变量作用域的问题，此处我也考虑错了，理解成局部变量了。下面是变量作用域的总结：
>PHP中变量的作用域可以分为:
**超全局变量：**在一个脚本的任何作用域里都可以被访问,可直接在局部范围里使用,不需要用global声明。比如$GLOBALS,$_ENV,$_SERVER,$_GET,$_POST,$_FILES,$_SESSION,$_COOKIE等.
**全局变量：**声明的变量不在class,function等语言结构内部.如果要在class,function等内部使用全局变量,需要用关键词global或者超全局变量$GLOBALS.
**局部变量：**在class,function等结构语句内部声明的变量.
**静态变量：**在function中使用关键词static声明的变量,静态变量的值保留直至当前请求的脚本运行结束,比如可以用来保存数据库连接对象.


#### 三、Linux命令
给你一段文本文件，例如：file.txt
102 baidu 100 5000
101 google 110 5000
104 sohu 100 4500
103 guge 50 3000
下面是需要执行的命令需求：
1、输出前两行
2、输出第3行
3、输出第1列
4、输出全部并且以第一列从小到大排序
5、回到家目录，再回到上次目录
下面是对上面命令的解答：
```
1、head -2 file.txt
2、sed -n '3p' file.txt 或 cat file.txt | head -3 | tail -1
3、awk '{print $1}' file.txt
4、sort -n -t ' ' -k 1 file.txt
5、cd ~ ; cd -
```


#### 四、操作系统方面
##### 1、进程间通信方式以及相对应的原理
通信方式有：管道、信号、共享内存
原理：
管道：
信号：
共享内存：

##### 2、操作系统中有个重复函数加载什么的

##### 3、I/O多路复用技术




#### 五、计算机网络
##### 1、计算机网络OSI七层协议模型、TCP/IP五层协议模型
OSI七层协议模型包括：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。
TCP/IP五层协议模型包括：应用层、传输层、网络层、数据链路层、物理层。
以TCP/IP五层协议模型来说明每层作用及相关协议：
应用层：对编程人员开发的接口，用于软件开发。主要协议包括：HTTP、SMTP、DNS等
传输层：接受应用层的数据包，进行处理，并选择相应的协议进行转发到下层。主要协议包括：TCP、UDP等
网络层：逻辑寻址，用于在网络中通过路由协议用IP:Port来进行子网定位。主要协议包括：路由协议、IP协议等
数据链路层：物理寻址，用于在子网中通过交换机根据Mac地址来进行定位主机；同时，将数据进行处理，转换为位流。
物理层：通过物理媒介，传输数据流。

##### 2、TCP/UDP的区别及特点
TCP：面向连接的、安全的协议。
UDP：无连接的、不安全的协议。

##### 3、HTTP相关知识点
HTTP：超文本传输协议。是一个面向连接的（底层采用的是TCP协议）、无状态的协议。


#### 六、原理方面
##### 1、web服务的工作原理
WEB服务器也称为WWW(WORLD WIDE WEB)服务器，主要功能是提供网上信息浏览服务。通俗的说，Web服务器是可以向发出请求的浏览器提供文档的程序。 
1、服务器是一种被动程序：只有当Internet上运行在其他计算机中的浏览器发出请求时，服务器才会响应。 
2、最常用的Web服务器是Apache和Microsoft的Internet信息服务器（Internet Information Services，IIS）。 
3、Internet上的服务器也称为Web服务器，是一台在Internet上具有独立IP地址的计算机，可以向Internet上的客户机提供WWW、Email和FTP等各种Internet服务。 
4、Web服务器是指驻留于因特网上某种类型计算机的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。服务器使用HTTP（超文本传输协议）与客户机浏览器进行信息交流，这就是人们常把它们称为HTTP服务器的原因。 
Web服务器不仅能够存储信息，还能在用户通过Web浏览器提供的信息的基础上运行脚本和程序。

**采用的协议：**
1、应用层使用HTTP协议。
2、HTML（标准通用标记语言下的一个应用）文档格式。
3、浏览器统一资源定位器（URL）。
4、为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

**Web服务的工作原理：**
Web服务器的工作原理并不复杂，一般可分成如下4个步骤：连接过程、请求过程、应答过程以及关闭连接。
**连接过程**：通过三次握手建立连接。（客户端向服务器发送请求报文SYN；服务器接受请求连接，并向客户端发送ACK确认；客户端接受ACK确认并返回给服务器，服务器接受到客户端返回的ACK确认后建立起连接。）
**请求过程**客户端与服务端建立连接后，客户端即可向服务端发送请求。（如果是持久连接，一次连接可多次请求。非持久连接，则一次连接只可请求一次。）
**应答过程**客户端将请求发送到服务端，服务端接受链接，并进行处理。然后把处理结果再返回给客户端。
**关闭连接**最后，通过四次挥手断开连接。（客户端向服务器发送断开连接请求报文FIN；服务器接受断开连接，并向客户端发送ACK确认报文，同时，待服务器端数据处理完后返回FIN关闭连接；客户端接受到服务端的确认报文ACK，待接收到服务端的关闭连接报文FIN后，返回ACK到服务端确认关闭连接。）

使用最多的Web Server服务器软件有：IIS、Apache、nginx。

>为何使用三次握手机制：
假设如下异常情况：
客户端向服务器发送了第一条请求报文，但是该报文并未在网络中被丢弃，而是长时间阻滞在某处，而客户端收不到服务器确认，以为该报文丢失，于是重新发送该报文，这次的报文成功到达服务器，如果不使用三次握手，则服务器只需对该报文发出确认，就建立了一个连接。而在这个连接建立，并释放后，第一次发送的，阻滞在网络中的报文到达了服务器，服务器以为是客户端又重新发送了一个连接请求（实际上在客户端那里，该连接早已失效），就又向客户端发送一个确认，但客户端认为他没有发送该请求报文，因此不理睬服务器发送的确认，而服务器以为又建立了一个新的连接，于是一直等待A发来数据，造成了服务器资源的浪费，并且会产生安全隐患。因此，若使用三次握手机制，服务器发送了该确认后，收不到客户端的确认，也就知道并没有建立连接，因此不会将资源浪费在这种没有意义的等待上。


##### 2、nginx的工作原理
nginx类似是一个代理服务器，当浏览器请求的是一些静态资源，则直接返回；若接收的是动态请求，则通过配置文件直接将请求映射到对应的location block，而此location中所配置的各个指令则会启动不同的模块去完成工作，最后返回给浏览器。
此处，处理动态请求的PHP文件，一般是PHP-FPM。


#### 七、其它知识点
##### 1、session和cookie的区别
首先，要知道session和cookie是怎么产生的。当客户端访问服务端的时候，服务器会对应生成一个唯一的SESSIONID，同数据一起返回给客户端，当客户端再次访问的时候，即可带着这个SESSIONID，服务端就可根据SESSIONID识别用户。HTTP是一个无状态的协议（即同一个会话的连续两次请求是互相不了解的，如果需要前面的信息，必须重传），session和cookie是会话层保持会话的一个措施。
（1）因此，首先一个区别就是session保存在服务端，cookie保存在客户端。
cookie保存在浏览器中，如果没有设置过期时间，则关闭浏览器的时候，cookie就消失了，相对应的SESSIONID也消失了。当设置过期时间的时候，cookie就保存在客户端硬盘上，当下次再访问网站的时候，可自动携带此cookie。
（2）由于cookie保存在客户端，因此cookie是不安全的，容易被人给copy，伪造cookie登录。session保存在服务端，相对来说安全一些。
假如浏览器禁止cookie，那应该怎么保持会话？
① 可通过重写URL，即通过GET方法附带SESSIONID的方式传送到服务端。
② 如果是表单，可通过隐藏表单传送SESSIONID。
（3）由于session是保存在服务端，因此session的增加会导致服务器数据量增加，应定时清理无效数据。
（4）cookie保存在客户端，但是也不能随意大批量使用，因为cookie的增加会增加数据传输量，导致带宽的增加。


##### 2、堆区与栈区介绍
内存分配有三种：静态存储区、堆区和栈区。他们的功能不同，对他们使用方式也就不同。
**静态存储区：**内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。
**栈区：**在执行函数时，函数（包括main函数）内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。（任何变量都处于站区，例如int a[] = {1, 2},变量a处于栈区。数组的内容也存在于栈区。）
**堆区：**亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，并立即将指针置位NULL，防止产生野指针。