<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-02T08:45:03.093Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flask  整体概述-一个完整的程序</title>
    <link href="http://yoursite.com/2018/03/02/Flask-%E6%95%B4%E4%BD%93%E6%A6%82%E8%BF%B0-%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/03/02/Flask-整体概述-一个完整的程序/</id>
    <published>2018-03-02T08:25:45.000Z</published>
    <updated>2018-03-02T08:45:03.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Flask-简介"><a href="#一、Flask-简介" class="headerlink" title="一、Flask 简介"></a>一、Flask 简介</h3><p>Flask(<a href="http://flask.pocoo.org/)是一种小型框架，小到可以称为“微框架”。但是，小并不意味着它比其他框架的功能少。Flask" target="_blank" rel="noopener">http://flask.pocoo.org/)是一种小型框架，小到可以称为“微框架”。但是，小并不意味着它比其他框架的功能少。Flask</a> 自开发伊始就被设计为可扩展的框架，它具有一个包含基本服务的强健核心，其他功能则可通过扩展实现。你可以自己挑选所需的扩展包，组成一个没有附加功能的精益组合，从而完全精确满足自身需求。</p><p>Flask 有两个主要依赖：路由、调试和Web 服务器网关接口（Web Server Gateway Interface，WSGI）子系统由Werkzeug（<a href="http://werkzeug.pocoo.org/）提供；模板系统由Jinja2（http://jinja.pocoo.org/）提供。Werkzeug" target="_blank" rel="noopener">http://werkzeug.pocoo.org/）提供；模板系统由Jinja2（http://jinja.pocoo.org/）提供。Werkzeug</a> 和Jinjia2 都是由Flask 的核心开发者开发而成。</p><p>Flask 并不原生支持数据库访问、Web 表单验证和用户认证等高级功能。这些功能以及其他大多数Web 程序中需要的核心服务都以扩展的形式实现，然后再与核心包集成。开发者可以任意挑选符合项目需求的扩展，甚至可以自行开发。这和大型框架的做法相反，大型框架往往已经替你做出了大多数决定，难以（有时甚至不允许）使用替代方案。</p><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><h4 id="1、使用虚拟环境"><a href="#1、使用虚拟环境" class="headerlink" title="1、使用虚拟环境"></a>1、使用虚拟环境</h4><p>安装Flask 最便捷的方式是使用虚拟环境。虚拟环境是Python解释器的一个私有副本，在这个环境中你可以安装私有包，而且不会影响系统中安装的全局Python 解释器。</p><p>虚拟环境非常有用，可以在系统的Python 解释器中避免包的混乱和版本的冲突。为每个程序单独创建虚拟环境可以保证程序只能访问虚拟环境中的包，从而保持全局解释器的干净整洁，使其只作为创建（更多）虚拟环境的源。</p><p>虚拟环境使用第三方实用工具virtualenv 创建。输入以下命令可以检查系统是否安装了virtualenv：<br>　　<code>$ virtualenv --version</code><br>如果结果显示错误，你就需要安装这个工具。</p><h5 id="（1）安装virtualenv"><a href="#（1）安装virtualenv" class="headerlink" title="（1）安装virtualenv"></a>（1）安装virtualenv</h5><p>① 大多数Linux 发行版都提供了virtualenv 包。例如，Ubuntu 用户可以使用下述命令安装它：<br>　　<code>$ sudo apt-get install python-virtualenv</code><br>② 如果你的电脑是Mac OS X 系统，就可以使用easy_install 安装virtualenv：<br>　　<code>$ sudo easy_install virtualenv</code><br>③ 如果你使用微软的Windows 系统或其他没有官方virtualenv 包的操作系统，那么安装过程要稍微复杂一点。<br>在浏览器中输入网址<a href="https://bitbucket.org/pypa/setuptools，回车后会进入setuptools" target="_blank" rel="noopener">https://bitbucket.org/pypa/setuptools，回车后会进入setuptools</a> 安装程序的主页。在这个页面中找到下载安装脚本的链接，脚本名为ez_setup.py。把这个文件保存到电脑的一个临时文件夹中，然后在这个文件夹中执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python ez_setup.py</span><br><span class="line">$ easy_install virtualenv</span><br></pre></td></tr></table></figure></p><h5 id="（2）创建虚拟环境"><a href="#（2）创建虚拟环境" class="headerlink" title="（2）创建虚拟环境"></a>（2）创建虚拟环境</h5><p>下一步是使用virtualenv 命令在flasky 文件夹中创建Python 虚拟环境。这个命令只有一个必需的参数，即虚拟环境的名字。创建虚拟环境后，当前文件夹中会出现一个子文件夹，名字就是上述命令中指定的参数，与虚拟环境相关的文件都保存在这个子文件夹中。<br>按照惯例，一般虚拟环境会被命名为venv：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv venv</span><br><span class="line">New python executable in venv/bin/python2.7</span><br><span class="line">Also creating executable in venv/bin/python</span><br><span class="line">Installing setuptools............done.</span><br><span class="line">Installing pip...............done.</span><br></pre></td></tr></table></figure></p><h5 id="（3）激活虚拟环境"><a href="#（3）激活虚拟环境" class="headerlink" title="（3）激活虚拟环境"></a>（3）激活虚拟环境</h5><p>现在，flasky 文件夹中就有了一个名为venv 的子文件夹，它保存一个全新的虚拟环境，其中有一个私有的Python 解释器。在使用这个虚拟环境之前，你需要先将其“激活”。如果你使用bash 命令行（Linux 和Mac OS X 用户），可以通过下面的命令激活这个虚拟环境：<br>　　<code>$ source venv/bin/activate</code><br>如果使用微软Windows 系统，激活命令是：<br>　　<code>$ venv\Scripts\activate</code><br>虚拟环境被激活后，其中Python 解释器的路径就被添加进PATH 中，但这种改变不是永久性的，它只会影响当前的命令行会话。为了提醒你已经激活了虚拟环境，激活虚拟环境的命令会修改命令行提示符，加入环境名：<br>　　<code>(venv) $</code><br>当虚拟环境中的工作完成后，如果你想回到全局Python 解释器中，可以在命令行提示符下输入deactivate。</p><h4 id="2、使用pip安装Python包（Flask）"><a href="#2、使用pip安装Python包（Flask）" class="headerlink" title="2、使用pip安装Python包（Flask）"></a>2、使用pip安装Python包（Flask）</h4><p>大多数Python 包都使用pip 实用工具安装，使用virtualenv 创建虚拟环境时会自动安装pip。激活虚拟环境后，pip 所在的路径会被添加进PATH。<br>执行下述命令可在虚拟环境中安装Flask：<br>　　<code>(venv) $ pip install flask</code><br>执行上述命令，你就在虚拟环境中安装Flask 及其依赖了。要想验证Flask 是否正确安装，你可以启动Python 解释器，尝试导入Flask：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python</span><br><span class="line">&gt;&gt;&gt; import flask</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>如果没有看到错误提醒，那恭喜你——你已经可以安装完成了。</p><h3 id="三、程序的基本结构"><a href="#三、程序的基本结构" class="headerlink" title="三、程序的基本结构"></a>三、程序的基本结构</h3><p>首先，来梳理一下Flask的工作流程。</p><h4 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h4><p>所有Flask 程序都必须创建一个程序实例。Web 服务器使用一种名为Web 服务器网关接口（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这个对象处理。程序实例是Flask 类的对象，经常使用下述代码创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure></p><p>Flask 类的构造函数<font color="red">只有一个必须指定的参数，即程序主模块或包的名字</font>。在大多数程序中，Python 的<strong>name</strong> 变量就是所需的值。</p><h4 id="2、路由和视图函数"><a href="#2、路由和视图函数" class="headerlink" title="2、路由和视图函数"></a>2、路由和视图函数</h4><p>客户端（例如Web 浏览器）把请求发送给Web 服务器，Web 服务器再把请求发送给Flask程序实例。程序实例需要知道对每个URL 请求运行哪些代码，所以保存了一个URL 到Python 函数的映射关系。<font color="red">处理URL和函数之间关系的程序称为路由</font>。</p><p>在Flask 程序中定义路由的最简便方式，是使用程序实例提供的app.route 修饰器，把修<br>饰的函数注册为路由。下面的例子说明了如何使用这个修饰器声明路由：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos;</span><br></pre></td></tr></table></figure></p><p><strong>（注：修饰器是Python 语言的标准特性，可以使用不同的方式修改函数的行为。惯常用法是使用修饰器把函数注册为事件的处理程序。）</strong></p><p>前例把index() 函数注册为程序根地址的处理程序，即将跟地址映射到index() 函数处理程序。在浏览器中访问<a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a> 后，会触发服务器执行index() 函数。这个函数的返回值称为响应，是客户端接收到的内容。如果客户端是Web 浏览器，响应就是显示给用户查看的文档。</p><p>像index() 这样的函数称为<font color="red">视图函数（view function）</font>。视图函数返回的响应可以是包含HTML 的简单字符串，也可以是复杂的表单，当然也可以是接口所需的数据格式（JSON或XML）。</p><p>此处再扩展一下，route 修饰器也支持动态URL，下例定义的路由中就有一部分是动态名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/user/&lt;name&gt;&apos;)</span><br><span class="line">def user(name):</span><br><span class="line">    return &apos;&lt;h1&gt;Hello, %s!&lt;/h1&gt;&apos; % name</span><br></pre></td></tr></table></figure></p><p>尖括号中的内容就是动态部分，任何能匹配静态部分的URL 都会映射到这个路由上。调用视图函数时，Flask 会将动态部分作为参数传入函数。在这个视图函数中，参数用于生成针对个人的欢迎消息。</p><p>路由中的动态部分默认使用字符串，不过也可使用类型定义。例如，路由/user/<int:id>只会匹配动态片段id 为整数的URL。Flask 支持在路由中使用int、float 和path 类型。path 类型也是字符串，但不把斜线视作分隔符，而将其当作动态片段的一部分。</int:id></p><h4 id="3、启动服务器"><a href="#3、启动服务器" class="headerlink" title="3、启动服务器"></a>3、启动服务器</h4><p>程序实例用run 方法启动Flask 集成的开发Web 服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">app.run(debug=True)</span><br></pre></td></tr></table></figure></p><p>__name__==’__main__‘ 是Python 的惯常用法，在这里确保直接执行这个脚本时才启动开发Web 服务器。如果这个脚本由其他脚本引入，程序假定父级脚本会启动不同的服务器，因此不会执行app.run()。</p><p>服务器启动后，会进入轮询，等待并处理请求。轮询会一直运行，直到程序停止，比如按Ctrl-C 键。</p><p>有一些选项参数可被app.run() 函数接受用于设置Web 服务器的操作模式。在开发过程中启用调试模式会带来一些便利，比如说激活调试器和重载程序。要想启用调试模式，我们可以把debug 参数设为True。</p><h4 id="4、一个完整的程序"><a href="#4、一个完整的程序" class="headerlink" title="4、一个完整的程序"></a>4、一个完整的程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># hello.py</span><br><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos;</span><br><span class="line"></span><br><span class="line">@app.route(&apos;user/&lt;name&gt;&apos;)</span><br><span class="line">def user(name):</span><br><span class="line">    return &apos;&lt;h1&gt;Hello, %s&lt;/h1&gt;&apos; % self.name</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>然后使用下述命令启动程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py</span><br><span class="line">* Running on http://127.0.0.1:5000/</span><br><span class="line">* Restarting with reloader</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Flask-简介&quot;&gt;&lt;a href=&quot;#一、Flask-简介&quot; class=&quot;headerlink&quot; title=&quot;一、Flask 简介&quot;&gt;&lt;/a&gt;一、Flask 简介&lt;/h3&gt;&lt;p&gt;Flask(&lt;a href=&quot;http://flask.pocoo.org/
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 模块之cPickle</title>
    <link href="http://yoursite.com/2018/02/05/Python-%E6%A8%A1%E5%9D%97%E4%B9%8BcPickle/"/>
    <id>http://yoursite.com/2018/02/05/Python-模块之cPickle/</id>
    <published>2018-02-05T09:28:00.000Z</published>
    <updated>2018-02-05T10:00:09.263Z</updated>
    
    <content type="html"><![CDATA[<p>在python中，一般可以使用pickle类来进行python对象的序列化，而cPickle提供了一个更快速简单的接口，如python文档所说的：“cPickle – A faster pickle”。使用cPickle模块永久地把这些对象储存在你的硬盘上。</p><blockquote><p><strong>对象持久化：</strong><br>如果希望透明地存储 Python 对象，而不丢失其身份和类型等信息，则需要某种形式的对象序列化：它是一个将任意复杂的对象转成对象的文本或二进制表示的过程。同样，必须能够将对象经过序列化后的形式恢复到原有的对象。在 Python 中，这种序列化过程称为 pickle，可以将对象 pickle 成字符串、磁盘上的文件或者任何类似于文件的对象，也可以将这些字符串、文件或任何类似于文件的对象 unpickle 成原来的对象。</p></blockquote><a id="more"></a><p>cPickle可以对任意一种类型的python对象进行序列化操作，比如list，dict，甚至是一个类的对象等。 pickle 模块提供了以下函数对： dumps(object) 返回一个字符串，它包含一个 pickle 格式的对象； loads(string) 返回包含在 pickle 字符串中的对象； dump(object, file) 将对象写到文件，这个文件可以是实际的物理文件，但也可以是任何类似于文件的对象，这个对象具有 write() 方法，可以接受单个的字符串参数； load(file) 返回包含在 pickle 文件中的对象。</p><h5 id="dump-和-load"><a href="#dump-和-load" class="headerlink" title="dump() 和 load()"></a>dump() 和 load()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a1 = &apos;apple&apos;</span><br><span class="line">&gt;&gt;&gt; b1 = &#123;1: &apos;One&apos;, 2: &apos;Two&apos;, 3: &apos;Three&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; c1 = [&apos;fee&apos;, &apos;fie&apos;, &apos;foe&apos;, &apos;fum&apos;]</span><br><span class="line">&gt;&gt;&gt; f1 = file(&apos;temp.pkl&apos;, &apos;wb&apos;)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(a1, f1, True)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(b1, f1, True)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(c1, f1, True)</span><br><span class="line">&gt;&gt;&gt; f1.close()</span><br><span class="line">&gt;&gt;&gt; f2 = file(&apos;temp.pkl&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; a2 = pickle.load(f2)</span><br><span class="line">&gt;&gt;&gt; a2</span><br><span class="line">&apos;apple&apos;</span><br><span class="line">&gt;&gt;&gt; b2 = pickle.load(f2)</span><br><span class="line">&gt;&gt;&gt; b2</span><br><span class="line">&#123;1: &apos;One&apos;, 2: &apos;Two&apos;, 3: &apos;Three&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; c2 = pickle.load(f2)</span><br><span class="line">&gt;&gt;&gt; c2</span><br><span class="line">[&apos;fee&apos;, &apos;fie&apos;, &apos;foe&apos;, &apos;fum&apos;]</span><br><span class="line">&gt;&gt;&gt; f2.close()</span><br></pre></td></tr></table></figure><blockquote><p><strong>dump： 将python对象序列化保存到本地的文件</strong><br>dump函数需要指定两个参数，第一个是需要序列化的python对象名称，第二个是本地的文件，需要注意的是，在这里需要使用open函数打开一个文件，并指定“写”操作<br><strong>load：载入本地文件，恢复python对象</strong><br>同dump一样，这里需要使用open函数打开本地的一个文件，并指定“读”操作 </p></blockquote><h5 id="dumps-和-loads"><a href="#dumps-和-loads" class="headerlink" title="dumps() 和 loads()"></a>dumps() 和 loads()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import cPickle as pickle</span><br><span class="line">&gt;&gt;&gt; t1 = (&apos;this is a string&apos;, 42, [1, 2, 3], None)</span><br><span class="line">&gt;&gt;&gt; t1</span><br><span class="line">(&apos;this is a string&apos;, 42, [1, 2, 3], None)</span><br><span class="line">&gt;&gt;&gt; p1 = pickle.dumps(t1)</span><br><span class="line">&gt;&gt;&gt; p1</span><br><span class="line">&quot;(S&apos;this is a string&apos;/nI42/n(lp1/nI1/naI2/naI3/naNtp2/n.&quot;</span><br><span class="line">&gt;&gt;&gt; print p1</span><br><span class="line">(S&apos;this is a string&apos;</span><br><span class="line">I42</span><br><span class="line">(lp1</span><br><span class="line">I1</span><br><span class="line">aI2</span><br><span class="line">aI3</span><br><span class="line">aNtp2</span><br><span class="line">.</span><br><span class="line">&gt;&gt;&gt; t2 = pickle.loads(p1)</span><br><span class="line">&gt;&gt;&gt; t2</span><br><span class="line">(&apos;this is a string&apos;, 42, [1, 2, 3], None)</span><br><span class="line">&gt;&gt;&gt; p2 = pickle.dumps(t1, True)</span><br><span class="line">&gt;&gt;&gt; p2</span><br><span class="line">&apos;(U/x10this is a stringK*]q/x01(K/x01K/x02K/x03eNtq/x02.&apos;</span><br><span class="line">&gt;&gt;&gt; t3 = pickle.loads(p2)</span><br><span class="line">&gt;&gt;&gt; t3</span><br><span class="line">(&apos;this is a string&apos;, 42, [1, 2, 3], None)</span><br></pre></td></tr></table></figure><blockquote><p><strong>dumps：将python对象序列化保存到一个字符串变量中</strong><br><strong>loads：从字符串变量中载入python对象</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在python中，一般可以使用pickle类来进行python对象的序列化，而cPickle提供了一个更快速简单的接口，如python文档所说的：“cPickle – A faster pickle”。使用cPickle模块永久地把这些对象储存在你的硬盘上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对象持久化：&lt;/strong&gt;&lt;br&gt;如果希望透明地存储 Python 对象，而不丢失其身份和类型等信息，则需要某种形式的对象序列化：它是一个将任意复杂的对象转成对象的文本或二进制表示的过程。同样，必须能够将对象经过序列化后的形式恢复到原有的对象。在 Python 中，这种序列化过程称为 pickle，可以将对象 pickle 成字符串、磁盘上的文件或者任何类似于文件的对象，也可以将这些字符串、文件或任何类似于文件的对象 unpickle 成原来的对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python模块" scheme="http://yoursite.com/tags/Python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python 基础小程序实践</title>
    <link href="http://yoursite.com/2018/02/05/Python-%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/02/05/Python-基础小程序实践/</id>
    <published>2018-02-05T08:54:59.000Z</published>
    <updated>2018-02-05T09:27:05.312Z</updated>
    
    <content type="html"><![CDATA[<p><strong>要求：</strong></p><blockquote><p>创建你自己的命令行 地址簿 程序。在这个程序中，你可以添加、修改、删除和搜索你的联系人（朋友、家人和同事等等）以及它们的信息（诸如电子邮件地址和/或电话号码）。这些详细信息应该被保存下来以便以后提取。</p></blockquote><p><strong>提示：</strong></p><blockquote><p>创建一个类来表示一个人的信息。使用字典储存每个人的对象，把他们的名字作为键。使用cPickle模块永久地把这些对象储存在你的硬盘上。使用字典内建的方法添加、删除和修改人员信息。</p></blockquote><p><font color="red">一旦你完成了这个程序，你就可以说是一个Python程序员了。</font><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#coding=utf-8</span><br><span class="line"># Filename: address.py</span><br><span class="line"></span><br><span class="line">import cPickle as p</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    &apos;&apos;&apos;Person class </span><br><span class="line">    save information of email,phone,name.&apos;&apos;&apos;</span><br><span class="line">    contacts = &#123;&#125;</span><br><span class="line">    contactfile = &apos;contact.data&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        f = file(Person.contactfile)</span><br><span class="line">        Person.contacts = p.load(f)</span><br><span class="line">        f.close()</span><br><span class="line">    </span><br><span class="line">    def add(self, name, email, phone):</span><br><span class="line">        Person.contacts[name] = &#123;&apos;email&apos;: email, &apos;phone&apos;: phone&#125;</span><br><span class="line">        f = file(Person.contactfile, &apos;w&apos;)</span><br><span class="line">        p.dump(Person.contacts, f)</span><br><span class="line">        f.close()</span><br><span class="line">        print &apos;optetor success!&apos;</span><br><span class="line"></span><br><span class="line">    def search(self, name):</span><br><span class="line">        if Person.contacts.has_key(name):</span><br><span class="line">            print &apos;Name: %s Email: %s Phone: %s&apos; % (name, Person.contacts[name][&apos;email&apos;], Person.contacts[name][&apos;phone&apos;])</span><br><span class="line">        else:</span><br><span class="line">            print &apos;search faild!&apos;</span><br><span class="line"></span><br><span class="line">    def delete(self, name):</span><br><span class="line">        if Person.contacts.has_key(name):</span><br><span class="line">            Person.contacts.pop(name)</span><br><span class="line">            f = file(Person.contactfile, &apos;w&apos;)</span><br><span class="line">            p.dump(Person.contacts, f)</span><br><span class="line">            f.close()</span><br><span class="line">            print &apos;delete success!&apos;</span><br><span class="line">        else:</span><br><span class="line">            print &apos;name is not exists!&apos;</span><br><span class="line"></span><br><span class="line">    def modify(self, name, email, phone):</span><br><span class="line">        if Person.contacts.has_key(name):</span><br><span class="line">            if email:</span><br><span class="line">                Person.contacts[name][&apos;email&apos;] = email</span><br><span class="line">            if phone:</span><br><span class="line">                Person.contacts[name][&apos;phone&apos;] = phone</span><br><span class="line">            f = file(Person.contactfile, &apos;w&apos;)</span><br><span class="line">            p.dump(Person.contacts, f)</span><br><span class="line">            f.close()</span><br><span class="line">            print &apos;modify success!&apos;</span><br><span class="line">        else:</span><br><span class="line">            print &apos;name is not exists!&apos;</span><br><span class="line"></span><br><span class="line">def p_add():</span><br><span class="line">    print &quot;Pleace input add information&quot;</span><br><span class="line">    name = raw_input(&apos;name:&apos;)</span><br><span class="line">    email = raw_input(&apos;email:&apos;)</span><br><span class="line">    phone = raw_input(&apos;phone:&apos;)</span><br><span class="line">    person = Person()</span><br><span class="line">    person.add(name, email, phone)</span><br><span class="line"></span><br><span class="line">def p_modify():</span><br><span class="line">    name = raw_input(&apos;Pleace input modify name:&apos;)</span><br><span class="line">    email = raw_input(&apos;email:&apos;)</span><br><span class="line">    phone = raw_input(&apos;phone:&apos;)</span><br><span class="line">    person = Person()</span><br><span class="line">    person.modify(name, email, phone)</span><br><span class="line"></span><br><span class="line">def p_delete():</span><br><span class="line">    name = raw_input(&apos;Pleace input search name:&apos;)</span><br><span class="line">    person = Person()</span><br><span class="line">    person.delete(name)</span><br><span class="line"></span><br><span class="line">def p_search():</span><br><span class="line">    name = raw_input(&apos;Pleace input search name:&apos;)</span><br><span class="line">    person = Person()</span><br><span class="line">    person.search(name)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&apos;&apos;&apos;What would you want to do ?</span><br><span class="line">    a=add, m=modify, d=delete, s=search&apos;&apos;&apos;)</span><br><span class="line">    optetor = raw_input(&apos;pleace input a character:&apos;)</span><br><span class="line">    if(optetor == &apos;a&apos;):</span><br><span class="line">        p_add()</span><br><span class="line">    elif(optetor == &apos;m&apos;):</span><br><span class="line">        p_modify()</span><br><span class="line">    elif(optetor == &apos;d&apos;):</span><br><span class="line">        p_delete()</span><br><span class="line">    elif(optetor == &apos;s&apos;):</span><br><span class="line">        p_search()</span><br><span class="line">    else:</span><br><span class="line">        print &apos;input error&apos;</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    try:</span><br><span class="line">        main()</span><br><span class="line">    except Exception,e:</span><br><span class="line">        print e</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;要求：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建你自己的命令行 地址簿 程序。在这个程序中，你可以添加、修改、删除和搜索你的联系人（朋友、家人和同事等等）以及它们的信息（诸如电子邮件地址和/或电话号码）。这些详细信息应该被保存下来以便以后提取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建一个类来表示一个人的信息。使用字典储存每个人的对象，把他们的名字作为键。使用cPickle模块永久地把这些对象储存在你的硬盘上。使用字典内建的方法添加、删除和修改人员信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;一旦你完成了这个程序，你就可以说是一个Python程序员了。&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python实践" scheme="http://yoursite.com/tags/Python%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级整理（Python中文手册）</title>
    <link href="http://yoursite.com/2018/02/05/Python-%E9%AB%98%E7%BA%A7%E6%95%B4%E7%90%86%EF%BC%88Python%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/02/05/Python-高级整理（Python中文手册）/</id>
    <published>2018-02-05T05:52:23.000Z</published>
    <updated>2018-02-05T06:30:38.424Z</updated>
    
    <content type="html"><![CDATA[<p>记住，Python把在程序中用到的任何东西都称为 对象 。这是从广义上说的。因此我们不会说“某某 东西 ”，我们说“某个 对象 ”。<br><strong>给面向对象编程用户的注释：</strong></p><blockquote><p>就每一个东西包括数、字符串甚至函数都是对象这一点来说，Python是极其完全地面向对象的。 </p></blockquote><a id="more"></a><h3 id="1、模块"><a href="#1、模块" class="headerlink" title="1、模块"></a>1、模块</h3><h4 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>你已经学习了如何在你的程序中定义一次函数而重用代码。如果你想要在其他程序中重用很多函数，那么你该如何编写程序呢？你可能已经猜到了，答案是使用模块。模块基本上就是一个包含了所有你定义的函数和变量的文件。为了在其他程序中重用模块，模块的文件名必须以.py为扩展名。</p><p>模块可以从其他程序 输入 以便利用它的功能。这也是我们使用Python标准库的方法。<br>模块的用处在于它能为你在别的程序中重用它提供的服务和功能。Python附带的标准库就是这样一组模块的例子。</p><h4 id="（2）字节编译的-pyc文件"><a href="#（2）字节编译的-pyc文件" class="headerlink" title="（2）字节编译的.pyc文件"></a>（2）字节编译的.pyc文件</h4><p>输入一个模块相对来说是一个比较费时的事情，所以Python做了一些技巧，以便使输入模块更加快一些。一种方法是创建 字节编译的文件 ，这些文件以.pyc作为扩展名。字节编译的文件与Python变换程序的中间状态有关。当你在下次从别的程序输入这个模块的时候，.pyc文件是十分有用的——它会快得多，因为一部分输入模块所需的处理已经完成了。另外，这些字节编译的文件也是与平台无关的。</p><h4 id="（3）from-import-语句"><a href="#（3）from-import-语句" class="headerlink" title="（3）from..import 语句"></a>（3）from..import 语句</h4><p>如果你想要直接输入argv变量到你的程序中（避免在每次使用它时打sys.），那么你可以使用from sys import argv语句。如果你想要输入所有sys模块使用的名字，那么你可以使用from sys import *语句。这对于所有模块都适用。<strong>一般说来，应该避免使用from..import而使用import语句，因为这样可以使你的程序更加易读，也可以避免名称的冲突。</strong></p><h4 id="（4）模块的-name"><a href="#（4）模块的-name" class="headerlink" title="（4）模块的 __name__"></a>（4）模块的 __name__</h4><p>每个模块都有一个名称，在模块中可以通过语句来找出模块的名称。这在一个场合特别有用——就如前面所提到的，当一个模块被第一次输入的时候，这个模块的主块将被运行。假如我们只想在程序本身被使用的时候运行主块，而在它被别的模块输入的时候不运行主块，我们该怎么做呢？这可以通过模块的__name__属性完成。</p><p><strong>例8.2 使用模块的__name__</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: using_name.py</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print &apos;This program is being run by itself&apos;</span><br><span class="line">else:</span><br><span class="line">    print &apos;I am being imported from another module&apos;</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python using_name.py</span><br><span class="line">This program is being run by itself</span><br><span class="line"></span><br><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import using_name</span><br><span class="line">I am being imported from another module</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>每个Python模块都有它的__name__，如果它是’__main__‘，这说明这个模块被用户单独运行，我们可以进行相应的恰当操作。</p><h4 id="（5）dir-函数"><a href="#（5）dir-函数" class="headerlink" title="（5）dir() 函数"></a>（5）dir() 函数</h4><p>你可以使用内建的dir函数来列出模块定义的标识符。标识符有函数、类和变量。<br>当你为dir()提供一个模块名的时候，它返回模块定义的名称列表。如果不提供参数，它返回当前模块中定义的名称列表。</p><h3 id="2、面向对象的编程"><a href="#2、面向对象的编程" class="headerlink" title="2、面向对象的编程"></a>2、面向对象的编程</h3><h4 id="（1）简介-1"><a href="#（1）简介-1" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>在我们的程序中，我们根据操作数据的函数或语句块来设计程序的。这被称为 面向过程的 编程。还有一种把数据和功能结合起来，用称为对象的东西包裹起来组织程序的方法。这种方法称为 面向对象的 编程理念。在大多数时候你可以使用过程性编程，但是有些时候当你想要编写大型程序或是寻求一个更加合适的解决方案的时候，你就得使用面向对象的编程技术。</p><p>类和对象是面向对象编程的两个主要方面。<strong>类</strong>创建一个新类型，而<strong>对象</strong>这个类的 实例 。这类似于你有一个int类型的变量，这存储整数的变量是int类的实例（对象）。</p><p><em>注意，即便是整数也被作为对象（属于int类）。这和C++、Java（1.5版之前）把整数纯粹作为类型是不同的。通过help(int)了解更多这个类的详情。</em></p><p>对象可以使用普通的 属于 对象的变量存储数据。属于一个对象或类的变量被称为<strong>域</strong>。对象也可以使用 属于 类的函数来具有功能。这样的函数被称为类的方法。这些术语帮助我们把它们与孤立的函数和变量区分开来。域和方法可以合称为类的<strong>属性</strong>。</p><p>域有两种类型——属于每个实例/类的对象或属于类本身。它们分别被称为<strong>实例变量</strong>和<strong>类变量</strong>。</p><p>类使用class关键字创建。类的域和方法被列在一个缩进块中。</p><h4 id="（2）self"><a href="#（2）self" class="headerlink" title="（2）self"></a>（2）self</h4><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，但是在调用这个方法的时候你不为这个参数赋值，Python会提供这个值。这个特别的变量指对象本身，按照惯例它的名称是self。</p><p>虽然你可以给这个参数任何名称，但是 强烈建议 你使用self这个名称——其他名称都是不赞成你使用的。使用一个标准的名称有很多优点——你的程序读者可以迅速识别它，如果使用self的话，还有些IDE（集成开发环境）也可以帮助你。</p><p>你一定很奇怪Python如何给self赋值以及为何你不需要给它赋值。举一个例子会使此变得清晰。假如你有一个类称为MyClass和这个类的一个实例MyObject。当你调用这个对象的方法MyObject.method(arg1, arg2)的时候，这会由Python自动转为MyClass.method(MyObject, arg1, arg2)——这就是self的原理了。</p><p><strong>（注：这也意味着如果你有一个不需要参数的方法，你还是得给这个方法定义一个self参数。）</strong></p><h4 id="（3）创建一个类"><a href="#（3）创建一个类" class="headerlink" title="（3）创建一个类"></a>（3）创建一个类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例11.1 创建一个类</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: simplestclass.py</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    pass # An empty block</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">print p</span><br></pre></td></tr></table></figure><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python simplestclass.py</span><br><span class="line">&lt;__main__.Person instance at 0xf6fcb18c&gt;</span><br></pre></td></tr></table></figure></p><p>我们使用class语句后跟类名，创建了一个新的类。这后面跟着一个缩进的语句块形成类体。在这个例子中，我们使用了一个空白块，它由pass语句表示。</p><p>接下来，我们使用类名后跟一对圆括号来创建一个对象/实例。为了验证，我们简单地打印了这个变量的类型。它告诉我们我们已经在__main__模块中有了一个Person类的实例。</p><p>可以注意到存储对象的计算机内存地址也打印了出来。这个地址在你的计算机上会是另外一个值，因为Python可以在任何空位存储对象。</p><h4 id="（4）init方法"><a href="#（4）init方法" class="headerlink" title="（4）init方法"></a>（4）<strong>init</strong>方法</h4><p>在Python的类中有很多方法的名字有特殊的重要意义。现在我们将学习__init__方法的意义。</p><p>__init__方法在类的一个对象被建立时，马上运行。这个方法可以用来对你的对象做一些你希望的 初始化 。注意，这个名称的开始和结尾都是双下划线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例11.3 使用__init__方法</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: class_init.py</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def sayHi(self):</span><br><span class="line">        print &apos;Hello, my name is&apos;, self.name</span><br><span class="line"></span><br><span class="line">p = Person(&apos;Swaroop&apos;)</span><br><span class="line">p.sayHi()</span><br><span class="line"></span><br><span class="line"># This short example can also be written as Person(&apos;Swaroop&apos;).sayHi()</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python class_init.py</span><br><span class="line">Hello, my name is Swaroop</span><br></pre></td></tr></table></figure></p><p>这里，我们把__init__方法定义为取一个参数name（以及普通的参数self）。在这个__init__里，我们只是创建一个新的域，也称为name。注意它们是两个不同的变量，尽管它们有相同的名字。点号使我们能够区分它们。</p><p>最重要的是，我们没有专门调用__init__方法，只是在创建一个类的新实例的时候，把参数包括在圆括号内跟在类名后面，从而传递给__init__方法。这是这种方法的重要之处。与 <em>construct</em> 的概念类似。</p><p>现在，我们能够在我们的方法中使用self.name域。这在sayHi方法中得到了验证。</p><h4 id="（5）类与对象的方法"><a href="#（5）类与对象的方法" class="headerlink" title="（5）类与对象的方法"></a>（5）类与对象的方法</h4><p>我们已经讨论了类与对象的功能部分，现在我们来看一下它的数据部分。事实上，它们只是与类和对象的<strong>名称空间</strong> 绑定 的普通变量，即这些名称只在这些类与对象的前提下有效。</p><p>有两种类型的 <strong>域</strong> ——类的变量和对象的变量，它们根据是类还是对象 拥有 这个变量而区分。</p><p><strong>类的变量</strong> 由一个类的所有对象（实例）共享使用。只有一个类变量的拷贝，所以当某个对象对类的变量做了改动的时候，这个改动会反映到所有其他的实例上。</p><p><strong>对象的变量</strong> 由类的每个对象/实例拥有。因此每个对象有自己对这个域的一份拷贝，即它们不是共享的，在同一个类的不同实例中，虽然对象的变量有相同的名称，但是是互不相关的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">例11.4 使用类与对象的变量</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: objvar.py</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    &apos;&apos;&apos;Represents a person.&apos;&apos;&apos;</span><br><span class="line">    population = 0</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        &apos;&apos;&apos;Initializes the person&apos;s data.&apos;&apos;&apos;</span><br><span class="line">        self.name = name</span><br><span class="line">        print &apos;(Initializing %s)&apos; % self.name</span><br><span class="line"></span><br><span class="line">        # When this person is created, he/she</span><br><span class="line">        # adds to the population</span><br><span class="line">        Person.population += 1</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        &apos;&apos;&apos;I am dying.&apos;&apos;&apos;</span><br><span class="line">        print &apos;%s says bye.&apos; % self.name</span><br><span class="line"></span><br><span class="line">        Person.population -= 1</span><br><span class="line"></span><br><span class="line">        if Person.population == 0:</span><br><span class="line">            print &apos;I am the last one.&apos;</span><br><span class="line">        else:</span><br><span class="line">            print &apos;There are still %d people left.&apos; % Person.population</span><br><span class="line"></span><br><span class="line">    def sayHi(self):</span><br><span class="line">        &apos;&apos;&apos;Greeting by the person.</span><br><span class="line"></span><br><span class="line">        Really, that&apos;s all it does.&apos;&apos;&apos;</span><br><span class="line">        print &apos;Hi, my name is %s.&apos; % self.name</span><br><span class="line"></span><br><span class="line">    def howMany(self):</span><br><span class="line">        &apos;&apos;&apos;Prints the current population.&apos;&apos;&apos;</span><br><span class="line">        if Person.population == 1:</span><br><span class="line">            print &apos;I am the only person here.&apos;</span><br><span class="line">        else:</span><br><span class="line">            print &apos;We have %d persons here.&apos; % Person.population</span><br><span class="line"></span><br><span class="line">swaroop = Person(&apos;Swaroop&apos;)</span><br><span class="line">swaroop.sayHi()</span><br><span class="line">swaroop.howMany()</span><br><span class="line"></span><br><span class="line">kalam = Person(&apos;Abdul Kalam&apos;)</span><br><span class="line">kalam.sayHi()</span><br><span class="line">kalam.howMany()</span><br><span class="line"></span><br><span class="line">swaroop.sayHi()</span><br><span class="line">swaroop.howMany()</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python objvar.py</span><br><span class="line">(Initializing Swaroop)</span><br><span class="line">Hi, my name is Swaroop.</span><br><span class="line">I am the only person here.</span><br><span class="line">(Initializing Abdul Kalam)</span><br><span class="line">Hi, my name is Abdul Kalam.</span><br><span class="line">We have 2 persons here.</span><br><span class="line">Hi, my name is Swaroop.</span><br><span class="line">We have 2 persons here.</span><br><span class="line">Abdul Kalam says bye.</span><br><span class="line">There are still 1 people left.</span><br><span class="line">Swaroop says bye.</span><br><span class="line">I am the last one.</span><br></pre></td></tr></table></figure></p><p>这是一个很长的例子，但是它有助于说明类与对象的变量的本质。这里，population属于Person类，因此是一个类的变量。name变量属于对象（它使用self赋值）因此是对象的变量。</p><p>观察可以发现__init__方法用一个名字来初始化Person实例。在这个方法中，我们让population增加1，这是因为我们增加了一个人。同样可以发现，self.name的值根据每个对象指定，这表明了它作为对象的变量的本质。</p><p>记住，你只能使用self变量来参考同一个对象的变量和方法。这被称为 属性参考 。</p><p>在这个程序中，我们还看到docstring对于类和方法同样有用。我们可以在运行时使用Person.__doc__和Person.sayHi.__doc__来分别访问类与方法的文档字符串。</p><p>就如同__init__方法一样，还有一个特殊的方法__del__，它在对象消逝的时候被调用。对象消逝即对象不再被使用，它所占用的内存将返回给系统作它用。在这个方法里面，我们只是简单地把Person.population减1。</p><p>当对象不再被使用时，__del__方法运行，但是很难保证这个方法究竟在 什么时候 运行。如果你想要指明它的运行，你就得使用del语句，就如同我们在以前的例子中使用的那样。</p><p><strong>给C++/Java/C#程序员的注释</strong><br>Python中所有的类成员（包括数据成员）都是 公共的 ，所有的方法都是 有效的 。<br>只有一个例外：如果你使用的数据成员名称以 双下划线前缀 比如__privatevar，Python的名称管理体系会有效地把它作为私有变量。<br>这样就有一个惯例，如果某个变量只想在类或对象中使用，就应该以单下划线前缀。而其他的名称都将作为公共的，可以被其他类/对象使用。记住这只是一个惯例，并不是Python所要求的（与双下划线前缀不同）。<br>同样，注意__del__方法与 destructor 的概念类似。</p><p><strong>一些特殊的方法：</strong></p><style type="text/css">    table th:first-of-type {        width: 100px;    }</style><table><thead><tr><th>名称</th><th>说明 </th></tr></thead><tbody><tr><td><strong>init</strong>(self,…)</td><td>这个方法在新建对象恰好要被返回使用之前被调用。 </td></tr><tr><td><strong>del</strong>(self)</td><td>恰好在对象要被删除之前调用。 </td></tr><tr><td><strong>str</strong>(self)</td><td>在我们对对象使用print语句或是使用str()的时候调用。 </td></tr><tr><td><strong>lt</strong>(self,other)</td><td>当使用 小于 运算符（&lt;）的时候调用。类似地，对于所有的运算符（+，&gt;等等）都有特殊的方法。 </td></tr><tr><td><strong>getitem</strong>(self,key)</td><td>使用x[key]索引操作符的时候调用。 </td></tr><tr><td><strong>len</strong>(self)</td><td>对序列对象使用内建的len()函数的时候调用。 </td></tr></tbody></table><h4 id="（6）继承"><a href="#（6）继承" class="headerlink" title="（6）继承"></a>（6）继承</h4><p>面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过 继承 机制。继承完全可以理解成类之间的 类型和子类型 关系。</p><p>假设你想要写一个程序来记录学校之中的教师和学生情况。他们有一些共同属性，比如姓名、年龄和地址。他们也有专有的属性，比如教师的薪水、课程和假期，学生的成绩和学费。</p><p>你可以为教师和学生建立两个独立的类来处理它们，但是这样做的话，如果要增加一个新的共有属性，就意味着要在这两个独立的类中都增加这个属性。这很快就会显得不实用。</p><p>一个比较好的方法是创建一个共同的类称为SchoolMember然后让教师和学生的类 继承 这个共同的类。即它们都是这个类型（类）的子类型，然后我们再为这些子类型添加专有的属性。</p><p>使用这种方法有很多优点。如果我们增加/改变了SchoolMember中的任何功能，它会自动地反映到子类型之中。例如，你要为教师和学生都增加一个新的身份证域，那么你只需简单地把它加到SchoolMember类中。然而，在一个子类型之中做的改动不会影响到别的子类型。另外一个优点是你可以把教师和学生对象都作为SchoolMember对象来使用，这在某些场合特别有用，比如统计学校成员的人数。一个子类型在任何需要父类型的场合可以被替换成父类型，即对象可以被视作是父类的实例，这种现象被称为多态现象。</p><p>另外，我们会发现在 重用 父类的代码的时候，我们无需在不同的类中重复它。而如果我们使用独立的类的话，我们就不得不这么做了。</p><p>在上述的场合中，SchoolMember类被称为 基本类 或 超类 。而Teacher和Student类被称为 导出类 或 子类 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">例11.5 使用继承</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: inherit.py</span><br><span class="line"></span><br><span class="line">class SchoolMember:</span><br><span class="line">    &apos;&apos;&apos;Represents any school member.&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        print &apos;(Initialized SchoolMember: %s)&apos; % self.name</span><br><span class="line"></span><br><span class="line">    def tell(self):</span><br><span class="line">        &apos;&apos;&apos;Tell my details.&apos;&apos;&apos;</span><br><span class="line">        print &apos;Name:&quot;%s&quot; Age:&quot;%s&quot;&apos; % (self.name, self.age),</span><br><span class="line"></span><br><span class="line">class Teacher(SchoolMember):</span><br><span class="line">    &apos;&apos;&apos;Represents a teacher.&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, name, age, salary):</span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.salary = salary</span><br><span class="line">        print &apos;(Initialized Teacher: %s)&apos; % self.name</span><br><span class="line"></span><br><span class="line">    def tell(self):</span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        print &apos;Salary: &quot;%d&quot;&apos; % self.salary</span><br><span class="line"></span><br><span class="line">class Student(SchoolMember):</span><br><span class="line">    &apos;&apos;&apos;Represents a student.&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, name, age, marks):</span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.marks = marks</span><br><span class="line">        print &apos;(Initialized Student: %s)&apos; % self.name</span><br><span class="line"></span><br><span class="line">    def tell(self):</span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        print &apos;Marks: &quot;%d&quot;&apos; % self.marks</span><br><span class="line"></span><br><span class="line">t = Teacher(&apos;Mrs. Shrividya&apos;, 40, 30000)</span><br><span class="line">s = Student(&apos;Swaroop&apos;, 22, 75)</span><br><span class="line"></span><br><span class="line">print # prints a blank line</span><br><span class="line"></span><br><span class="line">members = [t, s]</span><br><span class="line">for member in members:</span><br><span class="line">    member.tell() # works for both Teachers and Students</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python inherit.py</span><br><span class="line">(Initialized SchoolMember: Mrs. Shrividya)</span><br><span class="line">(Initialized Teacher: Mrs. Shrividya)</span><br><span class="line">(Initialized SchoolMember: Swaroop)</span><br><span class="line">(Initialized Student: Swaroop)</span><br><span class="line"></span><br><span class="line">Name:&quot;Mrs. Shrividya&quot; Age:&quot;40&quot; Salary: &quot;30000&quot;</span><br><span class="line">Name:&quot;Swaroop&quot; Age:&quot;22&quot; Marks: &quot;75&quot;</span><br></pre></td></tr></table></figure></p><p>为了使用继承，我们把基本类的名称作为一个元组跟在定义类时的类名称之后。然后，我们注意到基本类的<strong>init</strong>方法专门使用self变量调用，这样我们就可以初始化对象的基本类部分。这一点十分重要——Python不会自动调用基本类的constructor，你得亲自专门调用它。</p><p>我们还观察到我们在方法调用之前加上类名称前缀，然后把self变量及其他参数传递给它。</p><p>注意，在我们使用SchoolMember类的tell方法的时候，我们把Teacher和Student的实例仅仅作为SchoolMember的实例。</p><p>另外，在这个例子中，我们调用了子类型的tell方法，而不是SchoolMember类的tell方法。可以这样来理解，Python总是首先查找对应类型的方法，在这个例子中就是如此。如果它不能在导出类中找到对应的方法，它才开始到基本类中逐个查找。基本类是在类定义的时候，在元组之中指明的。</p><p>一个术语的注释——如果在继承元组中列了一个以上的类，那么它就被称作 多重继承 。</p><h3 id="3、输入-输出"><a href="#3、输入-输出" class="headerlink" title="3、输入/输出"></a>3、输入/输出</h3><p>在很多时候，你会想要让你的程序与用户（可能是你自己）交互。你会从用户那里得到输入，然后打印一些结果。我们可以分别使用raw_input和print语句来完成这些功能。对于输出，你也可以使用多种多样的str（字符串）类。例如，你能够使用rjust方法来得到一个按一定宽度右对齐的字符串。利用help(str)获得更多详情。</p><p>另一个常用的输入/输出类型是处理文件。创建、读和写文件的能力是许多程序所必需的，我们将会在这章探索如何实现这些功能。</p><h4 id="（1）文件"><a href="#（1）文件" class="headerlink" title="（1）文件"></a>（1）文件</h4><p>你可以通过创建一个file类的对象来打开一个文件，分别使用file类的read、readline或write方法来恰当地读写文件。对文件的读写能力依赖于你在打开文件时指定的模式。最后，当你完成对文件的操作的时候，你调用close方法来告诉Python我们完成了对文件的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">例12.1 使用文件</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: using_file.py</span><br><span class="line"></span><br><span class="line">poem = &apos;&apos;&apos;\</span><br><span class="line">Programming is fun</span><br><span class="line">When the work is done</span><br><span class="line">if you wanna make your work also fun:</span><br><span class="line">        use Python!</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">f = file(&apos;poem.txt&apos;, &apos;w&apos;) # open for &apos;w&apos;riting</span><br><span class="line">f.write(poem) # write text to file</span><br><span class="line">f.close() # close the file</span><br><span class="line"></span><br><span class="line">f = file(&apos;poem.txt&apos;)</span><br><span class="line"># if no mode is specified, &apos;r&apos;ead mode is assumed by default</span><br><span class="line">while True:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    if len(line) == 0: # Zero length indicates EOF</span><br><span class="line">        break</span><br><span class="line">    print line,</span><br><span class="line">    # Notice comma to avoid automatic newline added by Python</span><br><span class="line">f.close() # close the file</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python using_file.py</span><br><span class="line">Programming is fun</span><br><span class="line">When the work is done</span><br><span class="line">if you wanna make your work also fun:</span><br><span class="line">        use Python!</span><br></pre></td></tr></table></figure></p><p>首先，我们通过指明我们希望打开的文件和模式来创建一个file类的实例。模式可以为读模式（’r’）、写模式（’w’）或追加模式（’a’）。事实上还有多得多的模式可以使用，你可以使用help(file)来了解它们的详情。</p><p>我们首先用写模式打开文件，然后使用file类的write方法来写文件，最后我们用close关闭这个文件。</p><p>接下来，我们再一次打开同一个文件来读文件。如果我们没有指定模式，读模式会作为默认的模式。在一个循环中，我们使用readline方法读文件的每一行。这个方法返回包括行末换行符的一个完整行。所以，当一个 空的 字符串被返回的时候，即表示文件末已经到达了，于是我们停止循环。</p><p>注意，因为从文件读到的内容已经以换行符结尾，所以我们在print语句上<strong>使用逗号来消除自动换行</strong>。最后，我们用close关闭这个文件。</p><p>现在，来看一下poem.txt文件的内容来验证程序确实工作正常了。</p><h4 id="（2）存储器"><a href="#（2）存储器" class="headerlink" title="（2）存储器"></a>（2）存储器</h4><p>Python提供一个标准的模块，称为pickle。使用它你可以在一个文件中储存任何Python对象，之后你又可以把它完整无缺地取出来。这被称为 持久地 储存对象。</p><p>还有另一个模块称为cPickle，它的功能和pickle模块完全相同，只不过它是用C语言编写的，因此要快得多（比pickle快1000倍）。你可以使用它们中的任一个，而我们在这里将使用cPickle模块。记住，我们把这两个模块都简称为pickle模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">例12.2 储存与取储存</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: pickling.py</span><br><span class="line"></span><br><span class="line">import cPickle as p</span><br><span class="line">#import pickle as p</span><br><span class="line"></span><br><span class="line">shoplistfile = &apos;shoplist.data&apos;</span><br><span class="line"># the name of the file where we will store the object</span><br><span class="line"></span><br><span class="line">shoplist = [&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;]</span><br><span class="line"></span><br><span class="line"># Write to the file</span><br><span class="line">f = file(shoplistfile, &apos;w&apos;)</span><br><span class="line">p.dump(shoplist, f) # dump the object to a file</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">del shoplist # remove the shoplist</span><br><span class="line"></span><br><span class="line"># Read back from the storage</span><br><span class="line">f = file(shoplistfile)</span><br><span class="line">storedlist = p.load(f)</span><br><span class="line">print storedlist</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python pickling.py</span><br><span class="line">[&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;]</span><br></pre></td></tr></table></figure></p><p>首先，请注意我们使用了import..as语法。这是一种便利方法，以便于我们可以使用更短的模块名称。在这个例子中，它还让我们能够通过简单地改变一行就切换到另一个模块（cPickle或者pickle）！在程序的其余部分的时候，我们简单地把这个模块称为p。</p><p>为了在文件里储存一个对象，首先以写模式打开一个file对象，然后调用储存器模块的dump函数，把对象储存到打开的文件中。这个过程称为 储存 。</p><p>接下来，我们使用pickle模块的load函数的返回来取回对象。这个过程称为 取储存 。</p><h3 id="4、异常"><a href="#4、异常" class="headerlink" title="4、异常"></a>4、异常</h3><p>当你的程序中出现某些 异常的 状况的时候，异常就发生了。例如，当你想要读某个文件的时候，而那个文件不存在。或者在程序运行的时候，你不小心把它删除了。上述这些情况可以使用异常来处理。</p><p>假如你的程序中有一些无效的语句，会怎么样呢？Python会引发并告诉你那里有一个错误，从而处理这样的情况。</p><h4 id="（1）处理异常"><a href="#（1）处理异常" class="headerlink" title="（1）处理异常"></a>（1）处理异常</h4><p>我们可以使用try..except语句来处理异常。我们把通常的语句放在try-块中，而把我们的错误处理语句放在except-块中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">例13.1 处理异常</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: try_except.py</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    s = raw_input(&apos;Enter something --&gt; &apos;)</span><br><span class="line">except EOFError:</span><br><span class="line">    print &apos;\nWhy did you do an EOF on me?&apos;</span><br><span class="line">    sys.exit() # exit the program</span><br><span class="line">except:</span><br><span class="line">    print &apos;\nSome error/exception occurred.&apos;</span><br><span class="line">    # here, we are not exiting the program</span><br><span class="line"></span><br><span class="line">print &apos;Done&apos;</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python try_except.py</span><br><span class="line">Enter something --&gt;</span><br><span class="line">Why did you do an EOF on me?</span><br><span class="line"></span><br><span class="line">$ python try_except.py</span><br><span class="line">Enter something --&gt; Python is exceptional!</span><br><span class="line">Done</span><br></pre></td></tr></table></figure></p><p>我们把所有可能引发错误的语句放在try块中，然后在except从句/块中处理所有的错误和异常。except从句可以专门处理单一的错误或异常，或者一组包括在圆括号内的错误/异常。如果没有给出错误或异常的名称，它会处理 所有的 错误和异常。对于每个try从句，至少都有一个相关联的except从句。</p><p>如果某个错误或异常没有被处理，默认的Python处理器就会被调用。它会终止程序的运行，并且打印一个消息，我们已经看到了这样的处理。</p><p>你还可以让try..catch块关联上一个else从句。当没有异常发生的时候，else从句将被执行。</p><p>我们还可以得到异常对象，从而获取更多有个这个异常的信息。</p><h4 id="（2）引发异常"><a href="#（2）引发异常" class="headerlink" title="（2）引发异常"></a>（2）引发异常</h4><p>你可以使用raise语句 引发 异常。你还得指明错误/异常的名称和伴随异常 触发的 异常对象。你可以引发的错误或异常应该分别是一个Error或Exception类的直接或间接导出类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">例13.2 如何引发异常</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: raising.py</span><br><span class="line"></span><br><span class="line">class ShortInputException(Exception):</span><br><span class="line">    &apos;&apos;&apos;A user-defined exception class.&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, length, atleast):</span><br><span class="line">        Exception.__init__(self)</span><br><span class="line">        self.length = length</span><br><span class="line">        self.atleast = atleast</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    s = raw_input(&apos;Enter something --&gt; &apos;)</span><br><span class="line">    if len(s) &lt; 3:</span><br><span class="line">        raise ShortInputException(len(s), 3)</span><br><span class="line">    # Other work can continue as usual here</span><br><span class="line">except EOFError:</span><br><span class="line">    print &apos;\nWhy did you do an EOF on me?&apos;</span><br><span class="line">except ShortInputException, x:</span><br><span class="line">    print &apos;ShortInputException: The input was of length %d, \</span><br><span class="line">          was expecting at least %d&apos; % (x.length, x.atleast)</span><br><span class="line">else:</span><br><span class="line">    print &apos;No exception was raised.&apos;</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python raising.py</span><br><span class="line">Enter something --&gt;</span><br><span class="line">Why did you do an EOF on me?</span><br><span class="line"></span><br><span class="line">$ python raising.py</span><br><span class="line">Enter something --&gt; ab</span><br><span class="line">ShortInputException: The input was of length 2, was expecting at least 3</span><br><span class="line"></span><br><span class="line">$ python raising.py</span><br><span class="line">Enter something --&gt; abc</span><br><span class="line">No exception was raised.</span><br></pre></td></tr></table></figure></p><p>这里，我们创建了我们自己的异常类型，其实我们可以使用任何预定义的异常/错误。这个新的异常类型是ShortInputException类。它有两个域——length是给定输入的长度，atleast则是程序期望的最小长度。</p><p>在except从句中，我们提供了错误类和用来表示错误/异常对象的变量。这与函数调用中的形参和实参概念类似。在这个特别的except从句中，我们使用异常对象的length和atleast域来为用户打印一个恰当的消息。</p><h4 id="（3）try-finally"><a href="#（3）try-finally" class="headerlink" title="（3）try..finally"></a>（3）try..finally</h4><p>假如你在读一个文件的时候，希望在无论异常发生与否的情况下都关闭文件，该怎么做呢？这可以使用finally块来完成。注意，在一个try块下，你可以同时使用except从句和finally块。如果你要同时使用它们的话，需要把一个嵌入另外一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">例13.3 使用finally</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: finally.py</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    f = file(&apos;poem.txt&apos;)</span><br><span class="line">    while True: # our usual file-reading idiom</span><br><span class="line">        line = f.readline()</span><br><span class="line">        if len(line) == 0:</span><br><span class="line">            break</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print line,</span><br><span class="line">finally:</span><br><span class="line">    f.close()</span><br><span class="line">    print &apos;Cleaning up...closed the file&apos;</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python finally.py</span><br><span class="line">Programming is fun</span><br><span class="line">When the work is done</span><br><span class="line">Cleaning up...closed the file</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;finally.py&quot;, line 12, in ?</span><br><span class="line">    time.sleep(2)</span><br><span class="line">KeyboardInterrupt</span><br></pre></td></tr></table></figure></p><p>我们进行通常的读文件工作，但是我有意在每打印一行之前用time.sleep方法暂停2秒钟。这样做的原因是让程序运行得慢一些（Python由于其本质通常运行得很快）。在程序运行的时候，按Ctrl-c中断/取消程序。</p><p>我们可以观察到KeyboardInterrupt异常被触发，程序退出。但是在程序退出之前，finally从句仍然被执行，把文件关闭</p><h3 id="5、其它知识点"><a href="#5、其它知识点" class="headerlink" title="5、其它知识点"></a>5、其它知识点</h3><h4 id="（1）在函数中接收元组和列表"><a href="#（1）在函数中接收元组和列表" class="headerlink" title="（1）在函数中接收元组和列表"></a>（1）在函数中接收元组和列表</h4><p>当要使函数接收元组或字典形式的参数的时候，有一种特殊的方法，它分别使用<em>和*</em>前缀。这种方法在函数需要获取可变数量的参数的时候特别有用。</p><p>由于在args变量前有<em>前缀，所有多余的函数参数都会作为一个元组存储在args中。如果使用的是*</em>前缀，多余的参数则会被认为是一个字典的键/值对。</p><h4 id="（2）lambda形式"><a href="#（2）lambda形式" class="headerlink" title="（2）lambda形式"></a>（2）lambda形式</h4><p>lambda语句被用来创建新的函数对象，并且在运行时返回它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例15.2 使用lambda形式</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: lambda.py</span><br><span class="line"></span><br><span class="line">def make_repeater(n):</span><br><span class="line">    return lambda s: s*n</span><br><span class="line"></span><br><span class="line">twice = make_repeater(2)</span><br><span class="line"></span><br><span class="line">print twice(&apos;word&apos;)</span><br><span class="line">print twice(5)</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python lambda.py</span><br><span class="line">wordword</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p><p>这里，我们使用了make_repeater函数在运行时创建新的函数对象，并且返回它。lambda语句用来创建函数对象。本质上，lambda需要一个参数，后面仅跟单个表达式作为函数体，而表达式的值被这个新建的函数返回。注意，即便是print语句也不能用在lambda形式中，只能使用表达式。</p><h4 id="（3）exec-和-eval-语句"><a href="#（3）exec-和-eval-语句" class="headerlink" title="（3）exec 和 eval 语句"></a>（3）exec 和 eval 语句</h4><p>exec语句用来执行储存在字符串或文件中的Python语句。例如，我们可以在运行时生成一个包含Python代码的字符串，然后使用exec语句执行这些语句。下面是一个简单的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; exec &apos;print &quot;Hello World&quot;&apos;</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p><p>eval语句用来计算存储在字符串中的有效Python表达式。下面是一个简单的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; eval(&apos;2*3&apos;)</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记住，Python把在程序中用到的任何东西都称为 对象 。这是从广义上说的。因此我们不会说“某某 东西 ”，我们说“某个 对象 ”。&lt;br&gt;&lt;strong&gt;给面向对象编程用户的注释：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就每一个东西包括数、字符串甚至函数都是对象这一点来说，Python是极其完全地面向对象的。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python知识点" scheme="http://yoursite.com/tags/Python%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Python 基础整理（Python中文手册）</title>
    <link href="http://yoursite.com/2018/02/02/Python-%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88Python%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/02/02/Python-基础整理（Python中文手册）/</id>
    <published>2018-02-02T10:39:07.000Z</published>
    <updated>2018-02-05T06:14:09.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Python概述"><a href="#1、Python概述" class="headerlink" title="1、Python概述"></a>1、Python概述</h3><p>Python语言是少有的一种可以称得上即简单又功能强大的编程语言。你将惊喜地发现Python语言是多么地简单，它注重的是如何解决问题而不是编程语言的语法和结构。</p><p><strong>Python的官方介绍是：</strong></p><blockquote><p>Python是一种简单易学，功能强大的编程语言，它有高效率的高层数据结构，简单而有效地实现面向对象编程。Python简洁的语法和对动态输入的支持，再加上解释性语言的本质，使得它在大多数平台上的许多领域都是一个理想的脚本语言，特别适用于快速的应用程序开发。</p></blockquote><a id="more"></a><h3 id="2、基本数据类型：数和字符串"><a href="#2、基本数据类型：数和字符串" class="headerlink" title="2、基本数据类型：数和字符串"></a>2、基本数据类型：数和字符串</h3><h4 id="（1）数"><a href="#（1）数" class="headerlink" title="（1）数"></a>（1）数</h4><p>在Python中有4种类型的数——整数、长整数、浮点数和复数。</p><h4 id="（2）字符串"><a href="#（2）字符串" class="headerlink" title="（2）字符串"></a>（2）字符串</h4><p>字符串是 字符的序列 。字符串基本上就是一组单词。</p><blockquote><p>下面有几种方式使用字符串：<br><strong>使用单引号（’） </strong><br>你可以用单引号指示字符串，就如同’Quote me on this’这样。所有的空白，即空格和制表符都照原样保留。<br><strong>使用双引号（”） </strong><br>在双引号中的字符串与单引号中的字符串的使用完全相同，例如”What’s your name?”。<br><strong>使用三引号（’’’或”””） </strong><br>利用三引号，你可以指示一个多行的字符串。你可以在三引号中自由的使用单引号和双引号。例如：<br>‘’’This is a multi-line string. This is the first line.<br>This is the second line.<br>“What’s your name?,” I asked.<br>He said “Bond, James Bond.”<br>‘’’<br><em>（注意：使用转义符来输出特殊字符。）</em></p></blockquote><p><strong>自然字符串与Unicode字符串：</strong><br>自然字符串：如果你想要指示某些不需要如转义符那样的特别处理的字符串，那么你需要指定一个自然字符串。自然字符串通过给字符串加上前缀r或R来指定。例如r”Newlines are indicated by \n”。<br>Unicode字符串：在你处理文本文件的时候使用Unicode字符串，特别是当你知道这个文件含有用非英语的语言写的文本。Python允许你处理Unicode文本——你只需要在字符串前加上前缀u或U。例如，u”This is a Unicode string.”。<br><em>（注：字符串是不可变的，这意味着一旦你创造了一个字符串，你就不能再改变它了。）</em><br><em>（注：相邻的字符串会被Python自动级连。）</em></p><h3 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h3><p>变量就是我们想要的东西——它们的值可以变化，即你可以使用变量存储任何东西。变量只是你的计算机中存储信息的一部分内存。<br><em>（注：使用变量时只需要给它们赋一个值。不需要声明或定义数据类型。）</em><br><strong>标示符命名：</strong><br>标识符 是用来标识 某样东西 的名字。在命名标识符的时候，你要遵循这些规则：</p><ul><li>标示符由字母(大写或小写)、下划线(‘_’)或数字(0-9)组成。</li><li>标示符的第一个字符必须是字母或者下划线。</li><li>标示符名称是对大小写敏感的。例如，myname和myName不是一个标识符。</li></ul><h3 id="4、逻辑行与物理行"><a href="#4、逻辑行与物理行" class="headerlink" title="4、逻辑行与物理行"></a>4、逻辑行与物理行</h3><p>（1）Python默认是每个物理行对应一个逻辑行。如果你想要在一个物理行中使用多于一个逻辑行，那么你需要使用分号（;）来特别地标明这种用法。分号表示一个逻辑行/语句的结束。<br>（2）如果多个物理行中写一个逻辑行，可以使用反斜杠（’\’）来连接，被称为明确的行连接。有一种暗示的假设，可以使你不需要使用反斜杠。这种情况出现在逻辑行中使用了圆括号、方括号或波形括号的时候。这被称为暗示的行连接。</p><h3 id="5、缩进"><a href="#5、缩进" class="headerlink" title="5、缩进"></a>5、缩进</h3><p>空白在Python中是重要的。事实上行首的空白是重要的。它称为缩进。在逻辑行首的空白（空格和制表符）用来决定逻辑行的缩进层次，从而用来决定语句的分组。<br>这意味着同一层次的语句必须有相同的缩进。每一组这样的语句称为一个块。<br><strong>如何缩进</strong><br>不要混合使用制表符和空格来缩进，因为这在跨越不同的平台的时候，无法正常工作。我 强烈建议 你在每个缩进层次使用 单个制表符 或 两个 或 四个空格 。<br>选择这三种缩进风格之一。更加重要的是，选择一种风格，然后一贯地使用它，即 只 使用这一种风格。 </p><h3 id="6、运算符与表达式"><a href="#6、运算符与表达式" class="headerlink" title="6、运算符与表达式"></a>6、运算符与表达式</h3><h4 id="（1）运算符与它们的用法"><a href="#（1）运算符与它们的用法" class="headerlink" title="（1）运算符与它们的用法"></a>（1）运算符与它们的用法</h4><style type="text/css">    table th:first-of-type {        width: 50px;    }    table th:nth-of-type(2) {        width: 50px;    }</style><table><thead><tr><th>运算符</th><th>名称</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>两个对象相加</td><td>3 + 5得到8。’a’ + ‘b’得到’ab’。 </td></tr><tr><td>-</td><td>减</td><td>得到负数或是一个数减去另一个数</td><td>-5.2得到一个负数。50 - 24得到26。 </td></tr><tr><td>*</td><td>乘</td><td>两个数相乘或是返回一个被重复若干次的字符串</td><td>2 <em> 3得到6。’la’ </em> 3得到’lalala’。 </td></tr><tr><td>**</td><td>幂</td><td>返回x的y次幂</td><td>3 <em>* 4得到81（即3 </em> 3 <em> 3 </em> 3） </td></tr><tr><td>/</td><td>除</td><td>x除以y</td><td>4/3得到1（整数的除法得到整数结果）。4.0/3或4/3.0得到1.3333333333333333 </td></tr><tr><td>//</td><td>取整除</td><td>返回商的整数部分</td><td>4 // 3.0得到1.0 </td></tr><tr><td>%</td><td>取模</td><td>返回除法的余数</td><td>8%3得到2。-25.5%2.25得到1.5 </td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>把一个数的比特向左移一定数目（每个数在内存中都表示为比特或二进制数字，即0和1）</td><td>2 &lt;&lt; 2得到8。——2按比特表示为10 </td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>把一个数的比特向右移一定数目</td><td>11 &gt;&gt; 1得到5。——11按比特表示为1011，向右移动1比特后得到101，即十进制的5。 </td></tr><tr><td>&amp;</td><td>按位与</td><td>数的按位与</td><td>5 &amp; 3得到1。 </td></tr><tr><td>&#124;</td><td>按位或</td><td>数的按位或</td><td>5 &#124; 3得到7。 </td></tr><tr><td>^</td><td>按位异或</td><td>数的按位异或</td><td>5 ^ 3得到6 </td></tr><tr><td>~</td><td>按位翻转</td><td>x的按位翻转是-(x+1)</td><td>~5得到6。 </td></tr><tr><td>&lt;</td><td>小于</td><td>返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td>5 &lt; 3返回0（即False）而3 &lt; 5返回1（即True）。比较可以被任意连接：3 &lt; 5 &lt; 7返回True。 </td></tr><tr><td>&gt;</td><td>大于</td><td>返回x是否大于y</td><td>5 &gt; 3返回True。如果两个操作数都是数字，它们首先被转换为一个共同的类型。否则，它总是返回False。 </td></tr><tr><td>&lt;=</td><td>小于等于</td><td>返回x是否小于等于y</td><td>x = 3; y = 6; x &lt;= y返回True。 </td></tr><tr><td>&gt;=</td><td>大于等于</td><td>返回x是否大于等于y</td><td>x = 4; y = 3; x &gt;= y返回True。 </td></tr><tr><td>==</td><td>等于</td><td>比较对象是否相等</td><td>x = 2; y = 2; x == y返回True。x = ‘str’; y = ‘stR’; x == y返回False。x = ‘str’; y = ‘str’; x == y返回True。 </td></tr><tr><td>!=</td><td>不等于</td><td>比较两个对象是否不相等</td><td>x = 2; y = 3; x != y返回True。 </td></tr><tr><td>not</td><td>布尔“非”</td><td>如果x为True，返回False。如果x为False，它返回True。</td><td>x = True; not y返回False。 </td></tr><tr><td>and</td><td>布尔“与”</td><td>如果x为False，x and y返回False，否则它返回y的计算值。</td><td>x = False; y = True; x and y，由于x是False，返回False。在这里，Python不会计算y，因为它知道这个表达式的值肯定是False（因为x是False）。这个现象称为短路计算。 </td></tr><tr><td>or</td><td>布尔“或”</td><td>如果x是True，它返回True，否则它返回y的计算值。</td><td>x = True; y = False; x or y返回True。短路计算在这里也适用。 </td></tr></tbody></table><h4 id="（2）下面这个表给出Python的运算符优先级，从最低的优先级（最松散地结合）到最高的优先级（最紧密地结合）。"><a href="#（2）下面这个表给出Python的运算符优先级，从最低的优先级（最松散地结合）到最高的优先级（最紧密地结合）。" class="headerlink" title="（2）下面这个表给出Python的运算符优先级，从最低的优先级（最松散地结合）到最高的优先级（最紧密地结合）。"></a>（2）下面这个表给出Python的运算符优先级，从最低的优先级（最松散地结合）到最高的优先级（最紧密地结合）。</h4><table><thead><tr><th>运算符</th><th>描述 </th></tr></thead><tbody><tr><td>lambda</td><td>Lambda表达式 </td></tr><tr><td>or</td><td>布尔“或” </td></tr><tr><td>and</td><td>布尔“与” </td></tr><tr><td>not x</td><td>布尔“非” </td></tr><tr><td>in，not in</td><td>成员测试 </td></tr><tr><td>is，is not</td><td>同一性测试 </td></tr><tr><td>&lt;，&lt;=，&gt;，&gt;=，!=，==</td><td>比较 </td></tr><tr><td>&#124;</td><td>按位或 </td></tr><tr><td>^</td><td>按位异或 </td></tr><tr><td>&amp;</td><td>按位与 </td></tr><tr><td>&lt;&lt;，&gt;&gt;</td><td>移位 </td></tr><tr><td>+，-</td><td>加法与减法 </td></tr><tr><td>*，/，%</td><td>乘法、除法与取余 </td></tr><tr><td>+x，-x</td><td>正负号 </td></tr><tr><td>~x</td><td>按位翻转 </td></tr><tr><td>**</td><td>指数 </td></tr><tr><td>x.attribute</td><td>属性参考 </td></tr><tr><td>x[index]</td><td>下标 </td></tr><tr><td>x[index:index]</td><td>寻址段 </td></tr><tr><td>f(arguments…)</td><td>函数调用 </td></tr><tr><td>(experession,…)</td><td>绑定或元组显示 </td></tr><tr><td>[expression,…]</td><td>列表显示 </td></tr><tr><td>{key:datum,…}</td><td>字典显示 </td></tr><tr><td>‘expression,…’</td><td>字符串转换 </td></tr></tbody></table><h4 id="（3）一个表达式可以分解为运算符和操作数。"><a href="#（3）一个表达式可以分解为运算符和操作数。" class="headerlink" title="（3）一个表达式可以分解为运算符和操作数。"></a>（3）一个表达式可以分解为运算符和操作数。</h4><p>运算符 的功能是完成某件事，它们由如+这样的符号或者其他特定的关键字表示。运算符需要数据来进行运算，这样的数据被称为 操作数 。</p><h3 id="7、控制流"><a href="#7、控制流" class="headerlink" title="7、控制流"></a>7、控制流</h3><p>Python中的控制语句与PHP中的控制语句大概意义上都是一致的，不过要注意Python中没有switch语句结构，而且for语句结构有一些区别，如果你想要写for (int i = 0; i &lt; 5; i++)，那么用Python，你写成for i in range(0,5)。还有一点要注意的是，依据Python语言的特性，每个控制语句的结尾处都要包含一个冒号————我们通过它告诉Python下面跟着一个语句块。</p><h4 id="（1）if-语句"><a href="#（1）if-语句" class="headerlink" title="（1）if 语句"></a>（1）if 语句</h4><p>if语句用来检验一个条件， 如果 条件为真，我们运行一块语句（称为 if-块 ）， 否则 我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。<br>（注：在Python中没有switch语句。你可以使用if..elif..else语句来完成同样的工作（在某些场合，使用字典会更加快捷。） ）</p><h4 id="（2）for-语句"><a href="#（2）for-语句" class="headerlink" title="（2）for 语句"></a>（2）for 语句</h4><p>for..in是另外一个循环语句，它在一序列的对象上 递归 即逐一使用队列中的每个项目。</p><h4 id="（3）while-语句"><a href="#（3）while-语句" class="headerlink" title="（3）while 语句"></a>（3）while 语句</h4><p>只要在一个条件为真的情况下，while语句允许你重复执行一块语句。while语句是所谓 循环 语句的一个例子。<strong>while语句有一个可选的else从句。</strong></p><h4 id="（4）break-语句"><a href="#（4）break-语句" class="headerlink" title="（4）break 语句"></a>（4）break 语句</h4><p>break语句是用来 终止 循环语句的，即哪怕循环条件没有称为False或序列还没有被完全递归，也停止执行循环语句。</p><font color="red">一个重要的注释是，如果你从for或while循环中 终止 ，任何对应的循环else块将不执行。</font><h4 id="（5）continue-语句"><a href="#（5）continue-语句" class="headerlink" title="（5）continue 语句"></a>（5）continue 语句</h4><p>continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后 继续 进行下一轮循环。</p><h3 id="8、函数"><a href="#8、函数" class="headerlink" title="8、函数"></a>8、函数</h3><h4 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>函数是重用的程序段。它们允许你给一块语句一个名称，然后你可以在你的程序的任何地方使用这个名称任意多次地运行这个语句块。这被称为 调用 函数。我们已经使用了许多内建的函数，比如len和range。</p><p>函数通过def关键字定义。def关键字后跟一个函数的 标识符 名称，然后跟一对圆括号。圆括号之中可以包括一些变量名，该行以冒号结尾。接下来是一块语句，它们是函数体。</p><p>下面这个例子（定义函数）将说明这事实上是十分简单的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: function1.py</span><br><span class="line"></span><br><span class="line">def sayHello():</span><br><span class="line">    print &apos;Hello World!&apos; # block belonging to the function</span><br><span class="line"></span><br><span class="line">sayHello() # call the function</span><br></pre></td></tr></table></figure></p><p>我们使用上面解释的语法定义了一个称为sayHello的函数。这个函数不使用任何参数，因此在圆括号中没有声明任何变量。参数对于函数而言，只是给函数的输入，以便于我们可以传递不同的值给函数，然后得到相应的结果。</p><h4 id="（2）函数的形参"><a href="#（2）函数的形参" class="headerlink" title="（2）函数的形参"></a>（2）函数的形参</h4><p>函数取得的参数是你提供给函数的值，这样函数就可以利用这些值 做 一些事情。这些参数就像变量一样，只不过它们的值是在我们调用函数的时候定义的，而非在函数本身内赋值。</p><p>参数在函数定义的圆括号对内指定，用逗号分割。当我们调用函数的时候，我们以同样的方式提供值。注意我们使用过的术语——函数中的参数名称为 形参 而你提供给函数调用的值称为 实参 。</p><h4 id="（3）变量作用域"><a href="#（3）变量作用域" class="headerlink" title="（3）变量作用域"></a>（3）变量作用域</h4><p><strong>局部变量：</strong><br>当你在函数定义内声明变量的时候，它们与函数外具有相同名称的其他变量没有任何关系，即变量名称对于函数来说是 局部 的。这称为变量的 作用域 。所有变量的作用域是它们被定义的块，从它们的名称被定义的那点开始。</p><p><strong>全局变量：</strong><br>如果你想要为一个定义在函数外的变量赋值，那么你就得告诉Python这个变量名不是局部的，而是 全局 的。我们使用global语句完成这一功能。没有global语句，是不可能为定义在函数外的变量赋值的。<br>你可以使用定义在函数外的变量的值（假设在函数内没有同名的变量）。然而，我并不鼓励你这样做，并且你应该尽量避免这样做，因为这使得程序的读者会不清楚这个变量是在哪里定义的。使用global语句可以清楚地表明变量是在外面的块定义的。</p><h4 id="（4）函数的参数类型"><a href="#（4）函数的参数类型" class="headerlink" title="（4）函数的参数类型"></a>（4）函数的参数类型</h4><p><strong>默认参数：</strong><br>对于一些函数，你可能希望它的一些参数是 可选 的，如果用户不想要为这些参数提供值的话，这些参数就使用默认值。这个功能借助于默认参数值完成。你可以在函数定义的形参名后加上赋值运算符（=）和默认值，从而给形参指定默认参数值。<br>（注意，默认参数值应该是一个参数。更加准确的说，默认参数值应该是不可变的。）<br>（<strong>重要</strong><br>只有在形参表末尾的那些参数可以有默认参数值，即你不能在声明函数形参的时候，先声明有默认值的形参而后声明没有默认值的形参。<br>这是因为赋给形参的值是根据位置而赋值的。例如，def func(a, b=5)是有效的，但是def func(a=5, b)是 无效 的。）</p><p><strong>关键参数：</strong><br>如果你的某个函数有许多参数，而你只想指定其中的一部分，那么你可以通过命名来为这些参数赋值——这被称作 关键参数 ——我们使用名字（关键字）而不是位置（我们前面所一直使用的方法）来给函数指定实参。</p><p>这样做有两个 优势 ——一，由于我们不必担心参数的顺序，使用函数变得更加简单了。二、假设其他参数都有默认值，我们可以只给我们想要的那些参数赋值。</p><h4 id="（5）return-语句"><a href="#（5）return-语句" class="headerlink" title="（5）return 语句"></a>（5）return 语句</h4><p>return语句用来从一个函数 返回 即跳出函数。我们也可选从函数 返回一个值 。<br>（注：pass语句在Python中表示一个空的语句块。）</p><h4 id="（6）DocStrings"><a href="#（6）DocStrings" class="headerlink" title="（6）DocStrings"></a>（6）DocStrings</h4><p>Python有一个很奇妙的特性，称为 文档字符串 ，它通常被简称为 docstrings 。DocStrings是一个重要的工具，由于它帮助你的程序文档更加简单易懂，你应该尽量使用它。你甚至可以在程序运行的时候，从函数恢复文档字符串！<br>例7.8 使用DocStrings<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: func_doc.py</span><br><span class="line"></span><br><span class="line">def printMax(x, y):</span><br><span class="line">    &apos;&apos;&apos;Prints the maximum of two numbers.</span><br><span class="line"></span><br><span class="line">    The two values must be integers.&apos;&apos;&apos;</span><br><span class="line">    x = int(x) # convert to integers, if possible</span><br><span class="line">    y = int(y)</span><br><span class="line"></span><br><span class="line">    if x &gt; y:</span><br><span class="line">        print x, &apos;is maximum&apos;</span><br><span class="line">    else:</span><br><span class="line">        print y, &apos;is maximum&apos;</span><br><span class="line"></span><br><span class="line">printMax(3, 5)</span><br><span class="line">print printMax.__doc__</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python func_doc.py</span><br><span class="line">5 is maximum</span><br><span class="line">Prints the maximum of two numbers.</span><br><span class="line"></span><br><span class="line">        The two values must be integers.</span><br></pre></td></tr></table></figure></p><p>在函数的第一个逻辑行的字符串是这个函数的 文档字符串 。注意，DocStrings也适用于模块和类。<br>文档字符串的惯例是一个多行字符串，它的首行以大写字母开始，句号结尾。第二行是空行，从第三行开始是详细的描述。 强烈建议 你在你的函数中使用文档字符串时遵循这个惯例。</p><p>你可以使用__doc__（注意双下划线）调用printMax函数的文档字符串属性（属于函数的名称）。请记住Python把 每一样东西 都作为对象，包括这个函数。</p><p>如果你已经在Python中使用过help()，那么你已经看到过DocStings的使用了！它所做的只是抓取函数的__doc__属性，然后整洁地展示给你。你可以对上面这个函数尝试一下——只是在你的程序中包括help(printMax)。记住按q退出help。</p><p>自动化工具也可以以同样的方式从你的程序中提取文档。因此，我 强烈建议 你对你所写的任何正式函数编写文档字符串。随你的Python发行版附带的pydoc命令，与help()类似地使用DocStrings。</p><h3 id="9、数据结构"><a href="#9、数据结构" class="headerlink" title="9、数据结构"></a>9、数据结构</h3><p>数据结构基本上就是——它们是可以处理一些 数据 的 结构 。或者说，它们是用来存储一组相关数据的。<br>在Python中有三种内建的数据结构——列表、元组和字典。</p><h4 id="（1）列表"><a href="#（1）列表" class="headerlink" title="（1）列表"></a>（1）列表</h4><p>list是处理一组有序项目的数据结构，即你可以在一个列表中存储一个 序列 的项目（列表也是一个序列）。假想你有一个购物列表，上面记载着你要买的东西，你就容易理解列表了。只不过在你的购物表上，可能每样东西都独自占有一行，而在Python中，你在每个项目之间用逗号分割。</p><p>列表中的项目应该包括在方括号中，这样Python就知道你是在指明一个列表。一旦你创建了一个列表，你可以添加、删除或是搜索列表中的项目。由于你可以增加或删除项目，我们说列表是 <strong>可变的 数据类型，即这种类型是可以被改变的。</strong><br><em>（注：我们使用列表的sort方法来对列表排序。需要理解的是，这个方法影响列表本身，而不是返回一个修改后的列表——这与字符串工作的方法不同。这就是我们所说的<strong>列表是 可变的</strong> 而<strong>字符串是 不可变的</strong>。）</em></p><h4 id="（2）元组"><a href="#（2）元组" class="headerlink" title="（2）元组"></a>（2）元组</h4><p>元组和列表十分类似，只不过元组和字符串一样是 不可变的 即你不能修改元组。元组通过圆括号中用逗号分割的项目定义。元组通常用在使语句或用户定义的函数能够安全地采用一组值的时候，即被使用的元组的值不会改变。<br><em>（注：变量zoo是一个元组，我们看到len函数可以用来获取元组的长度。这也表明<strong>元组也是一个序列</strong>。）</em></p><p><strong>含有0个或1个项目的元组。</strong>一个空的元组由一对空的圆括号组成，如myempty = ()。然而，含有单个元素的元组就不那么简单了。你必须在第一个（唯一一个）项目后跟一个逗号，这样Python才能区分元组和表达式中一个带圆括号的对象。即如果你想要的是一个包含项目2的元组的时候，你应该指明singleton = (2 , )。<br><strong>注：元组最通常的用法是用在打印语句中，例如：print ‘%s is %d years old’ % (name, age) </strong></p><h4 id="（3）序列"><a href="#（3）序列" class="headerlink" title="（3）序列"></a>（3）序列</h4><p>列表、元组和字符串都是序列，但是序列是什么，它们为什么如此特别呢？序列的两个主要特点是索引操作符和切片操作符。索引操作符让我们可以从序列中抓取一个特定项目。切片操作符让我们能够获取序列的一个切片，即一部分序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">例9.5 使用序列</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: seq.py</span><br><span class="line"></span><br><span class="line">shoplist = [&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]</span><br><span class="line"></span><br><span class="line"># Indexing or &apos;Subscription&apos; operation</span><br><span class="line">print &apos;Item 0 is&apos;, shoplist[0]</span><br><span class="line">print &apos;Item 1 is&apos;, shoplist[1]</span><br><span class="line">print &apos;Item 2 is&apos;, shoplist[2]</span><br><span class="line">print &apos;Item 3 is&apos;, shoplist[3]</span><br><span class="line">print &apos;Item -1 is&apos;, shoplist[-1]</span><br><span class="line">print &apos;Item -2 is&apos;, shoplist[-2]</span><br><span class="line"></span><br><span class="line"># Slicing on a list</span><br><span class="line">print &apos;Item 1 to 3 is&apos;, shoplist[1:3]</span><br><span class="line">print &apos;Item 2 to end is&apos;, shoplist[2:]</span><br><span class="line">print &apos;Item 1 to -1 is&apos;, shoplist[1:-1]</span><br><span class="line">print &apos;Item start to end is&apos;, shoplist[:]</span><br><span class="line"></span><br><span class="line"># Slicing on a string</span><br><span class="line">name = &apos;swaroop&apos;</span><br><span class="line">print &apos;characters 1 to 3 is&apos;, name[1:3]</span><br><span class="line">print &apos;characters 2 to end is&apos;, name[2:]</span><br><span class="line">print &apos;characters 1 to -1 is&apos;, name[1:-1]</span><br><span class="line">print &apos;characters start to end is&apos;, name[:]</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ python seq.py</span><br><span class="line">Item 0 is apple</span><br><span class="line">Item 1 is mango</span><br><span class="line">Item 2 is carrot</span><br><span class="line">Item 3 is banana</span><br><span class="line">Item -1 is banana</span><br><span class="line">Item -2 is carrot</span><br><span class="line">Item 1 to 3 is [&apos;mango&apos;, &apos;carrot&apos;]</span><br><span class="line">Item 2 to end is [&apos;carrot&apos;, &apos;banana&apos;]</span><br><span class="line">Item 1 to -1 is [&apos;mango&apos;, &apos;carrot&apos;]</span><br><span class="line">Item start to end is [&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]</span><br><span class="line">characters 1 to 3 is wa</span><br><span class="line">characters 2 to end is aroop</span><br><span class="line">characters 1 to -1 is waroo</span><br><span class="line">characters start to end is swaroop</span><br></pre></td></tr></table></figure></p><p>首先，我们来学习如何使用索引来取得序列中的单个项目。这也被称作是下标操作。每当你用方括号中的一个数来指定一个序列的时候，Python会为你抓取序列中对应位置的项目。记住，Python从0开始计数。因此，shoplist[0]抓取第一个项目，shoplist[3]抓取shoplist序列中的第四个元素。</p><p>索引同样可以是负数，在那样的情况下，位置是从序列尾开始计算的。因此，shoplist[-1]表示序列的最后一个元素而shoplist[-2]抓取序列的倒数第二个项目。</p><p>切片操作符是序列名后跟一个方括号，方括号中有一对可选的数字，并用冒号分割。注意这与你使用的索引操作符十分相似。记住数是可选的，而冒号是必须的。</p><p>切片操作符中的第一个数（冒号之前）表示切片开始的位置，第二个数（冒号之后）表示切片到哪里结束。如果不指定第一个数，Python就从序列首开始。如果没有指定第二个数，则Python会停止在序列尾。注意，返回的序列从开始位置 开始 ，刚好在 结束 位置之前结束。即开始位置是包含在序列切片中的，而结束位置被排斥在切片外。</p><p>这样，shoplist[1:3]返回从位置1开始，包括位置2，但是停止在位置3的一个序列切片，因此返回一个含有两个项目的切片。类似地，shoplist[:]返回整个序列的拷贝。</p><p>你可以用负数做切片。负数用在从序列尾开始计算的位置。例如，shoplist[:-1]会返回除了最后一个项目外包含所有项目的序列切片。</p><p>使用Python解释器交互地尝试不同切片指定组合，即在提示符下你能够马上看到结果。序列的神奇之处在于你可以用相同的方法访问元组、列表和字符串。</p><h4 id="（4）字典"><a href="#（4）字典" class="headerlink" title="（4）字典"></a>（4）字典</h4><p>字典类似于你通过联系人名字查找地址和联系人详细情况的地址簿，即，我们把<strong>键</strong>（名字）和<strong>值</strong>（详细情况）联系在一起。注意，键必须是唯一的，就像如果有两个人恰巧同名的话，你无法找到正确的信息。</p><p>注意，你只能使用不可变的对象（比如字符串）来作为字典的键，但是你可以不可变或可变的对象作为字典的值。基本说来就是，你应该只使用简单的对象作为键。</p><p>键值对在字典中以这样的方式标记：d = {key1 : value1, key2 : value2 }。注意它们的键/值对用冒号分割，而各个对用逗号分割，所有这些都包括在花括号中。</p><p>记住字典中的键/值对是没有顺序的。如果你想要一个特定的顺序，那么你应该在使用前自己对它们排序。</p><p>字典是dict类的实例/对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">例9.4 使用字典</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: using_dict.py</span><br><span class="line"></span><br><span class="line"># &apos;ab&apos; is short for &apos;a&apos;ddress&apos;b&apos;ook</span><br><span class="line"></span><br><span class="line">ab = &#123;       &apos;Swaroop&apos;   : &apos;swaroopch@byteofpython.info&apos;,</span><br><span class="line">             &apos;Larry&apos;     : &apos;larry@wall.org&apos;,</span><br><span class="line">             &apos;Matsumoto&apos; : &apos;matz@ruby-lang.org&apos;,</span><br><span class="line">             &apos;Spammer&apos;   : &apos;spammer@hotmail.com&apos;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">print &quot;Swaroop&apos;s address is %s&quot; % ab[&apos;Swaroop&apos;]</span><br><span class="line"></span><br><span class="line"># Adding a key/value pair</span><br><span class="line">ab[&apos;Guido&apos;] = &apos;guido@python.org&apos;</span><br><span class="line"></span><br><span class="line"># Deleting a key/value pair</span><br><span class="line">del ab[&apos;Spammer&apos;]</span><br><span class="line"></span><br><span class="line">print &apos;\nThere are %d contacts in the address-book\n&apos; % len(ab)</span><br><span class="line">for name, address in ab.items():</span><br><span class="line">    print &apos;Contact %s at %s&apos; % (name, address)</span><br><span class="line"></span><br><span class="line">if &apos;Guido&apos; in ab: # OR ab.has_key(&apos;Guido&apos;)</span><br><span class="line">    print &quot;\nGuido&apos;s address is %s&quot; % ab[&apos;Guido&apos;]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python using_dict.py</span><br><span class="line">Swaroop&apos;s address is swaroopch@byteofpython.info</span><br><span class="line"></span><br><span class="line">There are 4 contacts in the address-book</span><br><span class="line"></span><br><span class="line">Contact Swaroop at swaroopch@byteofpython.info</span><br><span class="line">Contact Matsumoto at matz@ruby-lang.org</span><br><span class="line">Contact Larry at larry@wall.org</span><br><span class="line">Contact Guido at guido@python.org</span><br><span class="line"></span><br><span class="line">Guido&apos;s address is guido@python.org</span><br></pre></td></tr></table></figure></p><p>我们使用已经介绍过的标记创建了字典ab。然后我们使用在列表和元组章节中已经讨论过的索引操作符来指定键，从而使用键/值对。我们可以看到字典的语法同样十分简单。</p><p>我们可以使用索引操作符来寻址一个键并为它赋值，这样就增加了一个新的键/值对，就像在上面的例子中我们对Guido所做的一样。</p><p>我们可以使用我们的老朋友——del语句来删除键/值对。我们只需要指明字典和用索引操作符指明要删除的键，然后把它们传递给del语句就可以了。执行这个操作的时候，我们无需知道那个键所对应的值。</p><p>接下来，我们使用字典的items方法，来使用字典中的每个键/值对。这会返回一个元组的列表，其中每个元组都包含一对项目——键与对应的值。我们抓取这个对，然后分别赋给for..in循环中的变量name和address然后在for－块中打印这些值。</p><p>我们可以使用in操作符来检验一个键/值对是否存在，或者使用dict类的has_key方法。你可以使用help(dict)来查看dict类的完整方法列表。</p><p><strong>关键字参数与字典。</strong>如果换一个角度看待你在函数中使用的关键字参数的话，你已经使用了字典了！只需想一下——你在函数定义的参数列表中使用的键/值对。当你在函数中使用变量的时候，它只不过是使用一个字典的键（这在编译器设计的术语中被称作 符号表 ）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、Python概述&quot;&gt;&lt;a href=&quot;#1、Python概述&quot; class=&quot;headerlink&quot; title=&quot;1、Python概述&quot;&gt;&lt;/a&gt;1、Python概述&lt;/h3&gt;&lt;p&gt;Python语言是少有的一种可以称得上即简单又功能强大的编程语言。你将惊喜地发现Python语言是多么地简单，它注重的是如何解决问题而不是编程语言的语法和结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python的官方介绍是：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python是一种简单易学，功能强大的编程语言，它有高效率的高层数据结构，简单而有效地实现面向对象编程。Python简洁的语法和对动态输入的支持，再加上解释性语言的本质，使得它在大多数平台上的许多领域都是一个理想的脚本语言，特别适用于快速的应用程序开发。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python知识点" scheme="http://yoursite.com/tags/Python%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP预定义变量梳理（PHP手册版）</title>
    <link href="http://yoursite.com/2018/01/31/PHP%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E6%A2%B3%E7%90%86%EF%BC%88PHP%E6%89%8B%E5%86%8C%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/31/PHP预定义变量梳理（PHP手册版）/</id>
    <published>2018-01-31T09:46:04.000Z</published>
    <updated>2018-02-01T08:38:42.422Z</updated>
    
    <content type="html"><![CDATA[<p><strong>预定义变量</strong><br>超全局数组：$GLOBALS<br>服务器和执行环境信息：$_SERVER （详解）<br>URL参数获取变量数组：$_GET<br>表单参数获取变量数组：$_POST<br>上传数据获取：$_FILES<br>$_REQUEST（包含$_GET、$_POST和$_COOKIE）<br>SESSION变量的数组：$_SESSION<br>环境变量数组：$_ENV<br>COOKIE变量的数组：$_COOKIE<br><a id="more"></a><br><strong>下面只对$_SERVER这个变量进行详细说明其参数及其意义：</strong><br>$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。<br><strong>Note:</strong>  PHP 5.4.0 之前，$HTTP_SERVER_VARS 包含着相同的信息，但它不是一个超全局变量。 (注意 $HTTP_SERVER_VARS 与 $_SERVER 是不同的变量，PHP处理它们的方式不同) </p><p>在 $_SERVER 中，你也许能够，也许不能够找到下面的这些元素。注意，如果以命令行方式运行 PHP，下面列出的元素几乎没有有效的(或是没有任何实际意义的)。 </p><h5 id="‘PHP-SELF’"><a href="#‘PHP-SELF’" class="headerlink" title="‘PHP_SELF’"></a>‘PHP_SELF’</h5><p>当前执行脚本的文件名，与 document root 有关。例如，在地址为 <a href="http://example.com/foo/bar.php" target="_blank" rel="noopener">http://example.com/foo/bar.php</a> 的脚本中使用 $_SERVER[‘PHP_SELF’] 将得到 /foo/bar.php。<strong>FILE</strong> 常量包含当前(例如包含)文件的完整路径和文件名。   从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。</p><h5 id="‘argv’"><a href="#‘argv’" class="headerlink" title="‘argv’"></a>‘argv’</h5><p>传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。</p><h5 id="‘argc’"><a href="#‘argc’" class="headerlink" title="‘argc’"></a>‘argc’</h5><p>包含命令行模式下传递给该脚本的参数的数目(如果运行在命令行模式下)。</p><h5 id="‘GATEWAY-INTERFACE’"><a href="#‘GATEWAY-INTERFACE’" class="headerlink" title="‘GATEWAY_INTERFACE’"></a>‘GATEWAY_INTERFACE’</h5><p>服务器使用的 CGI 规范的版本；例如，”CGI/1.1”。</p><h5 id="‘SERVER-ADDR’"><a href="#‘SERVER-ADDR’" class="headerlink" title="‘SERVER_ADDR’"></a>‘SERVER_ADDR’</h5><p>当前运行脚本所在的服务器的 IP 地址。</p><h5 id="‘SERVER-NAME’"><a href="#‘SERVER-NAME’" class="headerlink" title="‘SERVER_NAME’"></a>‘SERVER_NAME’</h5><p>当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。<br>　　<strong>Note:</strong> 在 Apache 2 里，必须设置 UseCanonicalName = On 和 ServerName。 否则该值会由客户端提供，就有可能被伪造。 上下文有安全性要求的环境里，不应该依赖此值。</p><h5 id="‘SERVER-SOFTWARE’"><a href="#‘SERVER-SOFTWARE’" class="headerlink" title="‘SERVER_SOFTWARE’"></a>‘SERVER_SOFTWARE’</h5><p>服务器标识字符串，在响应请求时的头信息中给出。  ‘SERVER_PROTOCOL’请求页面时通信协议的名称和版本。例如，”HTTP/1.0”。</p><h5 id="‘REQUEST-METHOD’"><a href="#‘REQUEST-METHOD’" class="headerlink" title="‘REQUEST_METHOD’"></a>‘REQUEST_METHOD’</h5><p>访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”。<br>　　<strong>Note:</strong> 如果请求方法为 HEAD，PHP 脚本将在发送 Header 头信息之后终止(这意味着在产生任何输出后，不再有输出缓冲)。</p><h5 id="‘REQUEST-TIME’"><a href="#‘REQUEST-TIME’" class="headerlink" title="‘REQUEST_TIME’"></a>‘REQUEST_TIME’</h5><p>请求开始时的时间戳。从 PHP 5.1.0 起可用。</p><h5 id="‘REQUEST-TIME-FLOAT’"><a href="#‘REQUEST-TIME-FLOAT’" class="headerlink" title="‘REQUEST_TIME_FLOAT’"></a>‘REQUEST_TIME_FLOAT’</h5><p>请求开始时的时间戳，微秒级别的精准度。 自 PHP 5.4.0 开始生效。</p><h5 id="‘QUERY-STRING’"><a href="#‘QUERY-STRING’" class="headerlink" title="‘QUERY_STRING’"></a>‘QUERY_STRING’</h5><p>query string（查询字符串），如果有的话，通过它进行页面访问。</p><h5 id="‘DOCUMENT-ROOT’"><a href="#‘DOCUMENT-ROOT’" class="headerlink" title="‘DOCUMENT_ROOT’"></a>‘DOCUMENT_ROOT’</h5><p>当前运行脚本所在的文档根目录。在服务器配置文件中定义。</p><h5 id="‘HTTP-ACCEPT’"><a href="#‘HTTP-ACCEPT’" class="headerlink" title="‘HTTP_ACCEPT’"></a>‘HTTP_ACCEPT’</h5><p>当前请求头中 Accept: 项的内容，如果存在的话。</p><h5 id="‘HTTP-ACCEPT-CHARSET’"><a href="#‘HTTP-ACCEPT-CHARSET’" class="headerlink" title="‘HTTP_ACCEPT_CHARSET’"></a>‘HTTP_ACCEPT_CHARSET’</h5><p>当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。</p><h5 id="‘HTTP-ACCEPT-ENCODING’"><a href="#‘HTTP-ACCEPT-ENCODING’" class="headerlink" title="‘HTTP_ACCEPT_ENCODING’"></a>‘HTTP_ACCEPT_ENCODING’</h5><p>当前请求头中 Accept-Encoding: 项的内容，如果存在的话。例如：”gzip”。</p><h5 id="‘HTTP-ACCEPT-LANGUAGE’"><a href="#‘HTTP-ACCEPT-LANGUAGE’" class="headerlink" title="‘HTTP_ACCEPT_LANGUAGE’"></a>‘HTTP_ACCEPT_LANGUAGE’</h5><p>当前请求头中 Accept-Language: 项的内容，如果存在的话。例如：”en”。</p><h5 id="‘HTTP-CONNECTION’"><a href="#‘HTTP-CONNECTION’" class="headerlink" title="‘HTTP_CONNECTION’"></a>‘HTTP_CONNECTION’</h5><p>当前请求头中 Connection: 项的内容，如果存在的话。例如：”Keep-Alive”。</p><h5 id="‘HTTP-HOST’"><a href="#‘HTTP-HOST’" class="headerlink" title="‘HTTP_HOST’"></a>‘HTTP_HOST’</h5><p>当前请求头中 Host: 项的内容，如果存在的话。</p><h5 id="‘HTTP-REFERER’"><a href="#‘HTTP-REFERER’" class="headerlink" title="‘HTTP_REFERER’"></a>‘HTTP_REFERER’</h5><p>引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。</p><h5 id="‘HTTP-USER-AGENT’"><a href="#‘HTTP-USER-AGENT’" class="headerlink" title="‘HTTP_USER_AGENT’"></a>‘HTTP_USER_AGENT’</h5><p>当前请求头中 User-Agent: 项的内容，如果存在的话。该字符串表明了访问该页面的用户代理的信息。一个典型的例子是：Mozilla/4.5 [en] (X11; U; Linux 2.2.9 i586)。除此之外，你可以通过 get_browser() 来使用该值，从而定制页面输出以便适应用户代理的性能。  ‘HTTPS’如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。<br>　　<strong>Note:</strong> 注意当使用 IIS 上的 ISAPI 方式时，如果不是通过 HTTPS 协议被访问，这个值将为 off。</p><h5 id="‘REMOTE-ADDR’"><a href="#‘REMOTE-ADDR’" class="headerlink" title="‘REMOTE_ADDR’"></a>‘REMOTE_ADDR’</h5><p>浏览当前页面的用户的 IP 地址。</p><h5 id="‘REMOTE-HOST’"><a href="#‘REMOTE-HOST’" class="headerlink" title="‘REMOTE_HOST’"></a>‘REMOTE_HOST’</h5><p>浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。<br>　　<strong>Note:</strong> 你的服务器必须被配置以便产生这个变量。例如在 Apache 中，你需要在 httpd.conf 中设置 HostnameLookups On 来产生它。参见 gethostbyaddr()。</p><h5 id="‘REMOTE-PORT’"><a href="#‘REMOTE-PORT’" class="headerlink" title="‘REMOTE_PORT’"></a>‘REMOTE_PORT’</h5><p>用户机器上连接到 Web 服务器所使用的端口号。</p><h5 id="‘REMOTE-USER’"><a href="#‘REMOTE-USER’" class="headerlink" title="‘REMOTE_USER’"></a>‘REMOTE_USER’</h5><p>经验证的用户</p><h5 id="‘REDIRECT-REMOTE-USER’"><a href="#‘REDIRECT-REMOTE-USER’" class="headerlink" title="‘REDIRECT_REMOTE_USER’"></a>‘REDIRECT_REMOTE_USER’</h5><p>验证的用户，如果请求已在内部重定向。</p><h5 id="‘SCRIPT-FILENAME’"><a href="#‘SCRIPT-FILENAME’" class="headerlink" title="‘SCRIPT_FILENAME’"></a>‘SCRIPT_FILENAME’</h5><p>当前执行脚本的绝对路径。<br>　　<strong>Note:</strong> 如果在命令行界面（Command Line Interface, CLI）使用相对路径执行脚本，例如 file.php 或 ../file.php，那么 $_SERVER[‘SCRIPT_FILENAME’] 将包含用户指定的相对路径。</p><h5 id="‘SERVER-ADMIN’"><a href="#‘SERVER-ADMIN’" class="headerlink" title="‘SERVER_ADMIN’"></a>‘SERVER_ADMIN’</h5><p>该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。</p><h5 id="‘SERVER-PORT’"><a href="#‘SERVER-PORT’" class="headerlink" title="‘SERVER_PORT’"></a>‘SERVER_PORT’</h5><p>Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。<br>　　<strong>Note:</strong> 在 Apache 2 里，为了获取真实物理端口，必须设置 UseCanonicalName = On 以及 UseCanonicalPhysicalPort = On。 否则此值可能被伪造，不一定会返回真实端口值。 上下文有安全性要求的环境里，不应该依赖此值。</p><h5 id="‘SERVER-SIGNATURE’"><a href="#‘SERVER-SIGNATURE’" class="headerlink" title="‘SERVER_SIGNATURE’"></a>‘SERVER_SIGNATURE’</h5><p>包含了服务器版本和虚拟主机名的字符串。</p><h5 id="‘PATH-TRANSLATED’"><a href="#‘PATH-TRANSLATED’" class="headerlink" title="‘PATH_TRANSLATED’"></a>‘PATH_TRANSLATED’</h5><p>当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。<br>　　<strong>Note:</strong> 自 PHP 4.3.2 起，PATH_TRANSLATED 在 Apache 2 SAPI 模式下不再和 Apache 1 一样隐含赋值，而是若 Apache 不生成此值，PHP 便自己生成并将其值放入 SCRIPT_FILENAME 服务器常量中。这个修改遵守了 CGI 规范，PATH_TRANSLATED 仅在 PATH_INFO 被定义的条件下才存在。  Apache 2 用户可以在 httpd.conf 中设置 AcceptPathInfo = On 来定义 PATH_INFO。</p><h5 id="‘SCRIPT-NAME’"><a href="#‘SCRIPT-NAME’" class="headerlink" title="‘SCRIPT_NAME’"></a>‘SCRIPT_NAME’</h5><p>包含当前脚本的路径。这在页面需要指向自己时非常有用。<strong>FILE</strong> 常量包含当前脚本(例如包含文件)的完整路径和文件名。</p><h5 id="‘REQUEST-URI’"><a href="#‘REQUEST-URI’" class="headerlink" title="‘REQUEST_URI’"></a>‘REQUEST_URI’</h5><p>URI 用来指定要访问的页面。例如 “/index.html”。</p><h5 id="‘PHP-AUTH-DIGEST’"><a href="#‘PHP-AUTH-DIGEST’" class="headerlink" title="‘PHP_AUTH_DIGEST’"></a>‘PHP_AUTH_DIGEST’</h5><p>当作为 Apache 模块运行时，进行 HTTP Digest 认证的过程中，此变量被设置成客户端发送的”Authorization” HTTP 头内容（以便作进一步的认证操作）。</p><h5 id="‘PHP-AUTH-USER’"><a href="#‘PHP-AUTH-USER’" class="headerlink" title="‘PHP_AUTH_USER’"></a>‘PHP_AUTH_USER’</h5><p>当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名。</p><h5 id="‘PHP-AUTH-PW’"><a href="#‘PHP-AUTH-PW’" class="headerlink" title="‘PHP_AUTH_PW’"></a>‘PHP_AUTH_PW’</h5><p>当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码。</p><h5 id="‘AUTH-TYPE’"><a href="#‘AUTH-TYPE’" class="headerlink" title="‘AUTH_TYPE’"></a>‘AUTH_TYPE’</h5><p>当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型。</p><h5 id="‘PATH-INFO’"><a href="#‘PATH-INFO’" class="headerlink" title="‘PATH_INFO’"></a>‘PATH_INFO’</h5><p>包含由客户端提供的、跟在真实脚本名称之后并且在查询语句（query string）之前的路径信息，如果存在的话。例如，如果当前脚本是通过 URL <a href="http://www.example.com/php/path_info.php/some/stuff?foo=bar" target="_blank" rel="noopener">http://www.example.com/php/path_info.php/some/stuff?foo=bar</a> 被访问，那么 $_SERVER[‘PATH_INFO’] 将包含 /some/stuff。</p><h5 id="‘ORIG-PATH-INFO’"><a href="#‘ORIG-PATH-INFO’" class="headerlink" title="‘ORIG_PATH_INFO’"></a>‘ORIG_PATH_INFO’</h5><p>在被 PHP 处理之前，”PATH_INFO” 的原始版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;预定义变量&lt;/strong&gt;&lt;br&gt;超全局数组：$GLOBALS&lt;br&gt;服务器和执行环境信息：$_SERVER （详解）&lt;br&gt;URL参数获取变量数组：$_GET&lt;br&gt;表单参数获取变量数组：$_POST&lt;br&gt;上传数据获取：$_FILES&lt;br&gt;$_REQUEST（包含$_GET、$_POST和$_COOKIE）&lt;br&gt;SESSION变量的数组：$_SESSION&lt;br&gt;环境变量数组：$_ENV&lt;br&gt;COOKIE变量的数组：$_COOKIE&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP高级整理（PHP手册版）</title>
    <link href="http://yoursite.com/2018/01/31/PHP%E9%AB%98%E7%BA%A7%E6%95%B4%E7%90%86%EF%BC%88PHP%E6%89%8B%E5%86%8C%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/31/PHP高级整理（PHP手册版）/</id>
    <published>2018-01-31T09:45:52.000Z</published>
    <updated>2018-02-01T03:54:22.488Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>（1）用户自定义函数：</p><p>（2）函数的参数：<br>值传递（默认情况）<br>引用传递：在该参数前面加上符号 &amp;</p><p>（3）类型声明<br>在PHP 5中，类型声明也被称为类型提示。<br>类型声明允许函数在调用时要求参数为特定类型。 如果给出的值类型不对，那么将会产生一个错误： 在PHP 5中，这将是一个可恢复的致命错误，而在PHP 7中将会抛出一个TypeError异常。<br><a id="more"></a><br>（4）返回值：return</p><p>（5）匿名函数<br>匿名函数（Anonymous functions），也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。 </p><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><h5 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h5><p>每个类的定义都以关键字 class 开头，后面跟着类名，后面跟着一对花括号，里面包含有类的属性与方法的定义。<br>一个类可以包含有属于自己的常量，变量（称为”属性”）以及函数（称为”方法”）。<br>当一个方法在类定义内部被调用时，有一个可用的伪变量 $this。$this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象静态调用时也可能是另一个对象）。</p><p><strong>new</strong><br>要创建一个类的实例，必须使用 new 关键字。当创建新对象时该对象总是被赋值，除非该对象定义了构造函数并且在出错时抛出了一个异常。类应在被实例化之前定义（某些情况下则必须这样）。<br>如果在 new 之后跟着的是一个包含有类名的字符串，则该类的一个实例被创建。如果该类属于一个名字空间，则必须使用其完整名称。</p><p>在类定义内部，可以用 new self 和 new parent 创建新对象。<br>当把一个对象已经创建的实例赋给一个新变量时，新变量会访问同一个实例，就和用该对象赋值一样。此行为和给函数传递入实例时一样。可以用克隆给一个已创建的对象建立一个新实例。</p><p><strong>extends</strong><br>一个类可以在声明中用 extends 关键字继承另一个类的方法和属性。PHP不支持多重继承，一个类只能继承一个基类。<br>被继承的方法和属性可以通过用同样的名字重新声明被覆盖。但是如果父类定义方法时使用了 final，则该方法不可被覆盖。可以通过 parent:: 来访问被覆盖的方法或属性。<br>当覆盖方法时，参数必须保持一致否则 PHP 将发出 E_STRICT 级别的错误信息。但构造函数例外，构造函数可在被覆盖时使用不同的参数。</p><p><strong>匿名类</strong><br>PHP 7 开始支持匿名类。 匿名类很有用，可以创建一次性的简单对象。 </p><h5 id="（2）属性"><a href="#（2）属性" class="headerlink" title="（2）属性"></a>（2）属性</h5><p>类的变量成员叫做”属性”，或者叫”字段”、”特征”，在本文档统一称为”属性”。属性声明是由关键字 public，protected 或者 private 开头，然后跟一个普通的变量声明来组成。属性中的变量可以初始化，但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。</p><p>在类的成员方法里面，可以用 -&gt;（对象运算符）：$this-&gt;property（其中 property 是该属性名）这种方式来访问非静态属性。静态属性则是用 ::（双冒号）：self::$property 来访问。</p><p><strong>类常量：</strong><br>可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。<br>常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。<br>接口（interface）中也可以定义常量。</p><h5 id="（3）构造函数与析构函数"><a href="#（3）构造函数与析构函数" class="headerlink" title="（3）构造函数与析构函数"></a>（3）构造函数与析构函数</h5><p>PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 </p><p><strong>Note: </strong>如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。</p><p>PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p><p>和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 parent::__destruct()。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。<br>析构函数即使在使用 exit() 终c止脚本运行时也会被调用。在析构函数中调用 exit() 将会中止其余关闭操作的运行。 </p><h5 id="（4）访问控制符"><a href="#（4）访问控制符" class="headerlink" title="（4）访问控制符"></a>（4）访问控制符</h5><p>对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。<br><strong>final关键字：</strong><br>PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。</p><p><em>（注：类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有。类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。 ）</em></p><h5 id="（5）对象继承"><a href="#（5）对象继承" class="headerlink" title="（5）对象继承"></a>（5）对象继承</h5><p>继承已为大家所熟知的一个程序设计特性，PHP 的对象模型也使用了继承。继承将会影响到类与类，对象与对象之间的关系。<br>比如，当扩展一个类，子类就会继承父类所有公有的和受保护的方法。除非子类覆盖了父类的方法，被继承的方法都会保留其原有功能。<br>继承对于功能的设计和抽象是非常有用的，而且对于类似的对象增加新功能就无须重新再写这些公用的功能。</p><h5 id="（6）静态关键字-static"><a href="#（6）静态关键字-static" class="headerlink" title="（6）静态关键字 static"></a>（6）静态关键字 static</h5><p>声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。<br><em>（注：由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。）</em><br><strong>注意事项：</strong></p><ul><li>静态属性不可以由对象通过 -&gt; 操作符来访问。 </li><li>用静态方式调用一个非静态方法会导致一个 E_STRICT 级别的错误。 </li><li>就像其它所有的 PHP 静态变量一样，静态属性只能被初始化为文字或常量，不能使用表达式。所以可以把静态属性初始化为整数或数组，但不能初始化为另一个变量或函数返回值，也不能指向一个对象。 </li></ul><h5 id="（7）抽象类"><a href="#（7）抽象类" class="headerlink" title="（7）抽象类"></a>（7）抽象类</h5><p>PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。 </p><p>继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。 </p><h5 id="（8）对象接口"><a href="#（8）对象接口" class="headerlink" title="（8）对象接口"></a>（8）对象接口</h5><p>使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。<br>接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。<br>接口中定义的所有方法都必须是公有，这是接口的特性。 </p><p><strong>实现（implements）</strong><br>要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。 </p><p><strong>Note: </strong><br>实现多个接口时，接口中的方法不能有重名。<br><strong>Note: </strong><br>接口也可以继承，通过使用 extends 操作符。<br><strong>Note: </strong><br>类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。 </p><p><strong>常量</strong><br>接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所覆盖。</p><h5 id="（9）魔术方法"><a href="#（9）魔术方法" class="headerlink" title="（9）魔术方法"></a>（9）魔术方法</h5><p>__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()， __invoke()， __set<em>state()， \</em>_clone() 和 __debugInfo() 等方法在 PHP 中被称为”魔术方法”（Magic methods）。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。 </p><h4 id="10、命名空间"><a href="#10、命名空间" class="headerlink" title="10、命名空间"></a>10、命名空间</h4><h5 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h5><p>什么是命名空间？从广义上来说，命名空间是一种封装事物的方法。在很多地方都可以见到这种抽象概念。例如，在操作系统中目录用来将相关文件分组，对于目录中的文件来说，它就扮演了命名空间的角色。具体举个例子，文件 foo.txt 可以同时在目录/home/greg 和 /home/other 中存在，但在同一个目录中不能存在两个 foo.txt 文件。另外，在目录 /home/greg 外访问 foo.txt 文件时，我们必须将目录名以及目录分隔符放在文件名之前得到 /home/greg/foo.txt。这个原理应用到程序设计领域就是命名空间的概念。 </p><p>在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题： </p><ol><li>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。  </li><li>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</li></ol><h5 id="（2）定义命名空间-PHP-5-gt-5-3-0-PHP-7"><a href="#（2）定义命名空间-PHP-5-gt-5-3-0-PHP-7" class="headerlink" title="（2）定义命名空间(PHP 5 &gt;= 5.3.0, PHP 7)"></a>（2）定义命名空间(PHP 5 &gt;= 5.3.0, PHP 7)</h5><p>虽然任意合法的PHP代码都可以包含在命名空间中，但只有以下类型的代码受命名空间的影响，它们是：类（包括抽象类和traits）、接口、函数和常量。 </p><p>命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，除了一个以外：declare关键字。<br><em>（注：在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。另外，所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前）</em></p><h5 id="（3）使用命名空间：基础"><a href="#（3）使用命名空间：基础" class="headerlink" title="（3）使用命名空间：基础"></a>（3）使用命名空间：基础</h5><p>在讨论如何使用命名空间之前，必须了解 PHP 是如何知道要使用哪一个命名空间中的元素的。可以将 PHP 命名空间与文件系统作一个简单的类比。在文件系统中访问一个文件有三种方式： </p><ol><li>相对文件名形式如foo.txt。它会被解析为 currentdirectory/foo.txt，其中 currentdirectory 表示当前目录。因此如果当前目录是 /home/foo，则该文件名被解析为/home/foo/foo.txt。  </li><li>相对路径名形式如subdirectory/foo.txt。它会被解析为 currentdirectory/subdirectory/foo.txt。  </li><li>绝对路径名形式如/main/foo.txt。它会被解析为/main/foo.txt。  </li></ol><p>PHP 命名空间中的元素使用同样的原理。例如，类名可以通过三种方式引用：</p><ol><li><strong>非限定名称</strong>，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。   警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。详情参见 使用命名空间：后备全局函数名称/常量名称。  </li><li><strong>限定名称</strong>,或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。  </li><li><strong>完全限定名称</strong>，或包含了全局前缀操作符的名称，例如， $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。</li></ol><h5 id="（4）使用命名空间：别名-导入"><a href="#（4）使用命名空间：别名-导入" class="headerlink" title="（4）使用命名空间：别名/导入"></a>（4）使用命名空间：别名/导入</h5><p>允许通过别名引用或导入外部的完全限定名称，是命名空间的一个重要特征。这有点类似于在类 unix 文件系统中可以创建对其它的文件或目录的符号连接。<br>所有支持命名空间的PHP版本支持三种别名或导入方式：为类名称使用别名、为接口使用别名或为命名空间名称使用别名。PHP 5.6开始允许导入函数或常量或者为它们设置别名。<br>在PHP中，别名是通过操作符 use 来实现的. 下面是一个使用所有可能的五种导入方式的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Example #1 使用use操作符导入/使用别名</span><br><span class="line">&lt;?php</span><br><span class="line">namespace foo;</span><br><span class="line">use My\Full\Classname as Another;</span><br><span class="line"></span><br><span class="line">// 下面的例子与 use My\Full\NSname as NSname 相同</span><br><span class="line">use My\Full\NSname;</span><br><span class="line"></span><br><span class="line">// 导入一个全局类</span><br><span class="line">use ArrayObject;</span><br><span class="line"></span><br><span class="line">// importing a function (PHP 5.6+)</span><br><span class="line">use function My\Full\functionName;</span><br><span class="line"></span><br><span class="line">// aliasing a function (PHP 5.6+)</span><br><span class="line">use function My\Full\functionName as func;</span><br><span class="line"></span><br><span class="line">// importing a constant (PHP 5.6+)</span><br><span class="line">use const My\Full\CONSTANT;</span><br><span class="line"></span><br><span class="line">$obj = new namespace\Another; // 实例化 foo\Another 对象</span><br><span class="line">$obj = new Another; // 实例化 My\Full\Classname　对象</span><br><span class="line">NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func</span><br><span class="line">$a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象</span><br><span class="line">// 如果不使用 &quot;use \ArrayObject&quot; ，则实例化一个 foo\ArrayObject 对象</span><br><span class="line">func(); // calls function My\Full\functionName</span><br><span class="line">echo CONSTANT; // echoes the value of My\Full\CONSTANT</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>注意对命名空间中的名称（包含命名空间分隔符的完全限定名称如 Foo\Bar以及相对的不包含命名空间分隔符的全局名称如 FooBar）来说，前导的反斜杠是不必要的也不推荐的，因为导入的名称必须是完全限定的，不会根据当前的命名空间作相对解析。</p><h5 id="（5）名称解析规则"><a href="#（5）名称解析规则" class="headerlink" title="（5）名称解析规则"></a>（5）名称解析规则</h5><p>在说明名称解析规则之前，我们先看一些重要的定义： </p><blockquote><p>命名空间名称定义<br>① 非限定名称Unqualified name<br>    名称中不包含命名空间分隔符的标识符，例如 Foo<br>② 限定名称Qualified name<br>    名称中含有命名空间分隔符的标识符，例如 Foo\Bar<br>③ 完全限定名称Fully qualified name<br>    名称中包含命名空间分隔符，并以命名空间分隔符开始的标识符，例如 \Foo\Bar。 namespace\Foo 也是一个完全限定名称。 </p></blockquote><p>名称解析遵循下列规则： </p><ol><li>对完全限定名称的函数，类和常量的调用在编译时解析。例如 new \A\B 解析为类 A\B。  </li><li>所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 A\B\C 被导入为 C，那么对 C\D\e() 的调用就会被转换为 A\B\C\D\e()。  </li><li>在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 A\B 内部调用 C\D\e()，则 C\D\e() 会被转换为 A\B\C\D\e() 。  </li><li>非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 A\B\C 导入为C，则 new C() 被转换为 new A\B\C() 。  </li><li>在命名空间内部（例如A\B），对非限定名称的函数调用是在运行时解析的。例如对函数 foo() 的调用是这样解析的：  <ol><li>在当前命名空间中查找名为 A\B\foo() 的函数  </li><li>尝试查找并调用 全局(global) 空间中的函数 foo()。  </li></ol></li><li>在命名空间（例如A\B）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 new C() 及 new D\E() 的解析过程： new C()的解析:  <ol><li>在当前命名空间中查找A\B\C类。  </li><li>尝试自动装载类A\B\C。<br>new D\E()的解析:  </li><li>在类名称前面加上当前命名空间名称变成：A\B\D\E，然后查找该类。  </li><li>尝试自动装载类 A\B\D\E。<br>为了引用全局命名空间中的全局类，必须使用完全限定名称 new \C()。 </li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h4&gt;&lt;p&gt;（1）用户自定义函数：&lt;/p&gt;
&lt;p&gt;（2）函数的参数：&lt;br&gt;值传递（默认情况）&lt;br&gt;引用传递：在该参数前面加上符号 &amp;amp;&lt;/p&gt;
&lt;p&gt;（3）类型声明&lt;br&gt;在PHP 5中，类型声明也被称为类型提示。&lt;br&gt;类型声明允许函数在调用时要求参数为特定类型。 如果给出的值类型不对，那么将会产生一个错误： 在PHP 5中，这将是一个可恢复的致命错误，而在PHP 7中将会抛出一个TypeError异常。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP数据类型详解（PHP手册版）</title>
    <link href="http://yoursite.com/2018/01/31/PHP%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88PHP%E6%89%8B%E5%86%8C%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/31/PHP数据类型详解（PHP手册版）/</id>
    <published>2018-01-31T09:45:42.000Z</published>
    <updated>2018-02-01T03:26:47.510Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据类型</strong><br>四种标量类型：</p><blockquote><p>boolean（布尔型）、integer（整型）、float（浮点型，也称为double）、string（字符串）</p></blockquote><p>两种复合类型：</p><blockquote><p>array（数组）、object（对象）</p></blockquote><p>两种特殊类型：</p><blockquote><p>resource（资源）、Null</p></blockquote><p>其它伪类型：</p><blockquote><p>mixed（混合类型）、number（数字类型）、callback（回调类型）、void（无类型）</p></blockquote><a id="more"></a><h4 id="布尔型（boolean）："><a href="#布尔型（boolean）：" class="headerlink" title="布尔型（boolean）："></a>布尔型（boolean）：</h4><p>（1）指定一个布尔值，使用常量 TRUE 或 FALSE。两个都不区分大小写。<br>（2）强制转换为布尔型，用 (bool) 或 (boolean) 来强制转换。但是很多情况下不需要强制转换，会被自动转换。<br>当转换为 boolean 时，以下值被认为是 FALSE： </p><ul><li>布尔值 FALSE 本身  </li><li>整型值 0（零）  </li><li>浮点型值 0.0（零）  </li><li>空字符串，以及字符串 “0”  </li><li>不包括任何元素的数组  </li><li>特殊类型 NULL（包括尚未赋值的变量）  </li><li>从空标记生成的 SimpleXML 对象  </li></ul><p>所有其它值都被认为是 TRUE（包括任何资源 和 NAN）。</p><h4 id="整型（interger）："><a href="#整型（interger）：" class="headerlink" title="整型（interger）："></a>整型（interger）：</h4><p>（1）整型值可以使用十进制，十六进制，八进制或二进制表示，前面可以加上可选的符号（- 或者 +）。<br>要使用八进制表达，数字前必须加上 0（零）。要使用十六进制表达，数字前必须加上 0x。要使用二进制表达，数字前必须加上 0b。<br>（2）要明确地将一个值转换为 integer，用 (int) 或 (integer) 强制转换。不过大多数情况下都不需要强制转换，因为当运算符，函数或流程控制需要一个 integer 参数时，值会自动转换。还可以通过函数 intval() 来将一个值转换成整型。<br>当从浮点数转换成整数时，将向下取整。 </p><h4 id="浮点型（float）："><a href="#浮点型（float）：" class="headerlink" title="浮点型（float）："></a>浮点型（float）：</h4><p>（1）浮点型（也叫浮点数 float，双精度数 double 或实数 real）。<br>（2）浮点数的精度<br>浮点数的精度有限。尽管取决于系统，PHP 通常使用 IEEE 754 双精度格式，则由于取整而导致的最大相对误差为 1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运算时的误差传递。<br>（3）NaN<br>某些数学运算会产生一个由常量 NAN 所代表的结果。此结果代表着一个在浮点数运算中未定义或不可表述的值。任何拿此值与其它任何值（除了 TRUE）进行的松散或严格比较的结果都是 FALSE。<br>由于 NAN 代表着任何不同值，不应拿 NAN 去和其它值进行比较，包括其自身，应该用 is_nan() 来检查。 </p><h4 id="字符串（string）："><a href="#字符串（string）：" class="headerlink" title="字符串（string）："></a>字符串（string）：</h4><p>（1）一个字符串 string 就是由一系列的字符组成，其中每个字符等同于一个字节。这意味着 PHP 只能支持 256 的字符集，因此不支持 Unicode 。<br>（注：Note: string 最大可以达到 2GB。）<br>（2）一个字符串可以用 4 种方式表达： </p><ul><li>单引号  ：定义一个字符串的最简单的方法是用单引号把它包围起来（字符 ‘）。</li><li>双引号  ：如果字符串是包围在双引号（”）中， PHP 将对一些特殊的字符进行解析。</li><li>heredoc 语法结构  ：<br>第三种表达字符串的方法是用 heredoc 句法结构：&lt;&lt;&lt;。在该运算符之后要提供一个标识符，然后换行。接下来是字符串 string 本身，最后要用前面定义的标识符作为结束标志。<br>结束时所引用的标识符必须在该行的第一列，而且，标识符的命名也要像其它标签一样遵守 PHP 的规则：只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。<br>（Heredoc 结构就象是没有使用双引号的双引号字符串，这就是说在 heredoc 结构中单引号不用被转义，但是上文中列出的转义序列还可以使用。变量将被替换，但在 heredoc 结构中含有复杂的变量时要格外小心。 ）</li><li>nowdoc 语法结构（自 PHP 5.3.0 起）<br>就象 heredoc 结构类似于双引号字符串，Nowdoc 结构是类似于单引号字符串的。Nowdoc 结构很象 heredoc 结构，但是 nowdoc 中不进行解析操作。这种结构很适合用于嵌入 PHP 代码或其它大段文本而无需对其中的特殊字符进行转义。与 SGML 的 &lt;![CDATA[ ]]&gt; 结构是用来声明大段的不用解析的文本类似，nowdoc 结构也有相同的特征。<br>一个 nowdoc 结构也用和 heredocs 结构一样的标记 &lt;&lt;&lt;， 但是跟在后面的标识符要用单引号括起来，即 &lt;&lt;&lt;’EOT’。Heredoc 结构的所有规则也同样适用于 nowdoc 结构，尤其是结束标识符的规则。</li></ul><p><strong>（注：函数、方法、静态类变量和类常量只有在 PHP 5 以后才可在 {$} 中使用。然而，只有在该字符串被定义的命名空间中才可以将其值作为变量名来访问。只单一使用花括号 ({}) 无法处理从函数或方法的返回值或者类常量以及类静态变量的值。 ）</strong><br>（3）字符串可以用 ‘.’（点）运算符连接起来，注意 ‘+’（加号）运算符没有这个功能。对于 string 的操作有很多有用的函数，后面予以单独说明。</p><h4 id="数组（array）："><a href="#数组（array）：" class="headerlink" title="数组（array）："></a>数组（array）：</h4><p>PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。<br>（1）语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义数组 array()</span><br><span class="line">可以用 array() 语言结构来新建一个数组。它接受任意数量用逗号分隔的 键（key） =&gt; 值（value）对。 </span><br><span class="line">array(  key =&gt;  value</span><br><span class="line">     , ...</span><br><span class="line">     )</span><br><span class="line">// 键（key）可是是一个整数 integer 或字符串 string</span><br><span class="line">// 值（value）可以是任意类型的值</span><br></pre></td></tr></table></figure></p><p>最后一个数组单元之后的逗号可以省略。通常用于单行数组定义中，例如常用 array(1, 2) 而不是 array(1, 2, )。对多行数组定义通常保留最后一个逗号，这样要添加一个新单元时更方便。<br>自 5.4 起可以使用短数组定义语法，用 [] 替代 array()。<br><strong>（注：key 可以是 integer 或者 string。value 可以是任意类型。）</strong></p><p><strong>此外 key 会有如下的强制转换： </strong></p><ul><li>包含有合法整型值的字符串会被转换为整型。例如键名 “8” 实际会被储存为 8。但是 “08” 则不会强制转换，因为其不是一个合法的十进制数值。  </li><li>浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。  </li><li>布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。  </li><li>Null 会被转换为空字符串，即键名 null 实际会被储存为 “”。  </li><li>数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。  </li></ul><p>如果在数组定义中多个单元都使用了同一个键名，则只使用了最后一个，之前的都被覆盖了。</p><p>（2）注意事项：<br> ① 方括号和花括号可以互换使用来访问数组单元（例如 $array[42] 和 $array{42} 在上例中效果相同）。<br> ② 试图访问一个未定义的数组键名与访问任何未定义变量一样：会导致 E_NOTICE 级别错误信息，其结果为 NULL。<br> ③ 要修改某个值，通过其键名给该单元赋一个新值。要删除某键值对，对其调用 unset() 函数。<br> ④ 应该始终在用字符串表示的数组索引上加上引号。例如用 $foo[‘bar’] 而不是 $foo[bar]。原因是此代码中有一个未定义的常量（bar）而不是字符串（’bar’－注意引号），而 PHP 可能会在以后定义此常量，不幸的是你的代码中有同样的名字。它能运行，是因为 PHP 自动将裸字符串（没有引号的字符串且不对应于任何已知符号）转换成一个其值为该裸字符串的正常字符串。例如，如果没有常量定义为 bar，PHP 将把它替代为 ‘bar’ 并使用之。<br> 但这并不意味着总是给键名加上引号。用不着给键名为常量或变量的加上引号，否则会使 PHP 不能解析它们。</p><h4 id="对象类型（Object）："><a href="#对象类型（Object）：" class="headerlink" title="对象类型（Object）："></a>对象类型（Object）：</h4><p>要创建一个新的对象 object，使用 new 语句实例化一个类。<br>转换为对象：如果将一个对象转换成对象，它将不会有任何变化。如果其它任何类型的值被转换成对象，将会创建一个内置类 stdClass 的实例。如果该值为 NULL，则新的实例为空。 array 转换成 object 将使键名成为属性名并具有相对应的值，除了数字键，不迭代就无法被访问。 </p><h4 id="资源类型（resource）："><a href="#资源类型（resource）：" class="headerlink" title="资源类型（resource）："></a>资源类型（resource）：</h4><p>资源 resource 是一种特殊变量，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。<br>转换为资源：由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，因此将其它类型的值转换为资源没有意义。 </p><h4 id="NULL："><a href="#NULL：" class="headerlink" title="NULL："></a>NULL：</h4><p>特殊的 NULL 值表示一个变量没有值。NULL 类型唯一可能的值就是 NULL。<br><strong>（注：NULL 类型只有一个值，就是不区分大小写的常量 NULL。）</strong><br>在下列情况下一个变量被认为是 NULL： </p><ul><li>被赋值为 NULL。 </li><li>尚未被赋值。 </li><li>被 unset()。</li></ul><h4 id="许的强制转换有："><a href="#许的强制转换有：" class="headerlink" title="许的强制转换有："></a>许的强制转换有：</h4><ul><li>(int), (integer) - 转换为整形 integer </li><li>(bool), (boolean) - 转换为布尔类型 boolean </li><li>(float), (double), (real) - 转换为浮点型 float </li><li>(string) - 转换为字符串 string </li><li>(array) - 转换为数组 array </li><li>(object) - 转换为对象 object </li><li>(unset) - 转换为 NULL (PHP 5) </li><li>(binary) 转换和 b 前缀转换支持为 PHP 5.2.1 新增。 </li></ul><p><strong>（注意在括号内允许有空格和制表符）</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;br&gt;四种标量类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;boolean（布尔型）、integer（整型）、float（浮点型，也称为double）、string（字符串）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两种复合类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;array（数组）、object（对象）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两种特殊类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;resource（资源）、Null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其它伪类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mixed（混合类型）、number（数字类型）、callback（回调类型）、void（无类型）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP基础整理（PHP手册版）</title>
    <link href="http://yoursite.com/2018/01/31/PHP%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88PHP%E6%89%8B%E5%86%8C%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/31/PHP基础整理（PHP手册版）/</id>
    <published>2018-01-31T09:45:30.000Z</published>
    <updated>2018-02-01T03:40:09.541Z</updated>
    
    <content type="html"><![CDATA[<h4 id="PHP概述："><a href="#PHP概述：" class="headerlink" title="PHP概述："></a>PHP概述：</h4><p>PHP（“PHP: Hypertext Preprocessor”，超文本预处理器的字母缩写）是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML中，尤其适合 web 开发。<br>PHP常用于服务端脚本和命令行脚本。<br>服务端脚本。是 PHP 最传统，也是最主要的目标领域。开展这项工作需要具备以下三点：PHP 解析器（CGI 或者服务器模块）、web 服务器和 web 浏览器。需要在运行 web 服务器时，安装并配置 PHP，然后，可以用 web 浏览器来访问 PHP 程序的输出，即浏览服务端的 PHP 页面。一般做 web 开发和 api 开发。<br>命令行脚本。可以编写一段 PHP 脚本，并且不需要任何服务器或者浏览器来运行它。通过这种方式，仅仅只需要 PHP 解析器来执行。这种用法对于依赖 cron（Unix 或者 Linux 环境）或者 Task Scheduler（Windows 环境）的日常运行的脚本来说是理想的选择。这些脚本也可以用来处理简单的文本。<br><a id="more"></a></p><h4 id="基础语法："><a href="#基础语法：" class="headerlink" title="基础语法："></a>基础语法：</h4><h5 id="1、PHP标记："><a href="#1、PHP标记：" class="headerlink" title="1、PHP标记："></a>1、PHP标记：</h5><p>普通：&lt;?php ?&gt;<br>短标记：&lt;? ?&gt; 通过 php.ini 配置中的 short_open_tag 开启即可。</p><h5 id="2、注释"><a href="#2、注释" class="headerlink" title="2、注释"></a>2、注释</h5><p>单行：//<br>多行：/<em>  </em>/</p><h5 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h5><h6 id="（1）基础"><a href="#（1）基础" class="headerlink" title="（1）基础"></a>（1）基础</h6><p>PHP 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。<br>变量名与 PHP 中其它的标签一样遵循相同的规则。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。</p><p>变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。<br>PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用（换言之，”成为其别名” 或者 “指向”）了原始变量。改动新的变量将影响到原始变量，反之亦然。<br>使用引用赋值，简单地将一个 &amp; 符号加到将要赋值的变量前（源变量）。</p><p>虽然在 PHP 中并不需要初始化变量，但对变量进行初始化是个好习惯。未初始化的变量具有其类型的默认值 - 布尔类型的变量默认值是 FALSE，整形和浮点型变量默认值是零，字符串型变量（例如用于 echo 中）默认值是空字符串以及数组变量的默认值是空数组。 </p><h6 id="（2）变量范围："><a href="#（2）变量范围：" class="headerlink" title="（2）变量范围："></a>（2）变量范围：</h6><p>变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的 PHP 变量只有一个单独的范围。这个单独的范围跨度同样包含了 include 和 require 引入的文件。</p><p>局部变量：局部函数内部的变量将被限制在局部函数范围内。<br>全局变量：PHP 中全局变量在函数中使用时必须声明为 global。<br>超全局变量：PHP自定义特殊的数组。$GLOBALS、$_POST、$_GET、$_REQUEST、$_COOKIE。<br>静态变量：静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。</p><h6 id="（3）可变变量："><a href="#（3）可变变量：" class="headerlink" title="（3）可变变量："></a>（3）可变变量：</h6><p>有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &apos;hello&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。在上面的例子中 hello 使用了两个美元符号（$）以后，就可以作为一个可变变量的变量了。例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$$a = &apos;world&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这时，两个变量都被定义了：$a 的内容是”hello”并且 $hello 的内容是”world”。</p><p>要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下 $$a[1] 时，解析器需要知道是想要 $a[1] 作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 [1] 的值。解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1]。<br>类的属性也可以通过可变属性名来访问。可变属性名将在该调用所处的范围内被解析。例如，对于 $foo-&gt;$bar 表达式，则会在本地范围来解析 $bar 并且其值将被用于 $foo 的属性名。对于 $bar 是数组单元时也是一样。<br>也可使用花括号来给属性名清晰定界。最有用是在属性位于数组中，或者属性名包含有多个部分或者属性名包含有非法字符时。<br><strong>（注意，在 PHP 的函数和类的方法中，超全局变量不能用作可变变量。$this 变量也是一个特殊变量，不能被动态引用。）</strong></p><h5 id="5、常量"><a href="#5、常量" class="headerlink" title="5、常量"></a>5、常量</h5><p>常量是一个简单值的标识符（名字）。如同其名称所暗示的，在脚本执行期间该值不能改变（除了所谓的魔术常量，它们其实不是常量）。常量默认为大小写敏感。传统上常量标识符总是大写的。<br>常量名和其它任何 PHP 标签遵循同样的命名规则。合法的常量名以字母或下划线开始，后面跟着任何字母，数字或下划线。</p><h6 id="（1）语法"><a href="#（1）语法" class="headerlink" title="（1）语法"></a>（1）语法</h6><p>可以用 define() 函数来定义常量，在 PHP 5.3.0 以后，可以使用 const 关键字在类定义之外定义常量。一个常量一旦被定义，就不能再改变或者取消定义。如果只想检查是否定义了某常量，用 defined() 函数。</p><p>常量只能包含标量数据（boolean，integer，float 和 string）。可以定义 resource 常量，但应尽量避免，因为会造成不可预料的结果。 </p><p>可以简单的通过指定其名字来取得常量的值，与变量不同，不应该在常量前面加上 $ 符号。如果常量名是动态的，也可以用函数 constant() 来获取常量的值。用 get_defined_constants() 可以获得所有已定义的常量列表。<br><strong>（注: 常量和（全局）变量在不同的名字空间中。这意味着例如 TRUE 和 $TRUE 是不同的。）</strong></p><p>如果使用了一个未定义的常量，PHP 假定想要的是该常量本身的名字，如同用字符串调用它一样（CONSTANT 对应 “CONSTANT”）。此时将发出一个 E_NOTICE 级的错误。参见手册中为什么 $foo[bar] 是错误的（除非事先用 define() 将 bar 定义为一个常量）。 </p><p><strong>常量和变量有如下不同： </strong></p><ul><li>常量前面没有美元符号（$）；  </li><li>常量只能用 define() 函数定义，而不能通过赋值语句；  </li><li>常量可以不用理会变量的作用域而在任何地方定义和访问；  </li><li>常量一旦定义就不能被重新定义或者取消定义；  </li><li>常量的值只能是标量。</li></ul><p><strong>define() 与 const 区别：</strong><br>和使用 define() 来定义常量相反的是，使用 const 关键字定义常量必须处于最顶端的作用区域，因为用此方法是在编译时定义的。这就意味着不能在函数内，循环内以及 if 语句之内用 const 来定义常量。</p><h6 id="（2）魔术常量"><a href="#（2）魔术常量" class="headerlink" title="（2）魔术常量"></a>（2）魔术常量</h6><p>PHP 向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。<br>有八个魔术常量它们的值随着它们在代码中的位置改变而改变。例如 <strong>LINE</strong> 的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下： </p><p>几个 PHP 的”魔术常量”</p><style type="text/css">    table th:first-of-type{        width: 100px;    }</style><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>LINE</strong></td><td>文件中的当前行号。  </td></tr><tr><td><strong>FILE</strong></td><td>文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，<strong>FILE</strong> 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。  </td></tr><tr><td><strong>DIR</strong></td><td>文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(<strong>FILE</strong>)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增） =  </td></tr><tr><td><strong>FUNCTION</strong></td><td>函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。  </td></tr><tr><td><strong>CLASS</strong></td><td>类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 <strong>CLASS</strong> 对 trait 也起作用。当用在 trait 方法中时，<strong>CLASS</strong> 是调用 trait 方法的类的名字。  </td></tr><tr><td><strong>TRAIT</strong></td><td>Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4 起此常量返回 trait 被定义时的名字（区分大小写）。Trait 名包括其被声明的作用区域（例如 Foo\Bar）。  </td></tr><tr><td><strong>METHOD</strong></td><td>类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。  </td></tr><tr><td><strong>NAMESPACE</strong></td><td>当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。 </td></tr></tbody></table><h5 id="6、运算符"><a href="#6、运算符" class="headerlink" title="6、运算符"></a>6、运算符</h5><p>运算符优先级</p><table><thead><tr><th>结合方向</th><th>运算符</th><th>附加信息</th></tr></thead><tbody><tr><td>无</td><td>clone new</td><td>clone 和 new </td></tr><tr><td>左</td><td>[</td><td>array() </td></tr><tr><td>右</td><td>**</td><td>算术运算符 </td></tr><tr><td>右</td><td>++ – ~ (int) (float) (string) (array) (object) (bool) @</td><td>类型和递增／递减  </td></tr><tr><td>无</td><td>instanceof</td><td>类型  </td></tr><tr><td>右</td><td>!</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>* / %</td><td>算术运算符  </td></tr><tr><td>左</td><td>+ - .</td><td>算术运算符和字符串运算符 </td></tr><tr><td>左</td><td>&lt;&lt; &gt;&gt;</td><td>位运算符  </td></tr><tr><td>无</td><td>&lt; &lt;= &gt; &gt;=</td><td>比较运算符  </td></tr><tr><td>无</td><td>== != === !== &lt;&gt; &lt;=&gt;</td><td>比较运算符  </td></tr><tr><td>左</td><td>&amp;</td><td>位运算符和引用 </td></tr><tr><td>左</td><td>^</td><td>位运算符  </td></tr><tr><td>左</td><td>&#124;</td><td>位运算符  </td></tr><tr><td>左</td><td>&amp;&amp;</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>&#124;&#124;</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>??</td><td>比较运算符  </td></tr><tr><td>左</td><td>? :</td><td>ternary  </td></tr><tr><td>右</td><td>= += -= <em>= *</em>= /= .= %= &amp;= &#124;= ^= &lt;&lt;= &gt;&gt;=</td><td>赋值运算符  </td></tr><tr><td>左</td><td>and</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>xor</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>or</td><td>逻辑运算符  </td></tr></tbody></table><h5 id="7、流程控制"><a href="#7、流程控制" class="headerlink" title="7、流程控制"></a>7、流程控制</h5><h6 id="（1）条件判断"><a href="#（1）条件判断" class="headerlink" title="（1）条件判断"></a>（1）条件判断</h6><p><strong>if语句：</strong><br>单分支if语句：if(){}else{}<br>多分支if语句：if(){}elseif(){}else{}<br>分支嵌套语句：if(){if(){}}else{}</p><p><strong>switch语句：</strong><br>switch(expr){<br>    case 0:<br>        statement<br>        break;<br>    case 1:<br>        statement<br>        break;<br>    default:<br>        statement<br>        break;<br>}</p><h6 id="（2）循环判断"><a href="#（2）循环判断" class="headerlink" title="（2）循环判断"></a>（2）循环判断</h6><p><strong>for循环：</strong><br>for(expr1; expr2; expr3){</p><p>}</p><p><strong>foreach循环：</strong><br>仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。<br>foreach(array_expression as $value){<br>    statement<br>}<br>foreach(array_expression as $key=&gt;$value){<br>    statement<br>}</p><p><strong>while循环：</strong><br>while(){</p><p>}</p><p><strong>do-while循环：</strong><br>do{</p><p>}while();</p><h6 id="（3）中止语句"><a href="#（3）中止语句" class="headerlink" title="（3）中止语句"></a>（3）中止语句</h6><p>跳出循环语句：break;<br>跳出本次循环，执行下一个循环：continue;<br>结束函数的执行并将它的值返回：return;</p><h6 id="（4）加载语句"><a href="#（4）加载语句" class="headerlink" title="（4）加载语句"></a>（4）加载语句</h6><p>require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include 只产生警告（E_WARNING），脚本会继续运行。<br>require：<br>include：<br>唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。<br>require_once：<br>include_once：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;PHP概述：&quot;&gt;&lt;a href=&quot;#PHP概述：&quot; class=&quot;headerlink&quot; title=&quot;PHP概述：&quot;&gt;&lt;/a&gt;PHP概述：&lt;/h4&gt;&lt;p&gt;PHP（“PHP: Hypertext Preprocessor”，超文本预处理器的字母缩写）是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML中，尤其适合 web 开发。&lt;br&gt;PHP常用于服务端脚本和命令行脚本。&lt;br&gt;服务端脚本。是 PHP 最传统，也是最主要的目标领域。开展这项工作需要具备以下三点：PHP 解析器（CGI 或者服务器模块）、web 服务器和 web 浏览器。需要在运行 web 服务器时，安装并配置 PHP，然后，可以用 web 浏览器来访问 PHP 程序的输出，即浏览服务端的 PHP 页面。一般做 web 开发和 api 开发。&lt;br&gt;命令行脚本。可以编写一段 PHP 脚本，并且不需要任何服务器或者浏览器来运行它。通过这种方式，仅仅只需要 PHP 解析器来执行。这种用法对于依赖 cron（Unix 或者 Linux 环境）或者 Task Scheduler（Windows 环境）的日常运行的脚本来说是理想的选择。这些脚本也可以用来处理简单的文本。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Linux VPS、Linux系统防止DDOS攻击脚本[转]</title>
    <link href="http://yoursite.com/2018/01/25/Linux-VPS%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E9%98%B2%E6%AD%A2DDOS%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC-%E8%BD%AC/"/>
    <id>http://yoursite.com/2018/01/25/Linux-VPS、Linux系统防止DDOS攻击脚本-转/</id>
    <published>2018-01-25T07:00:10.000Z</published>
    <updated>2018-01-25T07:04:52.803Z</updated>
    
    <content type="html"><![CDATA[<p>转载地址：<a href="http://www.1987.name/33.html" target="_blank" rel="noopener">http://www.1987.name/33.html</a></p><p>互联网上明争暗斗如同现实社会一样，DDOS攻击屡见不鲜，是很多站长烦恼的事情，尤其是个人站长，资金有限，没有硬件防火墙那只能使用软件。Linux系统上第一个想到的替代软件肯定是iptables，但是它不会智能屏蔽攻击IP，需要手动执行，这样也是不现实。本文主要介绍一款配合iptables来智能抵御DDOS攻击的软件：<strong>DDoS Deflate。</strong><br><a id="more"></a></p><h4 id="关于DDOS-Deflate脚本"><a href="#关于DDOS-Deflate脚本" class="headerlink" title="关于DDOS Deflate脚本"></a>关于DDOS Deflate脚本</h4><p>DDOS deflate是一个轻量级的脚本，以协助阻止拒绝服务攻击的过程中的bash shell脚本。它使用下面的命令来创建一个连接到服务器的IP地址列表，以及与它们的连接总数 。这是最简单的安装软件的解决方案之一。我已经使用一年多，抵御一般性的DDOS攻击效果还是不错的。</p><p>主要原理是超过了预先配置的连接数的IP地址自动被服务器防火墙（iptables）阻止！<br><code>netstat -ntu | awk &#39;{print $5}&#39; | cut -d: -f1 | sort | uniq -c | sort -n</code></p><h4 id="DDOS-Deflate的5个主要功能"><a href="#DDOS-Deflate的5个主要功能" class="headerlink" title="DDOS Deflate的5个主要功能"></a>DDOS Deflate的5个主要功能</h4><ol><li>可以配置白名单的IP地址文件，配置文件路径：/usr/local/ddos/ignore.ip.list</li><li>配置文件简单明了，文件路径：/usr/local/ddos/ddos.conf</li><li>可以设置被防火墙（iptables）屏蔽的IP地址封锁时间（默认：600秒后自动解除封锁）</li><li>可以修改配置文件，脚本可以定时周期性运行（默认是：1分钟）</li><li>当遇到攻击，IP被封锁之后可以为指定的邮箱接收电子邮件警报。</li></ol><h4 id="DDOS-Deflate的安装方法"><a href="#DDOS-Deflate的安装方法" class="headerlink" title="DDOS Deflate的安装方法"></a>DDOS Deflate的安装方法</h4><p>DDOS Deflate非常简单，下载脚本后，直接执行脚本，结束后会显示安装信息，按ESC退出即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.inetbase.com/scripts/ddos/install.sh</span><br><span class="line">chmod +x install.sh</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure></p><p>安装结束后，配置主配文件ddos.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">##### Paths of the script and other files</span><br><span class="line">PROGDIR=&quot;/usr/local/ddos&quot; #软件文件存放位置</span><br><span class="line">PROG=&quot;/usr/local/ddos/ddos.sh&quot; #主要功能脚本路径</span><br><span class="line">IGNORE_IP_LIST=&quot;/usr/local/ddos/ignore.ip.list&quot; #白名单列表路径</span><br><span class="line">CRON=&quot;/etc/cron.d/ddos.cron&quot; #定时任务脚本路径</span><br><span class="line">APF=&quot;/etc/apf/apf&quot; #APF路径</span><br><span class="line">IPT=&quot;/sbin/iptables&quot; #iptables路径</span><br><span class="line"></span><br><span class="line">##### frequency in minutes for running the script</span><br><span class="line">##### Caution: Every time this setting is changed, run the script with --cron</span><br><span class="line">##### option so that the new frequency takes effect</span><br><span class="line">FREQ=1 #检查周期时间，默认1分钟</span><br><span class="line"></span><br><span class="line">##### How many connections define a bad IP? Indicate that below.</span><br><span class="line">NO_OF_CONNECTIONS=150 #允许客户端与服务器的最大连接数，超过IP就会被屏蔽，一般保持默认即可</span><br><span class="line"></span><br><span class="line">##### APF_BAN=1 (Make sure your APF version is atleast 0.96)</span><br><span class="line">##### APF_BAN=0 (Uses iptables for banning ips instead of APF)</span><br><span class="line">APF_BAN=0  #数字1为使用APF，数字0为使用iptables，这里推荐使用iptables </span><br><span class="line"></span><br><span class="line">##### KILL=0 (Bad IPs are&apos;nt banned, good for interactive execution of script)</span><br><span class="line">##### KILL=1 (Recommended setting)</span><br><span class="line">KILL=1 #是否屏蔽IP，当然是屏蔽，默认即可</span><br><span class="line"></span><br><span class="line">##### An email is sent to the following address when an IP is banned.</span><br><span class="line">##### Blank would suppress sending of mails</span><br><span class="line">EMAIL_TO=&quot;admin@1987.name&quot; #指定一个 电子邮件，用于发送警报 </span><br><span class="line"></span><br><span class="line">##### Number of seconds the banned ip should remain in blacklist.</span><br><span class="line">BAN_PERIOD=600 #屏蔽时间，这里自由设定</span><br></pre></td></tr></table></figure></p><p>配置文件中提到的APF，它也是linux系统中防火墙之一，这里稍作介绍：APF（Advanced Policy Firewall），是 Rf-x Networks 出品的Linux环境下的软件防火墙。APF采用Linux系统默认的 iptables 规则。APF可以算是Linux中最出名的软件防火墙之一。</p><h4 id="为DDOS-Deflate开启相关服务"><a href="#为DDOS-Deflate开启相关服务" class="headerlink" title="为DDOS Deflate开启相关服务"></a>为DDOS Deflate开启相关服务</h4><p>开启iptables<br><code>service iptables start</code><br>开启crontab，定时任务<br><code>service crond start</code></p><h4 id="如何卸载DDOS-Deflate"><a href="#如何卸载DDOS-Deflate" class="headerlink" title="如何卸载DDOS Deflate"></a>如何卸载DDOS Deflate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.inetbase.com/scripts/ddos/uninstall.ddos</span><br><span class="line">chmod +x uninstall.ddos</span><br><span class="line">./uninstall.ddos</span><br></pre></td></tr></table></figure><p>希望遇到DDOS攻击的朋友使用此软件能解决头疼问题，也感谢软件作者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载地址：&lt;a href=&quot;http://www.1987.name/33.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.1987.name/33.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;互联网上明争暗斗如同现实社会一样，DDOS攻击屡见不鲜，是很多站长烦恼的事情，尤其是个人站长，资金有限，没有硬件防火墙那只能使用软件。Linux系统上第一个想到的替代软件肯定是iptables，但是它不会智能屏蔽攻击IP，需要手动执行，这样也是不现实。本文主要介绍一款配合iptables来智能抵御DDOS攻击的软件：&lt;strong&gt;DDoS Deflate。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的vim标配</title>
    <link href="http://yoursite.com/2018/01/24/%E6%88%91%E7%9A%84vim%E6%A0%87%E9%85%8D/"/>
    <id>http://yoursite.com/2018/01/24/我的vim标配/</id>
    <published>2018-01-24T09:33:52.000Z</published>
    <updated>2018-01-24T10:05:48.897Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux下开发程序，一般都会离不开vi编辑器，而vim是vi的进阶版IDE。目前vim已经取代了vi编辑器，正常使用vi的时候就默认启用的是vim编辑器，不信你可自己查看，在bash命令行下输入”alias”即可看到是否vim已经取代了vi编辑器。但vim的用法与vi编辑器是一模一样，所以，不用担心使用过vi，而不会使用vim，只不过vim有更高级的用法罢了。而vim的配置就是其中一个非常好的用法。<br>一千个vimer就有一千个配置，vim的配置之多让人眩目，但常用的基本配置也就那些——我的vim标配。<br>首先，要知道在什么地方配置vim，一般只修改用户自己的vim配置文件即可(~/.vimrc)。下面给出我的配置清单：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set tabstop=4   &quot;设定tab缩进空格数</span><br><span class="line">set expandtab      &quot;设定tab自动转为空格</span><br><span class="line">set number         &quot;set nu 显示行号</span><br><span class="line">set hlsearch       &quot;搜索时高亮显示被找到的文本</span><br><span class="line">set syntax=on      &quot;自动语法高亮</span><br><span class="line">set smartindent    &quot;开启新行时使用智能自动缩进</span><br><span class="line">set showmatch   &quot;自动匹配括号</span><br></pre></td></tr></table></figure></p><p>（注：vim配置注释，使用双引号 “ 注释。）</p><h5 id="常用配置："><a href="#常用配置：" class="headerlink" title="常用配置："></a>常用配置：</h5><p>“显示行号<br>set nu/nonu</p><p>“语法高亮<br>syntax on/off</p><p>“tab缩进<br>set tabstop=4<br>set shiftwidth=4<br>set expandtab<br>set smarttab</p><p>“智能缩进<br>set smartindent<br>（表示在换行的时候光标进行智能缩进，触发智能缩进的场景有：以”{“结尾，以C语言关键字开头，可以通过:h cinwords进行查看，包括：if, else, while, do, for, switch，以”}”开头，此情况只有在执行”O”命令时候有效，但是这个配置有一点问题，就是当换行之后本来已经处于缩进状态了，如果输入”#”，那么缩进就会取消，”#”就会被插入到第一列，可是我们在写Python代码的时候，往往不希望这样做，所以我们可以增加配置”:inoremap # X^H”，其中 ^H 是先按CTRL-V再按CTRL-H输入的。）</p><p>“高亮被搜索的字符<br>set hlsearch</p><p>“背景色<br>set background=dark</p><p>“显示匹配（可自动匹配括号）<br>set showmatch</p><font color="red">待补录…</font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Linux下开发程序，一般都会离不开vi编辑器，而vim是vi的进阶版IDE。目前vim已经取代了vi编辑器，正常使用vi的时候就默认启用的是vim编辑器，不信你可自己查看，在bash命令行下输入”alias”即可看到是否vim已经取代了vi编辑器。但vim的用法与vi编辑器是一模一样，所以，不用担心使用过vi，而不会使用vim，只不过vim有更高级的用法罢了。而vim的配置就是其中一个非常好的用法。&lt;br&gt;一千个vimer就有一千个配置，vim的配置之多让人眩目，但常用的基本配置也就那些——我的vim标配。&lt;br&gt;首先，要知道在什么地方配置vim，一般只修改用户自己的vim配置文件即可(~/.vimrc)。下面给出我的配置清单：&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Linux 用户与账号管理</title>
    <link href="http://yoursite.com/2018/01/22/Linux-%E7%94%A8%E6%88%B7%E4%B8%8E%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/01/22/Linux-用户与账号管理/</id>
    <published>2018-01-22T10:25:29.000Z</published>
    <updated>2018-01-22T10:29:09.203Z</updated>
    
    <content type="html"><![CDATA[<p>Linux是个多用户多任务的分时操作系统，所有一个要使用系统资源的用户都必须先向系统管理员申请一个账号，然后以这个账号的身份进入系统。用户的账号一方面能帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也能帮助用户组织文件，并为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和用户口令。用户在登录时键入正确的用户名和口令后，才能进入系统和自己的主目录。</p><p>实现用户账号的管理，要完成的工作主要有如下几个方面：<br>a.用户账号的管理。<br>b.用户口令的管理。<br>c.用户组的管理。<br>d.用户切换<br><a id="more"></a></p><h4 id="用户账号的管理：添加、删除和修改："><a href="#用户账号的管理：添加、删除和修改：" class="headerlink" title="用户账号的管理：添加、删除和修改："></a>用户账号的管理：添加、删除和修改：</h4><h5 id="1、新增用户：useradd"><a href="#1、新增用户：useradd" class="headerlink" title="1、新增用户：useradd"></a>1、新增用户：useradd</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM]\</span><br><span class="line">&gt; [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号名</span><br><span class="line">选项与参数：</span><br><span class="line">    -u ：后面接的是 UID ，是一组数字。直接指定一个特定的 UID 给这个账号；</span><br><span class="line">    -g ：后面接的那个组名就是用户所属的用户组。该群组的 GID 会被放置到 /etc/passwd 的第四个字段内。</span><br><span class="line">    -G ：后面接的组名则是这个账号还可以加入的群组，即附加组。这个选项与参数会修改 /etc/group 内的相关资料！</span><br><span class="line">    -M ：强制！不要建立用户家目录！(系统账号默认值)</span><br><span class="line">    -m ：强制！要建立用户家目录！(一般账号默认值)</span><br><span class="line">    -c ：这个就是 /etc/passwd 的第五栏的说明内容(comment)！可以随便我们设定</span><br><span class="line">    -d ：指定某个目录成为家目录，而不要使用默认值。务必使用绝对路径！如果此目录不存在，则同时使用-m选项，能创建主目录。</span><br><span class="line">    -s ：后面接一个 shell ，若没有指定则预设是 /bin/bash</span><br><span class="line">    -r ：建立一个系统的账号，这个账号的 UID 会有限制 (参考 /etc/login.defs)</span><br><span class="line">    -e ：后面接一个日期，格式为【YYYY-MM-DD】此项目可写入 shadow 第八字段，亦即账号失效日的设定项目；</span><br><span class="line">    -f ：后面接 shadow 的第七字段项目，指定密码是否会失效。0 为立刻失效，-1 为永远不失效(密码只会过期而强制于登入时重新设定而已。)</span><br></pre></td></tr></table></figure><p>范例一：完全参考默认值建立一个用户，名称为 ben<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# useradd ben</span><br><span class="line">[root@www ~]# ll -d /home/ben</span><br><span class="line">drwx------ 4 ben ben 4096 Feb 25 09:38 /home/ben</span><br><span class="line"># 默认会建立用户家目录，且权限为 700 ！这是重点！</span><br><span class="line">[root@www ~]# grep ben /etc/passwd /etc/shadow /etc/group</span><br><span class="line">/etc/passwd:ben:x:504:505::/home/ben:/bin/bash</span><br><span class="line">/etc/shadow:ben:!!:14300:0:99999:7:::</span><br><span class="line">/etc/group:ben:x:505: &lt;==预设会建立一个与账号一模一样的群组名</span><br></pre></td></tr></table></figure></p><p>其实系统已经帮我们规定好非常多的默认值了，所以我们可以简单的使用【 useradd 账号 】来建立使用者即可。CentOS 这些默认值主要会帮我们处理几个项目：</p><ul><li>在 /etc/passwd 里面建立一行与账号相关的数据，包括建立 UID/GID/ 家目录等；</li><li>在 /etc/shadow 里面将此账号的密码相关参数填入，但是尚未有密码；</li><li>在 /etc/group 里面加入一个与账号名称一模一样的组名；</li><li>在 /home 底下建立一个与账号同名的目录作为用户家目录，且权限为 700</li></ul><p>由于在 /etc/shadow 内仅会有密码参数而不会有加密过的密码数据，因此我们在建立使用者账号时，还需要使用【 passwd 账号 】来给予密码才算是完成了用户建立的流程。</p><h5 id="2、删除用户：userdel"><a href="#2、删除用户：userdel" class="headerlink" title="2、删除用户：userdel"></a>2、删除用户：userdel</h5><p>这个功能就太简单了，目的在删除用户的相关数据，而用户的数据有：</p><ul><li>用户账号/密码相关参数：/etc/passwd, /etc/shadow</li><li>使用者群组相关参数：/etc/group, /etc/gshadow</li><li>用户个人档案数据： /home/username, /var/spool/mail/username..</li></ul><p>整个指令的语法非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# userdel [-r] username</span><br><span class="line">选项与参数：</span><br><span class="line">    -r ：连同用户的家目录也一起删除</span><br></pre></td></tr></table></figure></p><p>范例一：删除 ben ，连同家目录一起删除<br><code>[root@www ~]# userdel -r ben</code></p><p>这个指令下达的时候要小心了！通常我们要移除一个账号的时候，你可以手动的将 /etc/passwd 与 /etc/shadow 里头的该账号取消即可！一般而言，如果该账号只是【暂时不启用】的话，那么将 /etc/shadow 里头账号失效日期 (第八字段) 设定为 0 就可以让该账号无法使用，但是所有跟该账号相关的数据都会留下来！使用 userdel 的时机通常是【你真的确定不要让该用户在主机上面使用任何数据了！】</p><h5 id="3、修改用户：usermod"><a href="#3、修改用户：usermod" class="headerlink" title="3、修改用户：usermod"></a>3、修改用户：usermod</h5><p>（注：usermod 就是用来微调 useradd 增加的使用者参数）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# usermod [-cdegGlsuLU] username</span><br><span class="line">选项与参数：</span><br><span class="line">    -c ：后面接账号的说明，即 /etc/passwd 第五栏的说明栏，可以加入一些账号的说明。</span><br><span class="line">    -d ：后面接账号的家目录，即修改 /etc/passwd 的第六栏；</span><br><span class="line">    -e ：后面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 内的第八个字段数据！</span><br><span class="line">    -f ：后面接天数，为 shadow 的第七字段。</span><br><span class="line">    -g ：后面接初始群组，修改 /etc/passwd 的第四个字段，亦即是 GID 的字段！</span><br><span class="line">    -G ：后面接次要群组，修改这个使用者能够支持的群组，修改的是 /etc/group ！</span><br><span class="line">    -a ：与 -G 合用，可【增加次要群组的支持】而非【设定】！</span><br><span class="line">    -l ：后面接账号名称。亦即是修改账号名称， /etc/passwd 的第一栏！</span><br><span class="line">    -s ：后面接 Shell 的实际档案，例如 /bin/bash 或 /bin/csh 等等。</span><br><span class="line">    -u ：后面接 UID 数字！即 /etc/passwd 第三栏的资料；</span><br><span class="line">    -L ：暂时将用户的密码冻结，让他无法登入。其实仅改 /etc/shadow 的密码栏。</span><br><span class="line">    -U ：将 /etc/shadow 密码栏的 ! 拿掉，解冻！</span><br></pre></td></tr></table></figure></p><h5 id="4、相关用户功能："><a href="#4、相关用户功能：" class="headerlink" title="4、相关用户功能："></a>4、相关用户功能：</h5><p>finger：查阅用户相关的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# finger [-s] username</span><br><span class="line">选项与参数：</span><br><span class="line">    -s ：仅列出用户的账号、全名、终端机代号与登入时间等等；</span><br><span class="line">    -m ：列出与后面接的账号相同者，而不是利用部分比对 (包括全名部分)</span><br></pre></td></tr></table></figure></p><p>id：查询某人或自己的相关 UID/GID 等信息<br><code>[root@www ~]# id [username]</code></p><h4 id="用户口令的管理：passwd"><a href="#用户口令的管理：passwd" class="headerlink" title="用户口令的管理：passwd"></a>用户口令的管理：passwd</h4><p>使用 useradd 建立了账号之后，在预设的情况下，该账号是暂时被封锁的，也就是说，该账号是无法登入的，你可以去瞧一瞧 /etc/shadow 内的第二个字段就知道了。那该如何是好？使用 passwd 设定密码之后就可使用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# passwd [--sdtin] &lt;==所有人均可使用来改自己的密码</span><br><span class="line">[root@www ~]# passwd [-l] [-u] [--sdtin] [-S] \</span><br><span class="line">&gt; [-n 日数] [-x 日数] [-w 日数] [-i 日期] 账号 &lt;==root 功能</span><br><span class="line">选项与参数：</span><br><span class="line">    --stdin ：可以透过来自前一个管线的数据，作为密码输入，对 shell script 有帮助！</span><br><span class="line">    -l ：是 Lock 的意思，会将 /etc/shadow 第二栏最前面加上 ! 使密码失效；</span><br><span class="line">    -u ：与 -l 相对，是 Unlock 的意思！</span><br><span class="line">    -S ：列出密码相关参数，亦即 shadow 档案内的大部分信息。</span><br><span class="line">    -n ：后面接天数，shadow 的第 4 字段，多久不可修改密码天数</span><br><span class="line">    -x ：后面接天数，shadow 的第 5 字段，多久内必须要更动密码</span><br><span class="line">    -w ：后面接天数，shadow 的第 6 字段，密码过期前的警告天数</span><br><span class="line">    -i ：后面接【日期】，shadow 的第 7 字段，密码失效日期</span><br></pre></td></tr></table></figure></p><p>理论上，你的密码最好符合如下要求：</p><ul><li>密码不能与账号相同；</li><li>密码尽量不要选用字典里面会出现的字符串；</li><li>密码需要超过 8 个字符；</li><li>密码不要使用个人信息，如身份证、手机号码、其他电话号码等；</li><li>密码不要使用简单的关系式，如 1+1=2， Iamben 等；</li><li>密码尽量使用大小写字符、数字、特殊字符($,_,-等)的组合。</li></ul><h4 id="用户组的管理：新增、删除与修改"><a href="#用户组的管理：新增、删除与修改" class="headerlink" title="用户组的管理：新增、删除与修改"></a>用户组的管理：新增、删除与修改</h4><p>每个用户都有一个用户组，系统能对一个用户组中的所有用户进行集中管理。不同Linux系统对用户组的规定有所不同，如Linux下的用户属于和他同名的用户组，这个用户组在创建用户时同时创建。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就对/etc/group文件的更新。<br>用户组（group）就是具有相同特征的用户（user）的集合体；比如有时我们要让多个用户具有相同的权限，比如查看、修改某一文件或执行某个命令，这时我们需要用户组，我们把用户都定义到同一用户组，我们通过修改文件或目录的权限，让用户组具有一定的操作权限，这样用户组下的用户对该文件或目录都具有相同的权限，这是我们通过定义组和修改文件的权限来实现的；</p><h5 id="1、新增群组：groupadd"><a href="#1、新增群组：groupadd" class="headerlink" title="1、新增群组：groupadd"></a>1、新增群组：groupadd</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# groupadd [-g gid] [-r] 组名</span><br><span class="line">选项与参数：</span><br><span class="line">    -g ：后面接某个特定的 GID ，用来直接给予某个 GID</span><br><span class="line">    -r ：建立系统群组！与 /etc/login.defs 内的 GID_MIN 有关。</span><br></pre></td></tr></table></figure><p>范例一：新建一个群组，名称为 group1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# groupadd group1</span><br><span class="line">[root@www ~]# grep group1 /etc/group /etc/gshadow</span><br><span class="line">/etc/group:group1:x:702:</span><br><span class="line">/etc/gshadow:group1:!::</span><br><span class="line"># 群组的 GID 也是会由 500 以上最大 GID+1 来决定！</span><br></pre></td></tr></table></figure></p><h5 id="2、修改群组：groupmod"><a href="#2、修改群组：groupmod" class="headerlink" title="2、修改群组：groupmod"></a>2、修改群组：groupmod</h5><p>跟 usermod 类似的，这个指令仅是在进行 group 相关参数的修改而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# groupmod [-g gid] [-n group_name] 群组名</span><br><span class="line">选项与参数：</span><br><span class="line">    -g ：修改既有的 GID 数字；</span><br><span class="line">    -n ：修改既有的组名</span><br></pre></td></tr></table></figure></p><p>范例一：将刚刚上个指令建立的 group1 名称改为 mygroup ， GID 为 201<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# groupmod -g 201 -n mygroup group1</span><br><span class="line">[root@www ~]# grep mygroup /etc/group /etc/gshadow</span><br><span class="line">/etc/group:mygroup:x:201:</span><br><span class="line">/etc/gshadow:mygroup:!::</span><br></pre></td></tr></table></figure></p><h5 id="3、删除群组：groupdel"><a href="#3、删除群组：groupdel" class="headerlink" title="3、删除群组：groupdel"></a>3、删除群组：groupdel</h5><p><code>[root@www ~]# groupdel [groupname]</code><br>范例一：将刚刚的 mygroup 删除！<br><code>[root@www ~]# groupdel mygroup</code><br>范例二：若要删除 ben1 这个群组的话？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# groupdel ben1</span><br><span class="line">groupdel: cannot remove user&apos;s primary group.</span><br></pre></td></tr></table></figure></p><p>为什么 mygroup 可以删除，但是 ben1 就不能删除呢？原因很简单，【有某个账号 (/etc/passwd)的 initial group 使用该群组！】如果查阅一下，你会发现在 /etc/passwd 内的 vbird1 第四栏的 GID 就是 /etc/group 内的 ben1 那个群组的 GID ，所以，无法删除！否则 ben1 这个用户登入系统后，就会找不到 GID ，那可是会造成很大的麻烦！那么如果硬要要删除 ben1 这个群组呢？你【必须要确认 /etc/passwd 内的账号没有任何人使用该群组作为 initial group 】才行。你可以：</p><ul><li>修改 ben1 的 GID ，或者是：</li><li>删除 ben1 这个使用者。</li></ul><h4 id="用户的身份切换"><a href="#用户的身份切换" class="headerlink" title="用户的身份切换"></a>用户的身份切换</h4><p>在 Linux 系统当中要作身份的变换？这是为啥？可能有底下几个原因！</p><blockquote><p><strong>使用一般账号：系统平日操作的好习惯</strong><br>事实上，为了安全的缘故，一些老人家都会建议你，尽量以一般身份使用者来操作 Linux 的日常作业！等到需要设定系统环境时，才变换身份成为 root 来进行系统管理，相对比较安全！避免作错一些严重的指令，例如恐怖的【 rm -rf / 】(千万作不得！)<br><strong>用较低权限启动系统服务</strong><br>相对于系统安全，有的时候，我们必须要以某些系统账号来进行程序的执行。举例来说，Linux 主机上面的一套软件，名称为 apache ，我们可以额外建立一个名为 apache 的用户来启动 apache 软件，如此一来，如果这个程序被攻破，至少系统还不至于就损毁了！<br><strong>软件本身的限制</strong><br>在远古时代的 telnet 程序中，该程序默认是不许使用 root 的身份登入的，telnet 会判断登入者的 UID，若 UID 为 0 的话，那就直接拒绝登入了。所以，你只能使用一般使用者来登入 Linux 服务器。此外，ssh 也可以设定拒绝 root 登入！那如果你有系统设定需求该如何是好？就变换身份！</p></blockquote><p>由于上述考虑，所以我们都是使用一般账号登入系统的，等有需要进行系统维护或软件更新时才转为 root 的身份来动作。那如何让一般使用者转变身份成为 root 呢？主要有两种方式：</p><ul><li>以【 su - 】直接将身份变成 root 即可，但是这个指令即需要 root 的密码，也就是说，如果你要以 su 变成 root 的话，你的一般使用者就必须要有 root 的密码才行；</li><li>以【 sudo 指令 】执行 root 的指令串，由于 sudo 需要事先设定妥当，且 sudo 需要输入用户自己的密码，因此多人共管同一部主机时，sudo 要比 su 来的好！至少 root 密码不会流出去！</li></ul><h5 id="1、su"><a href="#1、su" class="headerlink" title="1、su"></a>1、su</h5><p>su 是最简单的身份切换指令了，他可以进行任何身份的切换！方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# su [-lm] [-c 指令] [username]</span><br><span class="line">选项与参数：</span><br><span class="line">    - ：单纯使用 - 如【 su - 】代表使用 login-shell 的变量档案读取方式来登入系统；</span><br><span class="line">    若使用者名称没有加上去，则代表切换为 root 的身份。</span><br><span class="line">    -l ：与 - 类似，但后面需要加欲切换的使用者账号！也是 login-shell 的方式。</span><br><span class="line">    -m ：-m 与 -p 是一样的，表示【使用目前的环境设定，而不读取新使用者的配置文件】</span><br><span class="line">    -c ：仅进行一次指令，所以 -c 后面可以加上指令！</span><br></pre></td></tr></table></figure></p><h5 id="2、sudo"><a href="#2、sudo" class="headerlink" title="2、sudo"></a>2、sudo</h5><p>相对于 su 需要了解新切换的用户密码 (常常是需要 root 的密码)，sudo 的执行则仅需要自己的密码即可！甚至可以设定不需要密码即可执行 sudo ！由于 sudo 可以让你以其他用户的身份执行指令 (通常是使用 root 的身份来执行指令)，因此并非所有人都能够执行 sudo ，而是仅有规范到 /etc/sudoers 内的用户才能够执行 sudo 这个指令！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sudo [-b] [-u 新使用者账号]</span><br><span class="line">选项与参数：</span><br><span class="line">    -b ：将后续的指令放到背景中让系统自行执行，而不与目前的 shell 产生影响</span><br><span class="line">    -u ：后面可以接欲切换的使用者，若无此项则代表切换身份为 root 。</span><br></pre></td></tr></table></figure></p><p>范例一：你想要以 sshd 的身份在 /tmp 底下建立一个名为 mysshd 的档案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sudo -u sshd touch /tmp/mysshd</span><br><span class="line">[root@www ~]# ll /tmp/mysshd</span><br><span class="line">-rw-r--r-- 1 sshd sshd 0 Feb 28 17:42 /tmp/mysshd</span><br><span class="line"># 特别留意，这个档案的权限是由 sshd 所建立的情况！</span><br></pre></td></tr></table></figure></p><p>范例二：你想要以 ben1 的身份建立 ~ben/www 并于其中建立 index.html档案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sudo -u ben1 sh -c &quot;mkdir ~ben1/www; cd ben1/www; \</span><br><span class="line">&gt; echo &apos;This is index.html file&apos; &gt; index.html&quot;</span><br><span class="line">[root@www ~]# ll -a ~ben1/www</span><br><span class="line">drwxr-xr-x 2 ben1 ben1 4096 Feb 28 17:51 .</span><br><span class="line">drwx------ 5 ben1 ben1 4096 Feb 28 17:51 ..</span><br><span class="line">-rw-r--r-- 1 ben1 ben1 24 Feb 28 17:51 index.html</span><br><span class="line"># 要注意，建立者的身份是 ben1 ，且我们使用 sh -c &quot;一串指令&quot; 来执行的！</span><br></pre></td></tr></table></figure></p><p>sudo 可以让你切换身份来进行某项任务，例如上面的两个范例。</p><blockquote><p>sudo 的执行是这样的流程：<br>1.当用户执行 sudo 时，系统于 /etc/sudoers 档案中搜寻该使用者是否有执行 sudo 的权限；<br>2.若使用者具有可执行 sudo 的权限后，便让使用者【输入用户自己的密码】来确认；<br>3.若密码输入成功，便开始进行 sudo 后续接的指令(但 root 执行 sudo 时，不需要输入密码)；<br>4.若欲切换的身份与执行者身份相同，那也不需要输入密码。</p></blockquote><p>所以说，sudo 执行的重点是：【能否使用 sudo 必须要看 /etc/sudoers 的设定值，而可使用 sudo 者是透过输入用户自己的密码来执行后续的指令串】！由于能否使用与 /etc/sudoers 有关，所以我们当然要去编辑 sudoers 档案！不过，因为该档案的内容是有一定的规范的，因此直接使用 vi 去编辑是不好的。此时，我们得要透过 visudo 去修改这个档案！<br>（需要修改 /etc/sudoers 文件再查找……）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux是个多用户多任务的分时操作系统，所有一个要使用系统资源的用户都必须先向系统管理员申请一个账号，然后以这个账号的身份进入系统。用户的账号一方面能帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也能帮助用户组织文件，并为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和用户口令。用户在登录时键入正确的用户名和口令后，才能进入系统和自己的主目录。&lt;/p&gt;
&lt;p&gt;实现用户账号的管理，要完成的工作主要有如下几个方面：&lt;br&gt;a.用户账号的管理。&lt;br&gt;b.用户口令的管理。&lt;br&gt;c.用户组的管理。&lt;br&gt;d.用户切换&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 档案权限与目录配置</title>
    <link href="http://yoursite.com/2018/01/22/Linux-%E6%A1%A3%E6%A1%88%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/01/22/Linux-档案权限与目录配置/</id>
    <published>2018-01-22T08:01:07.000Z</published>
    <updated>2018-01-22T08:13:45.923Z</updated>
    
    <content type="html"><![CDATA[<p>Linux最优秀的地方之一，就在于他的多人多任务环境。而为了让各个使用者具有较保密的档案数据，因此档案的权限管理就变的很重要了。Linux一般将档案可存取的身份分为三个类别，分别是owner/group/others，且三种身份各有read/write/execute等权限<br><a id="more"></a></p><h4 id="1、身份类别"><a href="#1、身份类别" class="headerlink" title="1、身份类别"></a>1、身份类别</h4><ul><li>档案拥有者User</li><li>群组概念Group</li><li>其他人Others</li><li>root</li></ul><p>对应记录数据的档案：</p><ul><li>各种身份的相关信息：/etc/passwd</li><li>个人的密码：/etc/shadow</li><li>组名:/etc/group</li></ul><h4 id="2、权限的意义"><a href="#2、权限的意义" class="headerlink" title="2、权限的意义"></a>2、权限的意义</h4><h5 id="（1）对档案"><a href="#（1）对档案" class="headerlink" title="（1）对档案"></a>（1）对档案</h5><blockquote><p>r：可读取此档案的实际内容<br>w：可编辑，新增或者修改此档案的内容（但不含删除该档案）<br>x：该档案具有可以被系统执行的权限（Windows底下一个档案是否具有执行的能力是藉由【扩展名】来判断的，例如：.exe, .bat, .com等等，但是在Linux底下，我们的档案是否能被执行，则是藉由是否具有【x】这个权限来决定的）</p></blockquote><h5 id="（2）对目录"><a href="#（2）对目录" class="headerlink" title="（2）对目录"></a>（2）对目录</h5><blockquote><p>r：可读取目录结构列表，可查询该目录下的文件名数据，ls命令可显示它们<br>w：可新建目录与档案，可删除已存在的目录与档案，可更改他们的名字，可移动它们的位置<br>x：用户能进入该目录成为工作目录，cd命令可进入它，如果没有x权限，不能执行它下面的任何指令<br>（注：对目录的 w 权限要谨慎给予！）</p></blockquote><p>案例：账户为dmtai的家目录为/home/dmtai，账户dmtai对这个目录有rwx的权限。此目录下有一个档案叫the_root.data，它的权限为：<br><code>-rwx------ 1 root root 4356 Sep 19 20:20 the_root.data</code><br>分析：档案对于账户dmtai来说属于others身份，所以这个档案，dmtai无法读取，无法编辑也无法执行。但是dmtai对目录dmtai具有rwx的权限，也就是说dmtai账户可以删除这个档案！！</p><h4 id="3、Linux文件属性"><a href="#3、Linux文件属性" class="headerlink" title="3、Linux文件属性"></a>3、Linux文件属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br><span class="line">-rw-r--r--    1           root   root     42304        Sep 4 18:26     install.log</span><br><span class="line">[档案类型][档案类型权限][连接数][User][Group][档案容量bytes][档案最后修改时间][档案名]</span><br></pre></td></tr></table></figure><p>各栏详解如下：</p><blockquote><p>（1）第一栏表示档案类型权限：总共10个字符，<br>第一个字符代表这个档案类型：<br>　　① 正规档案[-]：纯文本档（ASCII），二进制文件（binary），数据格式文件（data）<br>　　② 目录[d]<br>　　③ 连结档[l]<br>　　④ 设备与装置文件<br>　　　　1）区块设备档[b]：可随机存取装置（比如硬盘，软盘）<br>　　　　2）字符设备文件[c]：一次性读取装置（比如键盘，鼠标）<br>　　⑤ 资料接口文件（sockets）[s]：称为数据接口文件<br>　　⑥ 数据输送文件（FIFO,pipe）[p]：特殊的文件类型<br>接下来9个字符3个一组，三组权限分别对应为：User，Group，Others<br>（2）第二栏表示有多少档名连结到此节点(i-node)：<br>每个档案都会将他的权限与属性记录到文件系统的 i-node 中，不过，我们使用的目录树却是使用文件名来记录，因此每个档名就会连结到一个 i-node ！这个属性记录的，就是有多少不同的档名连结到相同的一个 i-node 号码就是了。<br>（3）第三栏表示这个档案(或目录)的【拥有者账号】<br>（4）第四栏表示这个档案的所属群组<br>（5）第五栏为这个档案的容量大小，默认单位为bytes；<br>（6）第六栏为这个档案的建档日期或者是最近的修改日期：<br>（7）第七栏为这个档案的档名</p></blockquote><h4 id="4、如何改变文件属性与权限"><a href="#4、如何改变文件属性与权限" class="headerlink" title="4、如何改变文件属性与权限"></a>4、如何改变文件属性与权限</h4><h5 id="（1）chgrp：改变档案所属群组"><a href="#（1）chgrp：改变档案所属群组" class="headerlink" title="（1）chgrp：改变档案所属群组"></a>（1）chgrp：改变档案所属群组</h5><p>基本语法：chgrp [-R] groupname filename<br>选项与参数：<br>    -R：进行递归的持续变更，即目录下的所有档案，目录都更新为属于这个新群组<br>示例：<br>chgrp users install.log #users这个群组必须存在于/etc/group记录的群组里</p><h5 id="（2）chown：改变档案拥有者"><a href="#（2）chown：改变档案拥有者" class="headerlink" title="（2）chown：改变档案拥有者"></a>（2）chown：改变档案拥有者</h5><p>基本语法：chown [-R] ownername[:groupname] filename<br>选项与参数：<br>    -R：进行递归的持续变更，即目录下的所有档案，目录都更新为属于这个新拥有者<br>示例：<br>chown bin install.log #bin这个拥有者必须存在于/etc/passwd记录的拥有者里</p><p>#应用：cp 源档案 目标档案后，新的使用者可能无法使用copy后的档案，这时就需要赋予新档案一个新的拥有者和新的群组了。</p><h5 id="（3）chmod：改变档案的权限，SUID，SGID，SBIT等特性"><a href="#（3）chmod：改变档案的权限，SUID，SGID，SBIT等特性" class="headerlink" title="（3）chmod：改变档案的权限，SUID，SGID，SBIT等特性"></a>（3）chmod：改变档案的权限，SUID，SGID，SBIT等特性</h5><blockquote><p><strong>数字类型改变档案权限</strong><br>各权限的分数如下：r:4 w:2 x:1<br>每种身份各自的权限都是以上3个相加得到。如7=4+2+1,5=4+0+1（不可能是5=2+2+1哦，因为第一个肯定是r，数值要不是4要不是0，不能是2）<br>基本语法：chmod [-R] xyz 档案或目录<br>选项与参数：<br>　　xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。<br>　　-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有档案都会变更<br>示例：<br>chmod 770 .bashrc</p><p><strong>符号类型改变档案权限</strong><br><img src="/uploads/2018/01/linux_permission.JPG" alt=""><br>基本语法：chmod ugoa +-= rwx 档案或目录  #a代表all即全部的身份<br>示例：<br>chmod u=rwx,go=rx .bashrc   #u=rwx,go=rx是连在一起的，中间没有任何空格符</p></blockquote><h4 id="5、Linux-目录配置"><a href="#5、Linux-目录配置" class="headerlink" title="5、Linux 目录配置"></a>5、Linux 目录配置</h4><h5 id="（1）目录配置依据：FHS（Filesystem-Hierarchy-Standard）"><a href="#（1）目录配置依据：FHS（Filesystem-Hierarchy-Standard）" class="headerlink" title="（1）目录配置依据：FHS（Filesystem Hierarchy Standard）"></a>（1）目录配置依据：FHS（Filesystem Hierarchy Standard）</h5><p>亊实上，FHS 是根据过去的经验一直再持续的改版的，FHS 依据文件系统使用的频繁与否与是否允许使用者随意更动，而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样：<br><img src="/uploads/2018/01/linux_directory_fhs.JPG" alt=""></p><p>上表中的目录就是一些代表性的目录，该目录底下所放置的数据在底下会谈到，这里先略过不谈。我们要了解的是，什么是那四个类型？</p><ul><li>可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录；</li><li>不可分享的：自己机器上面运作的装置档案或者是与程序有关的 socket 档案等，由于仅与自身机器有关，所以当然就不适合分享给其他主机了。</li><li>不变的：有些数据是不会经常变动的，跟随着 distribution 而不变动。例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；</li><li>可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。</li></ul><p>亊实上，FHS 针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：</p><ul><li>/ (root, 根目录)：与开机系统有关；</li><li>/usr (unix software resource)：与软件安装/执行有关；</li><li>/var (variable)：与系统运作过程有关。</li></ul><h5 id="（2）根目录-的意义与内容："><a href="#（2）根目录-的意义与内容：" class="headerlink" title="（2）根目录 (/) 的意义与内容："></a>（2）根目录 (/) 的意义与内容：</h5><p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。由于系统开机时需要特定的开机软件、核心档案、开机所需程序、函式库等等档案数据，若系统出现错误时，根目录也必项要包含有能够修复文件系统的程序才行。因为根目录是这么的重要，所以在 FHS 的要求方面，他希服根目录不要放在非常大的分割槽内，因为越大的分割槽你会放入越多的数据，如此一来根目录所在分割槽就可能会有较多发生错误的机会。</p><p>因此 FHS 标准建议：根目录(/)所在分割槽应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分割槽内，保持根目录越小越好。如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。</p><p>有鉴于上述的说明，因此 FHS 定义出根目录(/)底下应该要有底下这些次目录的存在才好：<br><img src="/uploads/2018/01/linux_directory_root.JPG" alt=""></p><p>另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载，其他分割槽则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录，就不能够与根目录放到不同的分割槽去！那哪些目录不可与根目录分开呢？有底下这些：</p><ul><li>/etc：配置文件</li><li>/bin：重要执行档</li><li>/dev：所需要的装置档案</li><li>/lib：执行档所需的函式库不核心所需的模块</li><li>/sbin：重要的系统执行文件</li></ul><h5 id="（3）-usr-的意义与内容："><a href="#（3）-usr-的意义与内容：" class="headerlink" title="（3）/usr 的意义与内容："></a>（3）/usr 的意义与内容：</h5><p>依据FHS 的基本定义，/usr 里面放置的数据属于可分享的与不可变动的(shareable, static)，如果你知道如何透过网络进行分割槽的挂载，那么 /usr 确实可以分享给局域网络内的其他主机来使用！</p><p>很多读者都会误会 /usr 为 user 的缩写，其实 usr 是 Unix Software Resource 的缩写，也就是【Unix 操作系统软件资源】所放置的目录，而不是用户的数据！这点要注意。FHS 建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。</p><p>因为是所有系统默认的软件(distribution 发布者提供的软件)都会放置到 /usr 底下，因此这个目录有点类似 Windows 系统的【C:\Windows\ + C:\Program files\】这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说，/usr 的次目录建议有底下这些：<br><img src="/uploads/2018/01/linux_directory_usr.jpg" alt=""></p><p>（4）/var 的意义与内容：<br>如果 /usr 是安装时会占用较大硬盘容量的目录，那么 /var 就是在系统运作后才会渐渐占用硬盘容量的目录。因为 /var 目录主要针对常态性变动的档案，包括快取(cache)、登录档(log file)以及某些软件运作所产生的档案，包括程序档案(lock file, run file)，或者例如 MySQL 数据库的档案等等。常见的次目录有：<br><img src="/uploads/2018/01/linux_directory_var.JPG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux最优秀的地方之一，就在于他的多人多任务环境。而为了让各个使用者具有较保密的档案数据，因此档案的权限管理就变的很重要了。Linux一般将档案可存取的身份分为三个类别，分别是owner/group/others，且三种身份各有read/write/execute等权限&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>一些常用服务器概述</title>
    <link href="http://yoursite.com/2018/01/22/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2018/01/22/一些常用服务器概述/</id>
    <published>2018-01-22T05:28:35.000Z</published>
    <updated>2018-01-22T05:52:47.329Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NAT服务器"><a href="#NAT服务器" class="headerlink" title="NAT服务器"></a>NAT服务器</h4><p>NAT服务器可以说为是一个路由器的延伸服务器，简单地说，你可以称他为内部LAN主机的【IP分享器】。<br>NAT 的全名是 Network Address Translation，字面上的意思是【网络地址的转换】。下面来看一下，若内部 LAN 有任何一部主机想要传送封包出去时，那么这个封包要如何透过 Linux 主机而传送出去？他是这样的：</p><blockquote><p>1.先经过 NAT table 的 PREROUTING 链；<br>2.经由路由判断确定这个封包是要进入本机与否，若不进入本机，则下一步；<br>3.再经过 Filter table 的 FORWARD 链；<br>4.通过 NAT table 的 POSTROUTING 链，最后传送出去。</p></blockquote><a id="more"></a><p>NAT 服务器的重点就在于上面流程的第 1,4 步骤，也就是 NAT table 的两条重要的链：PREROUTING 与 POSTROUTING。那这两条链有什么重要的功能呢？重点在于修改 IP！但是这两条链修改的 IP 是不一样的！POSTROUTING 在修改来源 IP，PREROUTING 则在修改目标 IP。由于修改的 IP 不一样，所以就称为来源 NAT(Source NAT, SNAT) 及目标 NAT(Destination NAT, DNAT)。</p><h4 id="DHCP服务器"><a href="#DHCP服务器" class="headerlink" title="DHCP服务器"></a>DHCP服务器</h4><p>动态主机设定协议( Dynamic Host Configuration Protocol ，DHCP )，这个服务可以自动的分配 IP 与相关的网络参数给客户端，来提供客户端自动以服务器提供的参数来设定他们的网络。使用者只要将自己的笔电设定好经由 DHCP 协议来取得网络参数后，一插上网络线，马上就可以享受 Internet 的服务</p><p>要设定好一个网络的环境，使计算机可以顺利的连上 Internet ，那么你的计算机里面一定要有底下几个网络的参数才行，分别是：</p><blockquote><p>IP, netmask, network, broadcast, gateway, DNS IP</p></blockquote><p>其中，那个 IP, netmask, network, broadcast 与 gateway 都可以在 /etc/sysconfig/network-scripts/ifcfg-eth[0-n] 这档案里面设定，DNS 服务器的地址则是在 /etc/resolv.conf 里头设定。只要这几个项目设定正确，那么计算机应该就没问题的可以上网了！所以说，你家里面的 3, 4 部计算机，你都可以手动的来设定好你所需要的网络参数，然后利用 NAT 服务器的功能，就可以连上 Internet 了！</p><p>如果是管理的学生计算机大概有 100 部好了，那么你怎么设定好这 100 部的计算机呢？<br>这个就是 DHCP 服务器最主要的工作，就是自动的将网络参数正确的分配给网域中的每部计算机，让客户端的计算机可以在开机的时候就立即自动的设定好网络的参数值，这些参数值可以包括了 IP、netmask、network、gateway 与 DNS 的地址等等。如此一来，身为管理员的你，只要注意到这一部提供网络参数的主机有没有挂掉就好了，其他同学们的个人计算机！你想都不必想要怎么去帮忙！因为 DHCP 主机已经完全都帮你搞定了！</p><h4 id="SSH服务器"><a href="#SSH服务器" class="headerlink" title="SSH服务器"></a>SSH服务器</h4><p>什么是 SSH 呢？它有什么特异功能？简单的来说，SSH 是 Secure SHell protocol 的简写 (安全的壳程序协议)，它可以透过数据封包加密技术，将等待传输的封包加密后再传输到网络上，因此，数据讯息就比较安全！这个 SSH 可以用来取代较不安全的 finger, R Shell (rcp, rlogin, rsh等), talk 及 telnet 等联机模式。<br>特别注意：这个 SSH 协议，在预设的状态中，本身就提供两个服务器功能：</p><ol><li>一个就是类似 telnet 的远程联机使用 shell 的服务器，亦即是俗称的 ssh ；</li><li>另一个就是类似 FTP 服务的 sftp-server ！提供更安全的 FTP 服务。</li></ol><h4 id="FTP服务器"><a href="#FTP服务器" class="headerlink" title="FTP服务器"></a>FTP服务器</h4><p>FTP (File Transfer Protocol) 可说是最古老的协议之一了，主要是用来进行档案的传输，尤其是大型档案的传输使用 FTP 更是方便！不过，值得注意的是，使用 FTP 来传输时，其实是具有一定程度的【危险性】，因为数据在因特网上面是完全没有受到保护的【明码】传输方式！但是单纯的 FTP 服务还是有其必要性的，例如很多学校就有 FTP 服务器的架设需求等！想要使用更安全的 FTP 协议，就可选择 vsftpd（Very Secure FTP Daemon） 这个软件。</p><h4 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h4><p>目前的因特网世界使用的是所谓的 TCP/IP 协议，其中 IP 有第四版的 IPv4(32位) 及第六版的 IPv6(128位)。不过，这个 IPv4 为了人脑已经转成四组十进制的数字了，例如12.34.56.78 这样的格式。当我们利用 Internet 传送数据的时候，就需要这个 IP ，<br>否则数据封包就不知道要送到哪里。<br>那么四组十进制的数字仍然不容易记忆，因此就诞生了域名服务系统（Domain Name System,DNS），DNS 的作用就是将数字IP转换为人们容易记忆的域名。</p><h4 id="WWW服务器"><a href="#WWW服务器" class="headerlink" title="WWW服务器"></a>WWW服务器</h4><p>我们最常讲的【架站】其实就是架设一个 Web 网站！那么什么是 Web 呢？那就是全球信息广播的意思 (World Wide Web)，或者也可以称之为互连网吧！这个是我们目前的人类最常使用的 Internet 的协议之一！通常说的上网就是使用 WWW 来查询用户所需要的信息！目前在 Unix-Like 系统中的 WWW 服务器主要就是透过 Apache 这个服务器软件来达成的，而为了动态网站，于是 LAMP (Linux + Apache + MySQL + PHP) 就这么产生了。</p><h4 id="Proxy服务器"><a href="#Proxy服务器" class="headerlink" title="Proxy服务器"></a>Proxy服务器</h4><p>代理服务器 (Proxy Server) 的原理其实很简单！就是以类似代理人的身份去取得用户所需要的数据就是了！但是由于它的【代理】能力，使得我们可以透过代理服务器来达成防火墙功能与用户浏览数据的分析！此外，也可以藉由代理服务器来达成节省带宽的目的（代理服务器缓存常用数据），以及加快内部网络对因特网的 WWW 访问速度！总之，代理服务器对于企业来说，是一个非常不错的工具！<br>（注：代理服务器还能够再次代理服务器，即上层代理。上层代理服务器最大的功能就是分流，内部代理服务器( Local proxy )可代理多个外部上层代理服务器达到分流的目的，实现更快的速度访问 Internat 服务！）</p><p>同时，代理服务器可分为正向代理与反向代理。区分很简单，正向代理就是代理服务器位于客户端，用户主机都通过代理服务器访问 Internat 服务，可以实现内部主机的 IP 隐藏的功能，同时，也可起到 Local 端防火墙的目的。反向代理就是代理服务器位于服务端，所有的外部访问都通过代理服务器来向内部服务请求数据，可以实现过滤用户请求，缓存常用数据增加访问速度及降低带宽，隔绝用户直接访问服务器的请求，达到保护服务器的作用，实现服务端的防火墙功能。</p><h4 id="Postfix服务器"><a href="#Postfix服务器" class="headerlink" title="Postfix服务器"></a>Postfix服务器</h4><p>邮件服务器（Postfix Server）即发送与接受邮件的服务器。那么电子邮件是个啥玩意儿？它是利用网络传递一些信息给远程服务器的一种信息传递行为，虽然消息正文是很冷很硬的计算机文字，确实比不上手写信件来的让人觉得温暖，不过，对于具有时效性的信息来说，电子邮件可是起到很重要的作用啊！不管你在任何有网络的地方，连上 Internat 就可收取的你的信件。而相对的，也会有很多问题出现，例如夹带病毒的电子邮件问题、怪客透过邮件程序入侵、广告及垃圾信息和不实的信件内容等。因此，就出现了免费与付费一说，一般免费的即可满足个人使用，付费的可避免一些问题，免遭损失！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;NAT服务器&quot;&gt;&lt;a href=&quot;#NAT服务器&quot; class=&quot;headerlink&quot; title=&quot;NAT服务器&quot;&gt;&lt;/a&gt;NAT服务器&lt;/h4&gt;&lt;p&gt;NAT服务器可以说为是一个路由器的延伸服务器，简单地说，你可以称他为内部LAN主机的【IP分享器】。&lt;br&gt;NAT 的全名是 Network Address Translation，字面上的意思是【网络地址的转换】。下面来看一下，若内部 LAN 有任何一部主机想要传送封包出去时，那么这个封包要如何透过 Linux 主机而传送出去？他是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.先经过 NAT table 的 PREROUTING 链；&lt;br&gt;2.经由路由判断确定这个封包是要进入本机与否，若不进入本机，则下一步；&lt;br&gt;3.再经过 Filter table 的 FORWARD 链；&lt;br&gt;4.通过 NAT table 的 POSTROUTING 链，最后传送出去。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>网络安全之常见攻击方式及解决方案</title>
    <link href="http://yoursite.com/2018/01/18/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2018/01/18/网络安全之常见攻击方式及解决方案/</id>
    <published>2018-01-18T05:50:23.000Z</published>
    <updated>2018-01-18T06:59:09.807Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、网络封包联机进入主机的流程"><a href="#1、网络封包联机进入主机的流程" class="headerlink" title="1、网络封包联机进入主机的流程"></a>1、网络封包联机进入主机的流程</h4><p>当来自一个网络上的联机要求想进入我们的主机时，这个网络封包在进入主机实际取得数据的整个流程是如何？了解了整个流程之后，你才会发现：了解要如何保护你的主机安全！</p><p>我们要将该流程更细致化说明，因为，透过这个流程分析，你会知道为啥我们的主机需要进行过一些防护之后，系统才能够比较强壮。此外，了解了网络是双向的，那么就能知道服务器与客户端都得要有 IP:port 才能够让彼此的软件互相沟通。现在，假设你的主机是 WWW 服务器，透过底下的图标，网络封包如何进入你的主机呢？<br><a id="more"></a><br><img src="/uploads/2018/01/network_packet_translate.JPG" alt="" title="网络封包进入主机的流程"></p><h5 id="1-经过防火墙的分析："><a href="#1-经过防火墙的分析：" class="headerlink" title="1. 经过防火墙的分析："></a>1. 经过防火墙的分析：</h5><p>Linux 系统有内建的防火墙机制，因此你的联机能不能成功，得要先看防火墙的脸色才行。预设的 Linux 防火墙就有两个机制，这两个机制都是独立存在的，因此我们预设就有两层防火墙。第一层是封包过滤式的 netfilter 防火墙，另一个则是透过软件管控的 TCP Wrappers 防火墙。</p><ul><li><strong>封包过滤防火墙：IP Filtering 或 Net Filter</strong><br>   要进入 Linux 本机的封包都会先通过 Linux 核心的预设防火墙，就是称为 netfilter 的咚咚，简单的说，就是 iptables 这个软件所提供的防火墙功能。为何称为封包过滤呢？因为他主要是分析 TCP/IP 的封包表头来进行过滤的机制，主要分析的是 OSI 的第二、三、四层，主要控制的就是 MAC, IP, ICMP, TCP 与 UDP 的端口与状态 (SYN, ACK…) 等。</li><li><strong>第二层防火墙：TCP Wrappers</strong><br>   通过 netfilter 之后，网络封包会开始接受 Super daemons 及 TCP_Wrappers 的检验，那个是什么呢？说穿了就是 /etc/hosts.allow 与 /etc/hosts.deny 的配置文件功能。这个功能也是针对 TCP 的 Header 进行再次的分析，同样你可以设定一些机制来抵制某些 IP 或 Port ，好让来源端的封包被丢弃或通过检验；</li></ul><p>透过防火墙的管控，我们可以将大部分来自因特网的垃圾联机丢弃，只允许自己开放的服务的联机进入本机而已，可以达到最基础的安全防护。</p><h5 id="2-服务-daemon-的基本功能："><a href="#2-服务-daemon-的基本功能：" class="headerlink" title="2. 服务 (daemon) 的基本功能："></a>2. 服务 (daemon) 的基本功能：</h5><p>预设的防火墙是 Linux 的内建功能，但防火墙主要管理的是 MAC, IP, Port 等封包表头方面的信息，如果想要管控某些目录可以进入，某些目录则无法使用的功能，那就得要透过权限以及服务器软件提供的相关功能了。举例来说，你可以在 httpd.conf 这个配置文件之内规范某些 IP 来源不能使用 httpd 这个服务来取得主机的数据，那么即使该 IP 通过前面两层的过滤，他依旧无法取得主机的资源！但要注意的是，如果 httpd 这支程序本来就有问题的话，那么 client 端将可直接利用 httpd 软件的漏洞来入侵主机，而不需要取得主机内 root 的密码！因此，要小心这些启动在因特网上面的软件！</p><h5 id="3-SELinux-对网络服务的细部权限控制："><a href="#3-SELinux-对网络服务的细部权限控制：" class="headerlink" title="3. SELinux 对网络服务的细部权限控制："></a>3. SELinux 对网络服务的细部权限控制：</h5><p>为了避免前面一个步骤的权限误用，或者是程序有问题所造成的资安状况，因此 Security Enhanced Linux (安全强化 Linux) 就来发挥它的功能！简单的说，SELinux 可以针对网络服务的权限来设定一些规则 (policy) ，让程序能够进行的功能有限，因此即使使用者的档案权限设定错误，以及程序有问题时，该程序能够进行的动作还是被限制的，即使该程序使用的是 root 的权限也一样。举例来说，前一个步骤的 httpd 真的被 cracker 攻击而让对方取得 root 的使用权，由于 httpd 已经被 SELinux 控制在 /var/www/html 里面，且能够进行的功能已经被规范住了，因此 cracker 就无法使用该程序来进行系统的进一步破坏。</p><h5 id="4-使用主机的文件系统资源："><a href="#4-使用主机的文件系统资源：" class="headerlink" title="4. 使用主机的文件系统资源："></a>4. 使用主机的文件系统资源：</h5><p>想一想，你使用浏览器连接到 WWW 主机最主要的目的是什么？当然就是读取主机的 WWW 数据！那 WWW 资料是啥？就是档案啊！所以，最终网络封包其实是要向主机要求文件系统的数据。我们这里假设你要使用 httpd 这支程序来取得系统的档案数据，但 httpd 默认是由一个系统账号名称为 httpd 来启动的，所以：你的网页数据的权限当然就是要让 httpd 这支程序可以读取才行啊！如果你前面三关的设定都 OK ，最终权限设定错误，使用者依旧无法浏览你的网页数据的。</p><p>在这些步骤之外，我们的 Linux 以及相关的软件都可能还会支持登录文件记录的功能，为了记录历史历程，以方便管理者在未来的错误查询与入侵检测，良好的分析登录档的习惯是一定要建立的，尤其是 /var/log/messages 与 /var/log/secure 这些个档案！</p><h4 id="2、常见的攻击手法与相关保护"><a href="#2、常见的攻击手法与相关保护" class="headerlink" title="2、常见的攻击手法与相关保护"></a>2、常见的攻击手法与相关保护</h4><p>上面我们了解到数据传送到本机时所需要经过的几道防线，那个权限是最后的关键！那么 cracker 是如何透过上述的流程还能够攻击你的系统？底下就让我们来分析分析。</p><h5 id="1-取得帐户信息后猜密码"><a href="#1-取得帐户信息后猜密码" class="headerlink" title="1. 取得帐户信息后猜密码"></a>1. 取得帐户信息后猜密码</h5><p>由于很多人喜欢用自己的名字来作为帐户信息，因此账号的取得是很容易的！举例来说，如果你的朋友将你的 email address 不小心泄漏出去，例如：dmtsai@your.host.name 之类的样式，那么人家就会知道你有一部主机，名称为 your.host.name，且在这部主机上面会有一个使用者账号，账号名称为 dmtsai ，之后这个坏家伙再利用某些特殊软件例如 nmap 来进行你主机的 port scan 之后，他就可以开始透过你主机有启动的软件功能来猜你这个账号的密码了！</p><p>另外，如果你常常观察你的主机登录文件，那你也会发现如果你的主机有启动 Mail server 的服务时，你的登录档就会常常出现有些怪家伙尝试以一些奇怪的常见账号在试图猜测你的密码，举例来说像：admin, administrator, webmaster …. 之类的账号，尝试来窃取你的私人信件。如果你的主机真的有这类的账号，而且这类的账号还没有良好的密码规划，那就容易【中标】！所以我们常讲，系统账号千万不能给予密码，容易被猜密码啊！</p><p>这种猜密码的攻击方式算是最早期的入侵模式之一了，攻击者知道你的账号，或者是可以猜出来你的系统有哪些账号，欠缺的就只是密码而已，因此他会【很努力的】去猜你的密码，此时，你的密码规划如果不好的话，很容易就被攻击了！主机也很容易被绑架！所以，良好的密码设置习惯是很重要的。</p><p>不过这种攻击方式比较费时，因为目前很多软件都有密码输入次数的限制，如果连续输入三次密码还不能成功的登入，那该次联机就会被断线！所以，这种攻击方式日益减少，目前偶而还会看到就是！这也是初级 cracker 会使用的方式之一。那我们要如何保护呢？基本方式是这样的：</p><blockquote><p>（1）减少信息的曝光机会：例如不要将 Email Address 随意散布到 Internet 上头；<br>（2）建立较严格的密码设定规则：包括 /etc/shadow, /etc/login.defs 等档案的设定，如果主机够稳定且不会持续加入某些账号时，也可以考虑使用 chattr 来限制账号 (/etc/passwd, /etc/shadow) 的更改；<br>（3）完善的权限设定：由于这类的攻击方式会取得你的某个使用者账号的登入权限，所以如果你的系统权限设定得宜的话，那么攻击者也仅能取得一般使用者的权限而已，对于主机的伤害比较有限！所以说，权限设定是重要的；</p></blockquote><h5 id="2-利用系统的程序漏洞【主动】攻击"><a href="#2-利用系统的程序漏洞【主动】攻击" class="headerlink" title="2. 利用系统的程序漏洞【主动】攻击"></a>2. 利用系统的程序漏洞【主动】攻击</h5><p>由上图中的第二道防线，我们知道如果你的主机有开放网络服务时，就必须有启动某个网络软件！我们也知道由于软件可能撰写方式的问题，可能产生一些会被 cracker 乱用的臭虫程序代码，而这些臭虫程序代码由于产生问题的大小，有分为 bug (臭虫，可能会造成系统的不稳定或当机) 与 Security (安全问题，程序代码撰写方式会导致系统的权限被恶意者所掌握) 等问题。</p><p>当程序的问题被公布后，某些较高阶的 cracker 会尝试撰写一些针对这个漏洞的攻击程序代码，并且将这个程序代码放置到 cracker 常去的网站上面，藉以推销自己的【功力】….. 这种攻击模式是目前最常见的，因为攻击者只要拿到攻击程序就可以进行攻击了，【而且由攻击开始到取得你系统的 root 权限不需要猜密码，不需要两分钟，就能够立刻入侵成功】。但这个玩意儿本身是靠【你主机的程序漏洞】来攻击的，所以，如果你的主机随时保持在实时更新的阶段，或者是关闭大部分不需要的程序，那就可以躲避过这个问题。因此，你应该要这样做：</p><blockquote><p>（1）关闭不需要的网络服务：开的 port 越少，可以被入侵的管道越少，一部主机负责的服务越单纯，越容易找出问题点。<br>（2）随时保持更新：这个没话讲！一定要进行的！<br>（3）关闭不需要的软件功能：举例来说，后面会提到的远程登录服务器 SSH 可以提供 root 由远程登录，那么危险的事情当然要给他取消啊！</p></blockquote><h5 id="3-利用社交工程作欺骗"><a href="#3-利用社交工程作欺骗" class="headerlink" title="3. 利用社交工程作欺骗"></a>3. 利用社交工程作欺骗</h5><p>社交工程 (Social Engineering) 指的其实很简单，就是透过人与人的互动来达到【入侵】的目的！在大公司里面，或许你可能会接到这样的电话：【我是人事部门的经理，我的账号为何突然间不能登入了？你给我看一看，恩？干脆直接帮我另建一个账号，我告诉你我要的密码是….】。如果你一时不查给他账号密码的话，你的主机可能就这样被绑走了！</p><p>社交工程的欺骗方法多的是，包括使用【好心的 email 通知】、【警告信函】、【中奖单】等等，样样都是要欺骗你的账号密码，有的则利用钓鱼方式来欺骗你在某些恶意网站上面输入你的账号密码！举例来说，一般 email 会常常收到一些活动的信件，要我们用账号密码登录，这种的就要小心了！那要如何防范呢？</p><blockquote><p>（1）追踪对谈者：不要一味的相信对方，你必须要有信心的向上呈报，不要一时心慌就中了计！<br>（2）不要随意透露账号/密码等信息：最好不要随意在 Internet 上面填写这些数据，真的很危险！因为在 Internet 上面，你永远不知道对方屏幕前面坐着的是谁？</p></blockquote><h5 id="4-利用程序功能的【被动】攻击"><a href="#4-利用程序功能的【被动】攻击" class="headerlink" title="4. 利用程序功能的【被动】攻击"></a>4. 利用程序功能的【被动】攻击</h5><p>除了主动攻击之外，还有所谓的被动攻击！那就得要由【恶意网站】讲起了。如果你喜欢上网随意浏览的话，那么有的时候可能会连上一些广告很多，或者是一堆弹出式窗口的网站，这些网站有时还会很好心的【提供你很多好用的软件自动下载与安装】的功能，如果该网站是你所信任的，例如 Red Hat, CentOS, Windows 官网的话，那还好，如果是一个你也不清楚他是干嘛的网站，那你是否要同意下载安装该软件？</p><p>如果你常常在注意一些网络危机处理的相关新闻时，常会发现 Windows 的浏览器 (IE) 有问题，有时则是全部的浏览器 (Firefox, Netscap, IE…) 都会出现问题。那你会不会觉得奇怪啊，怎么【浏览器也会有问题？】这是因为很多浏览器会主动的答应对方 WWW 主机所提供的各项程序功能，或者是自动安装来自对方主机的软件，有时浏览器还可能由于程序发生安全问题，让对方 WWW 浏览器得以传送恶意代码给你的主机来执行！</p><p>那你又会想啊，那我干嘛浏览那样的恶意网站？总是会有些粗心大意的时候啊！如果你今天不小心收到一个 email ，里面告诉你你的银行账号有问题，希望你赶紧连上某个网页去看看你的账号是否在有问题的行列中，你会不会去？如果今天有个网络消息说某某网页在提供大特价商品，那你会不会去碰碰运气？都是可能的啊！不过，这也就很容易被对方攻击到了。</p><p>那如何防备啊？当然建立良好的习惯最重要了：</p><blockquote><p>（1）随时更新主机上的所有软件：如果你的浏览器是没有问题的，那对方传递恶意代码时，你的浏览器就不会执行，那自然安全的多了！<br>（2）较小化软件的功能：举例来说，让你的收信软件不要主动的下载文件，让你的浏览器在安装某些软件时，要通过你的确认后才安装，这样就比较容易克服一些小麻烦；<br>（3）不要连接到不明的主机：因为很多时候我们都用 google 在搜寻问题的解决之道，那你如何知道对方是否是骗人的？所以，前面两点防备还是很重要的！不要以为没有连接上恶意网站就不会有问题！</p></blockquote><h5 id="5-蠕虫或木马的-rootkit"><a href="#5-蠕虫或木马的-rootkit" class="headerlink" title="5. 蠕虫或木马的 rootkit"></a>5. 蠕虫或木马的 rootkit</h5><p>rootkit 意思是说可以取得 root 权限的一群工具组 (kit)，就如同前面主动攻击程序漏洞的方法一样，rootkit 主要也是透过主机的程序漏洞。不过，rootkit 也会透过社交工程让用户下载、安装 rootkit 软件，结果让 cracker 得以简单的绑架对方主机！</p><p>rootkit 除了可以透过上述的方法来进行入侵之外，rootkit 还会伪装或者是进行自我复制，举例来说，很多的 rootkit 本身就是蠕虫或者是木马间谍程序。蠕虫会让你的主机一直发送封包向外攻击，结果会让你的网络带宽被吃光光，例如 2001-2003年间的 Nimda, Code Red 等等；至于木马程序 (Trojan Horse) 则会对你的主机进行开启后门 (开一个 port 来让 cracker 主动的入侵)，结果就是….绑架、绑架、绑架！</p><p>rootkit 其实挺不好追踪的，因为很多时候他会主动的去修改系统观察的指令，包括 ls, top, netstat, ps, who, w, last, find 等等，让你看不到某些有问题的程序，如此一来，你的 Linux 主机就很容易被当成是跳板了！有够危险！那如何防备呢？</p><blockquote><p>（1）不要随意安装不明来源的档案或者是不明网站的档案数据；<br>（2）不要让系统有太多危险的指令：例如 SUID/SGID 的程序，这些程序很可能会造成用户不当的使用，而使得木马程序有机可趁！<br>（3）可以定时以 rkhunter 之类的软件来追查：有个网站提供 rootkit 程序的检查，你可以前往下载与分析你的主机：<a href="http://www.rootkit.nl/projects/rootkit_hunter.html" target="_blank" rel="noopener">http://www.rootkit.nl/projects/rootkit_hunter.html</a></p></blockquote><h5 id="6-DDoS-攻击法-Distributed-Denial-of-Service"><a href="#6-DDoS-攻击法-Distributed-Denial-of-Service" class="headerlink" title="6. DDoS 攻击法 (Distributed Denial of Service )"></a>6. DDoS 攻击法 (Distributed Denial of Service )</h5><p>这类型的攻击中文翻译成【分布式阻断服务攻击】，从字面上的意义来看，它就是透过分散在各地的僵尸计算机进行攻击，让你的系统所提供的服务被阻断而无法顺利的提供服务给其他用户的方式。这种攻击法也很要命，而且方法有很多，最常见的就属 SYN Flood 攻击法了！当主机接收了一个带有 SYN 的 TCP 封包之后，就会启用对方要求的 port 来等待联机，并且发送出回应封包(带有 SYN/ACK 旗目标 TCP 封包)，并等待 Client 端的再次回应。</p><p>好了，在这个步骤当中我们来想一想，如果 cient 端在发送出 SYN 的封包后，却将来自 Server 端的确认封包丢弃，那么你的 Server 端就会一直空等，而且 Client 端可以透过软件功能，在短短的时间内持续发送出这样的 SYN 封包，那么你的 Server 就会持续不断的发送确认封包，并且开启大量的 port 在空等！等到全部主机的 port 都启用完毕，那么…..系统就挂了！</p><p>更可怕的是，通常攻击主机的一方不会只有一部！他会透过 Internet 上面的僵尸网络 (已经成为跳板，但网站主却没有发现的主机) 发动全体攻击，让你的主机在短时间内就立刻挂点。这种 DDoS 的攻击手法比较类似【玉石俱焚】的手段，他不是入侵你的系统，而是要让你的系统无法正常提供服务！最常被用来作为阻断式服务的网络服务就是 WWW 了，因为 WWW 通常得对整个 Internet 开放服务。</p><p>这种攻击方法也是最难处理的，因为要嘛就得要系统核心有支持自动抵挡 DDoS 攻击的机制，要嘛你就得要自行撰写侦测软件来判断！而除非你的网站非常大，并且【得罪不少人】，否则应该不会被 DDoS 攻击！</p><h5 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h5><p>上面提到的都是比较常见的攻击方法，是还有一些高竿的攻击法，不过那些攻击法都需要有比较高的技术水准，例如 IP 欺骗。他可以欺骗你主机告知该封包来源是来自信任网域，而且透过封包传送的机制，由攻击的一方持续的主动发送出确认封包与工作指令。如此一来，你的主机可能就会误判该封包确实有响应，而且是来自内部的主机。</p><p>不过我们知道因特网是有路由的，而每部主机在每一个时段的 ACK 确认码都不相同，所以这个方式要达成可以登入，会比较麻烦，所以说，不太容易发生在我们这些小型主机上面！不过你还是得要注意一下说：</p><blockquote><p>（1）设定规则完善的防火墙：利用 Linux 内建的防火墙软件 iptables 建立较为完善的防火墙，可以防范部分的攻击行为；<br>（2）核心功能：这部份比较复杂，你必须要对系统核心有很深入的了解，才有办法设定好你的核心网络功能。<br>（3）登录文件与系统监控：你可以透过分析登录文件来了解系统的状况，另外也可以透过类似 MRTG 之类的监控软件来实时了解到系统是否有异常，这些工作都是很好的努力方向！</p></blockquote><h5 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h5><p>不要以为你的主机没有啥重要数据，被入侵或被植入木马也没有关系，因为我们的服务器通常会对内部来源的主机规范的较为宽松，如果你的主机在公司内部，但是不小心被入侵的话，那么贵公司的服务器是否就会暴露在危险的环境当中了？</p><p>所以啊，主机防护还是很重要的！不要小看了！提供几个方向给大家思考看看吧：</p><blockquote><p>1.建立完善的登入密码规则限制；<br>2.完善的主机权限设定；<br>3.设定自动升级与修补软件漏洞、及移除危险软件；<br>4.在每项系统服务的设定当中，强化安全设定的项目；<br>5.利用 iptables, TCP_Wrappers 强化网络防火墙；<br>6.利用主机监控软件如 MRTG 与 logwatch 来分析主机状况与登录文件；</p></blockquote><h4 id="3、关于Linux操作系统网络安全的有效应对措施"><a href="#3、关于Linux操作系统网络安全的有效应对措施" class="headerlink" title="3、关于Linux操作系统网络安全的有效应对措施"></a>3、关于Linux操作系统网络安全的有效应对措施</h4><h5 id="（1）安装防火墙、保证账号安全"><a href="#（1）安装防火墙、保证账号安全" class="headerlink" title="（1）安装防火墙、保证账号安全"></a>（1）安装防火墙、保证账号安全</h5><p>　　在互联网的安全防御中，每台计算机的系统都会自带安全防御工具及防火墙，其主要作用在于提供给用户审核、访问及防病毒等功能的同时，有效防止非授权用户进入系统，获取相关网络资源信息，并通过恰当地配置和调试，达到限制局域网非授权用户的访问，保护系统网络安全的目的，同时，对Linux操作系统用户账号的管理也要注意加密及口令安全的保护。 </p><h5 id="（2）关闭无需服务、重要文件需加密"><a href="#（2）关闭无需服务、重要文件需加密" class="headerlink" title="（2）关闭无需服务、重要文件需加密"></a>（2）关闭无需服务、重要文件需加密</h5><p>　　Linux操作系统本身会自带很多网络服务，其中有很多是没有必要的服务，用户应当及时进行关闭服务，以免因其造成严重的安全隐患，可以先找到 /etc/services 这个文件，对其所包含的网络服务数据库进行筛选，关闭不必要的网络服务，增强安全性。另外对系统中较为重要的文件也要进行加密，以保证一旦受到攻击可以不受到损害和窃取。 </p><h5 id="（3）阻止Ping命令请求以及Finger服务"><a href="#（3）阻止Ping命令请求以及Finger服务" class="headerlink" title="（3）阻止Ping命令请求以及Finger服务"></a>（3）阻止Ping命令请求以及Finger服务</h5><p>　　上文提到，TCP/IP 协议由于自身缺陷极易受到黑客的攻击，利用其漏洞从正常数据包通道传送数据，获得有利信息。如果将系统设置为Ping命令请求阻止，便会减少黑客攻击成功的几率，提高网络的安全性。而禁止Finger服务，删除 /usr/bin 中的Finger命令，则可以防止黑客借助此命令远程或本地侵入系统，得到用户的一切相关信息，进而保护了网络的安全。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、网络封包联机进入主机的流程&quot;&gt;&lt;a href=&quot;#1、网络封包联机进入主机的流程&quot; class=&quot;headerlink&quot; title=&quot;1、网络封包联机进入主机的流程&quot;&gt;&lt;/a&gt;1、网络封包联机进入主机的流程&lt;/h4&gt;&lt;p&gt;当来自一个网络上的联机要求想进入我们的主机时，这个网络封包在进入主机实际取得数据的整个流程是如何？了解了整个流程之后，你才会发现：了解要如何保护你的主机安全！&lt;/p&gt;
&lt;p&gt;我们要将该流程更细致化说明，因为，透过这个流程分析，你会知道为啥我们的主机需要进行过一些防护之后，系统才能够比较强壮。此外，了解了网络是双向的，那么就能知道服务器与客户端都得要有 IP:port 才能够让彼此的软件互相沟通。现在，假设你的主机是 WWW 服务器，透过底下的图标，网络封包如何进入你的主机呢？&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 防火墙的设定</title>
    <link href="http://yoursite.com/2018/01/17/Linux-%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E8%AE%BE%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/01/17/Linux-防火墙的设定/</id>
    <published>2018-01-17T10:45:23.000Z</published>
    <updated>2018-01-18T07:02:57.151Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Linux 的封包过滤软件：iptables</strong><br>《防火墙的认识》这篇文章说了那么多，主要就是说明防火墙是什么，能做什么，并且知道防火墙不是万能的。下面我说一下都使用什么来设定防火墙。<br>因为不同的核心使用的防火墙机制不同，且支持的软件指令与语法也不相同，所以在 Linux 上头设定属于你自己的防火墙规则时，要注意，先用 uname -r 追踪一下你的核心版本再说，目前大部分的核心都使用 kernel 2.6 版的核心，主要是使用 iptables 这个防火墙机制。<br><a id="more"></a></p><h4 id="1、封包进入流程：规则顺序的重要性！"><a href="#1、封包进入流程：规则顺序的重要性！" class="headerlink" title="1、封包进入流程：规则顺序的重要性！"></a>1、封包进入流程：规则顺序的重要性！</h4><p>因为 iptables 是利用封包过滤的机制，所以他会分析封包的表头数据。根据表头数据与定义的【规则】来决定该封包是否可以进入主机或者是被丢弃。意思就是说：【根据封包的分析资料”比对”你预先定义的规则内容，若封包数据与规则内容相同则进行动作，否则就继续下一条规则的比对！】重点在那个【比对与分析顺序】上。</p><p>举个简单的例子，假设我预先定义 10 条防火墙规则好了，那么当 Internet 来了一个封包想要进入我的主机，那么防火墙是如何分析这个封包的呢？我们以底下的图示来说明好了：<br><img src="/uploads/2018/01/network_iptables_rules.JPG" alt="" title="5-1 封包过滤的规则动作及分析流程"></p><p>当一个网络封包要进入到主机之前，会先经由 NetFilter 进行检查，那就是 iptables 的规则了。检查通过则接受 (ACCEPT) 进入本机取得资源，如果检查不通过，则可能予以丢弃 (DROP) ！上图中主要的目的在告知你：【规则是有顺序的】！例如当网络封包进入 Rule 1 的比对时，如果比对结果符合 Rule 1 ，此时这个网络封包就会进行 Action 1 的动作，而不会理会后续的 Rule 2, Rule 3…. 等规则的分析了。<br>而如果这个封包并不符合 Rule 1 的比对，那就会进入 Rule 2 的比对了！如此一个一个规则去进行比对就是了。那如果所有的规则都不符合怎办？此时就会透过预设动作 (封包政策, Policy) 来决定这个封包的去向。所以，当你的规则顺序排列错误时，就会产生很严重的错误了。（类比 rewrite 一致）</p><h4 id="2、iptables-的表格-table-与链-chain"><a href="#2、iptables-的表格-table-与链-chain" class="headerlink" title="2、iptables 的表格 (table) 与链 (chain)"></a>2、iptables 的表格 (table) 与链 (chain)</h4><p>事实上，上图 5-1 所列出的规则仅是 iptables 众多表格当中的一个链(chain) 而已。什么是链呢？这得由 iptables 的名称说起。为什么称为 ip”tables”呢？ 因为这个防火墙软件里面有多个表格 (table) ，每个表格都定义出自己的默认政策与规则，且每个表格的用途都不相同。我们可以使用底下这张图来稍微了解一下：<br><img src="/uploads/2018/01/network_iptables_chain.JPG" alt="" title="5-3 iptables 的表格与相关链示意图"></p><p>刚刚图 5-1 的规则内容仅只是图 5-3 内的某个 chain 而已！而预设的情况下，咱们 Linux 的 iptables 至少就有三个表格，包括管理本机进出的 filter 、管理后端主机 (防火墙内部的其他计算机) 的 nat 、管理特殊旗标使用的 mangle (较少使用) 。更有甚者，我们还可以自定义额外的链呢！真是很神奇吧！每个表格与其中链的用途分别是这样的：</p><ol><li><p>filter (过滤器)：主要跟进入 Linux 本机的封包有关，这个是预设的 table ！</p><ul><li>INPUT：主要与想要进入我们 Linux 本机的封包有关；</li><li>OUTPUT：主要与我们 Linux 本机所要送出的封包有关；</li><li>FORWARD：这个咚咚与 Linux 本机比较没有关系，他可以【转递封包】到后端的计算机中，与下列 nat table 相关性较高。</li></ul></li><li><p>nat (地址转换)：是 Network Address Translation 的缩写，这个表格主要在进行来源与目的之 IP 或 port 的转换，与 Linux 本机较无关，主要与 Linux 主机后的局域网络内计算机较有相关。</p><ul><li>PREROUTING：在进行路由判断之前所要进行的规则(DNAT/REDIRECT)</li><li>POSTROUTING：在进行路由判断之后所要进行的规则(SNAT/MASQUERADE)</li><li>OUTPUT：与发送出去的封包有关</li></ul></li><li><p>mangle (破坏者)：这个表格主要是与特殊的封包的路由旗标有关，早期仅有 PREROUTING 及 OUTPUT 链，不过从 kernel 2.4.18 之后加入了 INPUT 及FORWARD 链。由于这个表格与特殊旗标相关性较高，所以像咱们这种单纯的环境当中，较少使用 mangle 这个表格。</p></li></ol><p>所以说，如果你的 Linux 是作为 www 服务，那么要开放客户端对你的 www 要求有响应，就得要处理 filter 的 INPUT 链； 而如果你的 Linux 是作为局域网络的路由器，那么就得要分析 nat 的各个链以及 filter 的 FORWARD 链才行。</p><h4 id="3、本机的-iptables-语法"><a href="#3、本机的-iptables-语法" class="headerlink" title="3、本机的 iptables 语法"></a>3、本机的 iptables 语法</h4><p>防火墙的设定主要使用的就是 iptables 这个指令而已。而防火墙是系统管理员的主要任务之一，且对于系统的影响相当的大，因此【只能让 root 使用 iptables 】，不论是设定还是观察防火墙规则！</p><h5 id="（1）规则的观察与清除"><a href="#（1）规则的观察与清除" class="headerlink" title="（1）规则的观察与清除"></a>（1）规则的观察与清除</h5><p>如果你在安装的时候选择没有防火墙的话，那么 iptables 在一开始的时候应该是没有规则的，不过，可能因为你在安装的时候就有选择系统自动帮你建立防火墙机制，那系统就会有默认的防火墙规则了！无论如何，我们先来看看目前本机的防火墙规则是如何吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-t tables] [-L] [-nv]</span><br><span class="line">选项与参数：</span><br><span class="line">    -t ：后面接 table ，例如 nat 或 filter ，若省略此项目，则使用默认的filter</span><br><span class="line">    -L ：列出目前的 table 的规则</span><br><span class="line">    -n ：不进行 IP 与 HOSTNAME 的反查，显示讯息的速度会快很多！</span><br><span class="line">    -v ：列出更多的信息，包括通过该规则的封包总位数、相关的网络接口等</span><br><span class="line">范例：列出 filter table 三条链的规则</span><br><span class="line">[root@www ~]# iptables -L -n</span><br><span class="line">Chain INPUT (policy ACCEPT) &lt;==针对 INPUT 链，且预设政策为可接受</span><br><span class="line">target prot opt source destination &lt;==说明栏</span><br><span class="line">ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED</span><br><span class="line">&lt;==第 1 条规则</span><br><span class="line">ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0</span><br><span class="line">&lt;==第 2 条规则</span><br><span class="line">ACCEPT all -- 0.0.0.0/0 0.0.0.0/0</span><br><span class="line">&lt;==第 3 条规则</span><br><span class="line">ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22</span><br><span class="line">&lt;==以下类推</span><br><span class="line">REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited</span><br><span class="line">Chain FORWARD (policy ACCEPT) &lt;==针对 FORWARD 链，且预设政策为可接受</span><br><span class="line">target prot opt source destination</span><br><span class="line">REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited</span><br><span class="line">Chain OUTPUT (policy ACCEPT) &lt;==针对 OUTPUT 链，且预设政策为可接受</span><br><span class="line">target prot opt source destination</span><br></pre></td></tr></table></figure></p><blockquote><p>在上表中，每一个 Chain 就是前面提到的每个链。Chain 那一行里面括号的 policy 就是预设的政策，那底下的 target, prot 代表什么呢？<br><strong>target：</strong>代表进行的动作， ACCEPT 是放行，而 REJECT 则是拒绝，此外，尚有 DROP (丢弃) 的项目！<br><strong>prot：</strong>代表使用的封包协议，主要有 tcp, udp 及 icmp 三种封包格式；<br><strong>opt：</strong>额外的选项说明<br><strong>source ：</strong>代表此规则是针对哪个【来源 IP】进行限制？<br><strong>destination ：</strong>代表此规则是针对哪个【目标 IP】进行限制？</p></blockquote><p>在输出结果中，第一个范例因为没有加上 -t 的选项，所以默认就是 filter 这个表格内的 INPUT, OUTPUT, FORWARD 三条链的规则啰。若针对单机来说，INPUT 与 FORWARD 算是比较重要的管制防火墙链，所以你可以发现最后一条规则的政策是 REJECT (拒绝)！虽然 INPUT 与 FORWARD 的政策是放行 (ACCEPT)，不过在最后一条规则就已经将全部的封包都拒绝了！</p><p>不过这个指令的观察只是作个格式化的查阅，要详细解释每个规则会比较不容易解析。举例来说，我们将 INPUT 的 5 条规则依据输出结果来说明一下，结果会变成：</p><blockquote><ol><li>只要是封包状态为 RELATED,ESTABLISHED 就予以接受</li><li>只要封包协议是 icmp 类型的，就予以放行</li><li>无论任何来源 (0.0.0.0/0) 且要去任何目标的封包，不论任何封包格式(prot 为 all)，通通都接受</li><li>只要是传给 port 22 的主动式联机 tcp 封包就接受</li><li>全部的封包信息通通拒绝</li></ol></blockquote><p>最有趣的应该是第 3 条规则了，怎么会所有的封包信息都予以接受？如果都接受的话，那么后续的规则根本就不会有用嘛！其实那条规则是仅针对每部主机都有的内部循环测试网络 (lo) 接口！如果没有列出接口，那么我们就很容易搞错。所以，近来建议使用 iptables-save 这个指令来观察防火墙规则！因为 iptables-save 会列出完整的防火墙规则，只是并没有规格化输出而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables-save [-t table]</span><br><span class="line">选项与参数：</span><br><span class="line">-t ：可以仅针对某些表格来输出，例如仅针对 nat 或 filter 等等</span><br><span class="line">[root@www ~]# iptables-save</span><br><span class="line"># Generated by iptables-save v1.4.7 on Fri Jul 22 15:51:52 2011</span><br><span class="line">*filter &lt;==星号开头的指的是表格，这里为 filter</span><br><span class="line">:INPUT ACCEPT [0:0] &lt;==冒号开头的指的是链，三条内建的链</span><br><span class="line">:FORWARD ACCEPT [0:0] &lt;==三条内建链的政策都是 ACCEPT 啰！</span><br><span class="line">:OUTPUT ACCEPT [680:100461]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT &lt;==针对 INPUT的规则</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT &lt;==这条很重要！针对本机内部接口开放！</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited &lt;==针对FORWARD 的规则</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure></p><p>由上面的输出来看，有底线且内容含有 lo 的那条规则当中，【 -i lo 】指的就是由 lo 适配卡进来的封包！这样看就清楚多了！因为有写到接口的关系啊！不像之前的 <code>iptables -L -n</code>！既然这个规则不是我们想要的，那该如何修改规则呢？建议，先删除规则再慢慢建立各个需要的规则！那如何清除规则？这样做就对了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-t tables] [-FXZ]</span><br><span class="line">选项与参数：</span><br><span class="line">-F ：清除所有的已订定的规则；</span><br><span class="line">-X ：杀掉所有使用者 &quot;自定义&quot; 的 chain (应该说的是 tables ）；</span><br><span class="line">-Z ：将所有的 chain 的计数与流量统计都归零</span><br><span class="line">范例：清除本机防火墙 (filter) 的所有规则</span><br><span class="line">[root@www ~]# iptables -F</span><br><span class="line">[root@www ~]# iptables -X</span><br><span class="line">[root@www ~]# iptables -Z</span><br></pre></td></tr></table></figure></p><p>由于这三个指令会将本机防火墙的所有规则都清除，但却不会改变预设政策 (policy) ，所以如果你不是在本机下达这三行指令时，很可能你会被自己挡在家门外 (若 INPUT设定为 DROP 时)！要小心啊！</p><h5 id="2）定义预设政策-policy"><a href="#2）定义预设政策-policy" class="headerlink" title="(2）定义预设政策 (policy)"></a>(2）定义预设政策 (policy)</h5><p>清除规则之后，再接下来就是要设定规则的政策！还记得政策指的是什么吗？【 当你的封包不在你设定的规则之内时，则该封包的通过与否，是以 Policy 的设定为准】，在本机方面的预设政策中，假设你对于内部的使用者有信心的话，那么 filter 内的 INPUT 链方面可以定义的比较严格一点，而 FORWARD 与 OUTPUT 则可以订定的松一些！通常都是将 INPUT 的 policy 定义为 DROP ，其他两个则定义为 ACCEPT。至于 nat table 则暂时先不理会他。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-t nat] -P [INPUT,OUTPUT,FORWARD] [ACCEPT,DROP]</span><br><span class="line">选项与参数：</span><br><span class="line">-P ：定义政策( Policy )。注意，这个 P 为大写啊！</span><br><span class="line">ACCEPT ：该封包可接受</span><br><span class="line">DROP ：该封包直接丢弃，不会让 client 端知道为何被丢弃。</span><br><span class="line">范例：将本机的 INPUT 设定为 DROP ，其他设定为 ACCEPT</span><br><span class="line">[root@www ~]# iptables -P INPUT DROP</span><br><span class="line">[root@www ~]# iptables -P OUTPUT ACCEPT</span><br><span class="line">[root@www ~]# iptables -P FORWARD ACCEPT</span><br><span class="line">[root@www ~]# iptables-save</span><br><span class="line"># Generated by iptables-save v1.4.7 on Fri Jul 22 15:56:34 2011</span><br><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">COMMIT</span><br><span class="line"># Completed on Fri Jul 22 15:56:34 2011</span><br><span class="line"># 由于 INPUT 设定为 DROP 而又尚未有任何规则，所以上面的输出结果显示：</span><br><span class="line"># 所有的封包都无法进入你的主机！是不通的防火墙设定！(网络联机是双向的)</span><br></pre></td></tr></table></figure></p><p>看到输出的结果了吧？INPUT 被修改了设定！其他的 nat table 三条链的预设政策设定也是一样的方式，例如：<code>【 iptables -t nat -P PREROUTING ACCEPT 】</code>就设定了 nat table 的 PREROUTING 链为可接受的意思！预设政策设定完毕后，来谈一谈关于各规则的封包基础比对设定吧。</p><h5 id="（3）封包的基础比对：IP-网域及接口装置"><a href="#（3）封包的基础比对：IP-网域及接口装置" class="headerlink" title="（3）封包的基础比对：IP, 网域及接口装置"></a>（3）封包的基础比对：IP, 网域及接口装置</h5><p>开始来进行防火墙规则的封包比对设定吧！既然是因特网，那么我们就由最基础的 IP, 网域及端口，亦即是 OSI 的第三层谈起，再来谈谈装置 (网络卡) 的限制等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-AI 链名] [-io 网络接口] [-p 协议] \</span><br><span class="line">&gt; [-s 来源IP/网域] [-d 目标IP/网域] -j [ACCEPT|DROP|REJECT|LOG]</span><br><span class="line">选项与参数：</span><br><span class="line">-AI 链名：针对某的链进行规则的 &quot;插入&quot; 或 &quot;累加&quot;</span><br><span class="line">  -A ：新增加一条规则，该规则增加在原本规则的最后面。例如原本已经有四条规则，</span><br><span class="line">       使用 -A 就可以加上第五条规则！</span><br><span class="line">  -I ：插入一条规则。如果没有指定此规则的顺序，默认是插入变成第一条规则。例如原本有四条规则，</span><br><span class="line">       使用 -I 则该规则变成第一条，而原本四条变成 2~5 号</span><br><span class="line">  链 ：有 INPUT, OUTPUT, FORWARD 等，此链名称又与 -io 有关，请看底下。</span><br><span class="line">-io 网络接口：设定封包进出的接口规范</span><br><span class="line">  -i ：封包所进入的那个网络接口，例如 eth0, lo 等接口。需与 INPUT 链配合；</span><br><span class="line">  -o ：封包所传出的那个网络接口，需与 OUTPUT 链配合；</span><br><span class="line">-p 协定：设定此规则适用于哪种封包格式</span><br><span class="line">  主要的封包格式有： tcp, udp, icmp 及 all 。</span><br><span class="line">-s 来源 IP/网域：设定此规则之封包的来源项目，可指定单纯的 IP 或包括网域，例如：</span><br><span class="line">  IP ：192.168.0.100</span><br><span class="line">  网域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。</span><br><span class="line">  若规范为『不许』时，则加上 ! 即可，例如：</span><br><span class="line">  -s ! 192.168.100.0/24 表示不许 192.168.100.0/24 之封包来源；</span><br><span class="line">-d 目标 IP/网域：同 -s ，只不过这里指的是目标的 IP 或网域。</span><br><span class="line">-j ：后面接动作，主要的动作有接受(ACCEPT)、丢弃(DROP)、拒绝(REJECT)及记录(LOG)</span><br></pre></td></tr></table></figure></p><p>iptables 的基本参数就如同上面所示的，仅只谈到 IP 、网域与装置等等的信息。至于 TCP, UDP 封包特有的端口 (port number) 与状态 (如 SYN 旗标)，下面谈论。</p><p><strong>示例：</strong><br>先让我们来看看最基础的几个规则，例如开放 lo 这个本机的接口以及某个 IP 来源吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">范例：设定 lo 成为受信任的装置，亦即进出 lo 的封包都予以接受</span><br><span class="line">[root@www ~]# iptables -A INPUT -i lo -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>仔细看上面并没有列出 -s, -d 等等的规则，这表示：不论封包来自何处或去到哪里，只要是来自 lo 这个界面，就予以接受！这个观念挺重要的，就是【没有指定的项目，则表示该项目完全接受】的意思！例如这个案例当中，关于 -s, -d…等等的参数没有规定时，就代表不论什么值都会被接受。</p><h5 id="4）TCP-UDP-的规则比对：针对端口设定"><a href="#4）TCP-UDP-的规则比对：针对端口设定" class="headerlink" title="(4）TCP, UDP 的规则比对：针对端口设定"></a>(4）TCP, UDP 的规则比对：针对端口设定</h5><p>在谈到 TCP 与 UDP 时，比较特殊的就是那个端口 (port)，在 TCP 方面则另外有所谓的联机封包状态，包括最常见的 SYN 主动联机的封包格式。那么如何针对这两种封包格式进行防火墙规则的设定呢？你可以这样看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-AI 链] [-io 网络接口] [-p tcp,udp] \</span><br><span class="line">&gt; [-s 来源IP/网域] [--sport 埠口范围] \</span><br><span class="line">&gt; [-d 目标IP/网域] [--dport 埠口范围] -j [ACCEPT|DROP|REJECT]</span><br><span class="line">选项与参数：</span><br><span class="line">--sport 埠口范围：限制来源的端口口号码，端口口号码可以是连续的，例如1024:65535</span><br><span class="line">--dport 埠口范围：限制目标的端口口号码。</span><br></pre></td></tr></table></figure></p><p>事实上就是多了那个 –sport 及 –dport 这两个玩意儿，重点在那个 port 上面！不过你得要特别注意，因为仅有 tcp 与 udp 封包具有端口，因此你想要使用 –dport,–sport 时，得要加上 -p tcp 或 -p udp 的参数才会成功！底下让我们来进行几个小测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">范例：想要联机进入本机 port 21 的封包都抵挡掉：</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p tcp --dport 21 -j DROP</span><br><span class="line">范例：想连到我这部主机的网络 (upd port 137,138 tcp port 139,445) 就放行</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p udp --dport 137:138 -j ACCEPT</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p tcp --dport 139 -j ACCEPT</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p tcp --dport 445 -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>除了端口之外，在 TCP 还有特殊的旗标啊！最常见的就是那个主动联机的 SYN 旗标了。我们在 iptables 里面还支持【 –syn 】的处理方式，我们以底下的例子来说明好了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">范例：将来自任何地方来源 port 1:1023 的主动联机到本机端的 1:1023 联机丢弃</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p tcp --sport 1:1023 \</span><br><span class="line">&gt; --dport 1:1023 --syn -j DROP</span><br></pre></td></tr></table></figure></p><p>一般来说，client 端启用的 port 都是大于 1024 以上的端口，而 server 端则是启用小于 1023 以下的端口在监听的。所以我们可以让来自远程的小于 1023 以下的端口数据的主动联机都给他丢弃！但不适用在 FTP 的主动联机中！</p><h5 id="（5）iptables-外挂模块：mac-与-state"><a href="#（5）iptables-外挂模块：mac-与-state" class="headerlink" title="（5）iptables 外挂模块：mac 与 state"></a>（5）iptables 外挂模块：mac 与 state</h5><p>在 kernel 2.2 以前使用 ipchains 管理防火墙时，通常会让系统管理员相当头痛！因为 ipchains 没有所谓的封包状态模块，因此我们必须要针对封包的进、出方向进行管控。举例来说，如果你想要联机到远程主机的 port 22 时，你必须要针对两条规则来设定：</p><ul><li>本机端的 1024:65535 到远程的 port 22 必须要放行 (OUTPUT 链)；</li><li>远程主机 port 22 到本机的 1024:65535 必须放行 (INPUT 链)；</li></ul><p>这会很麻烦！因为如果你要联机到 10 部主机的 port 22 时，假设 OUTPUT 为预设开启 (ACCEPT)， 你依旧需要填写十行规则，让那十部远程主机的 port 22 可以联机到你的本地端主机上。那如果开启全部的 port 22 呢？又担心某些恶意主机会主动以 port 22 联机到你的机器上！同样的道理，如果你要让本地端主机可以连到外部的 port 80 (WWW 服务)，那就更不得了！这就是网络联机是双向的一个很重要的概念！</p><p>好在我们的 iptables 免除了这个困扰！他可以透过一个状态模块来分析 【这个想要进入的封包是否为刚刚我发出去的响应？】如果是刚刚我发出去的响应，那么就可以予以接受放行！这样就不用管远程主机是否联机进来的问题了！那如何达到呢？看看底下的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables -A INPUT [-m state] [--state 状态]</span><br><span class="line">选项与参数：</span><br><span class="line">-m ：一些 iptables 的外挂模块，主要常见的有：</span><br><span class="line">  state ：状态模块</span><br><span class="line">  mac ：网络卡硬件地址 (hardware address)</span><br><span class="line">--state ：一些封包的状态，主要有：</span><br><span class="line">  INVALID ：无效的封包，例如数据破损的封包状态</span><br><span class="line">  ESTABLISHED：已经联机成功的联机状态；</span><br><span class="line">  NEW ：想要新建立联机的封包状态；</span><br><span class="line">  RELATED ：这个最常用！表示这个封包是与我们主机发送出去的封包有关</span><br><span class="line">范例：只要已建立或相关封包就予以通过，只要是不合法封包就丢弃</span><br><span class="line">[root@www ~]# iptables -A INPUT -m state \</span><br><span class="line">&gt; --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">[root@www ~]# iptables -A INPUT -m state --state INVALID -j DROP</span><br></pre></td></tr></table></figure></p><p>如此一来，我们的 iptables 就会主动分析出该封包是否为响应状态，若是的话，就直接予以接受。这样一来你就不需要针对响应的封包来撰写个别的防火墙规则了！这真是太棒了！底下我们继续谈一下 iptables 的另一个外挂，那就是针对网卡来进行放行与防御：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">范例：针对局域网络内的 aa:bb:cc:dd:ee:ff 主机开放其联机</span><br><span class="line">[root@www ~]# iptables -A INPUT -m mac --mac-source aa:bb:cc:dd:ee:ff -j ACCEPT</span><br><span class="line">选项与参数：</span><br><span class="line">--mac-source ：就是来源主机的 MAC ！</span><br></pre></td></tr></table></figure></p><p>如果你的区网当中有某些网络高手，老是可以透过修改 IP 去尝试透过路由器往外跑，那你该怎么办？难道将整个区网拒绝？并不需要的，你可以透过之前谈到的 ARP 相关概念，去捉到那部主机的 MAC ，然后透过上头的这个机制，将该主机整个 DROP 掉即可。不管他改了什么 IP ，除非他知道你是用网卡的 MAC 来管理，否则他就是出不去！</p><h5 id="（6）超阳春客户端防火墙设计与防火墙规则储存"><a href="#（6）超阳春客户端防火墙设计与防火墙规则储存" class="headerlink" title="（6）超阳春客户端防火墙设计与防火墙规则储存"></a>（6）超阳春客户端防火墙设计与防火墙规则储存</h5><p>经过上述的本机 iptables 语法分析后，接下来我们来想想，如果站在客户端且不提供网络服务的 Linux 本机角色时， 你应该要如何设计你的防火墙呢？老实说，你只要分析过 CentOS 默认的防火墙规则就会知道了，理论上， 应该要有的规则如下：</p><ol><li>规则归零：清除所有已经存在的规则 (iptables -F…)</li><li>预设政策：除了 INPUT 这个自定义链设为 DROP 外，其他为预设 ACCEPT；</li><li>信任本机：由于 lo 对本机来说是相当重要的，因此 lo 必须设定为信任装置；</li><li>回应封包：让本机主动向外要求而响应的封包可以进入本机(ESTABLISHED,RELATED)</li><li>信任用户：这是非必要的，如果你想要让区网的来源可用你的主机资源时</li></ol><p>这就是最最阳春的防火墙，你可以透过第二步骤抵挡所有远程的来源封包，而透过第四步骤让你要求的远程主机响应封包可以进入， 加上让本机的 lo 这个内部循环装置可以放行，嘿嘿！一部 client 专用的防火墙规则就 OK 了！你可以在某个 script 上面这样做即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# vim bin/firewall.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin; export PATH</span><br><span class="line"># 1. 清除规则</span><br><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -Z</span><br><span class="line"># 2. 设定政策</span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"># 3~5. 制订各项规则</span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">#iptables -A INPUT -i eth0 -s 192.168.1.0/24 -j ACCEPT</span><br><span class="line"># 6. 写入防火墙规则配置文件</span><br><span class="line">/etc/init.d/iptables save</span><br><span class="line">[root@www ~]# sh bin/firewall.sh</span><br><span class="line">iptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]</span><br></pre></td></tr></table></figure></p><p>其实防火墙也是一个服务，你可以透过<code>【chkconfig --list iptables】</code>去察看就知道了。因此，你这次修改的各种设定想要在下次开机还保存，那就得要进行<code>【 /etc/init.d/iptables save 】</code>这个指令加参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Linux 的封包过滤软件：iptables&lt;/strong&gt;&lt;br&gt;《防火墙的认识》这篇文章说了那么多，主要就是说明防火墙是什么，能做什么，并且知道防火墙不是万能的。下面我说一下都使用什么来设定防火墙。&lt;br&gt;因为不同的核心使用的防火墙机制不同，且支持的软件指令与语法也不相同，所以在 Linux 上头设定属于你自己的防火墙规则时，要注意，先用 uname -r 追踪一下你的核心版本再说，目前大部分的核心都使用 kernel 2.6 版的核心，主要是使用 iptables 这个防火墙机制。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>Linux 防火墙的认识</title>
    <link href="http://yoursite.com/2018/01/17/Linux-%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2018/01/17/Linux-防火墙的认识/</id>
    <published>2018-01-17T10:45:06.000Z</published>
    <updated>2018-01-18T07:02:45.878Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、认识防火墙"><a href="#1、认识防火墙" class="headerlink" title="1、认识防火墙"></a>1、认识防火墙</h4><p>网络安全除了随时注意相关软件的漏洞以及网络上的安全通报之外，你最好能够依据自己的环境来订定防火墙机制！这样对于你的网络环境，会比较有保障一点！那么什么是防火墙呢？其实防火墙就是透过订定一些有顺序的规则，并管制进入到我们网域内的主机 (或者可以说是网域) 数据封包的一种机制！更广义的来说，只要能够分析与过滤进出我们管理之网域的封包数据，就可以称为防火墙。</p><p>防火墙又可以分为硬件防火墙与本机的软件防火墙。硬件防火墙是由厂商设计好的主机硬件，这部硬件防火墙内的操作系统主要以提供封包数据的过滤机制为主，并将其他不必要的功能拿掉。因为单纯作为防火墙功能而已，因此封包过滤的效率较佳。至于软件防火墙呢？那就是我们主要研究的方向！软件防火墙本身就是在保护系统网络安全的一套软件(或称为机制)，例如 Netfilter 与 TCP Wrappers 都可以称为软件防火墙。<br><a id="more"></a></p><h4 id="2、为何需要防火墙"><a href="#2、为何需要防火墙" class="headerlink" title="2、为何需要防火墙"></a>2、为何需要防火墙</h4><p>封包进入本机时，会通过防火墙、服务器软件程序、SELinux 与文件系统等。所以基本上，如果你的系统 </p><ul><li>(1)已经关闭不需要而且危险的服务； </li><li>(2)已经将整个系统的所有软件都保持在最新的状态； </li><li>(3)权限设定妥当且定时进行备份工作； </li><li>(4)已经教育用户具有良好的网络、系统操作习惯。 </li></ul><p>那么你的系统实际上已经颇为安全了！要不要架设防火墙？那就见仁见智了。</p><p>不过，毕竟网络世界是很复杂的，而 Linux 主机也不是一个简单的东西，说不定哪一天你在进行某个软件的测试时，主机突然间就启动了一个网络服务，如果你没有管制该服务的使用范围，那么该服务就等于对所有 Internet 开放，那就麻烦了！因为该服务可能可以允许任何人登入你的系统，那不是挺危险？</p><p>所以，防火墙能作什么呢？防火墙最大的功能就是帮助你【限制某些服务的存取来源】！举例来说： </p><ul><li>(1)你可以限制文件传输服务 (FTP) 只在子域内的主机才能够使用，而不对整个 Internet 开放； </li><li>(2)你可以限制整部 Linux 主机仅可以接受客户端的 WWW 要求，其他的服务都关闭； </li><li>(3)你还可以限制整部主机仅能主动对外联机。</li></ul><p>反过来说，若有客户端对我们主机发送主动联机的封包状态(TCP 封包的 SYN flag)就予以抵挡等等。这些就是最主要的防火墙功能了！</p><p>所以，防火墙最重要的任务就是在规划出：</p><ol><li>切割被信任(如子域)与不被信任(如 Internet)的网段；</li><li>划分出可提供 Internet 的服务与必须受保护的服务；</li><li>分析出可接受与不可接受的封包状态；</li></ol><p>当然，咱们 Linux 的 iptables 防火墙软件还可以进行更细部深入的 NAT(Network Address Translation) 的设定，并进行更弹性的 IP 封包伪装功能，不过，对于单一主机的防火墙来说，最简单的任务还是上面那三项就是了！所以，你需不需要防火墙呢？理论上，当然需要！而且你必须要知道【你的系统哪些数据与服务需要保护】，针对需要受保护的服务来设定防火墙的规则吧！底下我们先来谈一谈，那在Linux 上头常见的防火墙类型有哪些？</p><h4 id="3、Linux-系统上防火墙的主要类别"><a href="#3、Linux-系统上防火墙的主要类别" class="headerlink" title="3、Linux 系统上防火墙的主要类别"></a>3、Linux 系统上防火墙的主要类别</h4><p>基本上，依据防火墙管理的范围，我们可以将防火墙区分为网域型与单一主机型的控管。在单一主机型的控管方面，主要的防火墙有封包过滤型的 Netfilter 与依据服务软件程序作为分析的 TCP Wrappers 两种。若以区域型的防火墙而言，由于此类防火墙都是当作路由器角色，因此防火墙类型主要则有封包过滤的 Netfilter 与利用代理服务器 (proxy server) 进行存取代理的方式了。</p><h5 id="（1）Netfilter-封包过滤机制"><a href="#（1）Netfilter-封包过滤机制" class="headerlink" title="（1）Netfilter (封包过滤机制)"></a>（1）Netfilter (封包过滤机制)</h5><p>所谓的封包过滤，亦即是分析进入主机的网络封包，将封包的表头数据捉出来进行分析，以决定该联机为放行或抵挡的机制。由于这种方式可以直接分析封包表头数据，所以包括硬件地址(MAC), 软件地址 (IP), TCP, UDP, ICMP 等封包的信息都可以进行过滤分析的功能，因此用途非常的广泛。(其实主要分析的是OSI 七层协议的 2, 3, 4 层)</p><p>在 Linux 上面我们使用核心内建的 Netfilter 这个机制，而 Netfilter 提供了 iptables 这个软件来作为防火墙封包过滤的指令。由于 Netfilter 是核心内建的功能，因此他的效率非常的高！非常适合于一般小型环境的设定！Netfilter 利用一些封包过滤的规则设定，来定义出什么资料可以接收，什么资料需要剔除，以达到保护主机的目的！</p><h5 id="（2）TCP-Wrappers-程序控管"><a href="#（2）TCP-Wrappers-程序控管" class="headerlink" title="（2）TCP Wrappers (程序控管)"></a>（2）TCP Wrappers (程序控管)</h5><p>另一种抵挡封包进入的方法，为透过服务器程序的外挂 (tcpd) 来处置的！与封包过滤不同的是，这种机制主要是分析谁对某程序进行存取，然后透过规则去分析该服务器程序谁能够联机、谁不能联机。由于主要是透过分析服务器程序来控管，因此与启动的端口无关，只与程序的名称有关。举例来说，我们知道 FTP 可以启动在非正规的 port 21 进行监听，当你透过 Linux 内建的 TCP wrappers 限制 FTP 时，那么你只要知道 FTP 的软件名称 (vsftpd) ，然后对他作限制，则不管 FTP 启动在哪个端口，都会被该规则管理的。</p><h5 id="（3）Proxy-代理服务器"><a href="#（3）Proxy-代理服务器" class="headerlink" title="（3）Proxy (代理服务器)"></a>（3）Proxy (代理服务器)</h5><p>其实代理服务器是一种网络服务，它可以【代理】用户的需求，而代为前往服务器取得相关的资料。就有点像底下这个图示吧：<br><img src="/uploads/2018/01/17/network_proxy.JPG" alt="" title="Proxy Server 的运作原理简介"></p><p>以上图为例，当 Client 端想要前往 Internet 取得 Google 的数据时，他取得数据的流程是这样的：</p><blockquote><p>1.client 会向 proxy server 要求数据，请 proxy 帮忙处理；<br>2.proxy 可以分析使用者的 IP 来源是否合法？使用者想要去的 Google 服务器是否合法？如果这个 client 的要求都合法的话，那么 proxy 就会主动的帮忙 client 前往 Google 取得资料；<br>3.Google 所回传的数据是传给 proxy server 的，所以 Google 服务器上面看到的是 proxy server 的 IP；<br>4.最后 proxy 将 Google 回传的数据送给 client。</p></blockquote><p>这样了解了吗？没错，client 并没有直接连上 Internet ，所以在实线部分(步骤 1, 4)只要 Proxy 与 Client 可以联机就可以了！此时 client 甚至不需要拥有 public IP ！而当有人想要攻击 client 端的主机时，除非他能够攻破 Proxy server ，否则是无法与 client 联机的！<br>另外，一般 proxy 主机通常仅开放 port 80, 21, 20 等 WWW 与 FTP 的端口而已，而且通常 Proxy 就架设在路由器上面，因此可以完整的掌控局域网络内的对外联机！让你的 LAN 变的更安全啊！</p><h4 id="4、防火墙的使用限制"><a href="#4、防火墙的使用限制" class="headerlink" title="4、防火墙的使用限制"></a>4、防火墙的使用限制</h4><p>从前面的分析中，我们已经知道过封包滤式防火墙主要在分析 OSI 七层协议当中的 2, 3, 4 层，既然如此的话，Linux 的 Netfilter 机制到底可以做些什么事情呢？其实可以进行的分析工作主要有：</p><h5 id="（1）拒绝让-Internet-的封包进入主机的某些端口"><a href="#（1）拒绝让-Internet-的封包进入主机的某些端口" class="headerlink" title="（1）拒绝让 Internet 的封包进入主机的某些端口"></a>（1）拒绝让 Internet 的封包进入主机的某些端口</h5><p>这个应该不难了解。例如你的 port 21 这个 FTP 相关的端口，若只想要开放给内部网络的话，那么当 Internet 来的封包想要进入你的 port 21 时，就可以将该数据封包丢掉！因为我们可以分析的到该封包表头的端口号码！</p><h5 id="（2）拒绝让某些来源-IP-的封包进入"><a href="#（2）拒绝让某些来源-IP-的封包进入" class="headerlink" title="（2）拒绝让某些来源 IP 的封包进入"></a>（2）拒绝让某些来源 IP 的封包进入</h5><p>例如你已经发现某个 IP 主要都是来自攻击行为的主机，那么只要来自该 IP 的数据封包，就将他丢弃！这样也可以达到基础的安全！</p><h5 id="（3）拒绝让带有某些特殊旗标-flag-的封包进入"><a href="#（3）拒绝让带有某些特殊旗标-flag-的封包进入" class="headerlink" title="（3）拒绝让带有某些特殊旗标 (flag) 的封包进入"></a>（3）拒绝让带有某些特殊旗标 (flag) 的封包进入</h5><p>最常拒绝的就是带有 SYN 的主动联机的旗标了！只要一经发现，你就可以将该封包丢弃！（因为都是一些攻击封包，占着茅坑不拉屎！）</p><h5 id="（4）分析硬件地址-MAC-来决定联机与否"><a href="#（4）分析硬件地址-MAC-来决定联机与否" class="headerlink" title="（4）分析硬件地址 (MAC) 来决定联机与否"></a>（4）分析硬件地址 (MAC) 来决定联机与否</h5><p>如果你的局域网络里面有比较捣蛋的但是又具有比较高强的网络功力的高手时，如果你使用 IP 来抵挡他使用网络的权限，而他却懂得反正换一个 IP 就好了，都在同一个网域内！同样还是在搞破坏！！怎么办？没关系，我们可以死锁他的网络卡硬件地址啊！因为 MAC 是焊在网络卡上面的，所以你只要分析到该使用者所使用的 MAC 之后，可以利用防火墙将该 MAC 锁住，除非他能够一换再换他的网络卡来取得新的 MAC，否则换 IP 是没有用的！</p><p>虽然 Netfilter 防火墙已经可以做到这么多的事情，不过，还是有很多事情没有办法透过 Netfilter 来完成！什么？设定防火墙之后还不安全啊！那当然啦！谁说设定了防火墙之后你的系统就一定安全？防火墙虽然可以防止不受欢迎的封包进入我们的网络当中，不过，某些情况下，他并不能保证我们的网络一定就很安全。举几个例子来谈一谈：<br><strong>（1）防火墙并不能很有效的抵挡病毒或木马程序</strong><br>假设你已经开放了 WWW 的服务，那么你的 WWW 主机上面，防火墙一定得要将 WWW 服务的 port 开放给 Client 端登入才行吧！否则你的 WWW 主机设定了等于没有用对吧！也就是说，只要进入你的主机的封包是要求 WWW 数据的，就可以通过你的防火墙。那好了，【万一你的 WWW 服务器软件有漏洞，或者本身向你要求 WWW 服务的该封包就是病毒在侦测你的系统】时，你的防火墙可是一点办法也没有啊！因为本来设定的规则就是会让他通过。<br><strong>（2）防火墙对于来自内部 LAN 的攻击较无承受力</strong><br>一般来说，我们对于 LAN 里面的主机都没有什么防火墙的设定，因为是我们自己的 LAN ，所以当然就设定为信任网域了！不过，LAN 里面总是可能有些网络小白，虽然他们不是故意要搞破坏，但是他们就是不懂！所以就乱用网络。这个时候就很糟糕，因为防火墙对于内部的规则设定通常比较少，所以就容易造成内部员工对于网络误用或滥用的情况。</p><p>所以，在你的 Linux 主机实地上网之前，还是得先：</p><ul><li>（1）关闭几个不安全的服务；</li><li>（2）升级几个可能有问题的套件；</li><li>（3）架设好最起码的安全防护–防火墙–</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、认识防火墙&quot;&gt;&lt;a href=&quot;#1、认识防火墙&quot; class=&quot;headerlink&quot; title=&quot;1、认识防火墙&quot;&gt;&lt;/a&gt;1、认识防火墙&lt;/h4&gt;&lt;p&gt;网络安全除了随时注意相关软件的漏洞以及网络上的安全通报之外，你最好能够依据自己的环境来订定防火墙机制！这样对于你的网络环境，会比较有保障一点！那么什么是防火墙呢？其实防火墙就是透过订定一些有顺序的规则，并管制进入到我们网域内的主机 (或者可以说是网域) 数据封包的一种机制！更广义的来说，只要能够分析与过滤进出我们管理之网域的封包数据，就可以称为防火墙。&lt;/p&gt;
&lt;p&gt;防火墙又可以分为硬件防火墙与本机的软件防火墙。硬件防火墙是由厂商设计好的主机硬件，这部硬件防火墙内的操作系统主要以提供封包数据的过滤机制为主，并将其他不必要的功能拿掉。因为单纯作为防火墙功能而已，因此封包过滤的效率较佳。至于软件防火墙呢？那就是我们主要研究的方向！软件防火墙本身就是在保护系统网络安全的一套软件(或称为机制)，例如 Netfilter 与 TCP Wrappers 都可以称为软件防火墙。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>基础网络概念（三）</title>
    <link href="http://yoursite.com/2018/01/16/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/16/基础网络概念（三）/</id>
    <published>2018-01-16T10:33:33.000Z</published>
    <updated>2018-01-18T06:58:16.163Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、网络"><a href="#1、网络" class="headerlink" title="1、网络"></a>1、网络</h4><p>网络是由节点和连线构成，表示诸多对象及其相互联系。在数学上，网络是一种图，一般认为专指加权图。网络除了数学定义外，还有具体的物理含义，即网络是从某种相同类型的实际问题中抽象出来的模型。在计算机领域中，网络是信息传输、接收、共享的虚拟平台，通过它把各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络是人类发展史来最重要的发明，提高了科技和人类社会的发展。<br><a id="more"></a></p><h4 id="2、网络类型："><a href="#2、网络类型：" class="headerlink" title="2、网络类型："></a>2、网络类型：</h4><p><strong>地理位置：</strong></p><ul><li>1.局域网（LAN）：一般限定在较小的区域内，小于10km的范围，通常采用有线的方式连接起来。</li><li>2.城域网（MAN）：规模局限在一座城市的范围内，10～100km的区域。</li><li>3.广域网（WAN）：网络跨越国界、洲界，甚至全球范围。<br>局域网和广域网是网络的热点。局域网是组成其他两种类型网络的基础，城域网一般都加入了广域网。广域网的典型代表是internet网。</li><li>4.个人网：个人局域网就是在个人工作地方把属于个人使用的电子设备（如便携电脑等）用无线技术连接起来的网络，因此也常称为无线个人局域网WPAN，其范围大约在10m左右。</li></ul><p><strong>传输介质：</strong></p><ul><li>1.有线网：采用同轴电缆和双绞线来连接的计算机网络。</li><li>2.光纤网：光纤网也是有线网的一种，但由于其特殊性而单独列出，光纤网采用光导纤维作传输介质。光纤传输距离长，传输率高，可达数千兆bps，抗干扰性强，不会受到电子监听设备的监听，是高安全性网络的理想选择。</li><li>3.无线网：用电磁波作为载体来传输数据。</li></ul><h4 id="3、互联网"><a href="#3、互联网" class="headerlink" title="3、互联网"></a>3、互联网</h4><p>互联网（英语：Internet），又称网际网络，或音译因特网(Internet)、英特网，互联网始于1969年美国的阿帕网。是网络与网络之间所串连成的庞大网络，这些网络以一组通用的协议相连，形成逻辑上的单一巨大国际网络。通常internet泛指互联网，而Internet则特指因特网。这种将计算机网络互相联接在一起的方法可称作“网络互联”，在这基础上发展出覆盖全世界的全球性互联网络称互联网，即是互相连接一起的网络结构。互联网并不等同万维网，万维网只是一建基于超文本相互链接而成的全球性系统，且是互联网所能提供的服务其中之一。</p><p><strong>互联网运行原理：</strong><br>计算机网络是由许多计算机组成的，要实现网络的计算机之间传输数据，必须要做两件事，数据传输目的地址和保证数据迅速可靠传输的措施，这是因为数据在传输　过程中很容易丢失或传错，Internet使用一种专门的计算机语言(协议)，以保证数据安全、可靠地到达指定的目的地，这种语言分两部TCP(Transmission Control Protocol　传输控制协议)和 IP (Internet Protocol网间协议)sure网络营销理论。　TCP/IP协议的数据传输过程：TCP/IP协议所采用的通信方式是分组交换方式。所谓分组交换，简单说就是数据　在传输时分成若干段，每个数据段称为一个数据包，TCP/IP协议的基本传输单位是数据包，TCP/IP协议主要包括两个主要的协议，即TCP协议和IP协议，这两个协议可以　联合使用，也可以与其他协议联合使用，它们在数据传输过程中主要完成以下功能：</p><ul><li>1) 首先由TCP协议把数据分成若干数据包，给每个数据包写上序号，以便接收端把数据还原成原来的格式。</li><li>2) IP协议给每个数据包写上发送主机和接收主机的地址，一旦写上源地址和目的地址，数据包就可以在物理网上传送数据了。IP协议还具有利用路由算法进行路由选择的功能。</li><li>3) 这些数据包可以通过不同的传输途径(路由)进行传输，由于路径不同，加上其它的原因，可能出现顺序颠倒、数据丢失、数据失真甚至重复的现象。这些问题都由TCP协议来处理，它具有检查和处理错误的功能， 必要时还可以请求发送端重发。简言之，IP协议负责数据的传输，而TCP协议负责数据的可靠传输。</li></ul><h4 id="4、因特网"><a href="#4、因特网" class="headerlink" title="4、因特网"></a>4、因特网</h4><p>因特网（Internet）是一组全球信息资源的总汇。有一种粗略的说法，认为INTERNET是由于许多小的网络（子网）互联而成的一个逻辑网，每个子网中连接着若干台计算机（主机）。Internet以相互交流信息资源为目的，基于一些共同的协议，并通过许多路由器和公共互联网而成，它是一个信息资源和资源共享的集合。</p><h4 id="5、万维网"><a href="#5、万维网" class="headerlink" title="5、万维网"></a>5、万维网</h4><p>WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为Web。 分为Web客户端和Web服务器程序。 WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。 是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。<br>万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</p><h4 id="6、三者之间的关系"><a href="#6、三者之间的关系" class="headerlink" title="6、三者之间的关系"></a>6、三者之间的关系</h4><p>互联网、因特网、万维网三者的关系是：互联网包含因特网，因特网包含万维网，凡是能彼此通信的设备组成的网络就叫互联网。所以，即使仅有两台机器，不论用何种技术使其彼此通信，也叫互联网。国际标准的互联网写法是Internet，因特网是互联网的一种。因特网可不是仅有两台机器组成的互联网，它是由上千万台设备组成的互联网。因特网使用TCP/IP协议让不同的设备可以彼此通信。但使用TCP/IP协议的网络并不一定是因特网，一个局域网也可以使用TCP/IP协议。判断自己是否接入的是因特网，首先是看自己电脑是否安装了 TCP/IP协议，其次看是否拥有一个公网地址（所谓公网地址，就是所有私网地址以外的地址）。<br>因特网是基于TCP/IP协议实现的，TCP/IP协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如FTP、SMTP、HTTP。只要应用层使用的是HTTP协议，就称为万维网（World Wide Web）。之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为您的个人浏览器和百度网的服务器之间使用的是HTTP协议在交流。</p><h4 id="7、网络预测"><a href="#7、网络预测" class="headerlink" title="7、网络预测"></a>7、网络预测</h4><p><strong>（1）语义网</strong><br>SirTim Berners-Lee（Web创始者）关于语义网的观点成为人们的重要关注已经很长一段时间了。事实上，它已经象大白鲸一样神乎其神了。总之，语义网关涉到机器之间的对话，它使得网络更加智能化，或者像Berners-Lee描述的那样，计算机“在网络中分析所有的数据—内容，链接以及人机之间的交易处理”。在另一个时候，Berners-Lee把它描述为“为数据设计的似网程序”，如对信息再利用的设计。<br>就象Alex在《通往语义网》中写道，语义网的核心是创建可以处理事物意义的元数据来描述数据，一旦电脑装备上语义网，它将能解决复杂的语义优化问题。<br>因此，什么时候语义网时代才会到来呢？创建语义网的组件已经出现：RDF，OWL，这些微格式只是众多组件之一.但是，Alex在他文章中指出，将需要一些时间来诠释世界的信息，然后再以某种合适的方式来捕获个人信息。一些公司，如Hakia，Powerset以及Alex自己的adaptive blue都正在积极的实现语义网，因此，未来我们将变得关系更亲密，但是我们还得等上好些年，才能看到语义网的设想实现。<br><strong>（2）人工智能</strong><br>人工智能可能会是计算机历史中的一个终极目标。从1950年，阿兰图灵提出的测试机器如人机对话能力的图灵测试开始，人工智能就成为计算机科学家们的梦想，<br>在接下来的网络发展中，人工智能使得机器更加智能化。在这个意义上来看，这和语义网在某些方面有些相同。<br>1997年5月，IBM公司研制的深蓝（DEEP BLUE）计算机战胜了国际象棋大师卡斯帕洛夫（KASPAROV）。大家或许不会注意到，在一些地方计算机帮助人进行其它原来只属于人类的工作，计算机以它的高速和准确为人类发挥着它的作用。人工智能始终是计算机科学的前沿学科，计算机编程语言和其它计算机软件都因为有了人工智能的进展而得以存在。相信以后人工智能会给人类的生活带来更大的改变，期待下一次的变革“智能时代”的到来！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、网络&quot;&gt;&lt;a href=&quot;#1、网络&quot; class=&quot;headerlink&quot; title=&quot;1、网络&quot;&gt;&lt;/a&gt;1、网络&lt;/h4&gt;&lt;p&gt;网络是由节点和连线构成，表示诸多对象及其相互联系。在数学上，网络是一种图，一般认为专指加权图。网络除了数学定义外，还有具体的物理含义，即网络是从某种相同类型的实际问题中抽象出来的模型。在计算机领域中，网络是信息传输、接收、共享的虚拟平台，通过它把各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络是人类发展史来最重要的发明，提高了科技和人类社会的发展。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统服务之端口（port）</title>
    <link href="http://yoursite.com/2018/01/15/Linux-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%AB%AF%E5%8F%A3%EF%BC%88port%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/15/Linux-系统服务之端口（port）/</id>
    <published>2018-01-15T07:50:37.000Z</published>
    <updated>2018-01-18T07:02:32.243Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、什么是-port-？"><a href="#1、什么是-port-？" class="headerlink" title="1、什么是 port ？"></a>1、什么是 port ？</h4><p>当你启动一个网络服务，这个服务会依据 TCP/IP 的相关通讯协议启动一个端口在进行监听，那就是 TCP/UDP 封包的 port (端口)了。我们知道网络联机是双向的，服务器端得要启动一个监听的端口，客户端得要随机启动一个端口来接收响应的数据才行。那么服务器端的服务是否需要启动在固定的端口？客户端的端口是否又是固定的呢？我们将与 port 有关的资料给她汇整一下，如下：<br><a id="more"></a></p><blockquote><p><strong>1、服务器端启动的监听端口所对应的服务是固定的：</strong><br>例如 WWW 服务开启在 port 80 ，FTP 服务开启在 port 21，email 传送开启在port 25 等等，都是通讯协议上面的规范！<br><strong>2、客户端启动程序时，随机启动一个大于 1024 以上的端口：</strong><br>客户端启动的 port 是随机产生的，主要是开启在大于 1024 以上的端口。这个 port 也是由某些软件所产生的，例如浏览器、Filezilla 这个 FTP 客户端程序等等。<br><strong>3、一部服务器可以同时提供多种服务：</strong><br>所谓的【监听】是某个服务程序会一直常驻在内存当中，所以该程序启动的 port 就会一直存在。只要服务器软件激活的端口不同，那就不会造成冲突。当客户端连接到此服务器时，透过不同的端口，就可以取得不同的服务数据。所以，一部主机上面当然可以同时启动很多不同的服务！<br><strong>4、共 65536 个 port：</strong><br>由 TCP/UDP 表头数据中，就知道 port 占用 16 个位，因此一般主机会有 65536 个 port，而这些 port 又分成两个部分，以 port 1024 作区隔：</p><ul><li>只有 root 才能启动的保留的 port：<br>在小于 1024 的端口，都是需要以 root 的身份才能启动的，这些 port 主要是用于一些常见的通讯服务，在 Linux 系统下，常见的协议与 port 的对应是记录在 /etc/services 里面的。</li><li>大于 1024 用于 client 端的 port：<br>在大于 1024 以上的 port 主要是作为 client 端的软件激活的 port。</li></ul><p><strong>5、是否需要三向交握：</strong><br>建立可靠的联机服务需要使用到 TCP 协议，也就需要所谓的三向交握了，如果是非面向连接的服务，例如 DNS 与视讯系统，那只要使用 UDP 协议即可。<br><strong>6、通讯协议可以启用在非正规的 port：</strong><br>我们知道浏览器默认会连接到 WWW 主机的 port 80，那么你的 WWW 是否可以启动在非 80 的其他端口？当然可以！你可以透过 WWW 软件的设定功能将该软件使用的 port 启动在非正规的端口，只是如此一来，您的客户端要连接到你的主机时，就得要在浏览器的地方额外指定你所启用的非正规的端口才行。这个启动在非正规的端口功能，常常被用在一些所谓的地下网站！另外，某些软件默认就启动在大于 1024 以上的端口，如 MySQL 数据库软件就启动在 3306。<br><strong>7、所谓的 port 的安全性：</strong><br>事实上，没有所谓的 port 的安全性！因为【Port 的启用是由服务软件所造成的】，也就是说，真正影响网络安全的并不是 port ，而是启动 port 的那个软件 (程序)！或许你偶而会听到：【没有修补过漏洞的 bind 8.x 版，很容易被黑客所入侵，请尽快升级到 bind 9.x 以后版本】，所以，对安全真正有危害的是【某些不安全的服务】而不是【开了哪些 port 】才是！因此，没有必要的服务就将他关闭吧！尤其某些网络服务还会启动一些 port ！另外，那些已启动的软件也需要持续的保持更新！</p></blockquote><p>附属：一些系统必备的软件服务说明</p><table><thead><tr><th>服务名称</th><th>服务内容</th></tr></thead><tbody><tr><td>acpid</td><td>新版的电源管理模块，通常建议开启，不过，某些笔记本电脑可能不支持此项服务，那就得关闭</td></tr><tr><td>atd</td><td>在管理单一预约命令执行的服务，应该要启动的</td></tr><tr><td>crond</td><td>在管理工作排程的重要服务，请务必要启动啊！</td></tr><tr><td>haldaemon</td><td>作系统硬件变更侦测的服务，与 USB 设备关系很大</td></tr><tr><td>iptables</td><td>Linux 内建的防火墙软件，这个也可以启动！</td></tr><tr><td>network</td><td>这个重要了吧？要网络就要有他啊！</td></tr><tr><td>postfix</td><td>系统内部邮件传递服务，不要随便关闭他！</td></tr><tr><td>rsyslog</td><td>系统的登录文件记录，很重要的，务必启动啊！</td></tr><tr><td>sshd</td><td>这是系统默认会启动的，可以让你在远程以文字型态的终端机登入！</td></tr><tr><td>xinetd</td><td>就是那个 super daemon ！所以也要启动！</td></tr></tbody></table><p>上面列出的是主机需要的重点服务，请您不要关闭他！除非你知道作了之后会有什么后果。举例来说，你如果不需要管理电源，那么将 acpid 关闭也没有关系啊！如果你不需要提供远程联机功能，那么 sshd 也可以关闭啊！那其他你不知道的服务怎办？没关系，只要不是网络服务，你都可以保留他！如果是网络服务呢？那…建议你不知道的服务就先关闭他！</p><h4 id="2、端口的观察：netstat-nmap"><a href="#2、端口的观察：netstat-nmap" class="headerlink" title="2、端口的观察：netstat, nmap"></a>2、端口的观察：netstat, nmap</h4><p>现在，我们知道 port 是什么东西了，再来就是要来了解一下，我们的主机到底是开了多少的 port 呢？由于 port 的启动与服务有关，那么【服务】跟【 port 】对应的档案是哪一个？是【 /etc/services 】！而常用来观察 port 的则有底下两个程序：</p><ul><li>1.netstat：在本机上面以自己的程序监测自己的 port；</li><li>2.nmap：透过网络的侦测软件辅助，可侦测非本机上的其他网络主机，但有违法之虞（此处略过）。<br><em>（注：为什么使用nmap会违法？由于 nmap 的功能太强大了，所以很多 cracker 会直接以他来侦测别人的主机，这个时候就可能造成违法）</em></li></ul><p>底下我们来说一说 netstat 命令：<br>在做为服务器的 Linux 系统中，开启的网络服务越少越好！因为较少的服务可以较容易除错 (debug) 与了解安全漏洞，并可避免不必要的入侵管道！所以，这个时候请了解一下您的系统当中有没有哪些服务被开启了呢？要了解自己的系统当中的服务项目，最简便的方法就是使用 netstat ！这个东西不但简单，而且功能也是很不错的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">基本语法：</span><br><span class="line">[root@www ~]# netstat -[rn] &lt;==与路由有关的参数</span><br><span class="line">[root@www ~]# netstat -[antulpc] &lt;==与网络接口有关的参数</span><br><span class="line">选项与参数：</span><br><span class="line">与路由 (route) 有关的参数说明：</span><br><span class="line">    -r ：列出路由表(route table)，功能如同 route 这个指令；</span><br><span class="line">    -n ：不使用主机名与服务名称，使用 IP 与 port number ，如同 route -n与网络接口有关的参数：</span><br><span class="line">    -a ：列出所有的联机状态，包括 tcp/udp/unix socket 等；</span><br><span class="line">    -t ：仅列出 TCP 封包的联机；</span><br><span class="line">    -u ：仅列出 UDP 封包的联机；</span><br><span class="line">    -l ：仅列出有在 Listen (监听) 的服务之网络状态；</span><br><span class="line">    -p ：列出 PID 与 Program 的檔名；</span><br><span class="line">    -c ：可以设定几秒钟后自动更新一次，例如 -c 5 每五秒更新一次网络状态的显示；</span><br><span class="line">    （netstat -rn 与 route -n 是相同的。）</span><br></pre></td></tr></table></figure></p><blockquote><p>我们先来谈一谈关于网络联机状态的输出部分，他主要是分为底下几个大项：<br><strong>Proto：</strong>该联机的封包协议，主要为 TCP/UDP 等封包；<br><strong>Recv-Q：</strong>非由用户程序连接所复制而来的总 bytes 数；<br><strong>Send-Q：</strong>由远程主机所传送而来，但不具有 ACK 标志的总 bytes 数，意指主动联机 SYN 或其他标志的封包所占的 bytes 数；<br><strong>Local Address：</strong>本地端的地址，可以是 IP (-n 参数存在时)，也可以是完整的主机名。使用的格是就是『 IP:port 』只是 IP 的格式有 IPv4 及 IPv6 的差异。 如上所示，在 port 22 的接口中，使用的 :::22 就是针对 IPv6 的显示，事实上他就相同于 0.0.0.0:22 的意思。至于 port 25 仅针对 lo 接口开放，意指 Internet 基本上是无法连接到我本机的 25 埠口啦！<br><strong>Foreign Address：</strong>远程的主机 IP 与 port number<br><strong>stat：</strong>状态栏，主要的状态含有：</p><ul><li>ESTABLISED：已建立联机的状态；</li><li>SYN_SENT：发出主动联机 (SYN 标志) 的联机封包；</li><li>SYN_RECV：接收到一个要求联机的主动联机封包；</li><li>FIN_WAIT1：该插槽服务(socket)已中断，该联机正在断线当中；</li><li>FIN_WAIT2：该联机已挂断，但正在等待对方主机响应断线确认的封包；</li><li>TIME_WAIT：该联机已挂断，但 socket 还在网络上等待结束；</li><li>LISTEN：通常用在服务的监听 port ！可使用【 -l 】参数查阅。</li></ul></blockquote><p>基本上，我们常常谈到的 netstat 的功能，就是在观察网络的联机状态了，而网络联机状态中，又以观察【我目前开了多少的 port 在等待客户端的联机】以及 【目前我的网络联机状态中，有多少联机已建立或产生问题】最常见。<br>示例：<br><strong>1.列出在监听的网络服务：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# netstat -tunl</span><br><span class="line">ctive Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State</span><br><span class="line">tcp 0 0 0.0.0.0:111 0.0.0.0:* LISTEN</span><br><span class="line">tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN</span><br><span class="line">tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN</span><br><span class="line">....(底下省略)....</span><br></pre></td></tr></table></figure></p><p>上面说明了我的主机至少有启动 port 111, 22, 25 等，而且观察各联机接口，可发现 25 为 TCP 端口，但只针对 lo 内部循环测试网络提供服务，因特网是连不到该端口的。至于 port 22 则有提供因特网的联机功能。</p><p><strong>2.列出已联机的网络联机状态：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# netstat -tun</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State</span><br><span class="line">tcp 0 52 192.168.1.100:22 192.168.1.101:2162 ESTABLISHED</span><br></pre></td></tr></table></figure></p><p>从上面的数据来看，我的本地端服务器 (Local Address, 192.168.1.100) 目前仅有一条已建立的联机，那就是与 192.168.1.101 那部主机连接的联机，并且联机方向是由对方连接到我主机的 port 22 来取用我服务器的服务！</p><p><strong>3.删除已建立或在监听当中的联机：</strong><br>如果想要将已经建立，或者是正在监听当中的网络服务关闭的话，最简单的方法当然就是找出该联机的 PID，然后将他 kill 掉即可！例如下面的范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# netstat -tunp</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State PID/P name</span><br><span class="line">tcp 0 52 192.168.1.100:22 192.168.1.101:2162 ESTABLISHED 1342/0</span><br></pre></td></tr></table></figure></p><p>如上面的范例，我们可以找出来该联机是由 sshd 这个程序来启用的，并且他的 PID 是 1342，希望你不要心急的用 killall 这个指令，否则容易删错人 (因为你的主机里面可能会有多个 sshd 存在)，应该要使用 kill 这个指令才对！<br><code>[root@www ~]# kill -9 1342</code></p><h4 id="3、端口与服务的启动-关闭及开机时状态设定"><a href="#3、端口与服务的启动-关闭及开机时状态设定" class="headerlink" title="3、端口与服务的启动/关闭及开机时状态设定"></a>3、端口与服务的启动/关闭及开机时状态设定</h4><p>其实 port 是由执行某些软件之后被软件激活的。所以要关闭某些 port 时，那就直接将某个程序给他关闭就是了！关闭的方法你当然可以使用 kill，不过这毕竟不是正统的解决之道，因为 kill 这个指令通常具有强制关闭某些程序的功能，但我们想要正常的关闭该程序！所以，就利用系统给我们的 script 来关闭就好了。一般传统的服务有哪几种类型？</p><p><strong>stand alone 与 super daemon</strong><br>    在一般正常的 Linux 系统环境下，服务的启动与管理主要有两种方式：</p><ol><li>Stand alone<br>顾名思义，stand alone 就是直接执行该服务的执行档，让该执行文件直接加载到内存当中运作，用这种方式来启动可以让该服务具有较快速响应的优点。一般来说，这种服务的启动 script 都会放置到 /etc/init.d/ 这个目录底下，所以你通常可以使用：【 /etc/init.d/sshd restart 】之类的方式来重新启动这种服务；</li><li>Super daemon<br>用一个超级服务作为总管，来统一管理某些特殊的服务。在 CentOS 6.x 里面使用的则是 xinetd 这个 super daemon ！这种方式启动的网络服务虽然在响应上速度会比较慢，不过，可以透过 super daemon 额外提供一些控管，例如控制何时启动、何时可以进行联机、那个 IP 可以连进来、是否允许同时联机等等。通常个别服务的配置文件放置在 /etc/xinetd.d/ 当中，但设定完毕后需要重新以【 /etc/init.d/xinetd restart 】重新来启动才行！</li></ol><blockquote><p>例题：<br>我们知道系统的 Telnet 服务通常是以 super daemon 来控管的，请您启动您系统的 telnet 试看看。<br>答：<br>1、要启动 telnet 首先必须要已经安装了 telnet 的服务器才行，所以请先以 rpm 查询看看是否有安装 telnet-server 呢？【rpm -qa | grep telnet-server】如果没有安装的话，请利用原版光盘来安装，或者使用【yum install telnet-server】安装一下先；<br>2、由于是 super daemon 控管，所以请编辑 /etc/xinetd.d/telnet 这个档案，将其中的【disable = yes】改成【disable = no】之后以【/etc/init.d/xinetd restart】重新启动 super daemon 吧！<br>3、利用 netstat -tnlp 察看是否有启动 port 23 呢？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、什么是-port-？&quot;&gt;&lt;a href=&quot;#1、什么是-port-？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是 port ？&quot;&gt;&lt;/a&gt;1、什么是 port ？&lt;/h4&gt;&lt;p&gt;当你启动一个网络服务，这个服务会依据 TCP/IP 的相关通讯协议启动一个端口在进行监听，那就是 TCP/UDP 封包的 port (端口)了。我们知道网络联机是双向的，服务器端得要启动一个监听的端口，客户端得要随机启动一个端口来接收响应的数据才行。那么服务器端的服务是否需要启动在固定的端口？客户端的端口是否又是固定的呢？我们将与 port 有关的资料给她汇整一下，如下：&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用网络指令</title>
    <link href="http://yoursite.com/2018/01/12/Linux-%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/01/12/Linux-常用网络指令/</id>
    <published>2018-01-12T09:41:44.000Z</published>
    <updated>2018-01-18T07:02:19.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、网络参数设定使用的指令"><a href="#一、网络参数设定使用的指令" class="headerlink" title="一、网络参数设定使用的指令"></a>一、网络参数设定使用的指令</h3><p><strong>ifconfig ：</strong>查询、设定网络卡与 IP 网域等相关参数；<br><strong>ifup, ifdown：</strong>这两个档案是 script，透过更简单的方式来启动网络接口；<br><strong>route ：</strong>查询、设定路由表 (route table)<br><strong>ip ：</strong>复合式的指令，可以直接修改上述提到的功能；<br><em>（先会使用 ifconfig, ifup , ifdown 与 route 即可，等以后有经验了之后，再继续回来玩 ip 这个好玩的指令。）</em><br><a id="more"></a></p><h4 id="1、手动-自动设定与启动-关闭-IP-参数：-ifconfig-ifup-ifdown"><a href="#1、手动-自动设定与启动-关闭-IP-参数：-ifconfig-ifup-ifdown" class="headerlink" title="1、手动/自动设定与启动/关闭 IP 参数： ifconfig, ifup, ifdown"></a>1、手动/自动设定与启动/关闭 IP 参数： ifconfig, ifup, ifdown</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法如下：</span><br><span class="line">[root@www ~]# ifconfig &#123;interface&#125; &#123;up|down&#125; &lt;== 观察与启动接口</span><br><span class="line">[root@www ~]# ifconfig interface &#123;options&#125; &lt;== 设定与修改接口</span><br><span class="line">选项与参数：</span><br><span class="line">interface：网络卡接口代号，包括 eth0, eth1, ppp0 等等</span><br><span class="line">options ：可以接的参数，包括如下：</span><br><span class="line">    up, down ：启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)</span><br><span class="line">    mtu ：可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)</span><br><span class="line">    netmask ：就是子屏蔽网络；</span><br><span class="line">    broadcast：就是广播地址啊！</span><br></pre></td></tr></table></figure><p><strong>范例一：观察所有的网络接口(直接输入 ifconfig)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr FA:16:3E:C9:BF:42  </span><br><span class="line">          inet addr:10.99.192.224  Bcast:10.99.192.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:671391959 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:629925596 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:202240418477 (188.3 GiB)  TX bytes:161760425688 (150.6 GiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:19514029692 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:19514029692 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:4097035202575 (3.7 TiB)  TX bytes:4097035202575 (3.7 TiB)</span><br></pre></td></tr></table></figure></p><blockquote><p>至于上表出现的各项数据是这样的(数据排列由上而下、由左而右)：<br><strong>eth0：</strong>就是网络卡的代号，也有 lo 这个 loopback ；<br><strong>HWaddr：</strong>就是网络卡的硬件地址，俗称的 MAC 是也；<br><strong>inet addr：</strong>IPv4 的 IP 地址，后续的 Bcast, Mask 分别代表的是 Broadcast 与 netmask！<br><strong>inet6 addr：</strong>是 IPv6 的版本的 IP ，我们没有使用，所以略过；<br><strong>MTU：</strong>最大传输单位<br><strong>RX：</strong>那一行代表的是网络由启动到目前为止的封包接收情况，packets 代表封包数、errors 代表封包发生错误的数量、dropped 代表封包由于有问题而遭丢弃的数量等等<br><strong>TX：</strong>与 RX 相反，为网络由启动到目前为止的传送情况；<br><strong>collisions：</strong>代表封包碰撞的情况，如果发生太多次，表示你的网络状况不太好；<br><strong>txqueuelen：</strong>代表用来传输数据的缓冲区的储存长度；<br><strong>RX bytes, TX bytes：</strong>总接收、发送字节总量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifup/ifdown 语法如下：</span><br><span class="line">[root@www ~]# ifup &#123;interface&#125;</span><br></pre></td></tr></table></figure><h4 id="2、路由修改：-route"><a href="#2、路由修改：-route" class="headerlink" title="2、路由修改： route"></a>2、路由修改： route</h4><p>主机之间一定要有路由才能够互通 TCP/IP 的协议，否则就无法进行联机啊！一般来说，只要有网络接口，该接口就会产生一个路由，所以我们安装的主机有一个 eth0 的接口，看起来就会是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# route [-nee]</span><br><span class="line">[root@www ~]# route add [-net|-host] [网域或主机] netmask [mask] [gw|dev]</span><br><span class="line">[root@www ~]# route del [-net|-host] [网域或主机] netmask [mask] [gw|dev]</span><br><span class="line">观察的参数：</span><br><span class="line">    -n ：不要使用通讯协议或主机名，直接使用 IP 或 port number；</span><br><span class="line">    -ee ：使用更详细的信息来显示</span><br><span class="line">增加 (add) 与删除 (del) 路由的相关参数：</span><br><span class="line">    -net ：表示后面接的路由为一个网域；</span><br><span class="line">    -host ：表示后面接的为连接到单部主机的路由；</span><br><span class="line">    netmask ：与网域有关，可以设定 netmask 决定网域的大小；</span><br><span class="line">    gw ：gateway 的简写，后续接的是 IP 的数值，与 dev 不同；</span><br><span class="line">    dev ：如果只是要指定由那一块网络卡联机出去，则使用这个设定，后面接 eth0 等</span><br></pre></td></tr></table></figure></p><p><strong>范例一：单纯的观察路由状态</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.99.192.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line">0.0.0.0         10.99.192.1     0.0.0.0         UG    0      0        0 eth0</span><br></pre></td></tr></table></figure></p><blockquote><p>上面的信息需要知道的一些参数含义：<br><strong>Destination, Genmask：</strong>这两个玩意儿就是分别是 network 与 netmask ！所以这两个咚咚就组合成为一个完整的网域！<br><strong>Gateway：</strong>该网域是通过哪个 gateway 连接出去的？如果显示 0.0.0.0 表示该路由是直接由本机传送，亦即可以透过局域网络的 MAC 直接传讯；如果有显示 IP 的话，表示该路由需要经过路由器 (通讯闸) 的帮忙才能够传送出去。<br><strong>Flags：</strong>总共有多个旗标，代表的意义如下：<br>    U (route is up)：该路由是启动的；<br>    H (target is a host)：目标是一部主机 (IP) 而非网域；<br>    G (use gateway)：需要透过外部的主机 (gateway) 来转递封包；<br>    R (reinstate route for dynamic routing)：使用动态路由时，恢复路由信息的旗标；<br>    D (dynamically installed by daemon or redirect)：已经由服务或转 port 功能设定为动态路由<br>    M (modified from routing daemon or redirect)：路由已经被修改了；<br>    ! (reject route)：这个路由将不会被接受(用来抵挡不安全的网域！)<br><strong>Iface：</strong>这个路由传递封包的接口。</p></blockquote><h4 id="3、网络参数综合指令：-ip"><a href="#3、网络参数综合指令：-ip" class="headerlink" title="3、网络参数综合指令： ip"></a>3、网络参数综合指令： ip</h4><p>他就是整合了 ifconfig 与 route 这两个指令。ifup 就是利用 ip 这个指令来达成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ip [option] [动作] [指令]</span><br><span class="line">选项与参数：</span><br><span class="line">option ：设定的参数，主要有：</span><br><span class="line">    -s ：显示出该装置的统计数据(statistics)，例如总接受封包数等；</span><br><span class="line">动作：亦即是可以针对哪些网络参数进行动作，包括有：</span><br><span class="line">    link ：关于装置 (device) 的相关设定，包括 MTU, MAC 地址等等</span><br><span class="line">    addr/address ：关于额外的 IP 协议，例如多 IP 的达成等等；</span><br><span class="line">    route ：与路由有关的相关设定</span><br></pre></td></tr></table></figure></p><p>由上面的语法我们可以知道， ip 除了可以设定一些基本的网络参数之外，还能够进行额外的 IP 协议，包括多 IP 的达成，真是太完美了！底下我们就分三个部分 (link,addr, route) 来介绍这个 ip 指令吧！</p><p><strong>（1）关于装置接口 (device) 的相关设定： ip link</strong><br>ip link 可以设定与装置 (device) 有关的相关参数，包括 MTU 以及该网络接口的 MAC 等等，当然也可以启动 (up) 或关闭 (down) 某个网络接口啦！整个语法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ip [-s] link show &lt;== 单纯的查阅该装置相关的信息</span><br><span class="line">[root@www ~]# ip link set [device] [动作与参数]</span><br><span class="line">选项与参数：</span><br><span class="line">show：仅显示出这个装置的相关内容，如果加上 -s 会显示更多统计数据；</span><br><span class="line">set ：可以开始设定项目， device 指的是 eth0, eth1 等等界面代号；</span><br><span class="line">动作与参数：包括有底下的这些动作：</span><br><span class="line">up|down ：启动 (up) 或关闭 (down) 某个接口，其他参数使用默认的以太网络；</span><br><span class="line">address ：如果这个装置可以更改 MAC 的话，用这个参数修改！</span><br><span class="line">name ：给予这个装置一个特殊的名字；</span><br><span class="line">mtu ：就是最大传输单元啊！</span><br><span class="line">（使用 ip link show 可以显示出整个装置接口的硬件相关信息，如上所示，包括网卡地址(MAC)、MTU 等等）</span><br></pre></td></tr></table></figure></p><p><strong>（2）关于额外的 IP 相关设定： ip address</strong><br>如果说 ip link 是与 OSI 七层协定 的第二层资料连阶层有关的话，那么 ip address (ip addr) 就是与第三层网络层有关的参数啦！ 主要是在设定与 IP 有关的各项参数，包括 netmask, broadcast 等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ip address show &lt;==就是查阅 IP 参数啊！</span><br><span class="line">[root@www ~]# ip address [add|del] [IP 参数] [dev 装置名] [相关参数]</span><br><span class="line">选项与参数：</span><br><span class="line">show ：单纯的显示出接口的 IP 信息啊；</span><br><span class="line">add|del ：进行相关参数的增加 (add) 或删除 (del) 设定，主要有：</span><br><span class="line">IP 参数：主要就是网域的设定，例如 192.168.100.100/24 之类的设定；</span><br><span class="line">dev ：这个 IP 参数所要设定的接口，例如 eth0, eth1 等等；</span><br><span class="line">相关参数：主要有底下这些：</span><br><span class="line">    broadcast：设定广播地址，如果设定值是 + 表示『让系统自动计算』</span><br><span class="line">    label ：亦即是这个装置的别名，例如 eth0:0 就是了！</span><br><span class="line">    scope ：这个界面的领域，通常是这几个大类：</span><br><span class="line">    global ：允许来自所有来源的联机；</span><br><span class="line">    site ：仅支持 IPv6 ，仅允许本主机的联机；</span><br><span class="line">    link ：仅允许本装置自我联机；</span><br><span class="line">    host ：仅允许本主机内部的联机；</span><br><span class="line">    所以当然是使用 global ！预设也是 global ！</span><br></pre></td></tr></table></figure></p><p><strong>（3）关于路由的相关设定： ip route</strong><br>这个项目当然就是路由的观察与设定啰！事实上， ip route 的功能几乎与 route 这个指令差不多，但是，他还可以进行额外的参数设计，例如 MTU 的规划等等，相当的强悍啊！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ip route show &lt;==单纯的显示出路由的设定而已</span><br><span class="line">[root@www ~]# ip route [add|del] [IP 或网域] [via gateway] [dev 装置]</span><br><span class="line">选项与参数：</span><br><span class="line">show ：单纯的显示出路由表，也可以使用 list ；</span><br><span class="line">add|del ：增加 (add) 或删除 (del) 路由的意思。</span><br><span class="line">IP 或网域：可使用 192.168.50.0/24 之类的网域或者是单纯的 IP ；</span><br><span class="line">via ：从那个 gateway 出去，不一定需要；</span><br><span class="line">dev ：由那个装置连出去，这就需要了！</span><br><span class="line">mtu ：可以额外的设定 MTU 的数值喔！</span><br></pre></td></tr></table></figure></p><h3 id="二、网络侦错与观察指令"><a href="#二、网络侦错与观察指令" class="headerlink" title="二、网络侦错与观察指令"></a>二、网络侦错与观察指令</h3><h4 id="1、两部主机两点沟通：-ping"><a href="#1、两部主机两点沟通：-ping" class="headerlink" title="1、两部主机两点沟通： ping"></a>1、两部主机两点沟通： ping</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ping [选项与参数] IP</span><br><span class="line">选项与参数：</span><br><span class="line">-c 数值：后面接的是执行 ping 的次数，例如 -c 5 ；</span><br><span class="line">-n ：在输出数据时不进行 IP 与主机名的反查，直接使用 IP 输出(速度较快)；</span><br><span class="line">-s 数值：发送出去的 ICMP 封包大小，预设为 56bytes，不过你可以放大此一数值；</span><br><span class="line">-t 数值：TTL 的数值，预设是 255，每经过一个节点就会少一；</span><br><span class="line">-W 数值：等待响应对方主机的秒数。</span><br><span class="line">-M [do|dont] ：主要在侦测网络的 MTU 数值大小，两个常见的项目是：</span><br><span class="line">    do ：代表传送一个 DF (Don&apos;t Fragment) 旗标，让封包不能重新拆包与打包；</span><br><span class="line">    dont：代表不要传送 DF 旗标，表示封包可以在其他主机上拆包与打包</span><br></pre></td></tr></table></figure><p><strong>范例一：侦测一下 172.24.170.43 这部 DNS 主机是否存在？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ping -c 3 172.24.170.43</span><br><span class="line">PING 172.24.170.43 (172.24.170.43) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.24.170.43: icmp_seq=0 ttl=118 time=3.59 ms</span><br><span class="line">64 bytes from 172.24.170.43: icmp_seq=1 ttl=118 time=4.41 ms</span><br><span class="line">64 bytes from 172.24.170.43: icmp_seq=2 ttl=118 time=2.48 ms</span><br><span class="line"></span><br><span class="line">--- 172.24.170.43 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</span><br><span class="line">rtt min/avg/max/mdev = 2.485/3.495/4.411/0.792 ms, pipe 2</span><br></pre></td></tr></table></figure></p><blockquote><p>ping 最简单的功能就是传送 ICMP 封包去要求对方主机回应是否存在于网络环境中，上面的响应消息当中，几个重要的项目是这样的：<br><strong>64 bytes：</strong>表示这次传送的 ICMP 封包大小为 64 bytes 这么大，这是默认值，在某些特殊场合中，例如要搜索整个网络内最大的 MTU 时，可以使用 -s 2000 之类的数值来取代；<br><strong>icmp_seq=0：</strong>ICMP 所侦测进行的次数，第一次编号为 0 ；<br><strong>ttl=118：</strong>TTL 与 IP 封包内的 TTL 是相同的，每经过一个带有 MAC 的节点 (node) 时，例如 router, bridge 时， TTL 就会减少一，预设的 TTL 为 255 ，你可以透过 -t 150 之类的方法来重新设定预设 TTL 数值；<br><strong>time=3.59 ms：</strong>响应时间，单位有 ms(0.001 秒)及 us(0.000001 秒)，一般来说，越小的响应时间，表示两部主机之间的网络联机越良好！<br><strong>（注：如果你忘记加上 -c 3 这样的规定侦测次数，那就得要使用 [ctrl]-c 将他结束掉了！）</strong></p></blockquote><p><strong>用 ping 追踪路径中的最大 MTU 数值</strong><br>现在我们知道网络卡的 MTU 修改可以透过 ifconfig 或者是 ip 等指令来达成，那么追踪整个网络传输的最大 MTU 时，又该如何查询？最简单的方法当然是透过 ping 传送一个大封包， 并且不许中继的路由器或 switch 将该封包重组，那就能够处理啦！没错！可以这样的：<br><strong>范例二：找出最大的 MTU 数值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ping -c 2 -s 1000 -M do 172.24.170.43</span><br><span class="line">PING 172.24.170.43 (172.24.170.43) 1000(1028) bytes of data.</span><br><span class="line">1008 bytes from 172.24.170.43: icmp_seq=0 ttl=118 time=2.28 ms</span><br><span class="line">1008 bytes from 172.24.170.43: icmp_seq=1 ttl=118 time=3.40 ms</span><br><span class="line"></span><br><span class="line">--- 172.24.170.43 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 2.281/2.843/3.406/0.565 ms, pipe 2</span><br><span class="line"># 如果有响应，那就是可以接受这个封包，如果无响应，那就表示这个 MTU 太大了。</span><br><span class="line">[root@www ~]# ping -c 2 -s 8000 -M do 172.24.170.43</span><br><span class="line">PING 172.24.170.43 (172.24.170.43) 8000(8028) bytes of data.</span><br><span class="line">From 10.99.192.224 icmp_seq=0 Frag needed and DF set (mtu = 1500)</span><br><span class="line">From 10.99.192.224 icmp_seq=0 Frag needed and DF set (mtu = 1500)</span><br><span class="line"></span><br><span class="line">--- 172.24.170.43 ping statistics ---</span><br><span class="line">0 packets transmitted, 0 received, +2 errors</span><br><span class="line"># 这个错误讯息是说，本地端的 MTU 才到 1500 而已，你要侦测 8000 的 MTU</span><br><span class="line"># 根本就是无法达成的！那要如何是好？用前一小节介绍的 ip link 来进行MTU 设定吧！</span><br></pre></td></tr></table></figure></p><p>不过，你需要知道的是，由于 IP 封包表头 (不含 options) 就已经占用了 20bytes ，再加上 ICMP 的表头有 8 bytes ，所以当然你在使用 -s size 的时候，那个封包的大小就得要先扣除 (20+8=28) 的大小了。 因此如果要使用 MTU 为 1500 时，就得要下达【 ping -s 1472 -M do xx.yy.zz.ip 】才行啊！</p><p>另外，由于本地端的网络卡 MTU 也会影响到侦测，所以如果想要侦测整个传输媒体的 MTU 数值，那么每个可以调整的主机就得要先使用 ifcofig 或 ip 先将 MTU 调大，然后再去进行侦测， 否则就会出现像上面提供的案例一样，可能会出现错误讯息的！</p><p>如果是要连上 Internet 的主机，注意不要随便调整 MTU ，因为我们无法知道 Internet 上面的每部机器能够支持的 MTU 到多大，因为……不是我们能够管的到的。</p><h4 id="2、两主机间各节点分析：-traceroute"><a href="#2、两主机间各节点分析：-traceroute" class="headerlink" title="2、两主机间各节点分析： traceroute"></a>2、两主机间各节点分析： traceroute</h4><p>我们前面谈到的指令大多数都是针对主机的网络参数设定所需要的，而 ping 是两部主机之间的回声与否判断， 那么有没有指令可以追踪两部主机之间通过的各个节点(node) 通讯状况的好坏呢？举例来说，如果我们联机到 yahoo 的速度比平常慢，你觉得是 (1)自己的网络环境有问题？ (2)还是外部的 Internet 有问题？如果是 (1)的话，我们当然需要检查自己的网络环境啊，看看是否又有谁中毒了？但如果是 Internet的问题呢？那只有『等等等』啊！ 判断是 (1) 还是 (2) 就得要使用 traceroute 这个指令！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# traceroute [选项与参数] IP</span><br><span class="line">选项与参数：</span><br><span class="line">-n ：可以不必进行主机的名称解析，单纯用 IP ，速度较快！</span><br><span class="line">-U ：使用 UDP 的 port 33434 来进行侦测，这是预设的侦测协议；</span><br><span class="line">-I ：使用 ICMP 的方式来进行侦测；</span><br><span class="line">-T ：使用 TCP 来进行侦测，一般使用 port 80 测试</span><br><span class="line">-w ：若对方主机在几秒钟内没有回声就宣告不治...预设是 5 秒</span><br><span class="line">-p 端号：若不想使用 UDP 与 TCP 的预设埠号来侦测，可在此改变埠号。</span><br><span class="line">-i 装置：用在比较复杂的环境，如果你的网络接口很多很复杂时，才会用到这个参数；</span><br><span class="line">    举例来说，你有两条 ADSL 可以连接到外部，那你的主机会有两个ppp，</span><br><span class="line">    你可以使用 -i 来选择是 ppp0 还是 ppp1 </span><br><span class="line">-g 路由：与 -i 的参数相仿，只是 -g 后面接的是 gateway 的 IP 就是了。</span><br></pre></td></tr></table></figure></p><p><strong>范例一：侦测本机到 yahoo 去的各节点联机状态</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# traceroute -n tw.yahoo.com</span><br><span class="line">traceroute to tw.yahoo.com (119.160.246.241), 30 hops max, 40 byte</span><br><span class="line">packets</span><br><span class="line">1 192.168.1.254 0.279 ms 0.156 ms 0.169 ms</span><br><span class="line">2 172.20.168.254 0.430 ms 0.513 ms 0.409 ms</span><br><span class="line">3 10.40.1.1 0.996 ms 0.890 ms 1.042 ms</span><br><span class="line">4 203.72.191.85 0.942 ms 0.969 ms 0.951 ms</span><br><span class="line">5 211.20.206.58 1.360 ms 1.379 ms 1.355 ms</span><br><span class="line">6 203.75.72.90 1.123 ms 0.988 ms 1.086 ms</span><br><span class="line">7 220.128.24.22 11.238 ms 11.179 ms 11.128 ms</span><br><span class="line">8 220.128.1.82 12.456 ms 12.327 ms 12.221 ms</span><br><span class="line">9 220.128.3.149 8.062 ms 8.058 ms 7.990 ms</span><br><span class="line">10 * * *</span><br><span class="line">11 119.160.240.1 10.688 ms 10.590 ms 119.160.240.3 10.047 ms</span><br><span class="line">12 * * * &lt;==可能有防火墙装置等情况发生所致</span><br></pre></td></tr></table></figure></p><p>这个 traceroute 挺有意思的，这个指令会针对欲连接的目的地之所有 node 进行 UDP 的逾时等待，例如上面的例子当中，由鸟哥的主机连接到 Yahoo 时，他会经过 12 个节点以上，traceroute 会主动的对这 12 个节点做 UDP 的回声等待，并侦测回复的时间，每节点侦测三次，最终回传像上头显示的结果。 你可以发现每个节点其实回复的时间大约在 50 ms 以内，算是还可以的 Internet 环境了。</p><p>比较特殊的算是第 10/12 个，会回传星号的，代表该 node 可能设有某些防护措施，让我们发送的封包信息被丢弃所致。 因为我们是直接透过路由器转递封包，并没有进入路由器去取得路由器的使用资源，所以某些路由器仅支持封包转递，并不会接受来自客户端的各项侦测啦！此时就会出现上述的问题。</p><h4 id="3、察看本机的网络联机与后门：-netstat"><a href="#3、察看本机的网络联机与后门：-netstat" class="headerlink" title="3、察看本机的网络联机与后门： netstat"></a>3、察看本机的网络联机与后门： netstat</h4><p>如果你觉得你的某个网络服务明明就启动了，但是就是无法造成联机的话，那么应该怎么办？首先你应该要查询一下自己的网络接口所监听的端口 (port) 来看看是否真的有启动，因为有时候屏幕上面显示的 [OK] 并不一定是 OK 啊！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# netstat -[rn] &lt;==与路由有关的参数</span><br><span class="line">[root@www ~]# netstat -[antulpc] &lt;==与网络接口有关的参数</span><br><span class="line">选项与参数：</span><br><span class="line">与路由 (route) 有关的参数说明：</span><br><span class="line">-r ：列出路由表(route table)，功能如同 route 这个指令；</span><br><span class="line">-n ：不使用主机名与服务名称，使用 IP 与 port number ，如同 route -n</span><br><span class="line">与网络接口有关的参数：</span><br><span class="line">-a ：列出所有的联机状态，包括 tcp/udp/unix socket 等；</span><br><span class="line">-t ：仅列出 TCP 封包的联机；</span><br><span class="line">-u ：仅列出 UDP 封包的联机；</span><br><span class="line">-l ：仅列出有在 Listen (监听) 的服务之网络状态；</span><br><span class="line">-p ：列出 PID 与 Program 的檔名；</span><br><span class="line">-c ：可以设定几秒钟后自动更新一次，例如 -c 5 每五秒更新一次网络状态的显示；</span><br><span class="line">（netstat -rn 与 route -n 是相同的。）</span><br></pre></td></tr></table></figure></p><blockquote><p>我们先来谈一谈关于网络联机状态的输出部分，他主要是分为底下几个大项：<br><strong>Proto：</strong>该联机的封包协议，主要为 TCP/UDP 等封包；<br><strong>Recv-Q：</strong>非由用户程序连接所复制而来的总 bytes 数；<br><strong>Send-Q：</strong>由远程主机所传送而来，但不具有 ACK 标志的总 bytes 数，意指主动联机 SYN 或其他标志的封包所占的 bytes 数；<br><strong>Local Address：</strong>本地端的地址，可以是 IP (-n 参数存在时)，也可以是完整的主机名。使用的格是就是『 IP:port 』只是 IP 的格式有 IPv4 及 IPv6 的差异。 如上所示，在 port 22 的接口中，使用的 :::22 就是针对 IPv6 的显示，事实上他就相同于 0.0.0.0:22 的意思。至于 port 25 仅针对 lo 接口开放，意指 Internet 基本上是无法连接到我本机的 25 埠口啦！<br><strong>Foreign Address：</strong>远程的主机 IP 与 port number<br><strong>stat：</strong>状态栏，主要的状态含有：<br>      ESTABLISED：已建立联机的状态；<br>      SYN_SENT：发出主动联机 (SYN 标志) 的联机封包；<br>      SYN_RECV：接收到一个要求联机的主动联机封包；<br>      FIN_WAIT1：该插槽服务(socket)已中断，该联机正在断线当中；<br>      FIN_WAIT2：该联机已挂断，但正在等待对方主机响应断线确认的封包；<br>      TIME_WAIT：该联机已挂断，但 socket 还在网络上等待结束；<br>      LISTEN：通常用在服务的监听 port ！可使用『 -l 』参数查阅。</p></blockquote><p>基本上，我们常常谈到的 netstat 的功能，就是在观察网络的联机状态了，而网络联机状态中，又以观察【我目前开了多少的 port 在等待客户端的联机】以及 【目前我的网络联机状态中，有多少联机已建立或产生问题】最常见。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、网络参数设定使用的指令&quot;&gt;&lt;a href=&quot;#一、网络参数设定使用的指令&quot; class=&quot;headerlink&quot; title=&quot;一、网络参数设定使用的指令&quot;&gt;&lt;/a&gt;一、网络参数设定使用的指令&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;ifconfig ：&lt;/strong&gt;查询、设定网络卡与 IP 网域等相关参数；&lt;br&gt;&lt;strong&gt;ifup, ifdown：&lt;/strong&gt;这两个档案是 script，透过更简单的方式来启动网络接口；&lt;br&gt;&lt;strong&gt;route ：&lt;/strong&gt;查询、设定路由表 (route table)&lt;br&gt;&lt;strong&gt;ip ：&lt;/strong&gt;复合式的指令，可以直接修改上述提到的功能；&lt;br&gt;&lt;em&gt;（先会使用 ifconfig, ifup , ifdown 与 route 即可，等以后有经验了之后，再继续回来玩 ip 这个好玩的指令。）&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
