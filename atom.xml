<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-04T10:37:00.792Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>接口文档说明</title>
    <link href="http://yoursite.com/2018/06/04/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/06/04/接口文档说明/</id>
    <published>2018-06-04T10:35:31.000Z</published>
    <updated>2018-06-04T10:37:00.792Z</updated>
    
    <content type="html"><![CDATA[<p>接口文档编写格式：</p><p>服务名称：<br>video-clip-repeat</p><p>需求概述：<br>很多视频是由相同片段重复播放合成，这种视频信息量低，用户观看体验差，检测出此类视频能有效降低feed、大搜等badcase。</p><p>核心功能：<br>检测出视频是否包含重复片段，如果包含则给出重复片段时间点。</p><p>错误码表：</p><table><thead><tr><th>错误码</th><th>错误信息</th><th>解释</th></tr></thead><tbody><tr><td>0</td><td>Success</td><td>成功</td></tr><tr><td>1</td><td>Failed to parse input json.</td><td>配置文件解析错误</td></tr><tr><td>2</td><td>Not found KEY:video_url in input json</td><td>json格式里没有video_url字段</td></tr><tr><td>3</td><td>Video_url value is NULL</td><td>video_url字段的内容为空</td></tr></tbody></table><p>返回信息格式：</p><table><thead><tr><th>参数</th><th>参数类型</th><th>必须</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>err_no</td><td>uint32</td><td>是</td><td>错误码</td><td>0正常，非零错误</td></tr><tr><td>err_msg</td><td>string</td><td>是</td><td>错误信息</td><td>参考错误码表</td></tr><tr><td>result</td><td>string</td><td>否</td><td></td><td>只在err_no为0时有结果</td></tr></tbody></table><p>接口名称：<br>1、接口地址：<br><a href="http://xxxx:8120/xxx" target="_blank" rel="noopener">http://xxxx:8120/xxx</a></p><p>2、HTTP方法：POST</p><p>3、请求参数：<br>格式：json</p><table><thead><tr><th>参数</th><th>类型</th><th>是否必选</th><th>说明     </th></tr></thead><tbody><tr><td>video_url</td><td>string</td><td>是</td><td>视频的url链接，必选参数，不能为空</td></tr><tr><td>type_name</td><td>string</td><td>是</td><td>固定值：video-clip-repeat</td></tr></tbody></table><p>4、输出参数：<br>格式：json</p><table><thead><tr><th>参数</th><th></th><th></th><th>类型</th><th>必须</th><th>说明     </th></tr></thead><tbody><tr><td>ratio</td><td></td><td></td><td>double</td><td>是</td><td>重复片段占视频时长的比例</td></tr><tr><td>video_time</td><td></td><td></td><td>string</td><td>是</td><td>视频总时长</td></tr><tr><td>result</td><td></td><td></td><td>json</td><td>是</td><td>列表列表里面是重复片段组的json</td></tr><tr><td></td><td>scopes</td><td></td><td>json</td><td>是</td><td>列表列表包含了每个重复片段的起始时间</td></tr><tr><td></td><td></td><td>start_time</td><td>string</td><td>是</td><td>片段起始时间，例如：”00:01:58”</td></tr><tr><td></td><td></td><td>end_time</td><td>string</td><td>是</td><td>片段终止时间，例如：”00:01:58”</td></tr></tbody></table><p>5、正确返回值示例：<br>{<br>    “log_id”: 2874085801,<br>    “words_result”: [{<br>        “location”: {<br>            “left”: 69,<br>            “top”: 35,<br>            “width”: 510,<br>            “height”: 100<br>        },<br>        “words”: “DOO”,<br>        “chars”: [{<br>            “location”: {<br>                “left”: 84,<br>                “top”: 40,<br>                “width”: 330,<br>                “height”: 90<br>            },<br>            “char”: “DOO”<br>        }]<br>    }],<br>    “words_result_num”: 1<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接口文档编写格式：&lt;/p&gt;
&lt;p&gt;服务名称：&lt;br&gt;video-clip-repeat&lt;/p&gt;
&lt;p&gt;需求概述：&lt;br&gt;很多视频是由相同片段重复播放合成，这种视频信息量低，用户观看体验差，检测出此类视频能有效降低feed、大搜等badcase。&lt;/p&gt;
&lt;p&gt;核心功能：&lt;b
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
      <category term="接口" scheme="http://yoursite.com/categories/PHP/%E6%8E%A5%E5%8F%A3/"/>
    
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>接口代码架构</title>
    <link href="http://yoursite.com/2018/06/04/%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2018/06/04/接口代码架构/</id>
    <published>2018-06-04T10:35:22.000Z</published>
    <updated>2018-06-04T10:39:01.765Z</updated>
    
    <content type="html"><![CDATA[<p>下面列出接口代码架构格式，不一定完全一致，大概满足需求即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">— InterfaceBase.php //接口基文件</span><br><span class="line">— InterfaceFactory.php     //接口工厂文件，即入口文件（按需求使用）</span><br><span class="line">— GoodInterface.php //商品接口基文件</span><br><span class="line">— CartInterface.php //购物车接口基文件</span><br><span class="line">— Output.php //定义错误码文件</span><br><span class="line">— ......//其它接口文件</span><br><span class="line">— api_1/// 1版本的接口文件夹</span><br><span class="line">— — Good.php   //商品接口文件</span><br><span class="line">— — Cart.php   //购物车接口文件</span><br><span class="line">— — ......   //其它接口文件</span><br><span class="line">— api_2///2版本的接口文件夹</span><br><span class="line">— — Good.php   //商品接口文件</span><br><span class="line">— — ......  //其它接口文件</span><br></pre></td></tr></table></figure></p><p>下面附属重要文件的代码格式，一般不需要改变。<br><a id="more"></a></p><h5 id="接口基文件：InterfaceBase-php"><a href="#接口基文件：InterfaceBase-php" class="headerlink" title="接口基文件：InterfaceBase.php"></a>接口基文件：InterfaceBase.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * @file InterfaceBase.php</span><br><span class="line"> * @author ***</span><br><span class="line"> * @date 2017/05/26</span><br><span class="line"> * @brief </span><br><span class="line"> *  </span><br><span class="line"> **/</span><br><span class="line">class Service_data_Ocr_Base_OcrBase &#123;</span><br><span class="line">    protected $_fixed_args = null;      //接口默认参数</span><br><span class="line">    protected $_args = null;            //接口处理参数</span><br><span class="line">    protected $_requestData;            //请求数据</span><br><span class="line">    protected $_resizeImage = null;     //压缩图片数据</span><br><span class="line">    protected $_ocrResizeFactor = 1.0;  //压缩因子</span><br><span class="line">    protected $_service_name = null;    //请求服务</span><br><span class="line">    protected $_appid = null;           //用户APPID</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *@param service name &amp; fixed args</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    public function __construct($service_name,$fixed_args) &#123;</span><br><span class="line">        $this-&gt;_service_name = $service_name;</span><br><span class="line">        $this-&gt;_fixed_args = $fixed_args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入口方法</span><br><span class="line">     *@param input param</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    public function run(&amp;$arrInput) &#123;</span><br><span class="line">        $this-&gt;_checkParams($arrInput);</span><br><span class="line">        $this-&gt;_buildRequest($arrInput);</span><br><span class="line">        $this-&gt;_appid = $arrInput[&apos;appid&apos;];</span><br><span class="line">        $rpcResponse = $this-&gt;_getResult();</span><br><span class="line">        $result = $this-&gt;_buildResponse($arrInput,$rpcResponse);</span><br><span class="line">        return $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 检测传入参数数据</span><br><span class="line">     *@param &amp;$arrInput input params from client</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    protected function _checkParams(&amp;$arrInput) &#123;</span><br><span class="line">        $ori_image_size = strlen($arrInput[&apos;image&apos;]);</span><br><span class="line">        $this-&gt;_checkImage($arrInput);</span><br><span class="line">        $resize_image_size = strlen($arrInput[&apos;image&apos;]);</span><br><span class="line">        if($resize_image_size !== $ori_image_size) &#123;</span><br><span class="line">            $this-&gt;_resizeImage = $arrInput[&apos;image&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对图片进行处理 （单独模块拉出来实现，避免一个方法的实现内容过长）</span><br><span class="line">     *@param &amp;$arrInput, $ocrResizeFactor</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    protected function _checkImage(&amp;$arrInput) &#123;</span><br><span class="line">        //对图片进行处理</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *@param &amp;$arrInput, $ocrResizeFactor</span><br><span class="line">     * @param: $refusedLen 直接拒绝图片尺寸阈值;$refusedSize 直接拒绝图片大小阈值;$minBoderLen: 直接拒绝的最小尺寸图片</span><br><span class="line">     * @param: $resizeLen 符合压缩图片的边长上限; $resizeSize 符合压缩条件的大小上限</span><br><span class="line">     * @param: $resizedSizeThread 压缩后图片是否请求后端的条件大小</span><br><span class="line">     * @return null</span><br><span class="line">     */</span><br><span class="line">    protected function _checkImageExtra(&amp;$arrInput, $refusedLen, $refusedSize, $resizeLen, $resizeSize, $resizedSizeThread, $minBoderLen = 15) &#123;</span><br><span class="line">        pass;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 单独接口处理请求参数，在每个接口中实现</span><br><span class="line">     *@param build args</span><br><span class="line">     *@return </span><br><span class="line">     */</span><br><span class="line">    protected function _buildArgs(&amp;$arrInput) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 整合请求参数数据</span><br><span class="line">     *@param arrInput</span><br><span class="line">     *@return</span><br><span class="line">     */</span><br><span class="line">    protected function _buildRequest(&amp;$arrInput) &#123;</span><br><span class="line">        $this-&gt;_buildArgs($arrInput);   //调用接口处理参数并返回处理结果</span><br><span class="line">        $appid = $arrInput[&apos;appid&apos;];</span><br><span class="line">        $requestData = array(</span><br><span class="line">            &apos;appid&apos; =&gt; $appid,</span><br><span class="line">            &apos;logid&apos; =&gt; intval(Bd_Log::genLogID()),</span><br><span class="line">            &apos;format&apos; =&gt; &apos;json&apos;,</span><br><span class="line">            &apos;from&apos; =&gt; &apos;openapi&apos;,</span><br><span class="line">            &apos;cmdid&apos; =&gt; &apos;123&apos;,</span><br><span class="line">            &apos;clientip&apos; =&gt; strval($_SERVER[&apos;HTTP_X_REAL_IP&apos;]),</span><br><span class="line">            &apos;data&apos; =&gt; base64_encode($this-&gt;_args),</span><br><span class="line">        );</span><br><span class="line">        $this-&gt;_requestData = $requestData;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向后端请求数据</span><br><span class="line">     *@param null</span><br><span class="line">     *@return ral response </span><br><span class="line">     */    </span><br><span class="line">    protected function  _getResult() &#123;</span><br><span class="line">        $service_name = $this-&gt;_service_name;</span><br><span class="line">        $arrayHeader = array(</span><br><span class="line">            &apos;pathinfo&apos;   =&gt; &apos;GeneralClassifyService/classify&apos;,</span><br><span class="line">            &apos;Content-Type&apos; =&gt; &apos;application/json&apos;,</span><br><span class="line">        );        </span><br><span class="line">        $arrayReturn = ral($service_name, &apos;post&apos;, $this-&gt;_requestData, *, $arrayHeader);</span><br><span class="line">        $intErrno = ral_get_errno();</span><br><span class="line">        $strErrmsg = ral_get_error();</span><br><span class="line">        if ($intErrno != 0) &#123;</span><br><span class="line">            Bd_Log::warning(&quot;get from ocr ral error.[$intErrno][$strErrmsg] from service_name[$service_name]&quot;);</span><br><span class="line">            throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_INTERNAL_ERROR);</span><br><span class="line">        &#125;        </span><br><span class="line">        return $arrayReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 整合数据并返回</span><br><span class="line">     *@param input params &amp; return from ral</span><br><span class="line">     *@return </span><br><span class="line">     */</span><br><span class="line">    protected function _buildResponse($arrInput,$arrayReturn) &#123;</span><br><span class="line">        Util::dealErrResponse($arrayReturn);        //处理错误输出</span><br><span class="line">        $decodedResult = base64_decode($arrayReturn[&apos;result&apos;]);</span><br><span class="line">        $result = json_decode($decodedResult, $assoc=true);</span><br><span class="line">        return $this-&gt;buildResponse($arrInput, $result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *@param arrInput, array        //用户传入数据</span><br><span class="line">     *@param ocrResult, array       //后端处理后数据</span><br><span class="line">     *@return openapiResult, array  //返回整合数组</span><br><span class="line">     */</span><br><span class="line">    protected function buildResponse(&amp;$arrInput, &amp;$ocrResult) &#123;</span><br><span class="line">        // 建立数据并返回</span><br><span class="line">        return $openapiResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接口工厂文件：InterfaceFactory-php"><a href="#接口工厂文件：InterfaceFactory-php" class="headerlink" title="接口工厂文件：InterfaceFactory.php"></a>接口工厂文件：InterfaceFactory.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line">* @file InterfaceFactory.php</span><br><span class="line">* @brief </span><br><span class="line">* @author ** *</span><br><span class="line">* @version </span><br><span class="line">* @date 2016-08-03</span><br><span class="line"> */</span><br><span class="line">class InterfaceFactory &#123;</span><br><span class="line">    /**</span><br><span class="line">     *@param arrInput</span><br><span class="line">     *@return object of Service_Data_InterfaceProxy</span><br><span class="line">     */</span><br><span class="line">    public static function create(&amp;$arrInput) &#123;</span><br><span class="line">        switch ($arrInput[&apos;openservice&apos;]) &#123;</span><br><span class="line">            case &apos;good&apos;:</span><br><span class="line">                switch ($arrInput[&apos;classify_type&apos;]) &#123;</span><br><span class="line">                    case &apos;clothing&apos;:</span><br><span class="line">                        if (strtolower($arrInput[&apos;version&apos;]) == &apos;v1&apos;) &#123;</span><br><span class="line">                            return new api_v1/ClothingInterface($arrInput);</span><br><span class="line">                        &#125;else &#123;</span><br><span class="line">                            return new api_v2/ClothingInterface($arrInput);</span><br><span class="line">                        &#125;</span><br><span class="line">                    case &apos;shoes&apos;:</span><br><span class="line">                        if (strtolower($arrInput[&apos;version&apos;]) == &apos;v2&apos;) &#123;</span><br><span class="line">                            return new api_v2/ShoesInterface($arrInput);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            return new api_v1/ShoesInterface($arrInput);</span><br><span class="line">                        &#125;</span><br><span class="line">                    default:</span><br><span class="line">                        throw new Exception(&apos;&apos;, Output::ERRNUM_METHOD_NOT_SUPPORT);</span><br><span class="line">                &#125;</span><br><span class="line">            case &apos;cart&apos;:</span><br><span class="line">                return new CartInterface($arrInput);</span><br><span class="line">            default:</span><br><span class="line">                try &#123;</span><br><span class="line">                    $className = ucfirst($arrInput[&apos;openservice&apos;]).&quot;Interface&quot;;</span><br><span class="line">                    $clazz = new ReflectionClass($className);</span><br><span class="line">                    return $clazz-&gt;newInstance($arrInput);</span><br><span class="line">                &#125; catch (Exception $e) &#123;</span><br><span class="line">                    throw new Exception(&apos;&apos;, Output::ERRNUM_METHOD_NOT_SUPPORT);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="商品接口文件：GoodInterface-php"><a href="#商品接口文件：GoodInterface-php" class="headerlink" title="商品接口文件：GoodInterface.php"></a>商品接口文件：GoodInterface.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @file GoodInterface.php</span><br><span class="line"> * @author ***</span><br><span class="line"> * @date 2017/11/16</span><br><span class="line"> * @brief </span><br><span class="line"> *  </span><br><span class="line"> **/</span><br><span class="line">class GoodInterface extends InterfaceBase &#123;</span><br><span class="line">    /*</span><br><span class="line">     *@param null</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    public function __construct() &#123;</span><br><span class="line">        $fixed_args = &quot;encoding=1&amp;recg_type=seq&amp;international=1&amp;save_img=true&quot;; //接口默认参数</span><br><span class="line">        parent::__construct(&quot;serverName&quot;,$fixed_args); //传入基文件数据</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户处理对应接口传入数据</span><br><span class="line">     *@param input params outside</span><br><span class="line">     *@return protected memerber:args</span><br><span class="line">     */    </span><br><span class="line">    protected function _buildArgs(&amp;$arrInput) &#123;</span><br><span class="line">        if($arrInput[&apos;object_type&apos;] == &apos;webimage_s1&apos;)&#123;</span><br><span class="line">            $this-&gt;_service_name = &apos;serverName01&apos;;</span><br><span class="line">            $object_type = &apos;webimage_v1&apos;;</span><br><span class="line">        &#125;else if($arrInput[&apos;object_type&apos;] == &apos;webimage_s2&apos;)&#123;</span><br><span class="line">            $this-&gt;_service_name = &apos;serverName01&apos;;</span><br><span class="line">            $object_type = &apos;webimage_v2&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        $args = Util::dealArgs($arrInput);</span><br><span class="line">        $this-&gt;_args = $this-&gt;_args . $args;</span><br><span class="line">        if(isset($arrInput[&apos;language_type&apos;]))&#123;</span><br><span class="line">            $this-&gt;_args = $this-&gt;_args . &quot;&amp;languagetype=CHN_ENG&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $image = $arrInput[&apos;image&apos;];</span><br><span class="line">        //组合处理参数，供请求函数调用</span><br><span class="line">        $this-&gt;_args = $this-&gt;_fixed_args . $this-&gt;_args . &quot;&amp;object_type=&quot; .$object_type. &quot;&amp;image=&quot; .$image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="购物车接口文件：CartInterface-php"><a href="#购物车接口文件：CartInterface-php" class="headerlink" title="购物车接口文件：CartInterface.php"></a>购物车接口文件：CartInterface.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * @file CartInterface.php</span><br><span class="line"> * @author ***</span><br><span class="line"> * @date 2018/3/9</span><br><span class="line"> * @brief </span><br><span class="line"> *  </span><br><span class="line"> **/</span><br><span class="line">class CartInterface extends InterfaceBase &#123;</span><br><span class="line">    /*</span><br><span class="line">     *@param null</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    public function __construct() &#123;</span><br><span class="line">        $fixed_args = &quot;&quot;;</span><br><span class="line">        parent::__construct(&quot;serverName&quot;,$fixed_args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     *@param input params outside</span><br><span class="line">     *@return protected memerber:args</span><br><span class="line">     */</span><br><span class="line">    protected function _buildArgs(&amp;$arrInput) &#123;</span><br><span class="line">        $image = $arrInput[&apos;image&apos;];</span><br><span class="line">        $this-&gt;_args = &quot;object_type=vat_invoice&amp;image=$image&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 接口自定义返回数据</span><br><span class="line">     *@param arrInput, array</span><br><span class="line">     *@param ocrResult, array</span><br><span class="line">     *@return openapiResult, array</span><br><span class="line">     */</span><br><span class="line">    protected function buildResponse(&amp;$arrInput, &amp;$ocrResult) &#123;</span><br><span class="line">        $words_result = $ocrResult[&apos;ret&apos;];</span><br><span class="line">        $words_result_num = count($words_result);</span><br><span class="line">        if($words_result_num == 0)&#123;</span><br><span class="line">            $words_result = array();</span><br><span class="line">        &#125;</span><br><span class="line">        return array(</span><br><span class="line">            &apos;words_result_num&apos; =&gt; $words_result_num,</span><br><span class="line">            &apos;words_result&apos; =&gt; $words_result</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="版本1对应的商品接口文件：Good-php"><a href="#版本1对应的商品接口文件：Good-php" class="headerlink" title="版本1对应的商品接口文件：Good.php"></a>版本1对应的商品接口文件：Good.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @file Good.php</span><br><span class="line"> * @author ***</span><br><span class="line"> * @date 2017/11/16</span><br><span class="line"> * @brief </span><br><span class="line"> *  </span><br><span class="line"> **/</span><br><span class="line">class Good extends GoodInterface &#123;</span><br><span class="line">    /*</span><br><span class="line">     *@param null</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    public function __construct() &#123; //根据需求可自定义修改</span><br><span class="line">        parent::__construct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户处理对应接口传入数据</span><br><span class="line">     *@param input params outside</span><br><span class="line">     *@return protected memerber:args</span><br><span class="line">     */    </span><br><span class="line">    protected function _buildArgs(&amp;$arrInput) &#123;</span><br><span class="line">        $this-&gt;_service_name = &apos;serverName03&apos;;</span><br><span class="line">        $object_type = &apos;webimage_v3&apos;;</span><br><span class="line">        $args = Util::dealArgs($arrInput);</span><br><span class="line">        $this-&gt;_args = $this-&gt;_args . $args;</span><br><span class="line">        if(isset($arrInput[&apos;language_type&apos;]))&#123;</span><br><span class="line">            $this-&gt;_args = $this-&gt;_args . &quot;&amp;languagetype=CHN_ENG&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        $image = $arrInput[&apos;image&apos;];</span><br><span class="line">        //组合处理参数，供请求函数调用</span><br><span class="line">        $this-&gt;_args = $this-&gt;_fixed_args . $this-&gt;_args . &quot;&amp;object_type=&quot; .$object_type. &quot;&amp;image=&quot; .$image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="输出错误整合文件：Output-php"><a href="#输出错误整合文件：Output-php" class="headerlink" title="输出错误整合文件：Output.php"></a>输出错误整合文件：Output.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * @author ***</span><br><span class="line"> * @description 输出http请求结果</span><br><span class="line"> */</span><br><span class="line">class Output &#123;</span><br><span class="line">    const ERROR_NO_INVALID_PARAM        = 1;    // 非法参数</span><br><span class="line">    const ERROR_NO_POST_RESPONSE_EMPTY  = 2;    // 后端返回为空</span><br><span class="line">    const ERROR_NO_POST_RESPONSE_ERROR  = 3;    // 后端返回错误</span><br><span class="line">    const ERROR_NO_MOLA_RESPONSE_ERROR  = 4;    // mola返回内容错误</span><br><span class="line">    const ERROR_NO_CACHE_RESPONSE_ERROR = 5;    // cache返回内容错误</span><br><span class="line"></span><br><span class="line">    private static $objTpl = null;                  // 模板对象实例</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param int Errornum to be translated</span><br><span class="line">     * @return string The translated string</span><br><span class="line">     * 根据错误码返回错误文字信息 </span><br><span class="line">     */</span><br><span class="line">    public static function findErrorMsg($intErrNo)</span><br><span class="line">    &#123;</span><br><span class="line">        switch($intErrNo) &#123;</span><br><span class="line">            case self::ERROR_NO_INVALID_PARAM:</span><br><span class="line">                return &apos;参数不合法&apos;;</span><br><span class="line">            case self::ERROR_NO_POST_RESPONSE_EMPTY:</span><br><span class="line">                return &apos;抱歉，后端数据返回为空&apos;;</span><br><span class="line">            case self::ERROR_NO_POST_RESPONSE_ERROR:</span><br><span class="line">                return &apos;抱歉，后端数据返回错误&apos;;</span><br><span class="line">            case self::ERROR_NO_MOLA_RESPONSE_ERROR:</span><br><span class="line">                return &apos;抱歉，MOLA数据返回错误&apos;;</span><br><span class="line">            case self::ERROR_NO_CACHE_RESPONSE_ERROR:</span><br><span class="line">                return &apos;抱歉，CACHE数据返回错误&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &apos;未知错误&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * 根据strCallbackName是否为空，返回json或者jsonp的错误结果</span><br><span class="line">     * @param string </span><br><span class="line">     * @param integer</span><br><span class="line">     * @param string</span><br><span class="line">     * @param array</span><br><span class="line">     * @param array</span><br><span class="line">     * @return </span><br><span class="line">     */</span><br><span class="line">    public static function showErrorJS(</span><br><span class="line">        $strCallbackName,</span><br><span class="line">        $intErrNo,</span><br><span class="line">        $strErrmsg = &apos;&apos;,</span><br><span class="line">        $arrData = array(),</span><br><span class="line">        $arrExtra = array()</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * 根据strCallbackName是否为空，返回json或者jsonp的成功结果</span><br><span class="line">     * @param string </span><br><span class="line">     * @param array</span><br><span class="line">     * @param array</span><br><span class="line">     * @return </span><br><span class="line">     **/</span><br><span class="line">    public static function showSuccessJS(</span><br><span class="line">        $strCallbackName,</span><br><span class="line">        $arrData,</span><br><span class="line">        $arrExtra = array()</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 返回显示错误信息的json </span><br><span class="line">     * @param integer</span><br><span class="line">     * @param string</span><br><span class="line">     * @param array</span><br><span class="line">     * @param array</span><br><span class="line">     * @return </span><br><span class="line">     */</span><br><span class="line">    public static function showErrorJSON($intErrNo, $strErrmsg = &apos;&apos;, $arrData = array(), $arrExtra = array())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回包含成功数据信息的json </span><br><span class="line">     * @param array</span><br><span class="line">     * @param array</span><br><span class="line">     * @return </span><br><span class="line">     */</span><br><span class="line">    public static function showSuccessJSON($arrData, $arrExtra = array())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回显示错误信息的jsonp</span><br><span class="line">     * @param string</span><br><span class="line">     * @param integer</span><br><span class="line">     * @param string</span><br><span class="line">     * @param array</span><br><span class="line">     * @param array</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static function showErrorJSONP(</span><br><span class="line">        $strCallbackName,</span><br><span class="line">        $intErrNo,</span><br><span class="line">        $strErrmsg = &apos;&apos;,</span><br><span class="line">        $arrData = array(),</span><br><span class="line">        $arrExtra = array()</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回包含成功数据信息的jsonp</span><br><span class="line">     * @param string</span><br><span class="line">     * @param array</span><br><span class="line">     * @param array</span><br><span class="line">     * @return </span><br><span class="line">     */</span><br><span class="line">    public static function showSuccessJSONP(</span><br><span class="line">        $strCallbackName,</span><br><span class="line">        $arrData,</span><br><span class="line">        $arrExtra = array()</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 显示模版</span><br><span class="line">     * @param string</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static function showSuccessPage($strTemplatePath)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 显示出错模版</span><br><span class="line">     * @param integer</span><br><span class="line">     * @param string</span><br><span class="line">     * @return </span><br><span class="line">     */</span><br><span class="line">    public static function showErrorPage($intErrNo, $strTemplatePath)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取模版对象</span><br><span class="line">     * @param</span><br><span class="line">     * @return object</span><br><span class="line">     */</span><br><span class="line">    public static function getTplInstance()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果url上带有debug=true参数，则输出所有模版变量；</span><br><span class="line">     * 如果还带有debugParam参数，则输出特定某一个变量</span><br><span class="line">     * @param</span><br><span class="line">     * @return bool</span><br><span class="line">     */</span><br><span class="line">    public static function makeDebug()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为openapi定制的输出格式</span><br><span class="line">     * @param array 未经处理的输出格式</span><br><span class="line">     * @param integer int64的日志号</span><br><span class="line">     * @return null</span><br><span class="line">     */</span><br><span class="line">    public static function printOpenapi($arrInput, $intLogid)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="公共处理函数：Util-php"><a href="#公共处理函数：Util-php" class="headerlink" title="公共处理函数：Util.php"></a>公共处理函数：Util.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * @file Util.php</span><br><span class="line"> * @author ***</span><br><span class="line"> * @date 2017/06/07 10:57:13</span><br><span class="line"> * @brief </span><br><span class="line"> *  </span><br><span class="line"> **/</span><br><span class="line">class Util &#123;</span><br><span class="line"></span><br><span class="line">    private static $OCR_PASSTHROUGH_PARAMS = array(</span><br><span class="line">        &apos;version&apos; =&gt; &apos;version&apos;,</span><br><span class="line">        &apos;auto_enhance&apos; =&gt; &apos;auto_enhance&apos;,</span><br><span class="line">        &apos;fromproduct&apos; =&gt; &apos;fromproduct&apos;,</span><br><span class="line">    ); </span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     *@param $arrayReturn </span><br><span class="line">     *@return ret</span><br><span class="line">     */</span><br><span class="line">    static public function dealErrResponse($arrayReturn)</span><br><span class="line">    &#123;</span><br><span class="line">        if($arrayReturn[&apos;err_no&apos;] == 0) return;</span><br><span class="line">        if ( $arrayReturn[&apos;err_no&apos;] == 5 ) &#123;</span><br><span class="line">            Bd_Log::addNotice(&apos;ocr_backend_error&apos;, &quot;[&quot; . $arrayReturn[&apos;err_no&apos;] . &quot;][&quot; . $arrayReturn[&apos;err_msg&apos;] . &quot;]&quot;);</span><br><span class="line">            $innerError = json_decode($arrayReturn[&apos;err_msg&apos;], $assoc=true);</span><br><span class="line">            if ( is_array($innerError) ) &#123;</span><br><span class="line">                switch (intval($innerError[&apos;errno&apos;])) &#123;</span><br><span class="line">                    case -1:</span><br><span class="line">                        throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_OCR_RECOGNIZE_UNKONWN_ERROR);</span><br><span class="line">                        break;</span><br><span class="line">                    case -2:</span><br><span class="line">                        throw new Exception(&apos;image too large&apos;, Service_Data_Output::ERRNUM_INVALID_IMGSIZE);</span><br><span class="line">                        break;</span><br><span class="line">                    case -3:</span><br><span class="line">                        throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_INVALID_IMAGE_FORMAT);</span><br><span class="line">                        break;</span><br><span class="line">                    case -4:</span><br><span class="line">                        throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_INVALID_IMAGE_FORMAT);</span><br><span class="line">                        break;</span><br><span class="line">                    case -5:</span><br><span class="line">                        throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_INTERNAL_ERROR);</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_UNKNOWN);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_UNKNOWN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ($arrayReturn[&apos;err_no&apos;] != 0) &#123;</span><br><span class="line">            Bd_Log::addNotice(&apos;ocr_backend_error&apos;, &quot;[&quot; . $arrayReturn[&apos;err_no&apos;] . &quot;][&quot; . $arrayReturn[&apos;err_msg&apos;] . &quot;]&quot;);</span><br><span class="line">            Bd_Log::warning(&quot;get from service error.[&quot; . $arrayReturn[&apos;err_no&apos;] . &quot;][&quot; . $arrayReturn[&apos;err_msg&apos;] . &quot;]&quot;);</span><br><span class="line">            throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_UNKNOWN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param $arrInput</span><br><span class="line">     * @return string</span><br><span class="line">     */</span><br><span class="line">    static public function dealArgs($arrInput)</span><br><span class="line">    &#123;</span><br><span class="line">        $args = &apos;&apos;;</span><br><span class="line">        ;</span><br><span class="line">        return $args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red">注：以上代码信息只做说明架构思想，所含信息内容可忽略。</font></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面列出接口代码架构格式，不一定完全一致，大概满足需求即可。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;— InterfaceBase.php 		//接口基文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— InterfaceFactory.php 	    //接口工厂文件，即入口文件（按需求使用）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— GoodInterface.php 		//商品接口基文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— CartInterface.php 		//购物车接口基文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— Output.php 				//定义错误码文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— ......					//其它接口文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— api_1/			// 1版本的接口文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— — Good.php 		  //商品接口文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— — Cart.php 		  //购物车接口文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— — ...... 			  //其它接口文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— api_2/			//2版本的接口文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— — Good.php 		  //商品接口文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— — ......			  //其它接口文件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下面附属重要文件的代码格式，一般不需要改变。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
      <category term="接口" scheme="http://yoursite.com/categories/PHP/%E6%8E%A5%E5%8F%A3/"/>
    
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Flask - SQLAlchemy 多条件模糊查询</title>
    <link href="http://yoursite.com/2018/04/23/Flask-SQLAlchemy-%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/"/>
    <id>http://yoursite.com/2018/04/23/Flask-SQLAlchemy-多条件模糊查询/</id>
    <published>2018-04-23T10:53:25.000Z</published>
    <updated>2018-04-23T10:55:33.902Z</updated>
    
    <content type="html"><![CDATA[<p>在做项目的时候，总会遇到搜索的需求，平常写SQL语句很简单。但是，在Flask 使用SQLAlchemy管理数据库的时候，应该如何使用，做了一下笔记，如下。</p><h4 id="一、使用SQLALchemy"><a href="#一、使用SQLALchemy" class="headerlink" title="一、使用SQLALchemy"></a>一、使用SQLALchemy</h4><p>一般的搜索都需要模糊查询，如果存在多条查询的需求，可如下操作：<br><code>users = User.query.filter(User.name.like(&quot;%&quot;+搜索的内容+&quot;%&quot;), User.age.like(&quot;%&quot;+搜索的内容+&quot;%&quot;)).all()</code></p><p>此种方式有一个弊端，就是不能 “or” 查询，只能 “and” 查询。<br>进行 “or” 查询，我的一个做法就是只能分开查询，然后合并数据即可。<br><a id="more"></a></p><h4 id="二、使用原生SQL操作"><a href="#二、使用原生SQL操作" class="headerlink" title="二、使用原生SQL操作"></a>二、使用原生SQL操作</h4><p>使用 session会话执行 SQL语句。（注：还有一种支持线程安全的方式，可使用 <code>scoped_session()</code>实现）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from app import db</span><br><span class="line"></span><br><span class="line">sql = &quot;SELECT * FROM `moviecol` \</span><br><span class="line">        LEFT JOIN `movie` ON moviecol.movie_id=movie.id \</span><br><span class="line">        LEFT JOIN `user` ON moviecol.user_id=user.id \</span><br><span class="line">        WHERE movie.title like &apos;%&quot;+keywords+&quot;%&apos; or user.name like &apos;%&quot;+keywords+&quot;%&apos; \</span><br><span class="line">        ORDER BY moviecol.addtime DESC \</span><br><span class="line">        LIMIT &quot;+str(page)+&quot;,&quot;+str(page_config[&apos;moviecol_per_page&apos;])</span><br><span class="line">res = db.session.execute(sql).fetchall()</span><br></pre></td></tr></table></figure></p><p>其中 Session类的相关方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public_methods = (</span><br><span class="line">    &apos;__contains__&apos;, &apos;__iter__&apos;, &apos;add&apos;, &apos;add_all&apos;, &apos;begin&apos;, &apos;begin_nested&apos;,</span><br><span class="line">    &apos;close&apos;, &apos;commit&apos;, &apos;connection&apos;, &apos;delete&apos;, &apos;execute&apos;, &apos;expire&apos;,</span><br><span class="line">    &apos;expire_all&apos;, &apos;expunge&apos;, &apos;expunge_all&apos;, &apos;flush&apos;, &apos;get_bind&apos;,</span><br><span class="line">    &apos;is_modified&apos;, &apos;bulk_save_objects&apos;, &apos;bulk_insert_mappings&apos;,</span><br><span class="line">    &apos;bulk_update_mappings&apos;,</span><br><span class="line">    &apos;merge&apos;, &apos;query&apos;, &apos;refresh&apos;, &apos;rollback&apos;,</span><br><span class="line">    &apos;scalar&apos;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做项目的时候，总会遇到搜索的需求，平常写SQL语句很简单。但是，在Flask 使用SQLAlchemy管理数据库的时候，应该如何使用，做了一下笔记，如下。&lt;/p&gt;
&lt;h4 id=&quot;一、使用SQLALchemy&quot;&gt;&lt;a href=&quot;#一、使用SQLALchemy&quot; class=&quot;headerlink&quot; title=&quot;一、使用SQLALchemy&quot;&gt;&lt;/a&gt;一、使用SQLALchemy&lt;/h4&gt;&lt;p&gt;一般的搜索都需要模糊查询，如果存在多条查询的需求，可如下操作：&lt;br&gt;&lt;code&gt;users = User.query.filter(User.name.like(&amp;quot;%&amp;quot;+搜索的内容+&amp;quot;%&amp;quot;), User.age.like(&amp;quot;%&amp;quot;+搜索的内容+&amp;quot;%&amp;quot;)).all()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此种方式有一个弊端，就是不能 “or” 查询，只能 “and” 查询。&lt;br&gt;进行 “or” 查询，我的一个做法就是只能分开查询，然后合并数据即可。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Python 标准模块之 uuiid</title>
    <link href="http://yoursite.com/2018/04/23/Python-%E6%A0%87%E5%87%86%E6%A8%A1%E5%9D%97%E4%B9%8B-uuiid/"/>
    <id>http://yoursite.com/2018/04/23/Python-标准模块之-uuiid/</id>
    <published>2018-04-23T10:52:51.000Z</published>
    <updated>2018-04-23T10:54:24.749Z</updated>
    
    <content type="html"><![CDATA[<p>uuid是128位的全局唯一标识符（univeral unique identifier），通常用32位的一个字符串的形式来表现。有时也称guid(global unique identifier)。python中自带了uuid模块来进行uuid的生成和管理工作。</p><p>python中的uuid模块基于信息如MAC地址、时间戳、命名空间、随机数、伪随机数来uuid。具体方法有如下几个：</p><blockquote><p><strong>uuid.getnode()：</strong>获取硬件地址为48位正整数。这是第一次运行，它可能会启动一个单独的程序，可能会很慢。如果所有尝试获取硬件地址都失败，我们选择一个随机的48位数字，其第8位设置为1，如RFC 4122中推荐的那样。“硬件地址”表示网络接口的MAC地址，以及具有多个网络接口可以返回其中任何一个的MAC地址。<br><strong>uuid.uuid1([ node [，clock_seq ] ])：</strong>从主机ID，序列号和当前时间生成一个UUID。如果 没有给出节点，getnode()则用于获取硬件地址。如果 给出clock_seq，它将用作序列号; 否则选择一个随机的14位序列号。（可以保证全球范围内的唯一性。但是可能会危害隐私，因为它会创建一个包含计算机网络地址的UUID。）<br><strong>uuid.uuid3(名称空间，名称)：</strong>根据名称空间标识（这是一个UUID）和一个名称（这是一个字符串）的MD5散列生成一个UUID。<br><strong>uuid.uuid4()：</strong>生成一个随机的UUID。（注：有一定概率重复的）<br><strong>uuid.uuid5 (名称空间，名称)：</strong>根据名称空间标识（这是一个UUID）和名称（它是一个字符串）的SHA-1散列生成一个UUID。（注：和uuid3基本相同，只不过采用的散列算法是sha1）</p></blockquote><a id="more"></a><p>该uuid模块定义了以下用于uuid3()或的名称空间标识符 uuid5()。</p><blockquote><p><strong>uuid.NAMESPACE_DNS</strong><br>当指定此名称空间时，名称字符串是完全限定的域名。<br><strong>uuid.NAMESPACE_URL</strong><br>当这个名字空间被指定时，名字字符串就是一个URL。<br><strong>uuid.NAMESPACE_OID</strong><br>当这个名字空间被指定时，名字字符串就是一个ISO OID。<br><strong>uuid.NAMESPACE_X500</strong><br>当指定此名称空间时，名称字符串是DER中的X.500 DN或文本输出格式。</p></blockquote><p>UUID 实例具有这些只读属性：</p><blockquote><p><strong>UUID.bytes</strong><br>UUID作为一个16字节的字符串（包含以big-endian字节顺序的六个整数字段）。<br><strong>UUID.bytes_le</strong><br>UUID作为16字节的字符串（以 little-endian字节顺序包含time_low，time_mid和time_hi_version）。<br><strong>UUID.fields</strong><br>UUID的六个整数字段的元组，它们也可用作六个单独的属性和两个派生属性：</p></blockquote><table><thead><tr><th>领域</th><th>含义</th></tr></thead><tbody><tr><td>time_low</td><td>UUID的前32位</td></tr><tr><td>time_mid</td><td>UUID的接下来的16位</td></tr><tr><td>time_hi_version</td><td>UUID的接下来的16位</td></tr><tr><td>clock_seq_hi_variant</td><td>UUID的接下来的8位</td></tr><tr><td>clock_seq_low</td><td>UUID的接下来的8位</td></tr><tr><td>node</td><td>UUID的最后48位</td></tr><tr><td>time</td><td>60位时间戳</td></tr><tr><td>clock_seq</td><td>14位序列号</td></tr></tbody></table><blockquote><p><strong>UUID.hex</strong><br>UUID作为32个字符的十六进制字符串。<br><strong>UUID.int</strong><br>UUID是一个128位整数。<br><strong>UUID.urn</strong><br>UUID作为RFC4122中规定的URN。<br><strong>UUID.variant</strong><br>UUID变体，它确定UUID的内部布局。这将是一个常量RESERVED_NCS，RFC_4122， RESERVED_MICROSOFT，或RESERVED_FUTURE。<br><strong>UUID.version</strong><br>UUID版本号（1到5，仅在变体时才有意义 RFC_4122）。</p></blockquote><p>以下是uuid模块典型用法的一些示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import uuid</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # make a UUID based on the host ID and current time</span><br><span class="line">&gt;&gt;&gt; uuid.uuid1()</span><br><span class="line">UUID(&apos;a8098c1a-f86e-11da-bd1a-00112444be1e&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # make a UUID using an MD5 hash of a namespace UUID and a name</span><br><span class="line">&gt;&gt;&gt; uuid.uuid3(uuid.NAMESPACE_DNS, &apos;python.org&apos;)</span><br><span class="line">UUID(&apos;6fa459ea-ee8a-3ca4-894e-db77e160355e&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # make a random UUID</span><br><span class="line">&gt;&gt;&gt; uuid.uuid4()</span><br><span class="line">UUID(&apos;16fd2706-8baf-433b-82eb-8c7fada847da&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # make a UUID using a SHA-1 hash of a namespace UUID and a name</span><br><span class="line">&gt;&gt;&gt; uuid.uuid5(uuid.NAMESPACE_DNS, &apos;python.org&apos;)</span><br><span class="line">UUID(&apos;886313e1-3b8a-5372-9b90-0c9aee199e5d&apos;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;uuid是128位的全局唯一标识符（univeral unique identifier），通常用32位的一个字符串的形式来表现。有时也称guid(global unique identifier)。python中自带了uuid模块来进行uuid的生成和管理工作。&lt;/p&gt;
&lt;p&gt;python中的uuid模块基于信息如MAC地址、时间戳、命名空间、随机数、伪随机数来uuid。具体方法有如下几个：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;uuid.getnode()：&lt;/strong&gt;获取硬件地址为48位正整数。这是第一次运行，它可能会启动一个单独的程序，可能会很慢。如果所有尝试获取硬件地址都失败，我们选择一个随机的48位数字，其第8位设置为1，如RFC 4122中推荐的那样。“硬件地址”表示网络接口的MAC地址，以及具有多个网络接口可以返回其中任何一个的MAC地址。&lt;br&gt;&lt;strong&gt;uuid.uuid1([ node [，clock_seq ] ])：&lt;/strong&gt;从主机ID，序列号和当前时间生成一个UUID。如果 没有给出节点，getnode()则用于获取硬件地址。如果 给出clock_seq，它将用作序列号; 否则选择一个随机的14位序列号。（可以保证全球范围内的唯一性。但是可能会危害隐私，因为它会创建一个包含计算机网络地址的UUID。）&lt;br&gt;&lt;strong&gt;uuid.uuid3(名称空间，名称)：&lt;/strong&gt;根据名称空间标识（这是一个UUID）和一个名称（这是一个字符串）的MD5散列生成一个UUID。&lt;br&gt;&lt;strong&gt;uuid.uuid4()：&lt;/strong&gt;生成一个随机的UUID。（注：有一定概率重复的）&lt;br&gt;&lt;strong&gt;uuid.uuid5 (名称空间，名称)：&lt;/strong&gt;根据名称空间标识（这是一个UUID）和名称（它是一个字符串）的SHA-1散列生成一个UUID。（注：和uuid3基本相同，只不过采用的散列算法是sha1）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python模块" scheme="http://yoursite.com/tags/Python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Flask 常见错误篇</title>
    <link href="http://yoursite.com/2018/04/16/Flask-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%AF%87/"/>
    <id>http://yoursite.com/2018/04/16/Flask-常见错误篇/</id>
    <published>2018-04-16T05:31:49.000Z</published>
    <updated>2018-04-23T10:55:47.365Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、在 admin/forms.py 表单文件中使用如下语句报错：</strong><br><code>auth_list = Auth.query.all()</code></p><p>报错信息，如下：</p><blockquote><p>RuntimeError: No application found. Either work inside a view function or push an application contex.</p></blockquote><p>报错信息意思是：没有找到应用程序。可以在视图函数内工作，也可以推动应用程序上下文。<br><a id="more"></a><br>因此，我们就要建立程序上下文，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.from_object(config[config_name])</span><br><span class="line">config[config_name].init_app(app)</span><br><span class="line"></span><br><span class="line">with app.app_context():</span><br><span class="line">db.init_app(app)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">return app</span><br></pre></td></tr></table></figure></p><p>就是在初始化的时候，添加 <code>app_context()</code> 上下文。</p><p><strong>2、元组赋值报错，如下：</strong></p><blockquote><p>TypeError: ‘NoneType’ object is not iterable</p></blockquote><p>这个错误提示一般发生在将None赋给多个值时。<br>在判断语句中，当if条件不满足，并且没有else语句时，函数默认返回None。<br>在没有return语句时，python也默认会返回None。<br>调用时，将None赋给多个值时，会出现提示：TypeError: ‘NoneType’ object is not iterable.</p><p><strong>3、模板中使用表单（wtf），报错如下：</strong></p><blockquote><p>TypeError: html_params() got multiple values for keyword argument ‘name’</p></blockquote><p>这个是由于表单中有一个变量为 “render_kw”，其值是键值对字典，且其键不能为 “name”。否则就报错！</p><p><strong>4、Flask 的 validate_on_submit() 老是false ??</strong><br>在 flask中提交表单时使用了validate_on_submit()来验证，但是每次提交时都是false，不知道什么原因啊？<br>但是只要把生成form表单的地方换成 quick_form自动生成，就正常了。<br>最后，通过上网搜索知道问题的原因了，就是CSRF的原因，直接在form里加上csrf_token就行了。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; form.csrf_token &#125;&#125;</span><br><span class="line">&#123;&#123; form.submit() &#125;&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1、在 admin/forms.py 表单文件中使用如下语句报错：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;auth_list = Auth.query.all()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;报错信息，如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RuntimeError: No application found. Either work inside a view function or push an application contex.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;报错信息意思是：没有找到应用程序。可以在视图函数内工作，也可以推动应用程序上下文。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask 使用session</title>
    <link href="http://yoursite.com/2018/04/16/Flask-%E4%BD%BF%E7%94%A8session/"/>
    <id>http://yoursite.com/2018/04/16/Flask-使用session/</id>
    <published>2018-04-16T05:30:53.000Z</published>
    <updated>2018-04-23T02:59:43.690Z</updated>
    
    <content type="html"><![CDATA[<p>1、首先安装session<br><code>pip install flask-session</code></p><p>2、引入框架中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from flask_session import Session</span><br><span class="line">sess = Session()</span><br><span class="line">sess.init_app(app)</span><br></pre></td></tr></table></figure></p><p>3、下面就可以在视图中使用引用使用了<br><code>from flask import session</code></p><a id="more"></a><p><strong>报错集锦：</strong></p><blockquote><p>Flask  session报下面错误：<br>RuntimeError: The session is unavailable because no secret key was set.  Set the secret_key on the application to something unique and secret.</p></blockquote><p>查找代码发现：<br>SERECT_KEY 已经设定。但是，仍然报此错误。原因是 SESSION_TYPE 未设置，如果不使用 内存缓存的话，可以使文件缓存。即：<br><code>SESSION_TYPE = &#39;filesystem&#39;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、首先安装session&lt;br&gt;&lt;code&gt;pip install flask-session&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、引入框架中&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;from flask_session import Session&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sess = Session()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sess.init_app(app)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3、下面就可以在视图中使用引用使用了&lt;br&gt;&lt;code&gt;from flask import session&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Python3 支持MySQL</title>
    <link href="http://yoursite.com/2018/04/16/Python3-%E6%94%AF%E6%8C%81MySQL/"/>
    <id>http://yoursite.com/2018/04/16/Python3-支持MySQL/</id>
    <published>2018-04-16T05:30:05.000Z</published>
    <updated>2018-04-16T05:34:26.838Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font color="red">注：MySQLdb 只适用于Python2.x，在Python3的替代品是：pymysql</font></blockquote><p>1、安装： pip install pymysql</p><p>一些框架默认仍然用的是MySQLdb，但是python3已经不支持MySQLdb，取而代之的是pymysql，因此运行的时候会报<br><code>ModuleNotFoundError: No module named &#39;MySQLdb&#39;</code></p><p>2、使用方式：</p><ol><li>安装成功后，可使用MySQLdb的语法使用pymysql</li><li>使用Flask集成的SQLAlchemy管理MySQL</li></ol><a id="more"></a><p>在框架中引入下面语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure></p><p>然后，在配置 <code>SQLALCHEMY_DATABASE_URI</code> 参数时，直接使用 mysql的使用方式即可。</p><blockquote><p>使用方式：<code>mysql://username:password@hostname/database</code></p></blockquote><p>3、生成对应数据表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python manage.py db init</span><br><span class="line">python manage.py db migrate</span><br><span class="line">python manage.py db upgrade</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;font color=&quot;red&quot;&gt;注：MySQLdb 只适用于Python2.x，在Python3的替代品是：pymysql&lt;/font&gt;

&lt;/blockquote&gt;
&lt;p&gt;1、安装： pip install pymysql&lt;/p&gt;
&lt;p&gt;一些框架默认仍然用的是MySQLdb，但是python3已经不支持MySQLdb，取而代之的是pymysql，因此运行的时候会报&lt;br&gt;&lt;code&gt;ModuleNotFoundError: No module named &amp;#39;MySQLdb&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、使用方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装成功后，可使用MySQLdb的语法使用pymysql&lt;/li&gt;
&lt;li&gt;使用Flask集成的SQLAlchemy管理MySQL&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 和 Socket 的区别</title>
    <link href="http://yoursite.com/2018/04/10/HTTP-%E5%92%8C-Socket-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/04/10/HTTP-和-Socket-的区别/</id>
    <published>2018-04-10T10:29:35.000Z</published>
    <updated>2018-04-10T10:53:34.084Z</updated>
    
    <content type="html"><![CDATA[<p>要弄明白 http 和 socket 首先要熟悉网络七层：物 数 网 传 会 表 应，如下图<br><img src="/uploads/2018/04/network_protocol.jpg" alt=""><br><a id="more"></a></p><blockquote><p><strong>HTTP 协议：</strong>超文本传输协议，对应于应用层，用于如何封装数据.<br><strong>TCP/UDP 协议：</strong>传输控制协议，对应于传输层，主要解决数据在网络中的传输。<br><strong>IP 协议：</strong>对应于网络层，同样解决数据在网络中的传输。</p></blockquote><p>传输数据的时候只使用 TCP/IP 协议(传输层)，如果没有应用层来识别数据内容，传输后的协议都是无用的。<br>应用层协议很多 FTP,HTTP,TELNET等，也可以自己定义应用层协议。<br>web 使用 HTTP 作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议，将数据发送到网络上。</p><h4 id="一、HTTP-连接"><a href="#一、HTTP-连接" class="headerlink" title="一、HTTP 连接"></a>一、HTTP 连接</h4><p>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</p><p>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，即使用的是<font color="red">“请求-响应”方式</font>。在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。即是<font color="red">“无状态”</font>的协议。</p><ul><li>1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</li><li>2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</li></ul><p><strong>http 为短连接：</strong>由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”。通常要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p><h4 id="二、Socket-连接"><a href="#二、Socket-连接" class="headerlink" title="二、Socket 连接"></a>二、Socket 连接</h4><p>要想明白 Socket，必须要理解 TCP 连接。<br>TCP 三次握手：握手过程中并不传输数据，在握手后服务器与客户端才开始传输数据，理想状态下，TCP 连接一旦建立，在通讯双方中的任何一方主动断开连接之前 TCP 连接会一直保持下去。</p><p>Socket 是对 TCP/IP 协议的封装，<font color="red">Socket 只是个接口不是协议，</font>通过 Socket 我们才能使用 TCP/IP 协议，除了 TCP，也可以使用 UDP 协议来传递数据。</p><p>创建 Socket 连接的时候，可以指定传输层协议，可以是 TCP 或者 UDP，当用 TCP 连接，该Socket就是个TCP连接，反之。</p><p>Socket 连接,至少需要一对套接字，分为 clientSocket，serverSocket。连接分为3个步骤：服务器监听、客户端请求、连接确认。<br><strong>Socket 为长连接：</strong>通常情况下Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立,通讯双方开始互发数据内容，直到双方断开连接。在实际应用中，由于网络节点过多，在传输过程中，会被节点断开连接，因此要通过轮询高速网络，该节点处于活跃状态。</p><p>很多情况下，都是需要服务器端向客户端主动推送数据，保持客户端与服务端的实时同步。</p><ul><li>若双方是 Socket 连接，可以由服务器直接向客户端发送数据。</li><li>若双方是 HTTP 连接，则服务器需要等客户端发送请求后，才能将数据回传给客户端。因此，客户端定时向服务器端发送请求，不仅可以保持在线，同时也询问服务器是否有新数据，如果有就将数据传给客户端。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要弄明白 http 和 socket 首先要熟悉网络七层：物 数 网 传 会 表 应，如下图&lt;br&gt;&lt;img src=&quot;/uploads/2018/04/network_protocol.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 详解</title>
    <link href="http://yoursite.com/2018/04/10/HTTP-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/10/HTTP-详解/</id>
    <published>2018-04-10T08:23:25.000Z</published>
    <updated>2018-04-10T10:29:02.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础概念篇"><a href="#一、基础概念篇" class="headerlink" title="一、基础概念篇"></a>一、基础概念篇</h3><h4 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。</p><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p><p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。<br><a id="more"></a></p><h4 id="2、在TCP-IP协议栈中的位置"><a href="#2、在TCP-IP协议栈中的位置" class="headerlink" title="2、在TCP/IP协议栈中的位置"></a>2、在TCP/IP协议栈中的位置</h4><p>HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：<br><img src="/uploads/2018/04/network_http_01.jpg" alt=""><br>默认HTTP的端口号为80，HTTPS的端口号为443。</p><h4 id="3、HTTP的请求响应模型"><a href="#3、HTTP的请求响应模型" class="headerlink" title="3、HTTP的请求响应模型"></a>3、HTTP的请求响应模型</h4><p>HTTP协议永远都是客户端发起请求，服务器回送响应。见下图：<br><img src="/uploads/2018/04/network_http_02.jpg" alt=""><br>这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。<br>HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。</p><h4 id="4、工作流程"><a href="#4、工作流程" class="headerlink" title="4、工作流程"></a>4、工作流程</h4><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><blockquote><p>1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。<br>2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。<br>3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。<br>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p></blockquote><p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p><h4 id="5、客户端一个请求流程（详细版）"><a href="#5、客户端一个请求流程（详细版）" class="headerlink" title="5、客户端一个请求流程（详细版）"></a>5、客户端一个请求流程（详细版）</h4><p>待补充。。。</p><h3 id="二、协议详解篇"><a href="#二、协议详解篇" class="headerlink" title="二、协议详解篇"></a>二、协议详解篇</h3><h4 id="1、HTTP-1-0-与-HTTP-1-1-比较"><a href="#1、HTTP-1-0-与-HTTP-1-1-比较" class="headerlink" title="1、HTTP/1.0 与 HTTP/1.1 比较"></a>1、HTTP/1.0 与 HTTP/1.1 比较</h4><table><thead><tr><th>异同点</th><th>HTTP/1.0</th><th>HTTP/1.1</th></tr></thead><tbody><tr><td>建立连接方面</td><td>连接不能复用</td><td>可复用，减少TCP三次握手的开销</td></tr><tr><td>请求方式</td><td>GET、POST、HEAD</td><td>GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE、CONNECT</td></tr><tr><td>Request消息头</td><td></td><td>新增Host域 </td></tr></tbody></table><h4 id="2、HTTP请求消息"><a href="#2、HTTP请求消息" class="headerlink" title="2、HTTP请求消息"></a>2、HTTP请求消息</h4><h5 id="（1）请求消息格式"><a href="#（1）请求消息格式" class="headerlink" title="（1）请求消息格式"></a>（1）请求消息格式</h5><p>HTTP请求消息实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /hello.htm HTTP/1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-cn</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">If-Modified-Since: Wed, 17 Oct 2007 02:15:55 GMT</span><br><span class="line">If-None-Match: W/&quot;158-1192587355000&quot;</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)</span><br><span class="line">Host: 192.168.2.162:8080</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure></p><p>请求消息格式如下所示：</p><blockquote><p>请求行<br>通用信息头|请求头|实体头<br>CRLF(回车换行)<br>实体内容</p></blockquote><p>其中“请求行”为：请求行 = 方法 [空格] 请求URI [空格] 版本号 [回车换行]</p><h5 id="（2）请求方法"><a href="#（2）请求方法" class="headerlink" title="（2）请求方法"></a>（2）请求方法</h5><p>HTTP的请求方法包括如下几种：<br>GET | POST | HEAD | PUT | DELETE | OPTIONS | TRACE | CONNECT</p><h4 id="3、HTTP响应消息"><a href="#3、HTTP响应消息" class="headerlink" title="3、HTTP响应消息"></a>3、HTTP响应消息</h4><h5 id="（1）响应消息格式"><a href="#（1）响应消息格式" class="headerlink" title="（1）响应消息格式"></a>（1）响应消息格式</h5><p>HTTP响应消息实例如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">ETag: W/&quot;158-1192590101000&quot;</span><br><span class="line">Last-Modified: Wed, 17 Oct 2007 03:01:41 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 158</span><br><span class="line">Date: Wed, 17 Oct 2007 03:01:59 GMT</span><br><span class="line">Server: Apache-Coyote/1.1</span><br></pre></td></tr></table></figure></p><p>HTTP响应消息的格式如下所示：</p><blockquote><p>状态行<br>通用信息头|响应头|实体头<br>CRLF<br>实体内容</p></blockquote><p>其中：状态行 = 版本号 [空格] 状态码 [空格] 原因 [回车换行]</p><h5 id="（2）响应状态码"><a href="#（2）响应状态码" class="headerlink" title="（2）响应状态码"></a>（2）响应状态码</h5><p><strong>1**：请求收到，继续处理</strong><br>100——客户必须继续发出请求<br>101——客户要求服务器根据请求转换HTTP协议版本</p><p><strong>2**：操作成功收到，分析、接受</strong></p><font color="red">200——交易成功</font><br>201——提示知道新文件的URL<br>202——接受和处理、但处理未完成<br>203——返回信息不确定或不完整<br>204——请求收到，但返回信息为空<br>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br>206——服务器已经完成了部分用户的GET请求<br><br><strong>3**：完成此请求必须进一步处理</strong><br>300——请求的资源可在多处得到<br><font color="red">301——删除请求数据</font><br>302——在其他地址发现了请求数据<br>303——建议客户访问其他URL或访问方式<br>304——客户端已经执行了GET，但文件未变化<br>305——请求的资源必须从服务器指定的地址得到<br>306——前一版本HTTP中使用的代码，现行版本中不再使用<br>307——申明请求的资源临时性删除<br><br><strong>4**：请求包含一个错误语法或不能完成</strong><br><font color="red">400——错误请求，如语法错误</font><br><font color="red">401——未授权</font><br>HTTP 401.1 - 未授权：登录失败<br>　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败<br>　　HTTP 401.3 - ACL 禁止访问资源<br>　　HTTP 401.4 - 未授权：授权被筛选器拒绝<br>　　HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败<br>402——保留有效ChargeTo头响应<br><font color="red">403——禁止访问</font><br>HTTP 403.1 禁止访问：禁止可执行访问<br>　　HTTP 403.2 - 禁止访问：禁止读访问<br>　　HTTP 403.3 - 禁止访问：禁止写访问<br>　　HTTP 403.4 - 禁止访问：要求 SSL<br>　　HTTP 403.5 - 禁止访问：要求 SSL 128<br>　　HTTP 403.6 - 禁止访问：IP 地址被拒绝<br>　　HTTP 403.7 - 禁止访问：要求客户证书<br>　　HTTP 403.8 - 禁止访问：禁止站点访问<br>　　HTTP 403.9 - 禁止访问：连接的用户过多<br>　　HTTP 403.10 - 禁止访问：配置无效<br>　　HTTP 403.11 - 禁止访问：密码更改<br>　　HTTP 403.12 - 禁止访问：映射器拒绝访问<br>　　HTTP 403.13 - 禁止访问：客户证书已被吊销<br>　　HTTP 403.15 - 禁止访问：客户访问许可过多<br>　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效<br>　　HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效<br><font color="red">404——没有发现文件、查询或URl</font><br>405——用户在Request-Line字段定义的方法不允许<br>406——根据用户发送的Accept拖，请求资源不可访问<br>407——类似401，用户必须首先在代理服务器上得到授权<br>408——客户端没有在用户指定的饿时间内完成请求<br>409——对当前资源状态，请求不能完成<br>410——服务器上不再有此资源且无进一步的参考地址<br>411——服务器拒绝用户定义的Content-Length属性请求<br>412——一个或多个请求头字段在当前请求中错误<br>413——请求的资源大于服务器允许的大小<br>414——请求的资源URL长于服务器允许的长度<br>415——请求资源不支持请求项目格式<br>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段<br>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。<br><br><strong>5**：服务器执行一个完全有效请求失败</strong><br><font color="red">HTTP 500 - 内部服务器错误</font><br>　　HTTP 500.100 - 内部服务器错误 - ASP 错误<br>　　HTTP 500-11 服务器关闭<br>　　HTTP 500-12 应用程序重新启动<br>　　HTTP 500-13 - 服务器太忙<br>　　HTTP 500-14 - 应用程序无效<br>　　HTTP 500-15 - 不允许请求 global.asa<br>Error 501 - 未实现<br><font color="red">HTTP 502 - 网关错误</font><h4 id="4、请求头："><a href="#4、请求头：" class="headerlink" title="4、请求头："></a>4、请求头：</h4><p>HTTP最常见的请求头如下：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Accept：</td><td>浏览器可接受的MIME类型；</td></tr><tr><td>Accept-Charset：</td><td>浏览器可接受的字符集；</td></tr><tr><td>Accept-Encoding：</td><td>浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间；</td></tr><tr><td>Accept-Language：</td><td>浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到；</td></tr><tr><td>Authorization：</td><td>授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中；</td></tr><tr><td>Connection：</td><td>表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小；</td></tr><tr><td>Content-Length：</td><td>表示请求消息正文的长度；</td></tr><tr><td>Cookie：</td><td>这是最重要的请求头信息之一；</td></tr><tr><td>From：</td><td>请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它；</td></tr><tr><td>Host：</td><td>初始URL中的主机和端口；</td></tr><tr><td>If-Modified-Since：</td><td>只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答；</td></tr><tr><td>Pragma：</td><td>指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；</td></tr><tr><td>Referer：</td><td>包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</td></tr></tbody></table><p>User-Agent：            | 浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用；<br>UA-Pixels，UA-Color，UA-OS，UA-CPU： | 由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</p><h4 id="5、响应头："><a href="#5、响应头：" class="headerlink" title="5、响应头："></a>5、响应头：</h4><p>HTTP最常见的响应头如下所示：</p><style type="text/css">    table th:first-of-type{        width: 24%;    }</style><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Allow：</td><td>服务器支持哪些请求方法（如GET、POST等）；</td></tr><tr><td>Content-Encoding：</td><td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即<code>request.getHeader(&quot;Accept-Encoding&quot;)</code>）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面；</td></tr><tr><td>Content-Length：</td><td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过<code>byteArrayStream.writeTo(response.getOutputStream()</code>发送内容；</td></tr><tr><td>Content-Type：</td><td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和MIME类型的对应关系；</td></tr><tr><td>Date：</td><td>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦；</td></tr><tr><td>Expires：</td><td>指明应该在什么时候认为文档已经过期，从而不再缓存它。</td></tr><tr><td>Last-Modified：</td><td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置；</td></tr><tr><td>Location：</td><td>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302；</td></tr><tr><td>Refresh：</td><td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过<code>setHeader(&quot;Refresh&quot;, &quot;5; URL=http://host/path&quot;)</code>让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的<code>&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;5;URL=http://host/path&quot;&gt;</code>实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是<meta http-equiv="Refresh" ...="">。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td></tr></tbody></table><h4 id="6、实体头"><a href="#6、实体头" class="headerlink" title="6、实体头"></a>6、实体头</h4><p>实体头用坐实体内容的元信息，描述了实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Allow：</td><td>GET,POST</td></tr><tr><td>Content-Encoding：</td><td>文档的编码（Encode）方法，例如：gzip，见“2.5 响应头”；</td></tr><tr><td>Content-Language：</td><td>内容的语言类型，例如：zh-cn；</td></tr><tr><td>Content-Length：</td><td>表示内容长度，eg：80，可参考“2.5响应头”；</td></tr><tr><td>Content-Location：</td><td>表示客户应当到哪里去提取文档，例如：<code>http://www.dfdf.org/</code>dfdf.html，可参考“2.5响应头”；</td></tr><tr><td>Content-MD5：</td><td>MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。Eg1：Content-MD5: <base64 128="" of="" md5="" digest="">。Eg2：dfdfdfdfdfdfdff==；</base64></td></tr><tr><td>Content-Range：</td><td>随部分实体一同发送；标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。Eg1：Content-Range: 1001-2000/5000，eg2：bytes 2543-4532/7898</td></tr><tr><td>Content-Type：</td><td>标明发送或者接收的实体的MIME类型。Eg：text/html; charset=GB2312       主类型/子类型；</td></tr><tr><td>Expires：</td><td>为0证明不缓存；</td></tr><tr><td>Last-Modified：</td><td>WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT.</td></tr></tbody></table><h4 id="7、扩展头"><a href="#7、扩展头" class="headerlink" title="7、扩展头"></a>7、扩展头</h4><p>在HTTP消息中，也可以使用一些再HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头，他们通常被当作是一种实体头处理。</p><p>现在流行的浏览器实际上都支持Cookie,Set-Cookie,Refresh和Content-Disposition等几个常用的扩展头字段。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Refresh：1;<code>url=http://www.dfdf.org</code></td><td>//过1秒跳转到指定位置；</td></tr><tr><td>Content-Disposition：</td><td>头字段,可参考“2.5响应头”；</td></tr><tr><td>Content-Type：</td><td>WEB 服务器告诉浏览器自己响应的对象的类型。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、基础概念篇&quot;&gt;&lt;a href=&quot;#一、基础概念篇&quot; class=&quot;headerlink&quot; title=&quot;一、基础概念篇&quot;&gt;&lt;/a&gt;一、基础概念篇&lt;/h3&gt;&lt;h4 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h4&gt;&lt;p&gt;HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。&lt;/p&gt;
&lt;p&gt;HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。&lt;/p&gt;
&lt;p&gt;HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>socket 详解</title>
    <link href="http://yoursite.com/2018/04/10/socket-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/10/socket-详解/</id>
    <published>2018-04-10T08:13:54.000Z</published>
    <updated>2018-04-10T10:11:47.416Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、网络中进程之间是如何通信？"><a href="#1、网络中进程之间是如何通信？" class="headerlink" title="1、网络中进程之间是如何通信？"></a>1、网络中进程之间是如何通信？</h4><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC）</li></ul><p>在本地我们通过进程 PID 来唯一标识一个进程，但是在网络中是行不通的。而 TCP/IP 协议簇帮我们解决了这个问题，<font color="red">网络层的“IP地址”</font>可以唯一标识网络中的主机，<font color="red">传输层的“协议+端口”</font>可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址、协议、端口）就可以标识网络中的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p><a id="more"></a><h4 id="2、什么是socket"><a href="#2、什么是socket" class="headerlink" title="2、什么是socket"></a>2、什么是socket</h4><p>那什么是socket呢？其实，Socket 就是编程接口（API），是对 TCP/IP 的封装，对外提供的接口。网络中进程间通信采用的就是 socket（套接字）。<br>看下图即可明白 socket：<br><img src="/uploads/2018/04/linux_socket_04.png" alt="" title="图1"><br><img src="/uploads/2018/04/linux_socket_03.png" alt="" title="图2"></p><blockquote><p>几种典型的应用编程接口：</p><ul><li>Berkeley UNIX 操作系统定义了一种 API，称为套接字接口（socket Interface），简称<font color="red">套接字（socket）</font>。</li><li>微软公司在其操作系统中采用了套接字接口 API，形成了一个稍有不同的 API，并称为 Windows Socket Interface，<font color="red">WINSOCK</font>。</li><li>AT&amp;T 为其 UNIX 系统 V 定义了一种 API，简写为 <font color="red">TLI</font>（Transport Layer Interface）(已经被淘汰了)。</li></ul></blockquote><h4 id="3、套接字（socket）概念"><a href="#3、套接字（socket）概念" class="headerlink" title="3、套接字（socket）概念"></a>3、套接字（socket）概念</h4><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p><p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，<strong>许多计算机操作系统为应用程序与TCP／IP协议交互提供了</strong><font color="red">套接字(Socket)接口</font>（由图2可看出来）。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><h4 id="4、socket原理"><a href="#4、socket原理" class="headerlink" title="4、socket原理"></a>4、socket原理</h4><p>要想明白 Socket，必须要理解TCP连接。</p><blockquote><p>建立TCP连接的“三次握手”：</p><ul><li><strong>第一次：</strong>客户端向服务器发送SYN包(syn=j)，同时自己处于SYN_SEND状态。</li><li><strong>第二次：</strong>服务器端收到SYN包后，必须确认客户的SYN(syn=j+1)，同时也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态。</li><li><strong>第三次：</strong>客户端收到服务器发来的SYN+ACK包，就向服务器发送SYN(syn=k+1)，发送完毕后，服务器和客户端都进入ESTABLISHED状态。完成三次握手。</li></ul></blockquote><p>握手过程中，并不传输数据。在握手后，服务器与客户端才开始传输数据，理想状态下，TCP连接一旦建立，在通讯双方中的任何一方主动断开连接之前，TCP连接会一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”。</p><h5 id="（1）socket-连接"><a href="#（1）socket-连接" class="headerlink" title="（1）socket 连接"></a>（1）socket 连接</h5><p>Socket连接，至少需要一对套接字，分为 clientSocket，serverSocket。连接分为3个步骤：</p><ul><li><strong>服务器监听：</strong>服务器并不定位具体客户端的套接字，而是时刻处于监听状态。</li><li><strong>客户端请求：</strong>客户端的套接字要描述它要连接的服务器的套接字。提供地址和端口号，然后向服务器套接字提出连接请求。</li><li><strong>连接确认：</strong>当服务器套接字收到客户端套接字发来的请求后，就响应客户端套接字的请求，并建立一个新的线程，把服务器端的套接字的描述发给客户端，一旦客户端确认了此描述，就正式建立连接。而服务器套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li></ul><p>创建Socket连接的时候，可以指定传输层协议。可以是TCP或者UDP，当用TCP连接，该Socket就是个TCP连接。</p><h5 id="（2）socket-函数"><a href="#（2）socket-函数" class="headerlink" title="（2）socket 函数"></a>（2）socket 函数</h5><p>Socket接口对外提供的函数如下：</p><style type="text/css">    table th:first-of-type{        width: 15%;    }</style><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>socket</td><td>创建套接字 </td></tr><tr><td>connect</td><td>“连接”远端服务器（仅用于客户端）</td></tr><tr><td>closesocket</td><td>释放/关闭套接字</td></tr><tr><td>bind</td><td>绑定套接字的本地IP地址和端口号（通常客户端不需要）</td></tr><tr><td>listen</td><td>配置服务端TCP套接字为监听模式，并设置队列大小（仅用于服务器端TCP套接字）</td></tr><tr><td>accept</td><td>接受/提取一个连接请求，创建新套接字，通过新套接（仅用于服务器端的TCP套接字）</td></tr><tr><td>recv</td><td>接收数据（用于TCP套接字或连接模式的客户端UDP套接字）</td></tr><tr><td>recvfrom</td><td>接收数据报（用于非连接模式的UDP套接字）</td></tr><tr><td>send</td><td>发送数据（用于TCP套接字或连接模式的客户端UDP套接字）</td></tr><tr><td>sendto</td><td>发送数据报（用于非连接模式的UDP套接字）</td></tr><tr><td>setsockopt</td><td>设置套接字选项参数</td></tr><tr><td>getsockopt</td><td>获取套接字选项参数</td></tr></tbody></table><h5 id="（3）socket-调用流程"><a href="#（3）socket-调用流程" class="headerlink" title="（3）socket 调用流程"></a>（3）socket 调用流程</h5><p><img src="/uploads/2018/04/linux_socket_05.png" alt=""></p><h5 id="（4）socket-管理"><a href="#（4）socket-管理" class="headerlink" title="（4）socket 管理"></a>（4）socket 管理</h5><p>通过 Socket描述符表来进行管理，每个进程中有一个描述符表。当应用进程创建套接字时，操作系统分配一个数据结构存储该套接字相关信息。如下图所示：<br><img src="/uploads/2018/04/linux_socket_02.png" alt=""></p><h5 id="（5）并发面向连接服务器基本流程"><a href="#（5）并发面向连接服务器基本流程" class="headerlink" title="（5）并发面向连接服务器基本流程"></a>（5）并发面向连接服务器基本流程</h5><p><img src="/uploads/2018/04/linux_socket_01.png" alt=""><br><strong>主线程1：</strong>创建（主）套接字，并绑定熟知端口号；<br><strong>主线程2：</strong>创建（主）套接字为被动监听模式，准备用于服务器；<br><strong>主线程3：</strong>反复调用accept() 函数接收下一个<font color="red">连接请求</font>（通过主套接字），并创建一个新的子线程处理该客户端响应；<br><strong>子线程1：</strong>接收一个客户端的<font color="red">服务请求</font>（通过新创建的套接字）；<br><strong>子线程2：</strong>遵循应用层协议与特定客户进行交互；<br><strong>子线程3：</strong>关闭/释放连接并推出（线程终止）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、网络中进程之间是如何通信？&quot;&gt;&lt;a href=&quot;#1、网络中进程之间是如何通信？&quot; class=&quot;headerlink&quot; title=&quot;1、网络中进程之间是如何通信？&quot;&gt;&lt;/a&gt;1、网络中进程之间是如何通信？&lt;/h4&gt;&lt;p&gt;本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息传递（管道、FIFO、消息队列）&lt;/li&gt;
&lt;li&gt;同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）&lt;/li&gt;
&lt;li&gt;共享内存（匿名的和具名的）&lt;/li&gt;
&lt;li&gt;远程过程调用（Solaris门和Sun RPC）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本地我们通过进程 PID 来唯一标识一个进程，但是在网络中是行不通的。而 TCP/IP 协议簇帮我们解决了这个问题，&lt;font color=&quot;red&quot;&gt;网络层的“IP地址”&lt;/font&gt;可以唯一标识网络中的主机，&lt;font color=&quot;red&quot;&gt;传输层的“协议+端口”&lt;/font&gt;可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址、协议、端口）就可以标识网络中的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置文件详解</title>
    <link href="http://yoursite.com/2018/04/09/Nginx-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/09/Nginx-配置文件详解/</id>
    <published>2018-04-09T10:09:58.000Z</published>
    <updated>2018-04-09T10:16:49.607Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、结构分析"><a href="#1、结构分析" class="headerlink" title="1、结构分析"></a>1、结构分析</h4><p>nginx配置文件中主要包括六块：main，events，http，server，location，upstream<br>结构如下图：</p><ul><li><strong>main块：</strong>主要控制nginx子进程的所属用户/用户组、派生子进程数、错误日志位置/级别、pid位置、子进程优先级、进程对应cpu、进程能够打开的文件描述符数目等</li><li><strong>events块：</strong>控制nginx处理连接的方式</li><li><strong>http块：</strong>是nginx处理http请求的主要配置模块，大多数配置都在这里面进行</li><li><strong>server块：</strong>是nginx中主机的配置块，可以配置多个虚拟主机</li><li><strong>location块：</strong>是server中对应的目录级别的控制块，可以有多个</li><li><strong>upstream块：</strong>是nginx做反向代理和负载均衡的配置块，可以有多个</li></ul><a id="more"></a><h4 id="2、配置命令解释"><a href="#2、配置命令解释" class="headerlink" title="2、配置命令解释"></a>2、配置命令解释</h4><p>nginx中每条配置命令都必须要以分号“;”结束！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">#定义Nginx运行的用户和用户组</span><br><span class="line">user www www;</span><br><span class="line"></span><br><span class="line">#nginx进程数，建议设置为等于CPU总核心数。</span><br><span class="line">worker_processes 8;</span><br><span class="line"></span><br><span class="line">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">error_log /var/log/nginx/error.log info;</span><br><span class="line"></span><br><span class="line">#指定nginx  pid的存放路径</span><br><span class="line">pid /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）</span><br><span class="line">#与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">#工作模式与连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; </span><br><span class="line">    #epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。</span><br><span class="line">    use epoll;</span><br><span class="line">    #单个进程最大连接数（最大连接数=连接数*进程数）</span><br><span class="line">    worker_connections 65535;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#设定http服务器</span><br><span class="line">http &#123;</span><br><span class="line">    include mime.types; #文件扩展名与文件类型映射表</span><br><span class="line">    default_type application/octet-stream; #默认文件类型</span><br><span class="line">    #charset utf-8; #默认编码</span><br><span class="line">    server_names_hash_bucket_size 128; #服务器名字的hash表大小</span><br><span class="line">    client_header_buffer_size 32k; #设定请求缓</span><br><span class="line">    large_client_header_buffers 4 64k; #设定请求缓</span><br><span class="line">    client_max_body_size 8m; #配置客户端能够上传的文件大小</span><br><span class="line">    sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，</span><br><span class="line">    #对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，</span><br><span class="line">    #以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br><span class="line">    autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line">    tcp_nopush on; #防止网络阻塞</span><br><span class="line">    tcp_nodelay on; #防止网络阻塞</span><br><span class="line">    keepalive_timeout 120; #长连接超时时间，单位是秒</span><br><span class="line">    </span><br><span class="line">    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问    速度。下面参数看字面意思都能理解。</span><br><span class="line">    fastcgi_connect_timeout 300;</span><br><span class="line">    fastcgi_send_timeout 300;</span><br><span class="line">    fastcgi_read_timeout 300;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">    #gzip模块设置</span><br><span class="line">    gzip on; #开启gzip压缩输出</span><br><span class="line">    gzip_min_length 1k; #最小压缩文件大小</span><br><span class="line">    gzip_buffers 4 16k; #压缩缓冲区</span><br><span class="line">    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br><span class="line">    gzip_comp_level 2; #压缩等级</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class="line">    #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用</span><br><span class="line"></span><br><span class="line">    #日志格式设定</span><br><span class="line">    log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;</span><br><span class="line">    #启用访问日志，并且指定日志采用的格式</span><br><span class="line">    access_log /var/log/nginx/ha97access.log main;</span><br><span class="line">    #自定义日志格式</span><br><span class="line">    #log_format access &apos;$http_x_forwarded_for $remote_addr [$time_local] &quot;http://$host&quot; &quot;$request&quot; &apos;</span><br><span class="line">    #&apos;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$remote_user&quot; &apos;;</span><br><span class="line">    #（x_forwarded_for表示用户的真实IP。）</span><br><span class="line"></span><br><span class="line">    upstream blog.ha97.com &#123;</span><br><span class="line">        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。</span><br><span class="line">        #weigth参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">        server 192.168.80.121:80 weight=3;</span><br><span class="line">        server 192.168.80.122:80 weight=2;</span><br><span class="line">        server 192.168.80.123:80 weight=3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #虚拟主机的配置</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">        #监听端口</span><br><span class="line">        listen 80;</span><br><span class="line">        #域名可以有多个，用空格隔开</span><br><span class="line">        server_name www.ha97.com ha97.com;</span><br><span class="line">        #默认索引文件</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">        #主机站点根目录地址</span><br><span class="line">        root /data/www/ha97;</span><br><span class="line">        #error_page   404    /404.html;  //404页面地址（可以配置其它错误页面地址如500等，格式一样）</span><br><span class="line"></span><br><span class="line">        #转发PHP文件到指定服务</span><br><span class="line">        location ~ .*\.(php|php5)?$&#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            include fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        #图片缓存时间设置</span><br><span class="line">        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$&#123;</span><br><span class="line">            expires 10d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #JS和CSS缓存时间设置</span><br><span class="line">        location ~ .*\.(js|css)?$&#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #对 &quot;/&quot; 启用反向代理</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:88;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            #以下是一些反向代理的配置，可选。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            client_max_body_size 10m; #允许客户端请求的最大单文件字节数</span><br><span class="line">            client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">            proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">            proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)</span><br><span class="line">            proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">            proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">            proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置</span><br><span class="line">            proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">            proxy_temp_file_write_size 64k;</span><br><span class="line">            #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #设定查看Nginx状态的地址</span><br><span class="line">        location /NginxStatus &#123;</span><br><span class="line">            stub_status on;</span><br><span class="line">            access_log on;</span><br><span class="line">            auth_basic &quot;NginxStatus&quot;;</span><br><span class="line">            auth_basic_user_file conf/htpasswd;</span><br><span class="line">            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #本地动静分离反向代理配置</span><br><span class="line">        #所有jsp的页面均交由tomcat或resin处理</span><br><span class="line">        location ~ .(jsp|jspx|do)?$ &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">        #所有静态文件由nginx直接读取不经过tomcat或resin</span><br><span class="line">        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip</span><br><span class="line">        |txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$&#123; </span><br><span class="line">            expires 15d; </span><br><span class="line">        &#125;</span><br><span class="line">        location ~ .*.(js|css)?$&#123; </span><br><span class="line">            expires 1h; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、结构分析&quot;&gt;&lt;a href=&quot;#1、结构分析&quot; class=&quot;headerlink&quot; title=&quot;1、结构分析&quot;&gt;&lt;/a&gt;1、结构分析&lt;/h4&gt;&lt;p&gt;nginx配置文件中主要包括六块：main，events，http，server，location，upstream&lt;br&gt;结构如下图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;main块：&lt;/strong&gt;主要控制nginx子进程的所属用户/用户组、派生子进程数、错误日志位置/级别、pid位置、子进程优先级、进程对应cpu、进程能够打开的文件描述符数目等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;events块：&lt;/strong&gt;控制nginx处理连接的方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;http块：&lt;/strong&gt;是nginx处理http请求的主要配置模块，大多数配置都在这里面进行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;server块：&lt;/strong&gt;是nginx中主机的配置块，可以配置多个虚拟主机&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;location块：&lt;/strong&gt;是server中对应的目录级别的控制块，可以有多个&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;upstream块：&lt;/strong&gt;是nginx做反向代理和负载均衡的配置块，可以有多个&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 中的事件驱动模型</title>
    <link href="http://yoursite.com/2018/04/09/Nginx-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/04/09/Nginx-中的事件驱动模型/</id>
    <published>2018-04-09T09:19:16.000Z</published>
    <updated>2018-04-09T09:40:21.110Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是事件驱动模型？"><a href="#什么是事件驱动模型？" class="headerlink" title="什么是事件驱动模型？"></a>什么是事件驱动模型？</h4><p>在计算机编程领域，事件驱动模型对应一种程序设计方式，Event-driven programming，即事件驱动程序设计。事件驱动模型一般是由事件收集器，事件发送器，事件处理器三部分基本单元组成。</p><ul><li>事件收集器专门负责收集所有的事件，包括来自用户的（如鼠标单击事件、键盘输入事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。</li><li>事件发送器负责将收集器收集到的事件分发到目标对象中。目标对象就是事件处理器所处的位置。</li><li>事件处理器主要负责具体事件的响应工作，它往往要到实现阶段才完全确定。</li></ul><p>事件驱动程序可以由任何编程语言来实现，只是难易程度有别。如果一个系统是以事件驱动程序模型作为编程基础的，那么，它的架构基本上是这样的：预先设计一个事件循环所形成的程序，这个事件循环程序构成了“事件收集器”，它不断地检查目前要处理的事件信息，然后使用“事件发送器”传递给“事件处理器”。“事件处理器”一般运用虚函数机制来实现。<br><a id="more"></a></p><h4 id="Nginx中的事件驱动模型"><a href="#Nginx中的事件驱动模型" class="headerlink" title="Nginx中的事件驱动模型"></a>Nginx中的事件驱动模型</h4><p>Nginx服务器响应和处理Web请求的过程，就是基于事件驱动模型的，它也包含事件收集器、事件发送器和事件处理器等三部分基本单元。Nginx的“事件收集器”和“事件发送器”的实现没有太大的特点，重点介绍一下它的“事件处理器”。<br>通常，我们在编写服务器处理模型的程序时，基于事件驱动模型，“目标对象”中的“事件处理器”可以有以下几种实现办法：</p><ul><li>“事件发送器”每传递过来一个请求，“目标对象”就创建一个新的进程，调用“事件处理器”来处理该请求。</li><li>“事件发送器”每传递过来一个请求，“目标对象”就创建一个新的线程，调用“事件处理器”来处理该请求。</li><li>“事件发送器”每传递过来一个请求，“目标对象”就将其放入一个待处理事件的列表，使用非阻塞I/O方式调用“事件处理器”来处理该请求。</li></ul><p>以上的三种处理方式，各有特点，第一种方式，由于创建新的进程的开销比较大，会导致服务器性能比较差，但其实现相对来说比较简单。<br>第二种方式，由于要涉及到线程的同步，故可能会面临死锁、同步等一系列问题，编码比较复杂。<br>第三种方式，在编写程序代码时，逻辑比前面两种都复杂。大多数网络服务器采用了第三种方式，逐渐形成了所谓的“事件驱动处理库”。<br>事件驱动处理库又被称为多路IO复用方法，最常见的包括以下三种：select模型，poll模型和epoll模型。Nginx服务器还支持rtsig模型、kqueue模型、dev/poll模型和eventport模型等。通过Nginx配置可以使得Nginx服务器支持这几种事件驱动处理模型。这里详细介绍以下它们。</p><h4 id="select库"><a href="#select库" class="headerlink" title="select库"></a>select库</h4><p>select库，是各个版本的Linux和Windows平台都支持的基本事件驱动模型库，并且在接口的定义上也基本相同，只是部分参数的含义略有差异。使用select库的步骤一般是：<br>首先，创建所关注事件的描述符集合。对于一个描述符，可以关注其上面的（Read)事件、写（Write)事件以及异常发送（Exception）事件，所以要创建三类事件描述符集合，分别用来收集读事件的描述符、写事件的描述符和异常事件的描述符。<br>其次，调用底层提供的select()函数，等待事件发生。这里需要注意的一点是，select的阻塞与是否设置非阻塞I/O是没有关系的。<br>然后，轮询所有事件描述符集合中的每一个事件描述符，检查是否有相应的事件发生，如果有，就进行处理。<br>Nginx服务器在编译过程中如果没有为其指定其他高性能事件驱动模型库，它将自动编译该库。我们可以使用–with-select_module和–without-select_module两个参数强制Nginx是否编译该库。</p><blockquote><p><strong>缺点：</strong><br>1、单个进程可监视的fd（描述符）数量被限制，即能监听端口的大小有限。<br>    一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.<br>2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：<br>    当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。<br>3、需要维护一个用来存放大量fd（描述符）的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p></blockquote><h4 id="poll库"><a href="#poll库" class="headerlink" title="poll库"></a>poll库</h4><p>poll库，作为Linux平台上的基本事件驱动模型，实在Linux2.1.23中引入的。Windows平台不支持poll库。<br>poll与select的基本工作方式是相同的，都是现创建一个关注事件的描述符集合，再去等待这些事件发生，然后在轮询描述符集合，检查有没有事件发生，如果有，就进行处理。<br>poll库与select库的主要区别在于，select库需要为读事件、写事件和异常事件分别创建一个描述符集合，因此在最后轮询的时候，需要分别轮询这三个集合。而poll库只需要创建一个集合，在每个描述符对应的结构上分别设置读事件、写事件或者异常事件，最后轮询的时候，可以同时检查这三种事件是否发生。可以说，poll库是select库的优化实现。<br>Nginx服务器在编译过程中如果没有为其制定其他高性能事件驱动模型库，它将自动编译该库。我们可以使用–with-poll_module和–without-poll_module两个参数强制Nginx是否编译该库。</p><blockquote><p><strong>缺点：</strong><br>1、大量的fd（描述符）的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。<br>2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p></blockquote><h4 id="epoll库"><a href="#epoll库" class="headerlink" title="epoll库"></a>epoll库</h4><p>epoll库是Nginx服务器支持的高性能事件驱动库之一，它是公认的非常优秀的事件驱动模型，和poll库及select库有很大的不同。epoll属于poll库的一个变种，是在Linux 2.5.44中引入的，在Linux 2.6以上的版本都可以使用它。poll库和select库在实际工作中，最大的区别在于效率。<br>从前面的介绍我们知道，它们的处理方式都是创建一个待处理事件列表，然后把这个列表发给内核，返回的时候，再去轮询检查这个列表，以判断事件是否发生。这样在描述符比较多的应用中，效率就显得比较低下了。一种比较好的做法是，把描述符列表的管理交给内核负责，一旦有某种事件发生，内核把发生事件的描述符列表通知给进程，这样就避免了轮询整个描述符列表。epoll库就是这样一种模型。<br>首先，epoll库通过相关调用通知内核创建一个由N个描述符的事件列表。然后，给这些描述符设置所关注的事件，并把它添加到内核的事件列表中去，在具体的编码过程中也可以通过相关调用对事件列表中的描述符进行修改和删除。<br>完成设置之后，epoll库就开始等待内核通知事件发生了。某一事件发生后，内核将发生事件的描述符列表上报给epoll库。得到事件列表的epoll库，就可以进行事件处理了。<br>epoll库在Linux平台上是最高效的。它支持一个进程打开大数目的事件描述符，上限是系统可以打开文件的最大数目。同时，epoll库的IO效率不随描述符数目增加而线性下降，因为它只会对内核上报的“活跃”的描述符进行操作。</p><blockquote><p><strong>优点：</strong><br>1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；<br>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；<br>    即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。<br>3、内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p></blockquote><h4 id="rtsig模型"><a href="#rtsig模型" class="headerlink" title="rtsig模型"></a>rtsig模型</h4><p>rtsig是Real-Time Signal的缩写，是实时信号的意思。从严格意义上说，rtsig模型并不是常用的事件驱动模型，但Nginx服务器使用了使用实时信号对事件进行响应的支持，官方文档中将rtsig模型与其他的事件驱动模型并列。<br>使用rtsig模型时，工作进程会通过系统内核建立一个rtsig队列用于存放标记事件发生（在Nginx服务器应用中特指客户端请求发生）的信号。每个事件发生时，系统内核就会产生一个信号存放到rtsig队列中等待工作进程的处理。<br>需要指出的是，rtsig队列有长度限制，超过该长度后就会发生溢出。默认情况下，Linux系统事件信号队列的最大长度设置为1024，也就是同时最多可以存放1024个发生事件的信号。在Linux 2.6.6-mm2之前的版本中，系统各个进程的事件信号队列是由内核统一管理的，用户可以通过修改内核参数/proc/sys/kernel/rtsig-max/来自定义该长度设置。在Linux 2.6.6-mm2之后的版本中，该内核参数被取消，系统各个进程分别拥有各自的事件信号队列，这个队列的大小由Linux系统的RLIMT_SIGPENGIND参数定义，在执行setrlimit()系统调用时确定该大小。Nginx提供了worker_rlimit_sigpending参数用于调节这种情况下的事件信号队列长度。<br>当rtsig队列发生溢出时，Nginx将暂时停止使用rtsig模型，而调用poll库处理未处理的事件，直到rgsit信号队列全部清空，然后再次启动rtsig模型，以防止新的溢出发生。<br>Nginx在配置文件中提供了相关参数对rtsig模型的使用配置。编译Nginx服务器时，使用–with-rtsig_module配置选项来启用rtsig模型的编译。</p><h4 id="其他事件驱动模型"><a href="#其他事件驱动模型" class="headerlink" title="其他事件驱动模型"></a>其他事件驱动模型</h4><p>除了以上四种主要的事件驱动模型，Nginx服务器针对特定的Linux平台提供了响应的事件驱动模型支持。目前实现的主要有kqueue模型、/dev/poll模型和eventport模型等。</p><ul><li><strong>kqueue模型</strong>，是用于支持BSD系列平台的高效事件驱动模型，主要用在FreeBSD 4.1及以上版本、OpenBSD 2.9及以上版本、NetBSD 2.0及以上版本以及Mac OS X平台上。该模型也是poll库的一个变种，其和epoll库的处理方式没有本质上的区别，都是通过避免轮询操作提供效率。该模型同时支持条件触发（level-triggered,也叫水平触发，只要满足条件就触发一个事件）和边缘触发（edge-triggered，每当状态变化时，触发一个事件）。如果大家在这些平台下使用Nginx服务器，建议选在该模型用于请求处理，以提高Nginx服务器的处理性能。</li><li><strong>/dev/poll模型</strong>，适用于支持Unix衍生平台的高效事件驱动模型，其主要在Solaris711/99及以上版本、HP/UX 11.22及以上版本、IRIX 6.5.15及以上版本和Tru64 UNIX 5.1A及以上版本的平台中使用。该模型是Sun公司在开发Solaris系列平台时提出的用于完成事件驱动机制的方案，它使用了虚拟的/dev/poll设备，开发人员可以将要监视的文件描述符加入这个设备，然后通过ioctl()调用来获取事件通知。在以上提到的平台中，建议使用该模型处理请求。</li><li><strong>eventport模型</strong>，适用于支持Solaris 10及以上版本平台的高效事件驱动模型。该模型也是Sun公司在开发Solaris系列平台时提出的用于完成事件驱动机制的方案，它可以有效防止内核崩溃情况的发生。Nginx服务器为此提供了支持。</li></ul><p>以上就是Nginx服务器支持的事件驱动库。可以看到，Nginx服务器针对不同的Linux或Unix衍生平台提供了多种事件驱动模型的处理，尽量发挥系统平台本身的优势，最大程度地提高处理客户端请求事件的能力。在实际工作中，我们需要根据具体情况和应用情景选择使用不同的事件驱动模型，以保证Nginx服务器的高效运行。</p><h4 id="select、poll、epoll-区别总结："><a href="#select、poll、epoll-区别总结：" class="headerlink" title="select、poll、epoll 区别总结："></a>select、poll、epoll 区别总结：</h4><p><strong>1、支持一个进程所能打开的最大连接数</strong></p><style type="text/css">    table th:first-of-type{        width: 10%;    }</style><table><thead><tr><th>select</th><th>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</th></tr></thead><tbody><tr><td>poll</td><td>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td></tr><tr><td>epoll</td><td>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</td></tr></tbody></table><p><strong>2、FD剧增后带来的IO效率问题</strong></p><table><thead><tr><th>select</th><th>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</th></tr></thead><tbody><tr><td>poll</td><td>同上</td></tr><tr><td>epoll</td><td>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</td></tr></tbody></table><p><strong>3、 消息传递方式</strong></p><table><thead><tr><th>select</th><th>内核需要将消息传递到用户空间，都需要内核拷贝动作</th></tr></thead><tbody><tr><td>poll</td><td>同上</td></tr><tr><td>epoll</td><td>epoll通过内核和用户空间共享一块内存来实现的。</td></tr></tbody></table><p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。<br>1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。<br>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是事件驱动模型？&quot;&gt;&lt;a href=&quot;#什么是事件驱动模型？&quot; class=&quot;headerlink&quot; title=&quot;什么是事件驱动模型？&quot;&gt;&lt;/a&gt;什么是事件驱动模型？&lt;/h4&gt;&lt;p&gt;在计算机编程领域，事件驱动模型对应一种程序设计方式，Event-driven programming，即事件驱动程序设计。事件驱动模型一般是由事件收集器，事件发送器，事件处理器三部分基本单元组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件收集器专门负责收集所有的事件，包括来自用户的（如鼠标单击事件、键盘输入事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。&lt;/li&gt;
&lt;li&gt;事件发送器负责将收集器收集到的事件分发到目标对象中。目标对象就是事件处理器所处的位置。&lt;/li&gt;
&lt;li&gt;事件处理器主要负责具体事件的响应工作，它往往要到实现阶段才完全确定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件驱动程序可以由任何编程语言来实现，只是难易程度有别。如果一个系统是以事件驱动程序模型作为编程基础的，那么，它的架构基本上是这样的：预先设计一个事件循环所形成的程序，这个事件循环程序构成了“事件收集器”，它不断地检查目前要处理的事件信息，然后使用“事件发送器”传递给“事件处理器”。“事件处理器”一般运用虚函数机制来实现。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx + FastCGI运行原理</title>
    <link href="http://yoursite.com/2018/04/09/Nginx-FastCGI%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/09/Nginx-FastCGI运行原理/</id>
    <published>2018-04-09T07:17:41.000Z</published>
    <updated>2018-04-09T08:28:30.314Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、什么是-FastCGI"><a href="#1、什么是-FastCGI" class="headerlink" title="1、什么是 FastCGI"></a>1、什么是 FastCGI</h4><p>FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等。同时，FastCGI也被许多脚本语言支持，其中就有PHP。</p><p>FastCGI是从CGI发展改进而来的。传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后将结果返回给HTTP服务器。这在处理高并发访问时几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少使用了。<br><a id="more"></a><br>FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p><h4 id="2、Nginx-FastCGI运行原理"><a href="#2、Nginx-FastCGI运行原理" class="headerlink" title="2、Nginx+FastCGI运行原理"></a>2、Nginx+FastCGI运行原理</h4><p>Nginx不支持对外部程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket（这个socket可以是文件socket，也可以是ip socket）。</p><p>wrapper：为了调用CGI程序，还需要一个FastCGI的wrapper（wrapper可以理解为用于启动另一个程序的程序），这个wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接收到请求，然后Fork(派生）出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据（html页面或者图片）发送给客户端。这就是Nginx+FastCGI的整个运作过程，如图1-3所示。<br><img src="/uploads/2018/04/nginx_fastcgi.png" alt=""></p><p>所以，我们首先需要一个wrapper，这个wrapper需要完成的工作：</p><ol><li>通过调用fastcgi（库）的函数通过socket和ningx通信（读写socket是fastcgi内部实现的功能，对wrapper是非透明的）</li><li>调度thread，进行fork和kill</li><li>和application（php）进行通信</li></ol><h4 id="3、spawn-fcgi与PHP-FPM"><a href="#3、spawn-fcgi与PHP-FPM" class="headerlink" title="3、spawn-fcgi与PHP-FPM"></a>3、spawn-fcgi与PHP-FPM</h4><p>FastCGI接口方式在脚本解析服务器上启动一个或者多个守护进程对动态脚本进行解析，这些进程就是FastCGI进程管理器，或者称为FastCGI引擎。 spawn-fcgi与PHP-FPM就是支持PHP的两个FastCGI进程管理器。因此HTTPServer完全解放出来，可以更好地进行响应和并发处理。</p><blockquote><p>spawn-fcgi与PHP-FPM的异同：<br>1）spawn-fcgi是HTTP服务器lighttpd的一部分，目前已经独立成为一个项目，一般与lighttpd配合使用来支持PHP。但是ligttpd的spwan-fcgi在高并发访问的时候，会出现内存泄漏甚至自动重启FastCGI的问题。即：PHP脚本处理器当机，这个时候如果用户访问的话，可能就会出现白页(即PHP不能被解析或者出错)。<br>2）Nginx是个轻量级的HTTP server，必须借助第三方的FastCGI处理器才可以对PHP进行解析，因此其实这样看来nginx是非常灵活的，它可以和任何第三方提供解析的处理器实现连接从而实现对PHP的解析(在nginx.conf中很容易设置)。nginx也可以使用spwan-fcgi(需要一同安装lighttpd，但是需要为nginx避开端口，一些较早的blog有这方面安装的教程)，但是由于spawn-fcgi具有上面所述的用户逐渐发现的缺陷，现在慢慢减少用nginx+spawn-fcgi组合了。</p></blockquote><p>由于spawn-fcgi的缺陷，现在出现了第三方(目前已经加入到PHP core中)的PHP的FastCGI处理器PHP-FPM，它和spawn-fcgi比较起来有如下优点：</p><ul><li>由于它是作为PHP的patch补丁来开发的，安装的时候需要和php源码一起编译，也就是说编译到php core中了，因此在性能方面要优秀一些；</li><li>同时它在处理高并发方面也优于spawn-fcgi，至少不会自动重启fastcgi处理器。因此，推荐使用Nginx+PHP/PHP-FPM这个组合对PHP进行解析。</li><li>相对Spawn-FCGI，PHP-FPM在CPU和内存方面的控制都更胜一筹，而且前者很容易崩溃，必须用crontab进行监控，而PHP-FPM则没有这种烦恼。</li><li>FastCGI 的主要优点是把动态语言和HTTP Server分离开来，所以Nginx与PHP/PHP-FPM经常被部署在不同的服务器上，以分担前端Nginx服务器的压力，使Nginx专一处理静态请求和转发动态请求，而PHP/PHP-FPM服务器专一解析PHP动态请求。</li></ul><h4 id="4、Nginx-PHP-FPM"><a href="#4、Nginx-PHP-FPM" class="headerlink" title="4、Nginx+PHP-FPM"></a>4、Nginx+PHP-FPM</h4><p>PHP-FPM是管理FastCGI的一个管理器，它作为PHP的插件存在，在安装PHP要想使用PHP-FPM时在老php的老版本（php5.3.3之前）就需要把PHP-FPM以补丁的形式安装到PHP中，而且PHP要与PHP-FPM版本一致，这是必须的）</p><p>PHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。<br>PHP5.3.3已经集成php-fpm了，不再是第三方的包了。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多优点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。</p><p>fastcgi已经在php5.3.5的core中了，不必在configure时添加 –enable-fastcgi了。老版本如php5.2的需要加此项。</p><p><strong>当我们安装Nginx和PHP-FPM完后，配置信息：</strong></p><blockquote><p>PHP-FPM的默认配置php-fpm.conf：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listen_address  127.0.0.1:9000 #这个表示php的fastcgi进程监听的ip地址以及端口</span><br><span class="line">start_servers</span><br><span class="line">min_spare_servers</span><br><span class="line">max_spare_servers</span><br></pre></td></tr></table></figure></p><p>Nginx配置运行php： 编辑nginx.conf加入如下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root html;   </span><br><span class="line">    fastcgi_pass 127.0.0.1:9000; 指定了fastcgi进程侦听的端口,nginx就是通过这里与php交互的</span><br><span class="line">    fastcgi_index index.php;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME   /usr/local/nginx/html$fastcgi_script_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>Nginx通过location指令，将所有以php为后缀的文件都交给127.0.0.1:9000来处理，而这里的IP地址和端口就是FastCGI进程监听的IP地址和端口。</p><p><strong>其整体工作流程：</strong><br>1)  FastCGI进程管理器php-fpm自身初始化，启动主进程php-fpm和启动start_servers个CGI 子进程。<br>    主进程php-fpm主要是管理fastcgi子进程，监听9000端口。<br>    fastcgi子进程等待来自Web Server的连接。<br>2)  当客户端请求到达Web Server Nginx是时，Nginx通过location指令，将所有以php为后缀的文件都交给127.0.0.1:9000来处理，即Nginx通过location指令，将所有以php为后缀的文件都交给127.0.0.1:9000来处理。<br>3)  FastCGI进程管理器PHP-FPM选择并连接到一个子进程CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程。<br>4)  FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。<br>5)  FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在 WebServer中）的下一个连接。</p><h4 id="5、Nginx-PHP正确配置"><a href="#5、Nginx-PHP正确配置" class="headerlink" title="5、Nginx+PHP正确配置"></a>5、Nginx+PHP正确配置</h4><p>一般web都做统一入口：把PHP请求都发送到同一个文件上，然后在此文件里通过解析「REQUEST_URI」实现路由。</p><p>Nginx配置文件分为好多块，常见的从外到内依次是「http」、「server」、「location」等等，缺省的继承关系是从外到内，也就是说内层块会自动获取外层块的值作为缺省值。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 80;  </span><br><span class="line">    server_name foo.com;  </span><br><span class="line">    root /path;  </span><br><span class="line">    location / &#123;  </span><br><span class="line">        index index.html index.htm index.php;  </span><br><span class="line">        if (!-e $request_filename) &#123;  </span><br><span class="line">            rewrite . /index.php last;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    location ~ \.php$ &#123;  </span><br><span class="line">        include fastcgi_params;  </span><br><span class="line">        fastcgi_param SCRIPT_FILENAME /path$fastcgi_script_name;  </span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;  </span><br><span class="line">        fastcgi_index index.php;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>1) 不应该在location 模块定义index</strong><br>一旦未来需要加入新的「location」，必然会出现重复定义的「index」指令，这是因为多个「location」是平级的关系，不存在继承，此时应该在「server」里定义「index」，借助继承关系，「index」指令在所有的「location」中都能生效。</p><p><strong>2) 使用try_files</strong><br>接下来看看「if」指令，说它是大家误解最深的Nginx指令毫不为过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!-e $request_filename) &#123;</span><br><span class="line">    rewrite . /index.php last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很多人喜欢用「if」指令做一系列的检查，不过这实际上是「try_files」指令的职责：<br><code>try_files $uri $uri/ /index.php;</code></p><p>除此以外，初学者往往会认为「if」指令是内核级的指令，但是实际上它是rewrite模块的一部分，加上Nginx配置实际上是声明式的，而非过程式的，所以当其和非rewrite模块的指令混用时，结果可能会非你所愿。</p><p><strong>3）fastcgi_params」配置文件：</strong><br><code>include fastcgi_params;</code></p><p>Nginx有两份fastcgi配置文件，分别是「fastcgi_params」和「fastcgi.conf」，它们没有太大的差异，唯一的区别是后者比前者多了一行「SCRIPT_FILENAME」的定义：<br><code>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</code></p><p>注意：$document_root 和 $fastcgi_script_name 之间没有 /。<br>原本Nginx只有「fastcgi_params」，后来发现很多人在定义「SCRIPT_FILENAME」时使用了硬编码的方式，于是为了规范用法便引入了「fastcgi.conf」。</p><p>不过这样的话就产生一个疑问：为什么一定要引入一个新的配置文件，而不是修改旧的配置文件？这是因为「fastcgi_param」指令是数组型的，和普通指令相同的是：内层替换外层；和普通指令不同的是：当在同级多次使用的时候，是新增而不是替换。换句话说，如果在同级定义两次「SCRIPT_FILENAME」，那么它们都会被发送到后端，这可能会导致一些潜在的问题，为了避免此类情况，便引入了一个新的配置文件。</p><p>此外，我们还需要考虑一个安全问题：在PHP开启「cgi.fix_pathinfo」的情况下，PHP可能会把错误的文件类型当作PHP文件来解析。如果Nginx和PHP安装在同一台服务器上的话，那么最简单的解决方法是用「try_files」指令做一次过滤：<br><code>try_files $uri =404;</code></p><p>依照前面的分析，给出一份改良后的版本，是不是比开始的版本清爽了很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 80;  </span><br><span class="line">    server_name foo.com;  </span><br><span class="line">    root /path;  </span><br><span class="line">    index index.html index.htm index.php;  </span><br><span class="line">    location / &#123;  </span><br><span class="line">        try_files $uri $uri/ /index.php;  </span><br><span class="line">    &#125;  </span><br><span class="line">    location ~ \.php$ &#123;  </span><br><span class="line">       try_files $uri =404;  </span><br><span class="line">       include fastcgi.conf;  </span><br><span class="line">       fastcgi_pass 127.0.0.1:9000;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、什么是-FastCGI&quot;&gt;&lt;a href=&quot;#1、什么是-FastCGI&quot; class=&quot;headerlink&quot; title=&quot;1、什么是 FastCGI&quot;&gt;&lt;/a&gt;1、什么是 FastCGI&lt;/h4&gt;&lt;p&gt;FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等。同时，FastCGI也被许多脚本语言支持，其中就有PHP。&lt;/p&gt;
&lt;p&gt;FastCGI是从CGI发展改进而来的。传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后将结果返回给HTTP服务器。这在处理高并发访问时几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少使用了。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 概述及工作原理</title>
    <link href="http://yoursite.com/2018/04/09/Nginx-%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/09/Nginx-概述及工作原理/</id>
    <published>2018-04-09T07:17:01.000Z</published>
    <updated>2018-04-09T09:17:03.708Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、nginx概述"><a href="#一、nginx概述" class="headerlink" title="一、nginx概述"></a>一、nginx概述</h4><p>Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强。</p><h5 id="1、什么是nginx？"><a href="#1、什么是nginx？" class="headerlink" title="1、什么是nginx？"></a>1、什么是nginx？</h5><p>Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。Nginx 是由俄罗斯人 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，它已经在该站点运行超过两年半了。Igor Sysoev 在建立的项目时,使用基于 BSD 许可。<br><a id="more"></a></p><p>Nginx 以<font color="red">事件驱动</font>的方式编写，所以有非常好的性能，同时也是<font color="red">一个非常高效的反向代理、负载平衡</font>。其拥有匹配 Lighttpd 的性能，同时还没有 Lighttpd 的内存泄漏问题，而且 Lighttpd 的 mod_proxy 也有一些问题并且很久没有更新。</p><p>现在，Igor 将源代码以类 BSD 许可证的形式发布。Nginx 因为它的稳定性、丰富的模块库、灵活的配置和低系统资源的消耗而闻名．业界一致认为它是 Apache2.2＋mod_proxy_balancer 的轻量级代替者，不仅是因为响应静态页面的速度非常快，而且它的模块数量达到 Apache 的近 2/3。对 proxy 和 rewrite 模块的支持很彻底，还支持 mod_fcgi、ssl、vhosts ，适合用来做 mongrel clusters 的前端 HTTP 响应。</p><h5 id="2、nginx的特点"><a href="#2、nginx的特点" class="headerlink" title="2、nginx的特点"></a>2、nginx的特点</h5><p>Nginx 做为 HTTP 服务器，有以下几项基本特性：</p><ul><li>处理静态文件，索引文件以及自动索引；打开文件描述符缓冲．</li><li>无缓存的反向代理加速，简单的负载均衡和容错．</li><li>FastCGI，简单的负载均衡和容错．</li><li>模块化的结构。包括 gzipping, byte ranges, chunked responses,以及 SSI-filter 等 filter。如果由 FastCGI 或其它代理服务器处理单页中存在的多个 SSI，则这项处理可以并行运行，而不需要相互等待。</li><li>支持 SSL 和 TLSSNI．</li></ul><p>Nginx 专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率 。它支持内核 Poll 模型，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。</p><p>Nginx 具有很高的稳定性。其它 HTTP 服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前 apache 一旦上到 200 个以上进程，web响应速度就明显非常缓慢了。而 Nginx 采取了分阶段资源分配技术，使得它的 CPU 与内存占用率非常低。Nginx 官方表示保持 10,000 个没有活动的连接，它只占 2.5M 内存，所以类似 DOS 这样的攻击对 Nginx 来说基本上是毫无用处的。就稳定性而言,Nginx 比 lighthttpd 更胜一筹。</p><p>Nginx 支持热部署。它的启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。</p><h4 id="二、nginx的架构"><a href="#二、nginx的架构" class="headerlink" title="二、nginx的架构"></a>二、nginx的架构</h4><p>众所周知，Nginx 性能高，而 Nginx 的高性能与其架构是分不开的。那么 Nginx 究竟是怎么样的呢？</p><p>Nginx 在启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程。我们也可以手动地关掉后台模式，让 Nginx 在前台运行，并且通过配置让 Nginx 取消 master 进程，从而可以使 Nginx 以单进程方式运行。很显然，生产环境下我们肯定不会这么做，所以关闭后台模式，一般是用来调试用的。所以，我们可以看到，Nginx 是以多进程的方式来工作的，当然 Nginx 也是支持多线程的方式的，只是我们主流的方式还是多进程的方式，也是 Nginx 的默认方式。Nginx 采用多进程的方式有诸多好处，所以我就主要讲解 Nginx 的多进程模式吧。</p><h5 id="1、Nginx-的进程模型"><a href="#1、Nginx-的进程模型" class="headerlink" title="1、Nginx 的进程模型"></a>1、Nginx 的进程模型</h5><p>刚才讲到，Nginx 在启动后，会有一个 master 进程和多个 worker 进程。<strong>master 进程主要用来管理 worker 进程，包含：接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动新的 worker 进程。而基本的网络事件，则是放在 worker 进程中来处理了。多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。</strong><font color="red">一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求。</font> worker 进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的<em>原因与 Nginx 的进程模型以及事件处理模型是分不开的</em>。Nginx 的进程模型，可以由下图来表示：<br><img src="/uploads/2018/04/nginx-chapter-01.png" alt=""></p><p>在 Nginx 启动后，如果我们要操作 Nginx，要怎么做呢？从上文中我们可以看到，master 来管理 worker 进程，所以我们只需要与 master 进程通信就行了。master 进程会接收来自外界发来的信号，再根据信号做不同的事情。所以我们要控制 Nginx，只需要通过 kill 向 master 进程发送信号就行了。比如kill -HUP pid，则是告诉 Nginx，从容地重启 Nginx，我们一般用这个信号来重启 Nginx，或重新加载配置，因为是从容地重启，因此服务是不中断的。master 进程在接收到 HUP 信号后是怎么做的呢？<font color="red">首先 master 进程在接到信号后，会先重新加载配置文件，然后再启动新的 worker 进程，并向所有老的 worker 进程发送信号，告诉他们可以光荣退休了。新的 worker 在启动后，就开始接收新的请求，而老的 worker 在收到来自 master 的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。</font>当然，直接给 master 进程发送信号，这是比较老的操作方式，Nginx 在 0.8 版本之后，引入了一系列命令行参数，来方便我们管理。比如，./nginx -s reload，就是来重启 Nginx，./nginx -s stop，就是来停止 Nginx 的运行。如何做到的呢？我们还是拿 reload 来说，我们看到，<font color="red">执行命令时，我们是启动一个新的 Nginx 进程，而新的 Nginx 进程在解析到 reload 参数后，就知道我们的目的是控制 Nginx 来重新加载配置文件了，它会向 master 进程发送信号，然后接下来的动作，就和我们直接向 master 进程发送信号一样了。</font></p><p>现在，我们知道了当我们在操作 Nginx 的时候，Nginx 内部做了些什么事情，那么，worker 进程又是如何处理请求的呢？我们前面有提到，<font color="red">worker 进程之间是平等的，每个进程，处理请求的机会也是一样的。</font>当我们提供 80 端口的 http 服务时，一个连接请求过来，每个进程都有可能处理这个连接，怎么做到的呢？首先，每个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面，先建立好需要 listen 的 socket（listenfd）<font color="red">（socket不知道是啥的，可点击查询）</font>之后，然后再 fork 出多个 worker 进程。所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当一个 worker 进程在 accept 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，<font color="red">一个请求，完全由 worker 进程来处理，而且只在一个 worker 进程中处理。</font></p><p>那么，Nginx 采用这种进程模型有什么好处呢？当然，好处肯定会很多了。首先，对于每个 worker 进程来说，独立的进程，不需要加锁<strong>（因为需要争抢处理请求，不使用accept_mutex接受互斥量，会导致多个worker进程处理一个请求的混乱结果）</strong>，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的 worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。当然，好处还有很多，大家可以慢慢体会。</p><h5 id="2、Nginx-事件模型"><a href="#2、Nginx-事件模型" class="headerlink" title="2、Nginx 事件模型"></a>2、Nginx 事件模型</h5><p>上面讲了很多关于 Nginx 的进程模型，接下来，我们来看看 Nginx 是如何处理事件的。</p><p>有人可能要问了，Nginx 采用多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限啊，多少个 worker 就能处理多少个并发，何来高并发呢？非也，这就是 Nginx 的高明之处，<font color="red">Nginx 采用了异步非阻塞的方式来处理请求，也就是说，Nginx 是可以同时处理成千上万个请求的。</font>想想 apache 的常用工作方式（apache 也有异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），每个请求会独占一个工作线程，当并发数上到几千时，就同时有几千的线程在处理请求了。这对操作系统来说，是个不小的挑战，线程带来的内存占用非常大，线程的上下文切换带来的 cpu 开销很大，自然性能就上不去了，而这些开销完全是没有意义的。</p><p>为什么 Nginx 可以采用异步非阻塞的方式来处理呢，或者异步非阻塞到底是怎么回事呢？我们先回到原点，看看一个请求的完整过程。<strong>首先，请求过来，要建立连接，然后再接收数据，接收数据后，再发送数据。具体到系统底层，就是读写事件，而当读写事件没有准备好时，必然不可操作，如果不用非阻塞的方式来调用，那就得阻塞调用了，事件没有准备好，那就只能等了，等事件准备好了，你再继续吧。阻塞调用会进入内核等待，cpu 就会让出去给别人用了，<font color="red">对单线程的 worker 来说</font>，显然不合适，当网络事件越多时，大家都在等待呢，cpu 空闲下来没人用，cpu利用率自然上不去了，更别谈高并发了。</strong>好吧，你说加进程数，这跟apache的线程模型有什么区别，注意，别增加无谓的上下文切换。所以，<font color="red">在 Nginx 里面，最忌讳阻塞的系统调用了。</font>不要阻塞，那就非阻塞喽。非阻塞就是，事件没有准备好，马上返回 EAGAIN，告诉你，事件还没准备好呢，你慌什么，过会再来吧。好吧，你过一会，再来检查一下事件，直到事件准备好了为止，在这期间，你就可以先去做其它事情，然后再来看看事件好了没。虽然不阻塞了，但你得不时地过来检查一下事件的状态，你可以做更多的事情了，但带来的开销也是不小的。所以，才会有了<font color="red">异步非阻塞的事件处理机制</font>，<strong>具体到系统调用就是像 select/poll/epoll/kqueue 这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。</strong><font color="red">这种机制正好解决了我们上面的两个问题，拿 epoll 为例(在后面的例子中，我们多以 epoll 为例子，以代表这一类函数)，当事件没准备好时，放到 epoll 里面，事件准备好了，我们就去读写，当读写返回 EAGAIN 时，我们将它再次加入到 epoll 里面。这样，只要有事件准备好了，我们就去处理它，只有当所有事件都没准备好时，才在 epoll 里面等着。这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。</font><strong>与多线程相比，这种事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常的轻量级。</strong>并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。 我之前有对连接数进行过测试，在 24G 内存的机器上，处理的并发请求数达到过 200 万。现在的网络服务器基本都采用这种方式，这也是nginx性能高效的主要原因。</p><p>我们之前说过，<font color="red">推荐设置 worker 的个数为 cpu 的核数，在这里就很容易理解了，更多的 worker 数，只会导致进程来竞争 cpu 资源了，从而带来不必要的上下文切换。</font>而且，nginx为了更好的利用多核特性，提供了 cpu 亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来 cache 的失效。像这种小的优化在 Nginx 中非常常见，同时也说明了 Nginx 作者的苦心孤诣。比如，Nginx 在做 4 个字节的字符串比较时，会将 4 个字符转换成一个 int 型，再作比较，以减少 cpu 的指令数等等。</p><p>现在，知道了 Nginx 为什么会选择这样的进程模型与事件模型了。对于一个基本的 Web 服务器来说，事件通常有三种类型，网络事件、信号、定时器。从上面的讲解中知道，网络事件通过异步非阻塞可以很好的解决掉。如何处理信号与定时器？</p><p>首先，<font color="red">信号的处理</font>。对 Nginx 来说，有一些特定的信号，代表着特定的意义。信号会中断掉程序当前的运行，在改变状态后，继续执行。如果是系统调用，则可能会导致系统调用的失败，需要重入。关于信号的处理，大家可以学习一些专业书籍，这里不多说。对于 Nginx 来说，如果nginx正在等待事件（epoll_wait 时），如果程序收到信号，在信号处理函数处理完后，epoll_wait 会返回错误，然后程序可再次进入 epoll_wait 调用。</p><p>另外，再来看看<font color="red">定时器</font>。由于 epoll_wait 等函数在调用的时候是可以设置一个超时时间的，所以 Nginx 借助这个超时时间来实现定时器。nginx里面的定时器事件是放在一颗维护定时器的红黑树里面，每次在进入 epoll_wait前，先从该红黑树里面拿到所有定时器事件的最小时间，在计算出 epoll_wait 的超时时间后进入 epoll_wait。所以，当没有事件产生，也没有中断信号时，epoll_wait 会超时，也就是说，定时器事件到了。这时，nginx会检查所有的超时事件，将他们的状态设置为超时，然后再去处理网络事件。由此可以看出，当我们写 Nginx 代码时，在处理网络事件的回调函数时，通常做的第一个事情就是判断超时，然后再去处理网络事件。</p><p>我们可以用一段伪代码来总结一下 Nginx 的事件处理模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    for t in run_tasks:</span><br><span class="line">        t.handler();</span><br><span class="line">    update_time(&amp;now);</span><br><span class="line">    timeout = ETERNITY;</span><br><span class="line">    for t in wait_tasks: /* sorted already */</span><br><span class="line">        if (t.time &lt;= now) &#123;</span><br><span class="line">            t.timeout_handler();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timeout = t.time - now;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    nevents = poll_function(events, timeout);</span><br><span class="line">    for i in nevents:</span><br><span class="line">        task t;</span><br><span class="line">        if (events[i].type == READ) &#123;</span><br><span class="line">            t.handler = read_handler;</span><br><span class="line">        &#125; else &#123; /* events[i].type == WRITE */</span><br><span class="line">            t.handler = write_handler;</span><br><span class="line">        &#125;</span><br><span class="line">        run_tasks_add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好，本节我们讲了进程模型，事件模型，包括网络事件，信号，定时器事件。</p><h4 id="三、Nginx的工作原理"><a href="#三、Nginx的工作原理" class="headerlink" title="三、Nginx的工作原理"></a>三、Nginx的工作原理</h4><p>nginx 主要用于Web和代理服务器，接收请求，对请求进行解析，静态资源直接返回，动态请求转发到后端做处理。由上面对nginx的架构进行解析知道，nginx常采用多进程的工作方式，nginx启动后，会有一个master进程和多个worker进程生成。master进程主要用来管理worker进程，而worker进程主要就是用来处理请求的，多个worker进程之间是对等的，他们同等竞争客户端的请求，相互之间是独立的。</p><p>每个worker进程中只有一个主线程，且采用异步非阻塞的事件处理机制来处理请求。假设机制处理采用的是epoll，主线程就会循环epoll，如果发现事件已经准备好了，就进行处理，否则再次放入epoll，继续循环。epoll中的请求数就是worker进程的连接数。因此就可处理大量的并发了。要注意，worker同一时间只能处理一个请求（因为只有一个主线程），会来回进行请求切换处理。但是，请求间的切换是没有代价的，切换也是因为异步事件未准备好，而主动让出的。</p><blockquote><font color="red"><strong>工作原理要点：</strong><br>1. nginx采用多进程的工作方式，进程模型是master-worker形式。（注：常采用多进程方式，也有多线程，单进程方式）<br>2. worker处理请求时采用异步非阻塞的处理方式。因此可支持高并发。<br>3. 进程间、线程间是没有上下文切换，仅仅只是请求切换，是没有任何代价的。（注：进程与进程间是相互独立的；每个请求仅且只可在一个worker进程中完成；worker进程中只包含一个主线程；请求间的切换是通过循环事件来实现的。）</font></blockquote><h4 id="四、Nginx相关问题"><a href="#四、Nginx相关问题" class="headerlink" title="四、Nginx相关问题"></a>四、Nginx相关问题</h4><h5 id="1、nginx为啥性能高？"><a href="#1、nginx为啥性能高？" class="headerlink" title="1、nginx为啥性能高？"></a>1、nginx为啥性能高？</h5><p>（1）nginx采用的是多进程模型<br>首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。<br>其次，采用独立的进程，可以让相互之间不会影响，一个进程退出之后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。当然，worker进程的异常退出，肯定是程序出BUG了，异常退出，会导致当前的worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险。<br>（2）nginx采用多进程事件模型：异步非阻塞<br>虽然nginx采用多worker的方式来处理请求，每个worker里面只有一个主线程，那能够处理的并发数很有限啊，多少个worker就能处理多少个并发，何来高并发呢？非也，这就是nginx的高明之处，nginx采用了异步非阻塞的方式来处理请求，也就是说，nginx是可以同时处理成千上万个请求的。一个worker进程可以同时处理的请求数只受限于内存大小，而且在架构设计上，不同的worker进程之间处理并发请求时几乎没有同步锁的限制，worker进程通常不会进入睡眠状态，因此，当Nginx上的进程数与CPU核心数相等时（最好每一个worker进程都绑定特定的CPU核心），进程间切换的代价是最小的。</p><p>而apache的常用工作方式（apache也有异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），每个进程在一个时刻只处理一个请求，因此，当并发数上到几千时，就同时有几千的进程在处理请求了。这对操作系统来说，是个不小的挑战，进程带来的内存占用非常大，进程的上下文切换带来的cpu开销很大，自然性能就上不去了，而这些开销完全是没有意义的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、nginx概述&quot;&gt;&lt;a href=&quot;#一、nginx概述&quot; class=&quot;headerlink&quot; title=&quot;一、nginx概述&quot;&gt;&lt;/a&gt;一、nginx概述&lt;/h4&gt;&lt;p&gt;Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强。&lt;/p&gt;
&lt;h5 id=&quot;1、什么是nginx？&quot;&gt;&lt;a href=&quot;#1、什么是nginx？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是nginx？&quot;&gt;&lt;/a&gt;1、什么是nginx？&lt;/h5&gt;&lt;p&gt;Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。Nginx 是由俄罗斯人 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，它已经在该站点运行超过两年半了。Igor Sysoev 在建立的项目时,使用基于 BSD 许可。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>面试 - 常见算法试题总结（PHP）</title>
    <link href="http://yoursite.com/2018/04/08/%E9%9D%A2%E8%AF%95-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/08/面试-常见算法试题总结/</id>
    <published>2018-04-08T09:52:05.000Z</published>
    <updated>2018-04-08T10:35:28.367Z</updated>
    
    <content type="html"><![CDATA[<p>试题目录：<br>1、斐波那契数列实现<br>2、楼梯有s阶台阶,上楼时可以一步上1阶,也可以一步上2阶，编程计算共有多少种不同的走法。<br>3、输入两个整数n和m，从数列1，2…….n中随意取几个数，使其和等于m，要求将其中所有的可能组合列出来。<br>4、求一个数组的最长递减子序列 比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，4，3，2}。<br>5、一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。<br>6、输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。例如输入“I am a student.”，则输出“student. a am I”。</p><a id="more"></a><hr><blockquote><p><strong>递归算法思想：</strong><br>1.递归过程一般通过函数或子过程实现；<br>2.递归算法在函数或子过程的内部，直接或间接调用自己的算法<br>3.递归算法实际上是把问题转化为规模缩小了的同类问题的子问题，然后再递归调用函数或过程来表示问题的解</p><font color="red">注意：必须有一个明确的递归结束条件；如果递归次数过多，容易造成栈溢出。</font></blockquote><hr><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><p>问题描述：<br>斐波那契数列： 1 1 2 3 5 8 13 21 34 55 …<br>概念：<br>前两个值都为1，该数列从第三位开始，每一位都是当前位前两位的和<br>规律公式为： <code>Fn = F(n-1) + F(n+1)</code></p><ul><li>F：指当前这个数列 </li><li>n：指数列的下标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* 非递归实现 */</span><br><span class="line">function fbnq($n)&#123;</span><br><span class="line">if($n&lt;=0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">$arr[1] = $arr[2] = 1;</span><br><span class="line">for($i=3; $i&lt;=$n; $i++)&#123;</span><br><span class="line">$arr[$i] = $arr[$i-1] + $arr[$i-2];</span><br><span class="line">&#125;</span><br><span class="line">return $arr;</span><br><span class="line">&#125;</span><br><span class="line">// echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">// var_dump(fbnq(10));</span><br><span class="line">/* 递归实现 */</span><br><span class="line">function fbnq_2($n)&#123;</span><br><span class="line">if($n &lt;= 0) return 0;</span><br><span class="line">static $arr;</span><br><span class="line">$arr[1] = $arr[2] = 1;</span><br><span class="line">    if($n &gt; 3)&#123;</span><br><span class="line">    fbnq_2($n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    $arr[$n] = $arr[$n-1] + $arr[$n-2];</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line">// var_dump(fbnq_2(10));</span><br></pre></td></tr></table></figure><h4 id="上台阶问题"><a href="#上台阶问题" class="headerlink" title="上台阶问题"></a>上台阶问题</h4><p>问题描述：楼梯有s阶台阶,上楼时可以一步上1阶,也可以一步上2阶，编程计算共有多少种不同的走法。</p><blockquote><p><strong>解题思路：</strong><br>此问题可分解为 f(n-1) + f(n-2) 种不同的走法。且结束条件为 小于等于 2（最多一步上2阶）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getStepSum($s)&#123;</span><br><span class="line">if($s &lt;= 0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;else if($s &lt;= 2)&#123;</span><br><span class="line">return $s;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return getStepSum($s-1)+getStepSum($s-2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// var_dump(getStepSum(3));</span><br></pre></td></tr></table></figure><h4 id="求数和问题"><a href="#求数和问题" class="headerlink" title="求数和问题"></a>求数和问题</h4><p>问题描述：输入两个整数n和m，从数列1，2…….n中随意取几个数，使其和等于m，要求将其中所有的可能组合列出来。</p><blockquote><p><strong>解题思路：</strong><br>输入sum和n，要求输出1,2…n里所有和为sum的组合<br>这是一个可划分子问题问题<br>若用f(sum, n)表示问题的界，则元素组合共有两种情况</p><ol><li>和为sum的组合里包括n，则f(sum, n) = f(sum - n, n - 1)</li><li>和为sum的组合里不包括n,则 f(sum, n) = f(sum, n - 1)<br>所以 f(sum, n) = f(sum - n, n - 1) U f(sum, n - 1)</li></ol><p>注：需要传入一个空数组来接收数，用于输出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function combination($sum, $n, $comb) &#123;</span><br><span class="line">if ($n &lt; 0 || $sum &lt; 0) &#123;</span><br><span class="line"> #当n &lt; 0或者sum &lt; 0都是不符合条件的结果</span><br><span class="line"> // print_r($comb);</span><br><span class="line"> // echo &quot;sum: &#123;$sum&#125; n: &#123;$n&#125;&lt;br&gt;&quot;;</span><br><span class="line"> return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($sum &lt; $n) &#123;</span><br><span class="line"> combination($sum, $sum, $comb); #sum &lt; n，则不可能需要比sum大的数来构成组合</span><br><span class="line"> return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#结果求得</span><br><span class="line">if ($sum == 0) &#123;</span><br><span class="line"> #输出元素组合</span><br><span class="line"> echo &quot;Combination: &quot;;</span><br><span class="line"> foreach ($comb as $val) &#123;</span><br><span class="line">     echo $val . &quot; &quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> echo &quot;&lt;br&gt;&quot;;</span><br><span class="line"> return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#组合里包含n的情况</span><br><span class="line">$comb[] = $n;</span><br><span class="line">combination($sum - $n, $n - 1, $comb);</span><br><span class="line"></span><br><span class="line">#组合里不包含n的情况</span><br><span class="line">array_pop($comb);</span><br><span class="line">combination($sum, $n - 1, $comb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最长递减子序列问题"><a href="#最长递减子序列问题" class="headerlink" title="最长递减子序列问题"></a>最长递减子序列问题</h4><p>问题描述：求一个数组的最长递减子序列 比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，4，3，2}。</p><blockquote><p><strong>解题思路：</strong><br>此问题就是比较大小的问题，把列表看成栈比较容易些（且是有序的栈）。与栈头比较大小，满足条件入栈，否则出栈。<br>注：需要判空数组的问题。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// $arr = [9, 4, 3, 2, 5, 4, 3, 1];</span><br><span class="line">$arr = [9, 4, 3, 2, 5, 4, 3, 1, 10, 8, 5, 3, 2, 1];</span><br><span class="line">function maxDescList($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$list[] = $arr[0];</span><br><span class="line">for($i=1; $i&lt;$len; $i++)&#123;</span><br><span class="line">$llen = count($list);</span><br><span class="line">for($j=$llen-1; $j&gt;=0; $j--)&#123;</span><br><span class="line">if($arr[$i] &gt; $list[$j])&#123;</span><br><span class="line">array_pop($list);</span><br><span class="line">if(empty($list))&#123;</span><br><span class="line">$list[] = $arr[$i];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">array_push($list, $arr[$i]);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $list;</span><br><span class="line">&#125;</span><br><span class="line">// echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">// var_dump(maxDescList($arr));</span><br></pre></td></tr></table></figure><h4 id="找重复出现的数字"><a href="#找重复出现的数字" class="headerlink" title="找重复出现的数字"></a>找重复出现的数字</h4><p>问题描述：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><blockquote><p><strong>解题思路：</strong><br>将整型数组看成栈比较容易理解。每次出栈一个元素，然后查询该值是否存在数组中。如果存在，说明数组该值有两个，然后删除该值（原因是如果不删除，出栈元素会再次重复一次，再出现就会出现错误。因为该值已经查询过）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$arr = [8, 5, 3, 4, 2, 4, 3, 5, 9, 8];</span><br><span class="line">function searchNum($arr)&#123;</span><br><span class="line">$list = array();</span><br><span class="line">while(!empty($arr))&#123;</span><br><span class="line">$val = array_pop($arr);</span><br><span class="line">if(!in_array($val, $arr))&#123;</span><br><span class="line">$list[] = $val;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$key = array_search($val, $arr);</span><br><span class="line">unset($arr[$key]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $list;</span><br><span class="line">&#125;</span><br><span class="line">// var_dump(searchNum($arr));</span><br></pre></td></tr></table></figure><h4 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h4><p>问题描述：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。例如输入<code>“I am a student.”</code>，则输出<code>“student. a am I”</code>。</p><blockquote><p><strong>解题思路：</strong><br>此题利用PHP函数很容易实现。<br>注：要注意使用 <code>array_reverse()</code> 数组翻转函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function strrevStr($str)&#123;</span><br><span class="line">$str_arr = explode(&quot; &quot;, $str);</span><br><span class="line">$reverse_arr = array_reverse($str_arr);</span><br><span class="line">return implode(&quot; &quot;, $reverse_arr);</span><br><span class="line">&#125;</span><br><span class="line">// $str = &quot;I am a student.&quot;;</span><br><span class="line">// echo strrevStr($str);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;试题目录：&lt;br&gt;1、斐波那契数列实现&lt;br&gt;2、楼梯有s阶台阶,上楼时可以一步上1阶,也可以一步上2阶，编程计算共有多少种不同的走法。&lt;br&gt;3、输入两个整数n和m，从数列1，2…….n中随意取几个数，使其和等于m，要求将其中所有的可能组合列出来。&lt;br&gt;4、求一个数组的最长递减子序列 比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，4，3，2}。&lt;br&gt;5、一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。&lt;br&gt;6、输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。例如输入“I am a student.”，则输出“student. a am I”。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试 - 常见函数试题总结（PHP）</title>
    <link href="http://yoursite.com/2018/04/03/%E9%9D%A2%E8%AF%95-%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/03/面试-常见函数试题总结/</id>
    <published>2018-04-03T07:14:51.000Z</published>
    <updated>2018-04-08T10:37:41.027Z</updated>
    
    <content type="html"><![CDATA[<p>试题目录：<br>1、写一个能创建多级目录的PHP函数<br>2、请写一段代码，确保多个进程同时写入一个文件成功<br>3、写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名<br>4、写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。<br>5、无限级分类<br><a id="more"></a></p><h4 id="1、写一个能创建多级目录的PHP函数"><a href="#1、写一个能创建多级目录的PHP函数" class="headerlink" title="1、写一个能创建多级目录的PHP函数"></a>1、写一个能创建多级目录的PHP函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function create_multidir($path, $mode=0777)&#123;</span><br><span class="line">if(is_dir($path))&#123;</span><br><span class="line">return &quot;目录已经存在！&quot;;</span><br><span class="line">&#125;else if(mkdir($path, $mode, true))&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、请写一段代码，确保多个进程同时写入一个文件成功"><a href="#2、请写一段代码，确保多个进程同时写入一个文件成功" class="headerlink" title="2、请写一段代码，确保多个进程同时写入一个文件成功"></a>2、请写一段代码，确保多个进程同时写入一个文件成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$fp = fopen($file, &apos;w+&apos;);</span><br><span class="line">if(flock($fp, LOCK_EX))&#123;</span><br><span class="line">//执行逻辑</span><br><span class="line">fwrite($fp, &quot;content&quot;);</span><br><span class="line">flock($fp, LOCK_UN);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo &quot;服务器繁忙...&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fclose($fp);</span><br></pre></td></tr></table></figure><h4 id="3、写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名"><a href="#3、写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名" class="headerlink" title="3、写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名"></a>3、写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名</h4><p>例如:<a href="http://www.sina.com.cn/abc/de/fg.php?id=1需要取出php或.php" target="_blank" rel="noopener">http://www.sina.com.cn/abc/de/fg.php?id=1需要取出php或.php</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getFileExtension($url)&#123;</span><br><span class="line">$url_arr = parse_url($url);</span><br><span class="line">$filename = basename($url_arr[&apos;path&apos;]);</span><br><span class="line">$file_arr = explode(&apos;.&apos;, $filename);</span><br><span class="line">return $file_arr[1];</span><br><span class="line">&#125;</span><br><span class="line">其中，最后获取扩展名，还可使用字符串截取函数。</span><br><span class="line">return strstr($filename, &apos;.&apos;);</span><br></pre></td></tr></table></figure></p><h4 id="4、写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。"><a href="#4、写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。" class="headerlink" title="4、写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。"></a>4、写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function getAllDirAndFile($path)&#123;</span><br><span class="line">$files = array();</span><br><span class="line">if(is_dir($path))&#123;</span><br><span class="line">$handle = opendir($path);</span><br><span class="line">while(($file=readdir($handle)) !== false)&#123;</span><br><span class="line">if($file != &apos;.&apos; &amp;&amp; $file != &apos;..&apos;)&#123;</span><br><span class="line">if(is_dir($path.&apos;/&apos;.$file))&#123;</span><br><span class="line">$files[$file] = getAllDirAndFile($path.&apos;/&apos;.$file);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$files[] = $file;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">closedir($handle);</span><br><span class="line">&#125;</span><br><span class="line">return $files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、无限级分类"><a href="#5、无限级分类" class="headerlink" title="5、无限级分类"></a>5、无限级分类</h4><p>创建类别表如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE category(</span><br><span class="line">cat_id smallint unsigned not null auto_increment primary key comment&apos;类别ID&apos;,</span><br><span class="line">cat_name VARCHAR(30)NOT NULL DEFAULT&apos;&apos;COMMENT&apos;类别名称&apos;,</span><br><span class="line">parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0 COMMENT&apos;类别父ID&apos;</span><br><span class="line">)engine=MyISAM charset=utf8;</span><br></pre></td></tr></table></figure></p><p>编写一个函数，递归遍历，实现无限分类。</p><p>代码实现：（结果显示层级分明）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getAllCategory($arr, $pid=0)&#123;</span><br><span class="line">$categories = array();</span><br><span class="line">foreach($arr as $val)&#123;</span><br><span class="line">if($val[&apos;parent_id&apos;] == $pid)&#123;</span><br><span class="line">$categories[$val[&apos;cat_id&apos;]] = $val;</span><br><span class="line">$categories[$val[&apos;cat_id&apos;]][&apos;childs&apos;] = getAllCategory($arr, $val[&apos;cat_id&apos;]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $categories;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码实现：（结果显示在一个层级，通过level标明层级）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getAllCategory($arr, $pid=0, $level)&#123;</span><br><span class="line">static $categories = array();</span><br><span class="line">foreach($arr as $val)&#123;</span><br><span class="line">if($val[&apos;parent_id&apos;] == $pid)&#123;</span><br><span class="line">$categories[] = $val;</span><br><span class="line">$categories[&apos;level&apos;] = $level;</span><br><span class="line">getAllCategory($arr, $val[&apos;cat_id&apos;], $level++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $categories;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;试题目录：&lt;br&gt;1、写一个能创建多级目录的PHP函数&lt;br&gt;2、请写一段代码，确保多个进程同时写入一个文件成功&lt;br&gt;3、写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名&lt;br&gt;4、写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。&lt;br&gt;5、无限级分类&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法问题 - 排序算法与二分查找法（PHP实现）</title>
    <link href="http://yoursite.com/2018/04/03/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/03/经典算法问题-排序算法与二分查找法/</id>
    <published>2018-04-03T05:53:33.000Z</published>
    <updated>2018-04-03T07:01:44.165Z</updated>
    
    <content type="html"><![CDATA[<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>测试数组：<br><code>$arr = [3,5,7,1,8,4,9,6,2];</code></p><h5 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h5><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。<br><a id="more"></a><br><strong>算法描述</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><strong>代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort($arr)&#123;</span><br><span class="line">if(!is_array($arr)) return false;</span><br><span class="line">$len = count($arr);</span><br><span class="line">if($len &lt;= 1) return $arr;</span><br><span class="line">for($i=0; $i&lt;$len; $i++)&#123;</span><br><span class="line">for($j=1; $j&lt;$len-$i; $j++)&#123;</span><br><span class="line">if($arr[$j-1] &gt; $arr[$j])&#123;</span><br><span class="line">$tmp = $arr[$j-1];</span><br><span class="line">$arr[$j-1] = $arr[$j];</span><br><span class="line">$arr[j] = $tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h5><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><p><strong>算法描述</strong><br>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><p><strong>代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function selectSort($arr)&#123;</span><br><span class="line">if(!is_array($arr)) return false;</span><br><span class="line">$len = count($arr);</span><br><span class="line">if($len &lt;= 1) return $arr;</span><br><span class="line">for($i=0; $i&lt;$len; $i++)&#123;</span><br><span class="line">$k = $i;</span><br><span class="line">for($j=$i+1; $j&lt;$len; $j++)&#123;</span><br><span class="line">if($arr[$k] &gt; $arr[$j])&#123;</span><br><span class="line">$k = $j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if($k != $i)&#123;</span><br><span class="line">$tmp = $arr[$k];</span><br><span class="line">$arr[$k] = $arr[$i];</span><br><span class="line">$arr[$i] = $tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h5><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong>算法描述</strong><br>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><p><strong>代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function insertSort($arr)&#123;</span><br><span class="line">if(!is_array($arr)) return false;</span><br><span class="line">$len = count($arr);</span><br><span class="line">if($len &lt;= 1) return $arr;</span><br><span class="line">for($i=1; $i&lt;$len; $i++)&#123;</span><br><span class="line">$tmp = $arr[$i];</span><br><span class="line">for($j=$i-1; $j&gt;=0; $j--)&#123;</span><br><span class="line">if($tmp &lt; $arr[$j])&#123;</span><br><span class="line">$arr[$j+1] = $arr[$j];</span><br><span class="line">$arr[$j] = $tmp;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h5><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p> <strong>算法描述</strong><br>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p><strong>代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function quickSort($arr)&#123;</span><br><span class="line">if(!is_array($arr)) return false;</span><br><span class="line">$len = count($arr);</span><br><span class="line">if($len &lt;= 1) return $arr;</span><br><span class="line">$left = $right = array();</span><br><span class="line">for($i=1; $i&lt;$len; $i++)&#123;</span><br><span class="line">if($arr[$i] &gt; $arr[0])&#123;</span><br><span class="line">$right[] = $arr[$i];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$left[] = $arr[$i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$left = quickSort($left);</span><br><span class="line">$right = quickSort($right);</span><br><span class="line">return array_merge($left, array($arr[0]), $right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><font color="red">排序参考文章：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></font><h4 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h4><p><strong>算法描述</strong></p><ol><li>二分查找又称折半查找，它是一种效率较高的查找方法。</li><li>二分查找要求：<br>（1）必须采用顺序存储结构<br>（2）.必须按关键字大小有序排列</li><li>原理：将数组分为三部分，依次是中值（所谓的中值就是数组中间位置的那个值）前，中值，中值后；将要查找的值和数组的中值进行比较，若小于中值则在中值前 面找，若大于中值则在中值后面找，等于中值时直接返回。然后依次是一个递归过程，将前半部分或者后半部分继续分解为三部分。</li><li>实现：二分查找的实现用递归和循环两种方式</li></ol><p><strong>（1）代码实现：（非递归实现）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function binarySearch1($arr, $searchV)&#123;</span><br><span class="line">$high = count($arr);</span><br><span class="line">$low = 0;</span><br><span class="line">while($low &lt;= $high)&#123;</span><br><span class="line">$middle = floor(($high+$low)/2);</span><br><span class="line">if($arr[$middle] &gt; $searchV)&#123;</span><br><span class="line">$high = $middle - 1;</span><br><span class="line">&#125;else if($arr[$middle] &lt; $searchV)&#123;</span><br><span class="line">$low = $middle +1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return $middle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>（2）代码实现：（递归实现）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function binarySearch2($arr, $searchV, $low, $high)&#123;</span><br><span class="line">if($low &lt;= $high)&#123;</span><br><span class="line">$middle = floor(($low+$high)/2);</span><br><span class="line">if($arr[$middle] &gt; $searchV)&#123;</span><br><span class="line">return binarySearch2($arr, $searchV, $low, $middle-1);</span><br><span class="line">&#125;else if($arr[$middle] &lt; $searchV)&#123;</span><br><span class="line">return binarySearch2($arr, $searchV, $middle+1, $high);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return $middle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h4&gt;&lt;p&gt;测试数组：&lt;br&gt;&lt;code&gt;$arr = [3,5,7,1,8,4,9,6,2];&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;1、冒泡排序&quot;&gt;&lt;a href=&quot;#1、冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1、冒泡排序&quot;&gt;&lt;/a&gt;1、冒泡排序&lt;/h5&gt;&lt;p&gt;冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法问题 - 最大连续子数列和与最大连续子数列乘积（PHP实现）</title>
    <link href="http://yoursite.com/2018/04/03/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E5%88%97%E5%92%8C%E4%B8%8E%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E5%88%97%E4%B9%98%E7%A7%AF/"/>
    <id>http://yoursite.com/2018/04/03/经典算法问题-最大连续子数列和与最大连续子数列乘积/</id>
    <published>2018-04-03T05:30:25.000Z</published>
    <updated>2018-04-03T05:50:17.119Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、最大连续子数列和问题"><a href="#一、最大连续子数列和问题" class="headerlink" title="一、最大连续子数列和问题"></a>一、最大连续子数列和问题</h4><p>给出测试数列：<br><code>$arr = [-2, 6, -1, 5, 4, -7, 2, 3];</code></p><h5 id="1、穷举法"><a href="#1、穷举法" class="headerlink" title="1、穷举法"></a>1、穷举法</h5><blockquote><p><strong>暴力求解法（穷举法）：</strong><br>暴力求解也是容易理解的做法，简单来说，我们只要用两层循环枚举起点和终点，这样就尝试了所有的子序列，然后计算每个子序列的和，然后找到其中最大的即可<br>我们可以采用一个两重的循环，假设两个循环的循环变量分别为i, j。第一层循环从第一个元素遍历到后面，第二个元素从&gt;=第一个元素的位置开始到最后。这样就可以遍历到所有的点。然后，我们取所有从i到j的连续数组部分和再比较。这样最终就可以得到最大的连续和以及最大子序列的起始与结束点。</p></blockquote><a id="more"></a><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function maxSubSum1($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$maxSum = 0;</span><br><span class="line">for($i=0; $i&lt;$len; $i++)&#123;</span><br><span class="line">for($j=$i; $j&lt;$len; $j++)&#123;</span><br><span class="line">$thisSum = 0;</span><br><span class="line">for($k=$i; $k&lt;=$j; $k++)&#123;</span><br><span class="line">$thisSum += $arr[$k];</span><br><span class="line">&#125;</span><br><span class="line">if($thisSum &gt; $maxSum)&#123;</span><br><span class="line">$maxSum = $thisSum;</span><br><span class="line">$seqStart = $i;</span><br><span class="line">$seqEnd = $j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$length = $seqEnd-$seqStart+1;</span><br><span class="line">return array_slice($arr, $seqStart, $length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2、优化穷举法"><a href="#2、优化穷举法" class="headerlink" title="2、优化穷举法"></a>2、优化穷举法</h5><blockquote><p><strong>一个简单的优化：</strong><br>前面那个最简单暴力的方法虽然看起来能解决问题，但是循环遍历的次数太多了。里面还是有不少可以改进的空间。比如说，每次我们用变量k遍历i到j的时候，都要计算求和。实际上当每次j增加1时，k把前面计算的结果在循环里又计算了一遍。这是完全没必要的，完全可以重复利用前面的计算结果。</p></blockquote><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function maxSubSum2($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$maxSum = 0;</span><br><span class="line">for($i=1; $i&lt;$len; $i++)&#123;</span><br><span class="line">$thisSum = 0;</span><br><span class="line">for($j=$i; $j&lt;$len; $j++)&#123;</span><br><span class="line">$thisSum += $arr[$j];</span><br><span class="line">if($thisSum &gt; $maxSum)&#123;</span><br><span class="line">$maxSum = $thisSum;</span><br><span class="line">$seqStart = $i;</span><br><span class="line">$seqEnd = $j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$length = $seqEnd-$seqStart+1;</span><br><span class="line">return array_slice($arr, $seqStart, $length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="3、线性算法"><a href="#3、线性算法" class="headerlink" title="3、线性算法"></a>3、线性算法</h5><blockquote><p>这个问题还是存在着一个线性时间复杂度的解法。需要我们对数组的序列进行进一步的分析。我们在数组中间找到的连续子序列，可能存在和为负的序列。如果需要找到一个最大的子数组的话，肯定该序列不是在最大子序列当中的。我们可以通过反证的方式来证明。<br>假设数组A[i…j]，里面的元素和为负。如果A[i….j]在一个最大子序列的数组中间，假定为A[i…k]，k &gt; j。那么既然从i到j这一段是负的，我把这一段去掉剩下的部分完全比我们假定的这个最大子序列还要大。这就和我的假设矛盾了。<br>这个假设还有一个限制，就是该数组就是从i开头的。否则有人可能会这么问，如果我A[i…j]这一部分确实是一个负数，但是在A[i]前面是一个很大的正数，使得他们的和为正数。那不就使得我们的结果不成立了么？如果我们是从某个数组的开头i开始的话，就不存在这个情况。<br>结合前面的讨论，我们就可以发现一个有意思的事情，就是假设我们从数组的开头A[0]开始，不断的往后面走，每一步判断是否当前和最大，并保存结果。当发现当前字串和为负数的时候，我们可以直接跳过。假设当前的索引为i的话，从0到i这一段的和是负数，可以排除。然后再从当前元素的后面开始找。这样可以得到最终最大子串和以及串的起点和终点。</p></blockquote><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function maxSubSum3($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$maxSum = 0;</span><br><span class="line">$thisSum = 0;</span><br><span class="line">for($i=0, $j=0; $j&lt;$len; $j++)&#123;</span><br><span class="line">$thisSum += $arr[$j];</span><br><span class="line">if($thisSum &gt; $maxSum)&#123;</span><br><span class="line">$maxSum = $thisSum;</span><br><span class="line">$seqStart = $i;</span><br><span class="line">$seqEnd = $j;</span><br><span class="line">&#125;else if($thisSum &lt; 0)&#123;</span><br><span class="line">$i = $j+1;</span><br><span class="line">$thisSum = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$length = $seqEnd-$seqStart+1;</span><br><span class="line">return array_slice($arr, $seqStart, $length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二、最大连续子数列乘积问题"><a href="#二、最大连续子数列乘积问题" class="headerlink" title="二、最大连续子数列乘积问题"></a>二、最大连续子数列乘积问题</h4><p>给出测试数列：<br><code>$arr = [2, 3, 0, -3, 3, -1, 0, 9];</code></p><h5 id="1、穷举法-1"><a href="#1、穷举法-1" class="headerlink" title="1、穷举法"></a>1、穷举法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function maxSubProduct1($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$maxPro = 0;</span><br><span class="line">for($i=0; $i&lt;$len; $i++)&#123;</span><br><span class="line">$thisPro = 1;</span><br><span class="line">for($j=$i; $j&lt;$len; $j++)&#123;</span><br><span class="line">$thisPro *= $arr[$j];</span><br><span class="line">if($thisPro &gt; $maxPro)&#123;</span><br><span class="line">$maxPro = $thisPro;</span><br><span class="line">$seqStart = $i;</span><br><span class="line">$seqEnd = $j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$length = $seqEnd-$seqStart+1;</span><br><span class="line">return array_slice($arr, $seqStart, $length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、线性算法"><a href="#2、线性算法" class="headerlink" title="2、线性算法"></a>2、线性算法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function maxSubProduct2($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$maxPro = 0;</span><br><span class="line">$thisPro = 1;</span><br><span class="line">for($i=0, $j=0; $j&lt;$len; $j++)&#123;</span><br><span class="line">$thisPro *= $arr[$j];</span><br><span class="line">if($thisPro &gt; $maxPro)&#123;</span><br><span class="line">$maxPro = $thisPro;</span><br><span class="line">$seqStart = $i;</span><br><span class="line">$seqEnd = $j;</span><br><span class="line">&#125;else if($thisPro == 0)&#123;</span><br><span class="line">$thisPro = 1;</span><br><span class="line">$i = $j+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$length = $seqEnd-$seqStart+1;</span><br><span class="line">return array_slice($arr, $seqStart, $length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong><br>通过对“最大连续子数列和与最大连续子数列乘积”的算法实现，可发现共通之处，即<font color="red">算法原理都是一样的</font>。最简单、最暴力的解决方法就是穷举法，同时，算法时间复杂度也是最差的。现实中使用必须要优化，否则特别影响性能。<br>因此，就出现了线性算法，此算法时间复杂度只有 O(n)，极大的提高了性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、最大连续子数列和问题&quot;&gt;&lt;a href=&quot;#一、最大连续子数列和问题&quot; class=&quot;headerlink&quot; title=&quot;一、最大连续子数列和问题&quot;&gt;&lt;/a&gt;一、最大连续子数列和问题&lt;/h4&gt;&lt;p&gt;给出测试数列：&lt;br&gt;&lt;code&gt;$arr = [-2, 6, -1, 5, 4, -7, 2, 3];&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;1、穷举法&quot;&gt;&lt;a href=&quot;#1、穷举法&quot; class=&quot;headerlink&quot; title=&quot;1、穷举法&quot;&gt;&lt;/a&gt;1、穷举法&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;暴力求解法（穷举法）：&lt;/strong&gt;&lt;br&gt;暴力求解也是容易理解的做法，简单来说，我们只要用两层循环枚举起点和终点，这样就尝试了所有的子序列，然后计算每个子序列的和，然后找到其中最大的即可&lt;br&gt;我们可以采用一个两重的循环，假设两个循环的循环变量分别为i, j。第一层循环从第一个元素遍历到后面，第二个元素从&amp;gt;=第一个元素的位置开始到最后。这样就可以遍历到所有的点。然后，我们取所有从i到j的连续数组部分和再比较。这样最终就可以得到最大的连续和以及最大子序列的起始与结束点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试总结（一）</title>
    <link href="http://yoursite.com/2018/04/02/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/02/面试总结（一）/</id>
    <published>2018-04-02T02:58:13.000Z</published>
    <updated>2018-04-03T05:51:23.803Z</updated>
    
    <content type="html"><![CDATA[<p>上周面试了一个公司，下面做一下总结。</p><h4 id="一、算法"><a href="#一、算法" class="headerlink" title="一、算法"></a>一、算法</h4><p>1、斐波那契数列实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">斐波那契数列： </span><br><span class="line">1 1 2 3 5 8 13 21 34 55 …</span><br><span class="line">概念： </span><br><span class="line">前两个值都为1，该数列从第三位开始，每一位都是当前位前两位的和 </span><br><span class="line">规律公式为： </span><br><span class="line">Fn = F(n-1) + F(n-2) </span><br><span class="line">F：指当前这个数列 </span><br><span class="line">n：指数列的下标</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><strong>PHP代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//非递归</span><br><span class="line">function fbnq($n)&#123;</span><br><span class="line">if($n&lt;=0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">$arr[1] = $arr[2] = 1;</span><br><span class="line">for($i=3; $i&lt;=$n; $i++)&#123;</span><br><span class="line">$arr[$i] = $arr[$i-1] + $arr[$i-2];</span><br><span class="line">&#125;</span><br><span class="line">return $arr;</span><br><span class="line">&#125;</span><br><span class="line">//递归实现</span><br><span class="line">function fbnq($n)&#123;</span><br><span class="line">if($n &lt;= 0) return 0;</span><br><span class="line">static $arr;</span><br><span class="line">$arr[1] = $arr[2] = 1;</span><br><span class="line">    if($n &gt; 3)&#123;</span><br><span class="line">    fbnq($n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    $arr[$n] = $arr[$n-1] + $arr[$n-2];</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、最大连续子数列乘积问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给出一个数列为：$arr = [2, 3, 0, -3, 3, -1, 0, 9];</span><br><span class="line">求出最大连续子数列乘积。</span><br><span class="line">结果为：[-3, 3, -1]</span><br></pre></td></tr></table></figure></p><p><strong>PHP代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function maxSubProduct($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$maxPro = 0;</span><br><span class="line">$thisPro = 1;</span><br><span class="line">for($i=0, $j=0; $j&lt;$len; $j++)&#123;</span><br><span class="line">$thisPro *= $arr[$j];</span><br><span class="line">if($thisPro &gt; $maxPro)&#123;</span><br><span class="line">$maxPro = $thisPro;</span><br><span class="line">$seqStart = $i;</span><br><span class="line">$seqEnd = $j;</span><br><span class="line">&#125;else if($thisPro == 0)&#123;</span><br><span class="line">$thisPro = 1;</span><br><span class="line">$i = $j+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$length = $seqEnd-$seqStart+1;</span><br><span class="line">return array_slice($arr, $seqStart, $length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二、PHP基础"><a href="#二、PHP基础" class="headerlink" title="二、PHP基础"></a>二、PHP基础</h4><h5 id="1、比较empty-、isset-两个函数的区别，对应给出如下示例："><a href="#1、比较empty-、isset-两个函数的区别，对应给出如下示例：" class="headerlink" title="1、比较empty()、isset()两个函数的区别，对应给出如下示例："></a>1、比较empty()、isset()两个函数的区别，对应给出如下示例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$a = 0;</span><br><span class="line">$b = &apos;0&apos;;</span><br><span class="line">$c = null;</span><br><span class="line">$d = &apos; &apos;;</span><br><span class="line">var_dump(empty($a)); //1</span><br><span class="line">var_dump(empty($b)); //1</span><br><span class="line">var_dump(empty($c)); //1</span><br><span class="line">var_dump(isset($c)); //0</span><br><span class="line">var_dump(isset($d)); //1</span><br><span class="line">var_dump($a == $b); //1</span><br><span class="line">var_dump($a == $c); //1</span><br></pre></td></tr></table></figure><p><strong>相关知识点介绍：</strong></p><blockquote><p><code>bool isset ( mixed $var [, mixed $... ] ) — 检测变量是否已设置并且不是 NULL。</code><br>返回值：如果 var 存在并且值不是 NULL 则返回 TRUE，否则返回 FALSE。<br>（注：isset() 只能用于变量，因为传递任何其它参数都将造成解析错误。若想检测常量是否已设置，可使用 defined() 函数。<br>因为是一个语言构造器而不是一个函数，不能被 可变函数 调用。）<br><code>bool empty ( mixed $var ) — 检查一个变量是否为空</code><br>判断一个变量是否被认为是空的。当一个变量并不存在，或者它的值等同于FALSE，那么它会被认为不存在。如果变量不存在的话，empty()并不会产生警告。<br>返回值：<br>当var存在，并且是一个非空非零的值时返回 FALSE 否则返回 TRUE.</p><blockquote><p><strong>以下的东西被认为是空的：</strong><br>“” (空字符串)<br>0 (作为整数的0)<br>0.0 (作为浮点数的0)<br>“0” (作为字符串的0)<br>NULL<br>FALSE<br>array() (一个空数组)<br>$var; (一个声明了，但是没有值的变量)<br>（注：因为是一个语言构造器而不是一个函数，不能被 可变函数 调用。）</p></blockquote></blockquote><h5 id="2、数组方面，给出如下："><a href="#2、数组方面，给出如下：" class="headerlink" title="2、数组方面，给出如下："></a>2、数组方面，给出如下：</h5><p>写出对应输出的结果，包括key=&gt;value值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$a = array( 2, 1, &apos;3&apos;=&gt;2 );</span><br><span class="line">$b = array( 2=&gt;1, 4=&gt;2, 5=&gt;4 );</span><br><span class="line">foreach( $a as &amp;$k )&#123;</span><br><span class="line">    $k++;</span><br><span class="line">&#125;</span><br><span class="line">foreach( $b as $k )&#123;</span><br><span class="line">    $k++;</span><br><span class="line">&#125;</span><br><span class="line">var_dump($a); //0=&gt;3, 1=&gt;2, 3=&gt;5</span><br><span class="line">var_dump($b); //2=&gt;1, 4=&gt;2, 5=&gt;3</span><br><span class="line">var_dump($k); //5</span><br></pre></td></tr></table></figure></p><p><strong>答案解析：</strong></p><blockquote><p>根据程序自上到下的执行顺序，可知道首先遍历$a数组，且要注意<font color="red">遍历只有值，没有key，仅仅只是名字而已。</font>此处，我就看错了。然后遍历$b数组，最后输出。<br>首先要知道的一点是：$a数组将值传引用了，因此后面对$k的值更改则会更改对应的值。<br>所以，$a的值相对应的都会+1，则其值为 0=&gt;3,1=&gt;2,3=&gt;3。<br>下面，又再次对$b数组进行遍历，仅仅只是值传递。所以，对于$b数组未做改变，原样输出：2=&gt;1,4=&gt;2,5=&gt;4。<br>虽然$b数组遍历未对数值的值进行改变，但是，对$k的值进行更改了。因此，$k的值再经过$b数组的遍历后为5，要注意，$k是传引用的，与$a数组中的最后一个值是引用关系。因此，$a数组中最后一个值现在变为5。且$k的值也是5。</p></blockquote><p><strong>相关知识点介绍：</strong><br>此处，考的知识点比较多一些，比较容易混淆且不被发现。<br>首先是遍历的时候，命名问题容易让人产生是$key，没有值的幻觉，因此要注意看（面试官提醒了我好几次，最后还是看错了）。<br>再次，就是传值与传引用的知识点运用。其中涉及到变量作用域的问题，此处我也考虑错了，理解成局部变量了。下面是变量作用域的总结：</p><blockquote><p>PHP中变量的作用域可以分为:<br><strong>超全局变量：</strong>在一个脚本的任何作用域里都可以被访问,可直接在局部范围里使用,不需要用global声明。比如$GLOBALS,$_ENV,$_SERVER,$_GET,$_POST,$_FILES,$_SESSION,$_COOKIE等.<br><strong>全局变量：</strong>声明的变量不在class,function等语言结构内部.如果要在class,function等内部使用全局变量,需要用关键词global或者超全局变量$GLOBALS.<br><strong>局部变量：</strong>在class,function等结构语句内部声明的变量.<br><strong>静态变量：</strong>在function中使用关键词static声明的变量,静态变量的值保留直至当前请求的脚本运行结束,比如可以用来保存数据库连接对象.</p></blockquote><h4 id="三、Linux命令"><a href="#三、Linux命令" class="headerlink" title="三、Linux命令"></a>三、Linux命令</h4><p>给你一段文本文件，例如：file.txt<br>102 baidu 100 5000<br>101 google 110 5000<br>104 sohu 100 4500<br>103 guge 50 3000<br>下面是需要执行的命令需求：<br>1、输出前两行<br>2、输出第3行<br>3、输出第1列<br>4、输出全部并且以第一列从小到大排序<br>5、回到家目录，再回到上次目录<br>下面是对上面命令的解答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、head -2 file.txt</span><br><span class="line">2、sed -n &apos;3p&apos; file.txt 或 cat file.txt | head -3 | tail -1</span><br><span class="line">3、awk &apos;&#123;print $1&#125;&apos; file.txt</span><br><span class="line">4、sort -n -t &apos; &apos; -k 1 file.txt</span><br><span class="line">5、cd ~ ; cd -</span><br></pre></td></tr></table></figure></p><h4 id="四、操作系统方面"><a href="#四、操作系统方面" class="headerlink" title="四、操作系统方面"></a>四、操作系统方面</h4><h5 id="1、进程间通信方式以及相对应的原理"><a href="#1、进程间通信方式以及相对应的原理" class="headerlink" title="1、进程间通信方式以及相对应的原理"></a>1、进程间通信方式以及相对应的原理</h5><p>通信方式有：管道、信号、共享内存<br>原理：<br>管道：<br>信号：<br>共享内存：</p><h5 id="2、操作系统中有个重复函数加载什么的"><a href="#2、操作系统中有个重复函数加载什么的" class="headerlink" title="2、操作系统中有个重复函数加载什么的"></a>2、操作系统中有个重复函数加载什么的</h5><h5 id="3、I-O多路复用技术"><a href="#3、I-O多路复用技术" class="headerlink" title="3、I/O多路复用技术"></a>3、I/O多路复用技术</h5><h4 id="五、计算机网络"><a href="#五、计算机网络" class="headerlink" title="五、计算机网络"></a>五、计算机网络</h4><h5 id="1、计算机网络OSI七层协议模型、TCP-IP五层协议模型"><a href="#1、计算机网络OSI七层协议模型、TCP-IP五层协议模型" class="headerlink" title="1、计算机网络OSI七层协议模型、TCP/IP五层协议模型"></a>1、计算机网络OSI七层协议模型、TCP/IP五层协议模型</h5><p>OSI七层协议模型包括：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。<br>TCP/IP五层协议模型包括：应用层、传输层、网络层、数据链路层、物理层。<br>以TCP/IP五层协议模型来说明每层作用及相关协议：<br>应用层：对编程人员开发的接口，用于软件开发。主要协议包括：HTTP、SMTP、DNS等<br>传输层：接受应用层的数据包，进行处理，并选择相应的协议进行转发到下层。主要协议包括：TCP、UDP等<br>网络层：逻辑寻址，用于在网络中通过路由协议用IP:Port来进行子网定位。主要协议包括：路由协议、IP协议等<br>数据链路层：物理寻址，用于在子网中通过交换机根据Mac地址来进行定位主机；同时，将数据进行处理，转换为位流。<br>物理层：通过物理媒介，传输数据流。</p><h5 id="2、TCP-UDP的区别及特点"><a href="#2、TCP-UDP的区别及特点" class="headerlink" title="2、TCP/UDP的区别及特点"></a>2、TCP/UDP的区别及特点</h5><p>TCP：面向连接的、安全的协议。<br>UDP：无连接的、不安全的协议。</p><h5 id="3、HTTP相关知识点"><a href="#3、HTTP相关知识点" class="headerlink" title="3、HTTP相关知识点"></a>3、HTTP相关知识点</h5><p>HTTP：超文本传输协议。是一个面向连接的（底层采用的是TCP协议）、无状态的协议。</p><h4 id="六、原理方面"><a href="#六、原理方面" class="headerlink" title="六、原理方面"></a>六、原理方面</h4><h5 id="1、web服务的工作原理"><a href="#1、web服务的工作原理" class="headerlink" title="1、web服务的工作原理"></a>1、web服务的工作原理</h5><p>WEB服务器也称为WWW(WORLD WIDE WEB)服务器，主要功能是提供网上信息浏览服务。通俗的说，Web服务器是可以向发出请求的浏览器提供文档的程序。<br>1、服务器是一种被动程序：只有当Internet上运行在其他计算机中的浏览器发出请求时，服务器才会响应。<br>2、最常用的Web服务器是Apache和Microsoft的Internet信息服务器（Internet Information Services，IIS）。<br>3、Internet上的服务器也称为Web服务器，是一台在Internet上具有独立IP地址的计算机，可以向Internet上的客户机提供WWW、Email和FTP等各种Internet服务。<br>4、Web服务器是指驻留于因特网上某种类型计算机的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。服务器使用HTTP（超文本传输协议）与客户机浏览器进行信息交流，这就是人们常把它们称为HTTP服务器的原因。<br>Web服务器不仅能够存储信息，还能在用户通过Web浏览器提供的信息的基础上运行脚本和程序。</p><p><strong>采用的协议：</strong><br>1、应用层使用HTTP协议。<br>2、HTML（标准通用标记语言下的一个应用）文档格式。<br>3、浏览器统一资源定位器（URL）。<br>4、为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><p><strong>Web服务的工作原理：</strong><br>Web服务器的工作原理并不复杂，一般可分成如下4个步骤：连接过程、请求过程、应答过程以及关闭连接。<br><strong>连接过程</strong>：通过三次握手建立连接。（客户端向服务器发送请求报文SYN；服务器接受请求连接，并向客户端发送ACK确认；客户端接受ACK确认并返回给服务器，服务器接受到客户端返回的ACK确认后建立起连接。）<br><strong>请求过程</strong>客户端与服务端建立连接后，客户端即可向服务端发送请求。（如果是持久连接，一次连接可多次请求。非持久连接，则一次连接只可请求一次。）<br><strong>应答过程</strong>客户端将请求发送到服务端，服务端接受链接，并进行处理。然后把处理结果再返回给客户端。<br><strong>关闭连接</strong>最后，通过四次挥手断开连接。（客户端向服务器发送断开连接请求报文FIN；服务器接受断开连接，并向客户端发送ACK确认报文，同时，待服务器端数据处理完后返回FIN关闭连接；客户端接受到服务端的确认报文ACK，待接收到服务端的关闭连接报文FIN后，返回ACK到服务端确认关闭连接。）</p><p>使用最多的Web Server服务器软件有：IIS、Apache、nginx。</p><blockquote><p>为何使用三次握手机制：<br>假设如下异常情况：<br>客户端向服务器发送了第一条请求报文，但是该报文并未在网络中被丢弃，而是长时间阻滞在某处，而客户端收不到服务器确认，以为该报文丢失，于是重新发送该报文，这次的报文成功到达服务器，如果不使用三次握手，则服务器只需对该报文发出确认，就建立了一个连接。而在这个连接建立，并释放后，第一次发送的，阻滞在网络中的报文到达了服务器，服务器以为是客户端又重新发送了一个连接请求（实际上在客户端那里，该连接早已失效），就又向客户端发送一个确认，但客户端认为他没有发送该请求报文，因此不理睬服务器发送的确认，而服务器以为又建立了一个新的连接，于是一直等待A发来数据，造成了服务器资源的浪费，并且会产生安全隐患。因此，若使用三次握手机制，服务器发送了该确认后，收不到客户端的确认，也就知道并没有建立连接，因此不会将资源浪费在这种没有意义的等待上。</p></blockquote><h5 id="2、nginx的工作原理"><a href="#2、nginx的工作原理" class="headerlink" title="2、nginx的工作原理"></a>2、nginx的工作原理</h5><p>nginx类似是一个代理服务器，当浏览器请求的是一些静态资源，则直接返回；若接收的是动态请求，则通过配置文件直接将请求映射到对应的location block，而此location中所配置的各个指令则会启动不同的模块去完成工作，最后返回给浏览器。<br>此处，处理动态请求的PHP文件，一般是PHP-FPM。</p><h4 id="七、其它知识点"><a href="#七、其它知识点" class="headerlink" title="七、其它知识点"></a>七、其它知识点</h4><h5 id="1、session和cookie的区别"><a href="#1、session和cookie的区别" class="headerlink" title="1、session和cookie的区别"></a>1、session和cookie的区别</h5><p>首先，要知道session和cookie是怎么产生的。当客户端访问服务端的时候，服务器会对应生成一个唯一的SESSIONID，同数据一起返回给客户端，当客户端再次访问的时候，即可带着这个SESSIONID，服务端就可根据SESSIONID识别用户。HTTP是一个无状态的协议（即同一个会话的连续两次请求是互相不了解的，如果需要前面的信息，必须重传），session和cookie是会话层保持会话的一个措施。<br>（1）因此，首先一个区别就是session保存在服务端，cookie保存在客户端。<br>cookie保存在浏览器中，如果没有设置过期时间，则关闭浏览器的时候，cookie就消失了，相对应的SESSIONID也消失了。当设置过期时间的时候，cookie就保存在客户端硬盘上，当下次再访问网站的时候，可自动携带此cookie。<br>（2）由于cookie保存在客户端，因此cookie是不安全的，容易被人给copy，伪造cookie登录。session保存在服务端，相对来说安全一些。<br>假如浏览器禁止cookie，那应该怎么保持会话？<br>① 可通过重写URL，即通过GET方法附带SESSIONID的方式传送到服务端。<br>② 如果是表单，可通过隐藏表单传送SESSIONID。<br>（3）由于session是保存在服务端，因此session的增加会导致服务器数据量增加，应定时清理无效数据。<br>（4）cookie保存在客户端，但是也不能随意大批量使用，因为cookie的增加会增加数据传输量，导致带宽的增加。</p><h5 id="2、堆区与栈区介绍"><a href="#2、堆区与栈区介绍" class="headerlink" title="2、堆区与栈区介绍"></a>2、堆区与栈区介绍</h5><p>内存分配有三种：静态存储区、堆区和栈区。他们的功能不同，对他们使用方式也就不同。<br><strong>静态存储区：</strong>内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。<br><strong>栈区：</strong>在执行函数时，函数（包括main函数）内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。（任何变量都处于站区，例如int a[] = {1, 2},变量a处于栈区。数组的内容也存在于栈区。）<br><strong>堆区：</strong>亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，并立即将指针置位NULL，防止产生野指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周面试了一个公司，下面做一下总结。&lt;/p&gt;
&lt;h4 id=&quot;一、算法&quot;&gt;&lt;a href=&quot;#一、算法&quot; class=&quot;headerlink&quot; title=&quot;一、算法&quot;&gt;&lt;/a&gt;一、算法&lt;/h4&gt;&lt;p&gt;1、斐波那契数列实现&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;斐波那契数列： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 1 2 3 5 8 13 21 34 55 …&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;概念： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前两个值都为1，该数列从第三位开始，每一位都是当前位前两位的和 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;规律公式为： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Fn = F(n-1) + F(n-2) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F：指当前这个数列 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n：指数列的下标&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之sort</title>
    <link href="http://yoursite.com/2018/03/30/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bsort/"/>
    <id>http://yoursite.com/2018/03/30/Linux命令之sort/</id>
    <published>2018-03-30T07:50:27.000Z</published>
    <updated>2018-03-30T10:37:02.455Z</updated>
    
    <content type="html"><![CDATA[<p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sort [选项] [参数]</span><br><span class="line">选项：</span><br><span class="line">-n：依照数值的大小排序；</span><br><span class="line">-r：以相反的顺序来排序；</span><br><span class="line">-k：是指定需要爱排序的栏位；</span><br><span class="line">-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符；</span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入制定的文件；（注：直接使用重定向会覆盖原文件，将其清空。）</span><br><span class="line">参数：</span><br><span class="line">文件：指定待排序的文件列表。</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="用法解析"><a href="#用法解析" class="headerlink" title="用法解析"></a>用法解析</h4><h5 id="sort的工作原理"><a href="#sort的工作原理" class="headerlink" title="sort的工作原理"></a>sort的工作原理</h5><p>sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ cat seq.txt</span><br><span class="line">banana</span><br><span class="line">apple</span><br><span class="line">pear</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">[root@www ~]$ sort seq.txt</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">pear</span><br></pre></td></tr></table></figure></p><h5 id="sort的-u选项"><a href="#sort的-u选项" class="headerlink" title="sort的-u选项"></a>sort的-u选项</h5><p>它的作用很简单，就是在输出行中去除重复行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ sort -u seq.txt</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure></p><h5 id="sort的-r选项"><a href="#sort的-r选项" class="headerlink" title="sort的-r选项"></a>sort的-r选项</h5><p>sort默认的排序方式是升序，如果想改成降序，就加个-r就搞定了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ sort -r seq.txt</span><br><span class="line">pear</span><br><span class="line">pear</span><br><span class="line">orange</span><br><span class="line">banana</span><br><span class="line">apple</span><br></pre></td></tr></table></figure></p><h5 id="sort的-n选项"><a href="#sort的-n选项" class="headerlink" title="sort的-n选项"></a>sort的-n选项</h5><p>sort排序默认是采用ASCII码值进行比较来排序的，因此对比10与2的大小时，10就会比2小了，因为比较10与2的时候，真实比较的是1与2的大小，显然1小，所以就将10放在2的前面了。<br>对于此类情况，我们只要使用-n选项，就限制sort使用数值来进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ cat number.txt</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">19</span><br><span class="line">11</span><br><span class="line">2</span><br><span class="line">[root@www ~]$ sort number.txt</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">19</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">[root@www ~]$ sort -n number.txt</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">19</span><br></pre></td></tr></table></figure></p><h5 id="sort的-o选项"><a href="#sort的-o选项" class="headerlink" title="sort的-o选项"></a>sort的-o选项</h5><p>由于sort默认是把结果输出到标准输出，所以需要用重定向才能将结果写入文件，形如sort filename &gt; newfile。<br>但是，如果你想把排序结果输出到原文件中，用重定向可就不行了。会将原文件覆盖，情况数据。<br>对于这种情况，sort提供了-o选项解决了这个问题，可将结果写入原文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ sort -r number.txt &gt; number.txt</span><br><span class="line">[root@www ~]$ cat number.txt</span><br><span class="line">[root@www ~]$</span><br><span class="line">[root@www ~]$ cat number.txt</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">19</span><br><span class="line">11</span><br><span class="line">2</span><br><span class="line">[root@www ~]$ sort -nr number.txt -o number.txt</span><br><span class="line">[root@www ~]$ cat number.txt</span><br><span class="line">19</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><h5 id="sort的-t选项和-k选项"><a href="#sort的-t选项和-k选项" class="headerlink" title="sort的-t选项和-k选项"></a>sort的-t选项和-k选项</h5><blockquote><p>如果有一个文件的内容是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ cat seq.txt</span><br><span class="line">banana:30:5.5</span><br><span class="line">apple:10:2.5</span><br><span class="line">pear:90:2.3</span><br><span class="line">orange:20:3.4</span><br></pre></td></tr></table></figure></p></blockquote><p>这个文件有三列，列与列之间用冒号隔开了，第一列表示水果类型，第二列表示水果数量，第三列表示水果价格。<br>那么我想以水果数量来排序，也就是以第二列来排序，如何利用sort实现？</p><p>此处就可使用sort提供的-t选项，指定以什么间隔符进行分割。然后，再使用-k选项指定对那一列或几列进行排序即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ sort -n -k 2 -t : seq.txt</span><br><span class="line">apple:10:2.5</span><br><span class="line">orange:20:3.4</span><br><span class="line">banana:30:5.5</span><br><span class="line">pear:90:2.3</span><br></pre></td></tr></table></figure></p><h5 id="sort的-k选项进阶版"><a href="#sort的-k选项进阶版" class="headerlink" title="sort的-k选项进阶版"></a>sort的-k选项进阶版</h5><blockquote><p>例如有一个文件内容是这样的：<br>第一个域是公司名称，第二个域是公司人数，第三个域是员工平均工资。（仅作演示）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ cat facebook.txt</span><br><span class="line">google 110 5000</span><br><span class="line">baidu 100 5000</span><br><span class="line">guge 50 3000</span><br><span class="line">sohu 100 4500</span><br></pre></td></tr></table></figure></p></blockquote><p>（1）首先，按照公司人数排序，人数相同的按照员工平均工资的升序排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ sort -n -t &apos; &apos; -k 2 facebook.txt</span><br><span class="line">guge 50 3000</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br><span class="line">[root@www ~]$ sort -n -t &apos; &apos; -k 2 -k 3 facebook.txt</span><br><span class="line">guge 50 3000</span><br><span class="line">sohu 100 4500</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br></pre></td></tr></table></figure></p><p>（2）下面，按照员工平均工资的降序排序，如果员工工资相同，则按照工资人数升序排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ sort -t &apos; &apos; -n -k 3r -k 3 facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。&lt;/p&gt;
&lt;h4 id=&quot;语法格式&quot;&gt;&lt;a href=&quot;#语法格式&quot; class=&quot;headerlink&quot; title=&quot;语法格式&quot;&gt;&lt;/a&gt;语法格式&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@www ~]# sort [选项] [参数]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;选项：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-n：依照数值的大小排序；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-r：以相反的顺序来排序；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-k：是指定需要爱排序的栏位；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-t&amp;lt;分隔字符&amp;gt;：指定排序时所用的栏位分隔字符；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-o&amp;lt;输出文件&amp;gt;：将排序后的结果存入制定的文件；（注：直接使用重定向会覆盖原文件，将其清空。）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;文件：指定待排序的文件列表。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
