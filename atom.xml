<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-06T10:48:01.046Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flask - 相关知识点总结</title>
    <link href="http://yoursite.com/2018/03/06/Flask-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/06/Flask-相关知识点总结/</id>
    <published>2018-03-06T10:46:40.000Z</published>
    <updated>2018-03-06T10:48:01.046Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、Flask入口文件集成-shell"><a href="#1、Flask入口文件集成-shell" class="headerlink" title="1、Flask入口文件集成 shell"></a>1、Flask入口文件集成 shell</h4><p>每次启动shell 会话都要导入数据库实例和模型，这真是份枯燥的工作。为了避免一直重复导入，我们可以做些配置，让Flask-Script 的shell 命令自动导入特定的对象。</p><p>若想把对象添加到导入列表中，我们要为shell 命令注册一个make_context 回调函数，如示例5-7 所示。<br><a id="more"></a><br>示例5-7　hello.py：为shell 命令添加一个上下文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.script import Shell</span><br><span class="line">def make_shell_context():</span><br><span class="line">    return dict(app=app, db=db, User=User, Role=Role)</span><br><span class="line">manager.add_command(&quot;shell&quot;, Shell(make_context=make_shell_context))</span><br></pre></td></tr></table></figure></p><p>make_shell_context() 函数注册了程序、数据库实例以及模型，因此这些对象能直接导入shell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python hello.py shell</span><br><span class="line">&gt;&gt;&gt; app</span><br><span class="line">&lt;Flask &apos;app&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; db</span><br><span class="line">&lt;SQLAlchemy engine=&apos;sqlite:////home/flask/flasky/data.sqlite&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; User</span><br><span class="line">&lt;class &apos;app.User&apos;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2、Flash消息"><a href="#2、Flash消息" class="headerlink" title="2、Flash消息"></a>2、Flash消息</h4><p>请求完成后，有时需要让用户知道状态发生了变化。这里可以使用确认消息、警告或者错误提醒。一个典型例子是，用户提交了有一项错误的登录表单后，服务器发回的响应重新渲染了登录表单，并在表单上面显示一个消息，提示用户用户名或密码错误。</p><p>这种功能是Flask 的核心特性。如示例所示，flash() 函数可实现这种效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, render_template, session, redirect, url_for, flash</span><br><span class="line">@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line">def index():</span><br><span class="line">form = NameForm()</span><br><span class="line">if form.validate_on_submit():</span><br><span class="line">old_name = session.get(&apos;name&apos;)</span><br><span class="line">if old_name is not None and old_name != form.name.data:</span><br><span class="line">flash(&apos;Looks like you have changed your name!&apos;)</span><br><span class="line">session[&apos;name&apos;] = form.name.data</span><br><span class="line">return redirect(url_for(&apos;index&apos;))</span><br><span class="line">return render_template(&apos;index.html&apos;, form = form, name = session.get(&apos;name&apos;))</span><br></pre></td></tr></table></figure></p><p>在这个示例中，每次提交的名字都会和存储在用户会话中的名字进行比较，而会话中存储的名字是前一次在这个表单中提交的数据。如果两个名字不一样，就会调用flash() 函数，在发给客户端的下一个响应中显示一个消息。</p><p>仅调用flash() 函数并不能把消息显示出来，程序使用的模板要渲染这些消息。最好在基模板中渲染Flash 消息，因为这样所有页面都能使用这些消息。Flask 把get_flashed_messages() 函数开放给模板，用来获取并渲染消息，如示例所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&#123;% for message in get_flashed_messages() %&#125;</span><br><span class="line">&lt;div class=&quot;alert alert-warning&quot;&gt;</span><br><span class="line">&lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;</span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block page_content %&#125;&#123;% endblock %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>在模板中使用循环是因为在之前的请求循环中每次调用flash() 函数时都会生成一个消息，所以可能有多个消息在排队等待显示。get_flashed_messages() 函数获取的消息在下次调用时不会再次返回，因此Flash 消息只显示一次，然后就消失了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、Flask入口文件集成-shell&quot;&gt;&lt;a href=&quot;#1、Flask入口文件集成-shell&quot; class=&quot;headerlink&quot; title=&quot;1、Flask入口文件集成 shell&quot;&gt;&lt;/a&gt;1、Flask入口文件集成 shell&lt;/h4&gt;&lt;p&gt;每次启动shell 会话都要导入数据库实例和模型，这真是份枯燥的工作。为了避免一直重复导入，我们可以做些配置，让Flask-Script 的shell 命令自动导入特定的对象。&lt;/p&gt;
&lt;p&gt;若想把对象添加到导入列表中，我们要为shell 命令注册一个make_context 回调函数，如示例5-7 所示。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Flask - 认证扩展</title>
    <link href="http://yoursite.com/2018/03/06/Flask-%E8%AE%A4%E8%AF%81%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/03/06/Flask-认证扩展/</id>
    <published>2018-03-06T10:43:25.000Z</published>
    <updated>2018-03-06T10:44:11.349Z</updated>
    
    <content type="html"><![CDATA[<p>Flask-Login：管理已登录用户的用户会话。<br>Werkzeug：计算密码散列值并进行核对。<br>itsdangerous：生成并核对加密安全令牌。</p><h4 id="1、密码安全性-使用Werkzeug实现密码散列"><a href="#1、密码安全性-使用Werkzeug实现密码散列" class="headerlink" title="1、密码安全性 - 使用Werkzeug实现密码散列"></a>1、密码安全性 - 使用Werkzeug实现密码散列</h4><p>众所周知，大多数用户都在不同的网站中使用相同的密码，因此，即便不保存任何敏感信息，攻击者获得存储在数据库中的密码之后，也能访问用户在其他网站中的账户。<br><a id="more"></a><br>若想保证数据库中用户密码的安全，关键在于不能存储密码本身，而要存储密码的散列值。计算密码散列值的函数接收密码作为输入，使用一种或多种加密算法转换密码，最终得到一个和原始密码没有关系的字符序列。核对密码时，密码散列值可代替原始密码，因为计算散列值的函数是可复现的：只要输入一样，结果就一样。</p><p>Werkzeug 中的security 模块能够很方便地实现密码散列值的计算。这一功能的实现只需要两个函数，分别用在注册用户和验证用户阶段。</p><ul><li>generate_password_hash(password, method=pbkdf2:sha1, salt_length=8)：这个函数将原始密码作为输入，以字符串形式输出密码的散列值，输出的值可保存在用户数据库中。method 和salt_length 的默认值就能满足大多数需求。</li><li>check_password_hash(hash, password)：这个函数的参数是从数据库中取回的密码散列值和用户输入的密码。返回值为True 表明密码正确。</li></ul><p>示例8-1 展示了创建的User 模型为支持密码散列所做的改动。<br>示例8-1　app/models.py：在User 模型中加入密码散列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from werkzeug.security import generate_password_hash, check_password_hash</span><br><span class="line">class User(db.Model):</span><br><span class="line">    __tablename__ == &apos;users&apos;</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    username = db.Column(db.String(64), unique=True, index=True)</span><br><span class="line">    password_hash = db.Column(db.String(128))</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def password(self):</span><br><span class="line">        raise AttributeError(&apos;password is not a readable attribute&apos;)</span><br><span class="line"></span><br><span class="line">    @password.setter</span><br><span class="line">    def password(self, password):</span><br><span class="line">        self.password_hash = generate_password_hash(password)</span><br><span class="line">    </span><br><span class="line">    def verify_password(self, password):</span><br><span class="line">        return check_password_hash(self.password_hash, password)</span><br><span class="line">    </span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;User %r&gt;&apos; % self.username</span><br></pre></td></tr></table></figure></p><p>计算密码散列值的函数通过名为password 的只写属性实现。设定这个属性的值时，赋值方法会调用Werkzeug 提供的generate_password_hash() 函数，并把得到的结果赋值给password_hash 字段。如果试图读取password 属性的值，则会返回错误，原因很明显，因为生成散列值后就无法还原成原来的密码了。</p><p>verify_password 方法接受一个参数（ 即密码）， 将其传给Werkzeug 提供的check_password_hash() 函数，和存储在User 模型中的密码散列值进行比对。如果这个方法返回True，就表明密码是正确的。</p><h4 id="2、使用Flask-Login认证用户"><a href="#2、使用Flask-Login认证用户" class="headerlink" title="2、使用Flask-Login认证用户"></a>2、使用Flask-Login认证用户</h4><p>用户登录程序后，他们的认证状态要被记录下来，这样浏览不同的页面时才能记住这个状态。Flask-Login 是个非常有用的小型扩展，专门用来管理用户认证系统中的认证状态，且不依赖特定的认证机制。</p><h5 id="（1）准备用于登录的用户模型"><a href="#（1）准备用于登录的用户模型" class="headerlink" title="（1）准备用于登录的用户模型"></a>（1）准备用于登录的用户模型</h5><p>要想使用Flask-Login 扩展，程序的User 模型必须实现几个方法。需要实现的方法如表8-1所示。<br>表8-1　Flask-Login要求实现的用户方法</p><table><thead><tr><th>方　　法</th><th>说　　明</th></tr></thead><tbody><tr><td>is_authenticated()</td><td>如果用户已经登录，必须返回True，否则返回False</td></tr><tr><td>is_active()</td><td>如果允许用户登录，必须返回True，否则返回False。如果要禁用账户，可以返回False</td></tr><tr><td>is_anonymous()</td><td>对普通用户必须返回False</td></tr><tr><td>get_id()</td><td>必须返回用户的唯一标识符，使用Unicode 编码字符串</td></tr></tbody></table><p>这4 个方法可以在模型类中作为方法直接实现，不过还有一种更简单的替代方案。Flask-Login 提供了一个UserMixin 类，其中包含这些方法的默认实现，且能满足大多数需求。修改后的User 模型如示例8-6 所示。</p><p>示例8-6　app/models.py：修改User 模型，支持用户登录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.login import UserMixin</span><br><span class="line">class User(UserMixin, db.Model):</span><br><span class="line">    __tablename__ = &apos;users&apos;</span><br><span class="line">    id = db.Column(db.Integer, primary_key = True)</span><br><span class="line">    email = db.Column(db.String(64), unique=True, index=True)</span><br><span class="line">    username = db.Column(db.String(64), unique=True, index=True)</span><br><span class="line">    password_hash = db.Column(db.String(128))</span><br></pre></td></tr></table></figure></p><p>注意，示例中同时还添加了email 字段。在这个程序中，用户使用电子邮件地址登录，因为相对于用户名而言，用户更不容易忘记自己的电子邮件地址。</p><p>Flask-Login 在程序的工厂函数中初始化，如示例8-7 所示。<br>示例8-7　app/<strong>init</strong>.py：初始化Flask-Login<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.login import LoginManager</span><br><span class="line"></span><br><span class="line">login_manager = LoginManager()</span><br><span class="line">login_manager.session_protection = &apos;strong&apos;</span><br><span class="line">login_manager.login_view = &apos;auth.login&apos;</span><br><span class="line"></span><br><span class="line">def create_app(config_name):</span><br><span class="line">    # ...</span><br><span class="line">    login_manager.init_app(app)</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure></p><p>LoginManager 对象的session_protection 属性可以设为None、’basic’ 或’strong’，以提供不同的安全等级防止用户会话遭篡改。设为’strong’ 时，Flask-Login 会记录客户端IP地址和浏览器的用户代理信息，如果发现异动就登出用户。login_view 属性设置登录页面的端点。如果登录路由在蓝本中定义，因此要在前面加上蓝本的名字。</p><p>最后，Flask-Login 要求程序实现一个回调函数，使用指定的标识符加载用户。这个函数的定义如示例8-8 所示。</p><p>示例8-8　app/models.py：加载用户的回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from . import login_manager</span><br><span class="line"></span><br><span class="line">@login_manager.user_loader</span><br><span class="line">def load_user(user_id):</span><br><span class="line">    return User.query.get(int(user_id))</span><br></pre></td></tr></table></figure></p><p>加载用户的回调函数接收以Unicode 字符串形式表示的用户标识符。如果能找到用户，这个函数必须返回用户对象；否则应该返回None。</p><h5 id="（2）保护路由"><a href="#（2）保护路由" class="headerlink" title="（2）保护路由"></a>（2）保护路由</h5><p>为了保护路由只让认证用户访问，Flask-Login 提供了一个login_required 修饰器。用法演示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.login import login_required</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/secret&apos;)</span><br><span class="line">@login_required</span><br><span class="line">def secret():</span><br><span class="line">    return &apos;Only authenticated users are allowed!&apos;</span><br></pre></td></tr></table></figure></p><p>如果未认证的用户访问这个路由，Flask-Login 会拦截请求，把用户发往登录页面。</p><h4 id="3、使用itsdangerous生成确认令牌"><a href="#3、使用itsdangerous生成确认令牌" class="headerlink" title="3、使用itsdangerous生成确认令牌"></a>3、使用itsdangerous生成确认令牌</h4><p>为验证电子邮件地址，用户注册后，程序会立即发送一封确认邮件。新账户先被标记成待确认状态，用户按照邮件中的说明操作后，才能证明自己可以被联系上。账户确认过程中，往往会要求用户点击一个包含确认令牌的特殊URL 链接。</p><p>确认邮件中最简单的确认链接是<a href="http://www.example.com/auth/confirm/" target="_blank" rel="noopener">http://www.example.com/auth/confirm/</a><id> 这种形式的URL，其中id 是数据库分配给用户的数字id。用户点击链接后，处理这个路由的视图函数就将收到的用户id 作为参数进行确认，然后将用户状态更新为已确认。</id></p><p>但这种实现方式显然不是很安全，只要用户能判断确认链接的格式，就可以随便指定URL中的数字，从而确认任意账户。解决方法是把URL 中的id 换成将相同信息安全加密后得到的令牌。</p><p>下面这个简短的shell 会话显示了如何使用itsdangerous 包生成包含用户id 的安全令牌：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python manage.py shell</span><br><span class="line">&gt;&gt;&gt; from manage import app</span><br><span class="line">&gt;&gt;&gt; from itsdangerous import TimedJSONWebSignatureSerializer as Serializer</span><br><span class="line">&gt;&gt;&gt; s = Serializer(app.config[&apos;SECRET_KEY&apos;], expires_in = 3600)</span><br><span class="line">&gt;&gt;&gt; token = s.dumps(&#123; &apos;confirm&apos;: 23 &#125;)</span><br><span class="line">&gt;&gt;&gt; token</span><br><span class="line">&apos;eyJhbGciOiJIUzI1NiIsImV4cCI6MTM4MTcxODU1OCwiaWF0IjoxMzgxNzE0OTU4fQ.ey ...&apos;</span><br><span class="line">&gt;&gt;&gt; data = s.loads(token)</span><br><span class="line">&gt;&gt;&gt; data</span><br><span class="line">&#123;u&apos;confirm&apos;: 23&#125;</span><br></pre></td></tr></table></figure></p><p>itsdangerous 提供了多种生成令牌的方法。其中，TimedJSONWebSignatureSerializer 类生成具有过期时间的JSON Web 签名（JSON Web Signatures，JWS）。这个类的构造函数接收的参数是一个密钥，在Flask 程序中可使用SECRET_KEY 设置。</p><p>dumps() 方法为指定的数据生成一个加密签名，然后再对数据和签名进行序列化，生成令牌字符串。expires_in 参数设置令牌的过期时间，单位为秒。</p><p>为了解码令牌，序列化对象提供了loads() 方法，其唯一的参数是令牌字符串。这个方法会检验签名和过期时间，如果通过，返回原始数据。如果提供给loads() 方法的令牌不正确或过期了，则抛出异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask-Login：管理已登录用户的用户会话。&lt;br&gt;Werkzeug：计算密码散列值并进行核对。&lt;br&gt;itsdangerous：生成并核对加密安全令牌。&lt;/p&gt;
&lt;h4 id=&quot;1、密码安全性-使用Werkzeug实现密码散列&quot;&gt;&lt;a href=&quot;#1、密码安全性-使用Werkzeug实现密码散列&quot; class=&quot;headerlink&quot; title=&quot;1、密码安全性 - 使用Werkzeug实现密码散列&quot;&gt;&lt;/a&gt;1、密码安全性 - 使用Werkzeug实现密码散列&lt;/h4&gt;&lt;p&gt;众所周知，大多数用户都在不同的网站中使用相同的密码，因此，即便不保存任何敏感信息，攻击者获得存储在数据库中的密码之后，也能访问用户在其他网站中的账户。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>物联网入门必备</title>
    <link href="http://yoursite.com/2018/03/06/%E7%89%A9%E8%81%94%E7%BD%91%E5%85%A5%E9%97%A8%E5%BF%85%E5%A4%87/"/>
    <id>http://yoursite.com/2018/03/06/物联网入门必备/</id>
    <published>2018-03-06T03:20:52.000Z</published>
    <updated>2018-03-06T10:49:55.139Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是物联网？"><a href="#什么是物联网？" class="headerlink" title="什么是物联网？"></a>什么是物联网？</h4><p>物联网是新一代信息技术的重要组成部分，也是“信息化”时代的重要发展阶段。其英文名称是：“Internet of things（IoT）”。顾名思义，物联网就是物物相连的互联网。这有两层意思：其一，物联网的核心和基础仍然是互联网，是在互联网基础上的延伸和扩展的网络；其二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信，也就是物物相息。物联网通过智能感知、识别技术与普适计算等通信感知技术，广泛应用于网络的融合中，也因此被称为继计算机、互联网之后世界信息产业发展的第三次浪潮。物联网是互联网的应用拓展，与其说物联网是网络，不如说物联网是业务和应用。因此，应用创新是物联网发展的核心，以用户体验为核心的创新2.0是物联网发展的灵魂。<br><a id="more"></a></p><h4 id="什么是认知物联网？"><a href="#什么是认知物联网？" class="headerlink" title="什么是认知物联网？"></a>什么是认知物联网？</h4><p>简单地说，认知物联网是将认知计算技术与互连设备产生的数据和这些设备可以执行的操作结合使用。您可能已经知道物联网，也知道我们所说的传感器和执行器的意思。从认知计算方面讲，物联网又是什么意思呢？当然，认知意味着思考，而计算机不具备普通人类的思考能力，它们现在可以执行一些人类认为是思考 的基本功能。认知涉及三个关键要素：</p><ul><li>理解</li><li>推理</li><li>学习</li></ul><p>在计算机中，系统理解意味着，能够读入大量的结构化和非结构化数据，并从中获取其意义，也就是说，建立一个概念、实体和关系的模型。推理 意味着，使用这个模型能够得出答案或解决相关问题，无需专门对答案和解决方案进行编程。而学习 意味着，能够自动地从数据推断出新的知识，这是大规模理解的一个关键组成部分。<br><img src="/uploads/2018/03/cognitive-iot-blog.jpg" alt=""></p><p>构建大规模的概念和关系的复杂模型过于费时，且成本高昂。此外，有许多关系是事先不知道或不明确的，所以只能让机器自动分析大数据集来发现模式，然后才能真正发现这些关系。</p><h4 id="会思考的物体"><a href="#会思考的物体" class="headerlink" title="会思考的物体"></a>会思考的物体</h4><p>认知计算对于物联网非常重要，这有几个关键原因。</p><ul><li><p><strong>生成数据的速率和规模：</strong>学习有助于优化流程或系统，在结合有关系统的传感器数据与其他上下文信息的基础上，使其更加高效。从设备生成的数据快速超越了人类通过分析去发现重要模式和学习的能力。应用机器学习对于能够扩展物联网是必不可少的。</p></li><li><p><strong>计算转移到物理世界：</strong>随着越来越多各种年龄和技术技能水平的人在与物联网系统进行交互，我们需要超越当前的机器接口范式，这种范式要求人类学会与机器交互所需的抽象和专用接口。此外，这种转移需要走向更加以人类为中心的接口。换句话说，人们需要能够用自然语言与物联网系统（物体）进行交互。该系统必须开始理解人类。来自麻省理工媒体实验室 (MIT Media Lab) 的作者 David Rose 提出了术语 “魔法对象 (enchanted objects) ” 来描述看似智能的行为，我们可以通过物联网和认知计算将这些行为注入连接的设备。</p></li><li><p><strong>多种数据源和数据类型的集成：</strong>在物联网中，存在许多数据源，可以提供相关的信息或上下文，有助于更好地理解和制定决策。数据有多种不同的类型，包括数字传感器数据、音频、视频、非结构化的文本数据、位置数据等，消化和分析这些数据类型并通过这些数据类型识别相关性和模式的能力，是一项非常强大的功能。通过掌握上下文可以大大提高对人类操作者的意图的理解，这包括物理环境、时间维度，甚至是情绪状况。通过集成多个不同的数据源可以完善推理和决策，例如，关联传感器数据与声学数据。</p></li></ul><h4 id="人类感知设备"><a href="#人类感知设备" class="headerlink" title="人类感知设备"></a>人类感知设备</h4><p><strong>认知物联网</strong> 是下一次飞跃，它通过学习并将更多的人类意识注入到与我们交互的设备和环境中，提高传感器驱动的复杂系统的准确性和效率。这一飞跃可以让我们的物体 用我们的语言（而不是其他方式）来理解我们，并与我们进行交互。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是物联网？&quot;&gt;&lt;a href=&quot;#什么是物联网？&quot; class=&quot;headerlink&quot; title=&quot;什么是物联网？&quot;&gt;&lt;/a&gt;什么是物联网？&lt;/h4&gt;&lt;p&gt;物联网是新一代信息技术的重要组成部分，也是“信息化”时代的重要发展阶段。其英文名称是：“Internet of things（IoT）”。顾名思义，物联网就是物物相连的互联网。这有两层意思：其一，物联网的核心和基础仍然是互联网，是在互联网基础上的延伸和扩展的网络；其二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信，也就是物物相息。物联网通过智能感知、识别技术与普适计算等通信感知技术，广泛应用于网络的融合中，也因此被称为继计算机、互联网之后世界信息产业发展的第三次浪潮。物联网是互联网的应用拓展，与其说物联网是网络，不如说物联网是业务和应用。因此，应用创新是物联网发展的核心，以用户体验为核心的创新2.0是物联网发展的灵魂。&lt;br&gt;
    
    </summary>
    
      <category term="物联网" scheme="http://yoursite.com/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="科技前沿" scheme="http://yoursite.com/tags/%E7%A7%91%E6%8A%80%E5%89%8D%E6%B2%BF/"/>
    
      <category term="物联网" scheme="http://yoursite.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>区块链入门必备</title>
    <link href="http://yoursite.com/2018/03/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E5%BF%85%E5%A4%87/"/>
    <id>http://yoursite.com/2018/03/06/区块链入门必备/</id>
    <published>2018-03-06T02:44:47.000Z</published>
    <updated>2018-03-06T03:21:45.859Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、区块链是什么？"><a href="#1、区块链是什么？" class="headerlink" title="1、区块链是什么？"></a>1、区块链是什么？</h4><p>区块链是一种防篡改的、共享的数字化账本，用于记录公有或私有对等网络中的交易。账本分发给网络中的所有成员节点，在通过哈希密码算法链接的区块的顺序链中，永久记录网络中的对等节点之间发生的资产交易的历史记录。</p><p>所有经过确认和证明的交易都从链的开头一直链接到最新的区块，因此得名区块链。区块链可以充当单一事实来源，而且区块链网络中的成员只能查看与他们相关的交易。<br><a id="more"></a></p><h4 id="2、区块链网络的工作原理"><a href="#2、区块链网络的工作原理" class="headerlink" title="2、区块链网络的工作原理"></a>2、区块链网络的工作原理</h4><p>区块链网络中的成员节点不依赖于第三方（比如金融机构）来仲裁交易，它们使用共识协议来协商账本内容，使用哈希加密算法和数字签名来确保交易的完整性。</p><p>共识性能确保共享账本是精确副本，并降低了发生交易欺诈的风险，因为篡改需要在许多地方同时执行。哈希加密算法（比如 SHA256 计算算法）能确保对交易输入的任何改动 — 甚至是最细微的改动 — 都会计算出一个不同的哈希值，表明交易输入可能被损坏。数字签名确保交易源自发送方（已使用私钥签名）而不是冒名顶替者。</p><p>去中心化对等区块链网络可阻止任何单个或一组参与者控制底层基础架构或破坏整个系统。网络中的参与者是平等的，都遵守相同的协议。它们可以是个人、国家代表、企业或所有这三种参与者的组合。</p><p>在其核心，该系统会记录交易的时间顺序，而且所有节点都使用选定的共识模型来协商交易的有效性。这会使交易不可逆并被网络中的所有成员接受。</p><h4 id="3、区块链技术的商业优势"><a href="#3、区块链技术的商业优势" class="headerlink" title="3、区块链技术的商业优势"></a>3、区块链技术的商业优势</h4><p>在传统业务网络中，所有参与者都维护着自己的账本，这些账本之间的重复和差异会导致争议、更长的结算时间，而且因为需要中介，还会导致相关的间接管理成本。但是，通过使用基于区块链的共享账本，交易在通过共识性验证并写入账本后，就不能再更改，这样企业就能节省时间和成本，同时减少风险。</p><p>区块链共识机制提供了经过整合的、一致的数据集的优势，减少了错误，拥有近实时的引用数据，而且参与者能够灵活更改其拥有的资产的描述。</p><p>因为没有参与成员拥有共享账本中所含信息的来源，所以区块链技术会提高参与成员之间的交易信息流中的可信度和完整性。</p><p>区块链技术的不变性机制降低了审计和合规性成本，增加了透明性。而且在使用区块链技术的业务网络上，合约得以智能、自动化执行并最终确认，所以企业会获得更高的执行速度、更低的成本和更少的风险，所有这些使企业能构建新收入流来与客户交互。</p><h4 id="4、如何才算是好的区块链用例？"><a href="#4、如何才算是好的区块链用例？" class="headerlink" title="4、如何才算是好的区块链用例？"></a>4、如何才算是好的区块链用例？</h4><p>要确定您的用例是否适合使用区块链，请询问自己以下问题：</p><ol><li>是否涉及业务网络？</li><li>是否使用共识性来验证交易？</li><li>是否需要审计线索或来源？</li><li>交易记录是否必须不可变或防篡改？</li><li>争议的解决方法是否会是最终解决方法？<br>如果第一个问题和其他问题中的至少一个问题的答案为“是”，那么您的用例就会从区块链技术受益。要成为合适的解决方案，区块链必须涉及一个网络，但该网络可以具有多种形式。该网络可位于企业之间，比如供应链，或者该网络可以在一个企业内。例如：在企业内，可以使用区块链网络在部门之间共享参考数据，或者创建审计或合规性网络。该网络也可存在于个人之间，比如需要在区块链上存储数据、数字资产或合约的人。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、区块链是什么？&quot;&gt;&lt;a href=&quot;#1、区块链是什么？&quot; class=&quot;headerlink&quot; title=&quot;1、区块链是什么？&quot;&gt;&lt;/a&gt;1、区块链是什么？&lt;/h4&gt;&lt;p&gt;区块链是一种防篡改的、共享的数字化账本，用于记录公有或私有对等网络中的交易。账本分发给网络中的所有成员节点，在通过哈希密码算法链接的区块的顺序链中，永久记录网络中的对等节点之间发生的资产交易的历史记录。&lt;/p&gt;
&lt;p&gt;所有经过确认和证明的交易都从链的开头一直链接到最新的区块，因此得名区块链。区块链可以充当单一事实来源，而且区块链网络中的成员只能查看与他们相关的交易。&lt;br&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="科技前沿" scheme="http://yoursite.com/tags/%E7%A7%91%E6%8A%80%E5%89%8D%E6%B2%BF/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 大型程序的结构</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-大型程序的结构/</id>
    <published>2018-03-05T10:04:46.000Z</published>
    <updated>2018-03-06T02:20:59.991Z</updated>
    
    <content type="html"><![CDATA[<p>尽管在单一脚本中编写小型Web 程序很方便，但这种方法并不能广泛使用。程序变复杂后，使用单个大型源码文件会导致很多问题。</p><p>不同于大多数其他的Web 框架，Flask 并不强制要求大型项目使用特定的组织方式，程序结构的组织方式完全由开发者决定。在本章，我们将介绍一种使用包和模块组织大型程序的方式。本书后续示例都将采用这种结构。</p><h4 id="1、项目结构"><a href="#1、项目结构" class="headerlink" title="1、项目结构"></a>1、项目结构</h4><p>Flask 程序的基本结构如示例7-1 所示。<br><a id="more"></a><br><strong>示例7-1　多文件Flask 程序的基本结构</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">|-flasky</span><br><span class="line">　　|-app/</span><br><span class="line">　　　　|-templates/</span><br><span class="line">　　　　|-static/</span><br><span class="line">　　　　|-main/</span><br><span class="line">　　　　　　|-__init__.py</span><br><span class="line">　　　　　　|-errors.py</span><br><span class="line">　　　　　　|-forms.py</span><br><span class="line">　　　　　　|-views.py</span><br><span class="line">　　　　|-__init__.py</span><br><span class="line">　　　　|-email.py</span><br><span class="line">　　　　|-models.py</span><br><span class="line">　　|-migrations/</span><br><span class="line">　　|-tests/</span><br><span class="line">　　　　|-__init__.py</span><br><span class="line">　　　　|-test*.py</span><br><span class="line">　　|-venv/</span><br><span class="line">　　|-requirements.txt</span><br><span class="line">　　|-config.py</span><br><span class="line">　　|-manage.py</span><br></pre></td></tr></table></figure></p><p>这种结构有4 个顶级文件夹：</p><ul><li>Flask程序一般都保存在名为app 的包中；</li><li>和之前一样，migrations文件夹包含数据库迁移脚本；</li><li>单元测试编写在 tests包中；</li><li>和之前一样，venv 文件夹包含 Python 虚拟环境。</li></ul><p>同时还创建了一些新文件：</p><ul><li>requirements.txt列出了所有依赖包，便于在其他电脑中重新生成相同的虚拟环境；</li><li>config.py 存储配置；</li><li>manage.py用于启动程序以及其他的程序任务。</li></ul><p>为了帮助你完全理解这个结构，下面几节讲解把hello.py 程序转换成这种结构的过程。</p><h4 id="2、配置选项"><a href="#2、配置选项" class="headerlink" title="2、配置选项"></a>2、配置选项</h4><p>程序经常需要设定多个配置。这方面最好的例子就是开发、测试和生产环境要使用不同的数据库，这样才不会彼此影响。</p><p>我们不再使用hello.py 中简单的字典状结构配置，而使用层次结构的配置类。config.py 文件的内容如示例7-2 所示。</p><p>示例7-2　config.py：程序的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">basedir = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line"></span><br><span class="line">class Config:</span><br><span class="line">    SECRET_KEY = os.environ.get(&apos;SECRET_KEY&apos;) or &apos;hard to guess string&apos;</span><br><span class="line">    SQLALCHEMY_COMMIT_ON_TEARDOWN = True</span><br><span class="line">    FLASKY_MAIL_SUBJECT_PREFIX = &apos;[Flasky]&apos;</span><br><span class="line">    FLASKY_MAIL_SENDER = &apos;Flasky Admin &lt;flasky@example.com&gt;&apos;</span><br><span class="line">    FLASKY_ADMIN = os.environ.get(&apos;FLASKY_ADMIN&apos;)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def init_app(app):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class DevelopmentConfig(Config):</span><br><span class="line">    DEBUG = True</span><br><span class="line">    MAIL_SERVER = &apos;smtp.googlemail.com&apos;</span><br><span class="line">    MAIL_PORT = 587</span><br><span class="line">    MAIL_USE_TLS = True</span><br><span class="line">    MAIL_USERNAME = os.environ.get(&apos;MAIL_USERNAME&apos;)</span><br><span class="line">    MAIL_PASSWORD = os.environ.get(&apos;MAIL_PASSWORD&apos;)</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;DEV_DATABASE_URL&apos;) or \</span><br><span class="line">        &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data-dev.sqlite&apos;)</span><br><span class="line"></span><br><span class="line">class TestingConfig(Config):</span><br><span class="line">    TESTING = True</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;TEST_DATABASE_URL&apos;) or \</span><br><span class="line">        &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data-test.sqlite&apos;)</span><br><span class="line"></span><br><span class="line">class ProductionConfig(Config):</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;DATABASE_URL&apos;) or \</span><br><span class="line">        &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;)</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    &apos;development&apos;: DevelopmentConfig,</span><br><span class="line">    &apos;testing&apos;: TestingConfig,</span><br><span class="line">    &apos;production&apos;: ProductionConfig,</span><br><span class="line">    &apos;default&apos;: DevelopmentConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基类Config 中包含通用配置，子类分别定义专用的配置。如果需要，你还可添加其他配置类。</p><p>为了让配置方式更灵活且更安全，某些配置可以从环境变量中导入。例如，SECRET_KEY 的值，这是个敏感信息，可以在环境中设定，但系统也提供了一个默认值，以防环境中没有定义。</p><p>在3 个子类中，SQLALCHEMY_DATABASE_URI 变量都被指定了不同的值。这样程序就可在不同的配置环境中运行，每个环境都使用不同的数据库。</p><p>配置类可以定义init_app() 类方法，其参数是程序实例。在这个方法中，可以执行对当前环境的配置初始化。现在，基类Config 中的init_app() 方法为空。</p><p>在这个配置脚本末尾，config 字典中注册了不同的配置环境，而且还注册了一个默认配置。</p><h4 id="3、程序包"><a href="#3、程序包" class="headerlink" title="3、程序包"></a>3、程序包</h4><p>程序包用来保存程序的所有代码、模板和静态文件。我们可以把这个包直接称为app（应用），如果有需求，也可使用一个程序专用名字。templates 和static 文件夹是程序包的一部分，因此这两个文件夹被移到了app 中。数据库模型和电子邮件支持函数也被移到了这个包中，分别保存为app/models.py 和app/email.py。</p><h5 id="（1）使用程序工厂函数"><a href="#（1）使用程序工厂函数" class="headerlink" title="（1）使用程序工厂函数"></a>（1）使用程序工厂函数</h5><p>在单个文件中开发程序很方便，但却有个很大的缺点，因为程序在全局作用域中创建，所以无法动态修改配置。运行脚本时，程序实例已经创建，再修改配置为时已晚。这一点对单元测试尤其重要，因为有时为了提高测试覆盖度，必须在不同的配置环境中运行程序。这个问题的解决方法是延迟创建程序实例，把创建过程移到可显式调用的工厂函数中。这种方法不仅可以给脚本留出配置程序的时间，还能够创建多个程序实例，这些实例有时在测试中非常有用。程序的工厂函数在app 包的构造文件中定义，如示例7-3 所示。</p><p>构造文件导入了大多数正在使用的Flask 扩展。由于尚未初始化所需的程序实例，所以没有初始化扩展，创建扩展类时没有向构造函数传入参数。create_app() 函数就是程序的工厂函数，接受一个参数，是程序使用的配置名。配置类在config.py 文件中定义，其中保存的配置可以使用Flask app.config 配置对象提供的from_object() 方法直接导入程序。至于配置对象，则可以通过名字从config 字典中选择。程序创建并配置好后，就能初始化扩展了。在之前创建的扩展对象上调用init_app() 可以完成初始化过程。</p><p>示例7-3　app/__init__.py：程序包的构造文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, render_template</span><br><span class="line">from flask.ext.bootstrap import Bootstrap</span><br><span class="line">from flask.ext.mail import Mail</span><br><span class="line">from flask.ext.moment import Moment</span><br><span class="line">from flask.ext.sqlalchemy import SQLAlchemy</span><br><span class="line">from config import config</span><br><span class="line"></span><br><span class="line">bootstrap = Bootstrap()</span><br><span class="line">mail = Mail()</span><br><span class="line">moment = Moment()</span><br><span class="line">db = SQLAlchemy()</span><br><span class="line"></span><br><span class="line">def create_app(config_name):</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(config[config_name])</span><br><span class="line">    config[config_name].init_app(app)</span><br><span class="line"></span><br><span class="line">    bootstrap.init_app(app)</span><br><span class="line">    mail.init_app(app)</span><br><span class="line">    moment.init_app(app)</span><br><span class="line">    db.init_app(app)</span><br><span class="line"></span><br><span class="line">    # 附加路由和自定义的错误页面</span><br><span class="line"></span><br><span class="line">    return app</span><br></pre></td></tr></table></figure></p><p>工厂函数返回创建的程序示例，不过要注意，现在工厂函数创建的程序还不完整，因为没<br>有路由和自定义的错误页面处理程序。</p><h5 id="（2）在蓝本中实现程序功能"><a href="#（2）在蓝本中实现程序功能" class="headerlink" title="（2）在蓝本中实现程序功能"></a>（2）在蓝本中实现程序功能</h5><p>转换成程序工厂函数的操作让定义路由变复杂了。在单脚本程序中，程序实例存在于全局作用域中，路由可以直接使用app.route 修饰器定义。但现在程序在运行时创建，只有调用create_app() 之后才能使用app.route 修饰器，这时定义路由就太晚了。和路由一样，自定义的错误页面处理程序也面临相同的困难，因为错误页面处理程序使用app.errorhandler 修饰器定义。</p><p>幸好Flask 使用蓝本提供了更好的解决方法。蓝本和程序类似，也可以定义路由。不同的是，在蓝本中定义的路由处于休眠状态，直到蓝本注册到程序上后，路由才真正成为程序的一部分。使用位于全局作用域中的蓝本时，定义路由的方法几乎和单脚本程序一样。</p><p>和程序一样，蓝本可以在单个文件中定义，也可使用更结构化的方式在包中的多个模块中创建。为了获得最大的灵活性，程序包中创建了一个子包，用于保存蓝本。示例7-4 是这个子包的构造文件，蓝本就创建于此。</p><p>示例7-4　app/main/__init__.py：创建蓝本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from flask import Blueprint</span><br><span class="line">main = Blueprint(&apos;main&apos;, __name__)</span><br><span class="line">from . import views, errors</span><br></pre></td></tr></table></figure></p><p>通过实例化一个Blueprint 类对象可以创建蓝本。这个构造函数有两个必须指定的参数：蓝本的名字和蓝本所在的包或模块。和程序一样，大多数情况下第二个参数使用Python 的__name__ 变量即可。</p><p>程序的路由保存在包里的app/main/views.py 模块中，而错误处理程序保存在app/main/errors.py 模块中。导入这两个模块就能把路由和错误处理程序与蓝本关联起来。注意，这些模块在app/main/__init__.py 脚本的末尾导入，这是为了避免循环导入依赖，因为在views.py 和errors.py 中还要导入蓝本main。</p><p>蓝本在工厂函数create_app() 中注册到程序上，如示例7-5 所示。<br>示例7-5　app/__init__.py：注册蓝本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def create_app(config_name):</span><br><span class="line">    # ...</span><br><span class="line">    from .main import main as main_blueprint</span><br><span class="line">    app.register_blueprint(main_blueprint)</span><br><span class="line">    </span><br><span class="line">    return app</span><br></pre></td></tr></table></figure></p><p>示例7-6 显示了错误处理程序。<br>示例7-6　app/main/errors.py：蓝本中的错误处理程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from flask import render_template</span><br><span class="line">from . import main</span><br><span class="line"></span><br><span class="line">@main.app_errorhandler(404)</span><br><span class="line">def page_not_found(e):</span><br><span class="line">    return render_template(&apos;404.html&apos;), 404</span><br><span class="line"></span><br><span class="line">@main.app_errorhandler(500)</span><br><span class="line">def internal_server_error(e):</span><br><span class="line">    return render_template(&apos;500.html&apos;), 500</span><br></pre></td></tr></table></figure></p><p>在蓝本中编写错误处理程序稍有不同，如果使用errorhandler 修饰器，那么只有蓝本中的错误才能触发处理程序。要想注册程序全局的错误处理程序，必须使用app_errorhandler。</p><p>在蓝本中定义的程序路由如示例7-7 所示。<br>示例7-7　app/main/views.py：蓝本中定义的程序路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">from flask import render_template, session, redirect, url_for</span><br><span class="line">from . import main</span><br><span class="line">from .forms import NameForm</span><br><span class="line">from .. import db</span><br><span class="line">from ..models import User</span><br><span class="line"></span><br><span class="line">@main.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line">def index():</span><br><span class="line">    form = NameForm()</span><br><span class="line">    if form.validate_on_submit():</span><br><span class="line">        # ...</span><br><span class="line">        return redirect(url_for(&apos;.index&apos;))</span><br><span class="line">    return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;),</span><br><span class="line">        known=session.get(&apos;known&apos;, False), current_time=datetime.utcnow())</span><br></pre></td></tr></table></figure></p><p>在蓝本中编写视图函数主要有两点不同：第一，和前面的错误处理程序一样，路由修饰器由蓝本提供；第二，url_for() 函数的用法不同。你可能还记得，url_for() 函数的第一个参数是路由的端点名，在程序的路由中，默认为视图函数的名字。例如，在单脚本程序中，index() 视图函数的URL 可使用url_for(‘index’) 获取。</p><p>在蓝本中就不一样了，Flask 会为蓝本中的全部端点加上一个命名空间，这样就可以在不同的蓝本中使用相同的端点名定义视图函数，而不会产生冲突。命名空间就是蓝本的名字（Blueprint 构造函数的第一个参数），所以视图函数index() 注册的端点名是main.index，其URL 使用url_for(‘main.index’) 获取。</p><p>url_for() 函数还支持一种简写的端点形式，在蓝本中可以省略蓝本名，例如url_for(‘.index’)。在这种写法中，命名空间是当前请求所在的蓝本。这意味着同一蓝本中的重定向可以使用简写形式，但跨蓝本的重定向必须使用带有命名空间的端点名。</p><p>为了完全修改程序的页面，表单对象也要移到蓝本中，保存于app/main/forms.py 模块。</p><h4 id="4、启动脚本"><a href="#4、启动脚本" class="headerlink" title="4、启动脚本"></a>4、启动脚本</h4><p>顶级文件夹中的manage.py 文件用于启动程序。脚本内容如示例7-8 所示。<br>示例7-8　manage.py：启动脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import os</span><br><span class="line">from app import create_app, db</span><br><span class="line">from app.models import User, Role</span><br><span class="line">from flask.ext.script import Manager, Shell</span><br><span class="line">from flask.ext.migrate import Migrate, MigrateCommand</span><br><span class="line"></span><br><span class="line">app = create_app(os.getenv(&apos;FLASK_CONFIG&apos;) or &apos;default&apos;)</span><br><span class="line"></span><br><span class="line">manager = Manager(app)</span><br><span class="line">migrate = Migrate(app, db)</span><br><span class="line"></span><br><span class="line">def make_shell_context():</span><br><span class="line">    return dict(app=app, db=db, User=User, Role=Role)</span><br><span class="line">manager.add_command(&quot;shell&quot;, Shell(make_context=make_shell_context))</span><br><span class="line"></span><br><span class="line">manager.add_command(&apos;db&apos;, MigrateCommand)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure></p><p>这个脚本先创建程序。如果已经定义了环境变量FLASK_CONFIG，则从中读取配置名；否则使用默认配置。然后初始化Flask-Script、Flask-Migrate 和为Python shell 定义的上下文。出于便利，脚本中加入了shebang 声明，所以在基于Unix 的操作系统中可以通过./manage.py 执行脚本，而不用使用复杂的python manage.py。</p><h4 id="5、需求文件"><a href="#5、需求文件" class="headerlink" title="5、需求文件"></a>5、需求文件</h4><p>程序中必须包含一个requirements.txt 文件，用于记录所有依赖包及其精确的版本号。如果要在另一台电脑上重新生成虚拟环境，这个文件的重要性就体现出来了，例如部署程序时使用的电脑。pip 可以使用如下命令自动生成这个文件：<br>　　<code>(venv) $ pip freeze &gt;requirements.txt</code></p><p>安装或升级包后，最好更新这个文件。需求文件的内容示例如下：</p><blockquote><p>Flask==0.10.1<br>Flask-Bootstrap==3.0.3.1<br>Flask-Mail==0.9.0<br>Flask-Migrate==1.1.0<br>Flask-Moment==0.2.0<br>Flask-SQLAlchemy==1.0<br>Flask-Script==0.6.6<br>Flask-WTF==0.9.4<br>Jinja2==2.7.1<br>Mako==0.9.1<br>MarkupSafe==0.18<br>SQLAlchemy==0.8.4<br>WTForms==1.0.5<br>Werkzeug==0.9.4<br>alembic==0.6.2<br>blinker==1.3<br>itsdangerous==0.23</p></blockquote><p>如果你要创建这个虚拟环境的完全副本，可以创建一个新的虚拟环境，并在其上运行以下命令：<br>　　<code>(venv) $ pip install -r requirements.txt</code></p><p>当你阅读本书时，该示例requirements.txt 文件中的版本号可能已经过期了。如果愿意，你可以试着使用这些包的最新版。如果遇到问题，你可以随时换回这个需求文件中的版本，因为这些版本和程序兼容。</p><h4 id="6、单元测试"><a href="#6、单元测试" class="headerlink" title="6、单元测试"></a>6、单元测试</h4><p>这个程序很小，所以没什么可测试的。不过为了演示，我们可以编写两个简单的测试，如示例7-9 所示。</p><p>示例7-9　tests/test_basics.py：单元测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line">from flask import current_app</span><br><span class="line">from app import create_app, db</span><br><span class="line"></span><br><span class="line">class BasicsTestCase(unittest.TestCase):</span><br><span class="line">    def setUp(self):</span><br><span class="line">        self.app = create_app(&apos;testing&apos;)</span><br><span class="line">        self.app_context = self.app.app_context()</span><br><span class="line">        self.app_context.push()</span><br><span class="line">        db.create_all()</span><br><span class="line">    </span><br><span class="line">    def tearDown(self):</span><br><span class="line">        db.session.remove()</span><br><span class="line">        db.drop_all()</span><br><span class="line">        self.app_context.pop()</span><br><span class="line"></span><br><span class="line">    def test_app_exists(self):</span><br><span class="line">        self.assertFalse(current_app is None)</span><br><span class="line">        def test_app_is_testing(self):</span><br><span class="line">        self.assertTrue(current_app.config[&apos;TESTING&apos;])</span><br></pre></td></tr></table></figure></p><p>这个测试使用Python 标准库中的unittest 包编写。setUp() 和tearDown() 方法分别在各测试前后运行，并且名字以test_ 开头的函数都作为测试执行。</p><p>setUp() 方法尝试创建一个测试环境，类似于运行中的程序。首先，使用测试配置创建程序，然后激活上下文。这一步的作用是确保能在测试中使用current_app，像普通请求一样。然后创建一个全新的数据库，以备不时之需。数据库和程序上下文在tearDown() 方法中删除。</p><p>第一个测试确保程序实例存在。第二个测试确保程序在测试配置中运行。若想把tests 文件夹作为包使用，需要添加tests/__init__.py 文件，不过这个文件可以为空，因为unittest 包会扫描所有模块并查找测试。</p><p>为了运行单元测试，你可以在manage.py 脚本中添加一个自定义命令。示例7-10 展示了如何添加test 命令。</p><p>示例7-10　manage.py：启动单元测试的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@manager.command</span><br><span class="line">def test():</span><br><span class="line">    &quot;&quot;&quot;Run the unit tests.&quot;&quot;&quot;</span><br><span class="line">    import unittest</span><br><span class="line">    tests = unittest.TestLoader().discover(&apos;tests&apos;)</span><br><span class="line">    unittest.TextTestRunner(verbosity=2).run(tests)</span><br></pre></td></tr></table></figure></p><p>manager.command 修饰器让自定义命令变得简单。修饰函数名就是命令名，函数的文档字符串会显示在帮助消息中。test() 函数的定义体中调用了unittest 包提供的测试运行函数。</p><p>单元测试可使用下面的命令运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python manage.py test</span><br><span class="line">test_app_exists (test_basics.BasicsTestCase) ... ok</span><br><span class="line">test_app_is_testing (test_basics.BasicsTestCase) ... ok</span><br><span class="line">.----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.001s</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><h4 id="7、创建数据库"><a href="#7、创建数据库" class="headerlink" title="7、创建数据库"></a>7、创建数据库</h4><p>重组后的程序和单脚本版本使用不同的数据库。</p><p>首选从环境变量中读取数据库的URL，同时还提供了一个默认的SQLite 数据库做备用。3种配置环境中的环境变量名和SQLite 数据库文件名都不一样。例如，在开发环境中，数据库URL 从环境变量DEV_DATABASE_URL 中读取，如果没有定义这个环境变量，则使用名为data-dev.sqlite 的SQLite 数据库。</p><p>不管从哪里获取数据库URL，都要在新数据库中创建数据表。如果使用Flask-Migrate 踪迁移，可使用如下命令创建数据表或者升级到最新修订版本：<br>　　<code>(venv) $ python manage.py db upgrade</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管在单一脚本中编写小型Web 程序很方便，但这种方法并不能广泛使用。程序变复杂后，使用单个大型源码文件会导致很多问题。&lt;/p&gt;
&lt;p&gt;不同于大多数其他的Web 框架，Flask 并不强制要求大型项目使用特定的组织方式，程序结构的组织方式完全由开发者决定。在本章，我们将介绍一种使用包和模块组织大型程序的方式。本书后续示例都将采用这种结构。&lt;/p&gt;
&lt;h4 id=&quot;1、项目结构&quot;&gt;&lt;a href=&quot;#1、项目结构&quot; class=&quot;headerlink&quot; title=&quot;1、项目结构&quot;&gt;&lt;/a&gt;1、项目结构&lt;/h4&gt;&lt;p&gt;Flask 程序的基本结构如示例7-1 所示。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 数据库之Flask-SQLAlchemy管理数据库</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BFlask-SQLAlchemy%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-数据库之Flask-SQLAlchemy管理数据库/</id>
    <published>2018-03-05T08:03:11.000Z</published>
    <updated>2018-03-06T02:24:36.616Z</updated>
    
    <content type="html"><![CDATA[<p>Flask-SQLAlchemy 是一个Flask 扩展，简化了在Flask 程序中使用SQLAlchemy 的操作。SQLAlchemy 是一个很强大的关系型数据库框架，支持多种数据库后台。SQLAlchemy 提供了高层ORM，也提供了使用数据库原生SQL 的低层功能。</p><p>和其他大多数扩展一样，Flask-SQLAlchemy 也使用pip 安装：<br>　　<code>(venv) $ pip install flask-sqlalchemy</code><br><a id="more"></a><br>在Flask-SQLAlchemy 中，数据库使用URL 指定。最流行的数据库引擎采用的数据库URL格式如表5-1 所示。</p><p><strong>表5-1　FLask-SQLAlchemy数据库URL</strong></p><table><thead><tr><th>数据库引擎</th><th>URL</th></tr></thead><tbody><tr><td>MySQL</td><td>mysql://username:password@hostname/database</td></tr><tr><td>Postgres</td><td>postgresql://username:password@hostname/database</td></tr><tr><td>SQLite（Unix）</td><td>sqlite:////absolute/path/to/database</td></tr><tr><td>SQLite（Windows）</td><td>sqlite:///c:/absolute/path/to/database</td></tr></tbody></table><p>在这些URL 中，hostname 表示MySQL 服务所在的主机，可以是本地主机（localhost），也可以是远程服务器。数据库服务器上可以托管多个数据库，因此database 表示要使用的数据库名。如果数据库需要进行认证，username 和password 表示数据库用户密令。<br><em>（注：SQLite 数据库不需要使用服务器，因此不用指定hostname、username 和password。URL 中的database 是硬盘上文件的文件名。）</em></p><p>程序使用的数据库URL 必须保存到Flask 配置对象的SQLALCHEMY_DATABASE_URI 键中。配置对象中还有一个很有用的选项，即SQLALCHEMY_COMMIT_ON_TEARDOWN 键，将其设为True时，每次请求结束后都会自动提交数据库中的变动。其他配置选项的作用请参阅Flask-SQLAlchemy 的文档。示例5-1 展示了如何初始化及配置一个简单的SQLite 数据库。</p><p>示例5-1　hello.py：配置数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.sqlalchemy import SQLAlchemy</span><br><span class="line">basedir = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;)</span><br><span class="line">app.config[&apos;SQLALCHEMY_COMMIT_ON_TEARDOWN&apos;] = True</span><br><span class="line">db = SQLAlchemy(app)</span><br></pre></td></tr></table></figure></p><p>db 对象是SQLAlchemy 类的实例，表示程序使用的数据库，同时还获得了Flask-SQLAlchemy提供的所有功能。</p><h4 id="1、定义模型"><a href="#1、定义模型" class="headerlink" title="1、定义模型"></a>1、定义模型</h4><p>模型这个术语表示程序使用的持久化实体。在ORM 中，模型一般是一个Python 类，类中的属性对应数据库表中的列。</p><p>Flask-SQLAlchemy 创建的数据库实例为模型提供了一个基类以及一系列辅助类和辅助函数，可用于定义模型的结构。图5-1 中的roles 表和users 表可定义为模型Role 和User，如示例5-2 所示。</p><p>示例5-2　hello.py：定义Role 和User 模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Role(db.Model):</span><br><span class="line">    __tablename__ = &apos;roles&apos;</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    name = db.Column(db.String(64), unique=True)</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;Role %r&gt;&apos; % self.name</span><br><span class="line">class User(db.Model):</span><br><span class="line">    __tablename__ = &apos;users&apos;</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    username = db.Column(db.String(64), unique=True, index=True)</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;User %r&gt;&apos; % self.username</span><br></pre></td></tr></table></figure></p><p>类变量__tablename__ 定义在数据库中使用的表名。如果没有定义__tablename__，Flask-SQLAlchemy 会使用一个默认名字，但默认的表名没有遵守使用复数形式进行命名的约定，所以最好由我们自己来指定表名。其余的类变量都是该模型的属性，被定义为db.Column类的实例。</p><p>db.Column 类构造函数的第一个参数是数据库列和模型属性的类型。表5-2 列出了一些可用的列类型以及在模型中使用的Python 类型。</p><p><strong>表5-2　最常用的SQLAlchemy列类型</strong></p><table><thead><tr><th>类型名</th><th>Python类型</th><th>说　　明</th></tr></thead><tbody><tr><td>Integer</td><td>int</td><td>普通整数，一般是32 位</td></tr><tr><td>SmallInteger</td><td>int</td><td>取值范围小的整数，一般是16 位</td></tr><tr><td>BigInteger</td><td>int 或long</td><td>不限制精度的整数</td></tr><tr><td>Float</td><td>float</td><td>浮点数</td></tr><tr><td>Numeric</td><td>decimal.Decimal</td><td>定点数</td></tr><tr><td>String</td><td>str</td><td>变长字符串</td></tr><tr><td>Text</td><td>str</td><td>变长字符串，对较长或不限长度的字符串做了优化</td></tr><tr><td>Unicode</td><td>unicode</td><td>变长Unicode 字符串</td></tr><tr><td>UnicodeText</td><td>unicode</td><td>变长Unicode 字符串，对较长或不限长度的字符串做了优化</td></tr><tr><td>Boolean</td><td>bool</td><td>布尔值</td></tr><tr><td>Date</td><td>datetime.date</td><td>日期</td></tr><tr><td>Time</td><td>datetime.time</td><td>时间</td></tr><tr><td>DateTime</td><td>datetime.datetime</td><td>日期和时间</td></tr><tr><td>Interval</td><td>datetime.timedelta</td><td>时间间隔</td></tr><tr><td>Enum</td><td>str</td><td>一组字符串</td></tr><tr><td>PickleType</td><td>任何Python 对象</td><td>自动使用Pickle 序列化</td></tr><tr><td>LargeBinary</td><td>str</td><td>二进制文件</td></tr></tbody></table><p>db.Column 中其余的参数指定属性的配置选项。表5-3 列出了一些可用选项。</p><p><strong>表5-3　最常使用的SQLAlchemy列选项</strong></p><table><thead><tr><th>选项名</th><th>说　　明</th></tr></thead><tbody><tr><td>primary_key</td><td>如果设为True，这列就是表的主键</td></tr><tr><td>unique</td><td>如果设为True，这列不允许出现重复的值</td></tr><tr><td>index</td><td>如果设为True，为这列创建索引，提升查询效率</td></tr><tr><td>nullable</td><td>如果设为True，这列允许使用空值；如果设为False，这列不允许使用空值</td></tr><tr><td>default</td><td>为这列定义默认值</td></tr></tbody></table><p><strong>（注：Flask-SQLAlchemy 要求每个模型都要定义主键，这一列经常命名为id。）</strong></p><p>虽然没有强制要求，但这两个模型都定义了__repr()__ 方法，返回一个具有可读性的字符串表示模型，可在调试和测试时使用。</p><h4 id="2、关系"><a href="#2、关系" class="headerlink" title="2、关系"></a>2、关系</h4><p>关系型数据库使用关系把不同表中的行联系起来。图5-1 所示的关系图表示用户和角色之间的一种简单关系。这是角色到用户的一对多关系，因为一个角色可属于多个用户，而每个用户都只能有一个角色。</p><p>图5-1 中的一对多关系在模型类中的表示方法如示例5-3 所示。</p><p>示例5-3　hello.py：关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Role(db.Model):</span><br><span class="line">    # ...</span><br><span class="line">    users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;)</span><br><span class="line"></span><br><span class="line">class User(db.Model):</span><br><span class="line">    # ...</span><br><span class="line">    role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;))</span><br></pre></td></tr></table></figure></p><p>如图5-1 所示，关系使用users 表中的外键连接了两行。添加到User 模型中的role_id 列被定义为外键，就是这个外键建立起了关系。传给db.ForeignKey() 的参数’roles.id’ 表明，这列的值是roles 表中行的id 值。</p><p>添加到Role 模型中的users 属性代表这个关系的面向对象视角。对于一个Role 类的实例，其users 属性将返回与角色相关联的用户组成的列表。db.relationship() 的第一个参数表明这个关系的另一端是哪个模型。如果模型类尚未定义，可使用字符串形式指定。</p><p>db.relationship() 中的backref 参数向User 模型中添加一个role 属性，从而定义反向关系。这一属性可替代role_id 访问Role 模型，此时获取的是模型对象，而不是外键的值。</p><p>大多数情况下，db.relationship() 都能自行找到关系中的外键，但有时却无法决定把哪一列作为外键。例如，如果User 模型中有两个或以上的列定义为Role 模型的外键，SQLAlchemy 就不知道该使用哪列。如果无法决定外键，你就要为db.relationship() 提供额外参数，从而确定所用外键。表5-4 列出了定义关系时常用的配置选项。</p><p><strong>表5-4　常用的SQLAlchemy关系选项</strong></p><table><thead><tr><th>选项名</th><th>说　　明</th></tr></thead><tbody><tr><td>backref</td><td>在关系的另一个模型中添加反向引用</td></tr><tr><td>primaryjoin</td><td>明确指定两个模型之间使用的联结条件。只在模棱两可的关系中需要指定</td></tr><tr><td>lazy</td><td>指定如何加载相关记录。可选值有select（首次访问时按需加载）、immediate（源对象加载后就加载）、joined（加载记录，但使用联结）、subquery（立即加载，但使用子查询），noload（永不加载）和dynamic（不加载记录，但提供加载记录的查询）</td></tr><tr><td>uselist</td><td>如果设为Fales，不使用列表，而使用标量值</td></tr><tr><td>order_by</td><td>指定关系中记录的排序方式</td></tr><tr><td>secondary</td><td>指定多对多关系中关系表的名字</td></tr><tr><td>secondaryjoin</td><td>SQLAlchemy 无法自行决定时，指定多对多关系中的二级联结条件</td></tr></tbody></table><p>除了一对多之外，还有几种其他的关系类型。一对一关系可以用前面介绍的一对多关系表示，但调用db.relationship() 时要把uselist 设为False，把“多”变成“一”。多对一关系也可使用一对多表示，对调两个表即可，或者把外键和db.relationship() 都放在“多”这一侧。最复杂的关系类型是多对多，需要用到第三张表，这个表称为关系表。</p><h4 id="3、数据库操作"><a href="#3、数据库操作" class="headerlink" title="3、数据库操作"></a>3、数据库操作</h4><h5 id="（1）创建表"><a href="#（1）创建表" class="headerlink" title="（1）创建表"></a>（1）创建表</h5><p>首先，我们要让Flask-SQLAlchemy 根据模型类创建数据库。方法是使用db.create_all()函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py shell</span><br><span class="line">&gt;&gt;&gt; from hello import db</span><br><span class="line">&gt;&gt;&gt; db.create_all()</span><br></pre></td></tr></table></figure></p><p>如果你查看程序目录，会发现新建了一个名为data.sqlite 的文件。这个SQLite 数据库文件的名字就是在配置中指定的。如果数据库表已经存在于数据库中，那么db.create_all()不会重新创建或者更新这个表。如果修改模型后要把改动应用到现有的数据库中，这一特性会带来不便。更新现有数据库表的粗暴方式是先删除旧表再重新创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.drop_all()</span><br><span class="line">&gt;&gt;&gt; db.create_all()</span><br></pre></td></tr></table></figure></p><p>（注：遗憾的是，这个方法有个我们不想看到的副作用，它把数据库中原有的数据都销毁了。末尾将会介绍一种更好的方式用于更新数据库。）</p><h5 id="（2）插入行"><a href="#（2）插入行" class="headerlink" title="（2）插入行"></a>（2）插入行</h5><p>下面这段代码创建了一些角色和用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from hello import Role, User</span><br><span class="line">&gt;&gt;&gt; admin_role = Role(name=&apos;Admin&apos;)</span><br><span class="line">&gt;&gt;&gt; mod_role = Role(name=&apos;Moderator&apos;)</span><br><span class="line">&gt;&gt;&gt; user_role = Role(name=&apos;User&apos;)</span><br><span class="line">&gt;&gt;&gt; user_john = User(username=&apos;john&apos;, role=admin_role)</span><br><span class="line">&gt;&gt;&gt; user_susan = User(username=&apos;susan&apos;, role=user_role)</span><br><span class="line">&gt;&gt;&gt; user_david = User(username=&apos;david&apos;, role=user_role)</span><br></pre></td></tr></table></figure></p><p>模型的构造函数接受的参数是使用关键字参数指定的模型属性初始值。注意，role 属性也可使用，虽然它不是真正的数据库列，但却是一对多关系的高级表示。这些新建对象的id属性并没有明确设定，因为主键是由Flask-SQLAlchemy 管理的。现在这些对象只存在于Python 中，还未写入数据库。因此id 尚未赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(admin_role.id)</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; print(mod_role.id)</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; print(user_role.id)</span><br><span class="line">None</span><br></pre></td></tr></table></figure></p><p>通过数据库会话管理对数据库所做的改动，在Flask-SQLAlchemy 中，会话由db.session表示。准备把对象写入数据库之前，先要将其添加到会话中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.session.add(admin_role)</span><br><span class="line">&gt;&gt;&gt; db.session.add(mod_role)</span><br><span class="line">&gt;&gt;&gt; db.session.add(user_role)</span><br><span class="line">&gt;&gt;&gt; db.session.add(user_john)</span><br><span class="line">&gt;&gt;&gt; db.session.add(user_susan)</span><br><span class="line">&gt;&gt;&gt; db.session.add(user_david)</span><br></pre></td></tr></table></figure></p><p>或者简写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.session.add_all([admin_role, mod_role, user_role,</span><br><span class="line">... user_john, user_susan, user_david])</span><br></pre></td></tr></table></figure></p><p>为了把对象写入数据库，我们要调用commit() 方法提交会话：<br><code>&gt;&gt;&gt; db.session.commit()</code></p><p>再次查看id 属性，现在它们已经赋值了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(admin_role.id)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(mod_role.id)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; print(user_role.id)</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>数据库会话能保证数据库的一致性。提交操作使用原子方式把会话中的对象全部写入数据库。如果在写入会话的过程中发生了错误，整个会话都会失效。如果你始终把相关改动放在会话中提交，就能避免因部分更新导致的数据库不一致性。</p><h5 id="（3）修改行"><a href="#（3）修改行" class="headerlink" title="（3）修改行"></a>（3）修改行</h5><p>在数据库会话上调用add() 方法也能更新模型。我们继续在之前的shell 会话中进行操作，下面这个例子把”Admin” 角色重命名为”Administrator”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; admin_role.name = &apos;Administrator&apos;</span><br><span class="line">&gt;&gt;&gt; db.session.add(admin_role)</span><br><span class="line">&gt;&gt;&gt; db.session.commit()</span><br></pre></td></tr></table></figure></p><h5 id="（4）删除行"><a href="#（4）删除行" class="headerlink" title="（4）删除行"></a>（4）删除行</h5><p>数据库会话还有个delete() 方法。下面这个例子把”Moderator” 角色从数据库中删除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.session.delete(mod_role)</span><br><span class="line">&gt;&gt;&gt; db.session.commit()</span><br></pre></td></tr></table></figure></p><p>注意，删除与插入和更新一样，提交数据库会话后才会执行。</p><h5 id="（5）查询行"><a href="#（5）查询行" class="headerlink" title="（5）查询行"></a>（5）查询行</h5><p>Flask-SQLAlchemy 为每个模型类都提供了query 对象。最基本的模型查询是取回对应表中的所有记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Role.query.all()</span><br><span class="line">[&lt;Role u&apos;Administrator&apos;&gt;, &lt;Role u&apos;User&apos;&gt;]</span><br><span class="line">&gt;&gt;&gt; User.query.all()</span><br><span class="line">[&lt;User u&apos;john&apos;&gt;, &lt;User u&apos;susan&apos;&gt;, &lt;User u&apos;david&apos;&gt;]</span><br></pre></td></tr></table></figure></p><p>使用过滤器可以配置query 对象进行更精确的数据库查询。下面这个例子查找角色为”User” 的所有用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; User.query.filter_by(role=user_role).all()</span><br><span class="line">[&lt;User u&apos;susan&apos;&gt;, &lt;User u&apos;david&apos;&gt;]</span><br></pre></td></tr></table></figure></p><p>若要查看SQLAlchemy 为查询生成的原生SQL 查询语句，只需把query 对象转换成字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(User.query.filter_by(role=user_role))</span><br><span class="line">&apos;SELECT users.id AS users_id, users.username AS users_username,</span><br><span class="line">users.role_id AS users_role_id FROM users WHERE :param_1 = users.role_id&apos;</span><br></pre></td></tr></table></figure></p><p>filter_by() 等过滤器在query 对象上调用，返回一个更精确的query 对象。多个过滤器可以一起调用，直到获得所需结果。</p><p>表5-5 列出了可在query 对象上调用的常用过滤器。完整的列表参见SQLAlchemy 文档（<a href="http://docs.sqlalchemy.org）。" target="_blank" rel="noopener">http://docs.sqlalchemy.org）。</a></p><p><strong>表5-5　常用的SQLAlchemy查询过滤器</strong></p><table><thead><tr><th>过滤器</th><th>说　　明</th></tr></thead><tbody><tr><td>filter()</td><td>把过滤器添加到原查询上，返回一个新查询</td></tr><tr><td>filter_by()</td><td>把等值过滤器添加到原查询上，返回一个新查询</td></tr><tr><td>limit()</td><td>使用指定的值限制原查询返回的结果数量，返回一个新查询</td></tr><tr><td>offset()</td><td>偏移原查询返回的结果，返回一个新查询</td></tr><tr><td>order_by()</td><td>根据指定条件对原查询结果进行排序，返回一个新查询</td></tr><tr><td>group_by()</td><td>根据指定条件对原查询结果进行分组，返回一个新查询</td></tr></tbody></table><p>在查询上应用指定的过滤器后，通过调用all() 执行查询，以列表的形式返回结果。除了all() 之外，还有其他方法能触发查询执行。表5-6 列出了执行查询的其他方法。</p><p><strong>表5-6　最常使用的SQLAlchemy查询执行函数</strong></p><table><thead><tr><th>方　法</th><th>说　　明</th></tr></thead><tbody><tr><td>all()</td><td>以列表形式返回查询的所有结果</td></tr><tr><td>first()</td><td>返回查询的第一个结果，如果没有结果，则返回None</td></tr><tr><td>first_or_404()</td><td>返回查询的第一个结果，如果没有结果，则终止请求，返回404 错误响应</td></tr><tr><td>get()</td><td>返回指定主键对应的行，如果没有对应的行，则返回None</td></tr><tr><td>get_or_404()</td><td>返回指定主键对应的行，如果没找到指定的主键，则终止请求，返回404 错误响应</td></tr><tr><td>count()</td><td>返回查询结果的数量</td></tr><tr><td>paginate()</td><td>返回一个Paginate 对象，它包含指定范围内的结果</td></tr></tbody></table><p>关系和查询的处理方式类似。下面这个例子分别从关系的两端查询角色和用户之间的一对多关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; users = user_role.users</span><br><span class="line">&gt;&gt;&gt; users</span><br><span class="line">[&lt;User u&apos;susan&apos;&gt;, &lt;User u&apos;david&apos;&gt;]</span><br><span class="line">&gt;&gt;&gt; users[0].role</span><br><span class="line">&lt;Role u&apos;User&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>这个例子中的user_role.users 查询有个小问题。执行user_role.users 表达式时，隐含的查询会调用all() 返回一个用户列表。query 对象是隐藏的，因此无法指定更精确的查询过滤器。就这个特定示例而言，返回一个按照字母顺序排序的用户列表可能更好。如果修改了关系的设置，加入了lazy = ‘dynamic’ 参数，从而禁止自动执行查询。</p><h4 id="4、使用Flask-Migrate实现数据库迁移"><a href="#4、使用Flask-Migrate实现数据库迁移" class="headerlink" title="4、使用Flask-Migrate实现数据库迁移"></a>4、使用Flask-Migrate实现数据库迁移</h4><p>在开发程序的过程中，你会发现有时需要修改数据库模型，而且修改之后还需要更新数据库。</p><p>仅当数据库表不存在时，Flask-SQLAlchemy 才会根据模型进行创建。因此，更新表的唯一方式就是先删除旧表，不过这样做会丢失数据库中的所有数据。</p><p>更新表的更好方法是使用数据库迁移框架。源码版本控制工具可以跟踪源码文件的变化，类似地，数据库迁移框架能跟踪数据库模式的变化，然后增量式的把变化应用到数据库中。</p><p>SQLAlchemy 的主力开发人员编写了一个迁移框架，称为Alembic（<a href="https://alembic.readthedocs.org/en/latest/index.html）。除了直接使用Alembic" target="_blank" rel="noopener">https://alembic.readthedocs.org/en/latest/index.html）。除了直接使用Alembic</a> 之外，Flask 程序还可使用Flask-Migrate（<a href="http://flask-migrate.readthedocs.org/en/latest/）扩展。这个扩展对Alembic" target="_blank" rel="noopener">http://flask-migrate.readthedocs.org/en/latest/）扩展。这个扩展对Alembic</a> 做了轻量级包装，并集成到Flask-Script 中，所有操作都通过Flask-Script 命令完成。</p><h5 id="（1）创建迁移仓库"><a href="#（1）创建迁移仓库" class="headerlink" title="（1）创建迁移仓库"></a>（1）创建迁移仓库</h5><p>首先，我们要在虚拟环境中安装Flask-Migrate：<br>　　<code>(venv) $ pip install flask-migrate</code><br>这个扩展的初始化方法如示例5-8 所示。</p><p>示例5-8　hello.py：配置Flask-Migrate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.migrate import Migrate, MigrateCommand</span><br><span class="line"># ...</span><br><span class="line">migrate = Migrate(app, db)</span><br><span class="line">manager.add_command(&apos;db&apos;, MigrateCommand)</span><br></pre></td></tr></table></figure></p><p>为了导出数据库迁移命令，Flask-Migrate 提供了一个MigrateCommand 类，可附加到Flask-Script 的manager 对象上。在这个例子中，MigrateCommand 类使用db 命令附加。</p><p>在维护数据库迁移之前，要使用init 子命令创建迁移仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py db init</span><br><span class="line">Creating directory /home/flask/flasky/migrations...done</span><br><span class="line">Creating directory /home/flask/flasky/migrations/versions...done</span><br><span class="line">Generating /home/flask/flasky/migrations/alembic.ini...done</span><br><span class="line">Generating /home/flask/flasky/migrations/env.py...done</span><br><span class="line">Generating /home/flask/flasky/migrations/env.pyc...done</span><br><span class="line">Generating /home/flask/flasky/migrations/README...done</span><br><span class="line">Generating /home/flask/flasky/migrations/script.py.mako...done</span><br><span class="line">Please edit configuration/connection/logging settings in</span><br><span class="line">&apos;/home/flask/flasky/migrations/alembic.ini&apos; before proceeding.</span><br></pre></td></tr></table></figure></p><p>这个命令会创建migrations 文件夹，所有迁移脚本都存放其中。</p><h5 id="（2）创建迁移脚本"><a href="#（2）创建迁移脚本" class="headerlink" title="（2）创建迁移脚本"></a>（2）创建迁移脚本</h5><p>在Alembic 中，数据库迁移用迁移脚本表示。脚本中有两个函数，分别是upgrade() 和downgrade()。upgrade() 函数把迁移中的改动应用到数据库中，downgrade() 函数则将改动删除。Alembic 具有添加和删除改动的能力，因此数据库可重设到修改历史的任意一点。</p><p>我们可以使用revision 命令手动创建Alembic 迁移，也可使用migrate 命令自动创建。手动创建的迁移只是一个骨架，upgrade() 和downgrade() 函数都是空的，开发者要使用Alembic 提供的Operations 对象指令实现具体操作。自动创建的迁移会根据模型定义和数据库当前状态之间的差异生成upgrade() 和downgrade() 函数的内容。</p><p>migrate 子命令用来自动创建迁移脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py db migrate -m &quot;initial migration&quot;</span><br><span class="line">INFO [alembic.migration] Context impl SQLiteImpl.</span><br><span class="line">INFO [alembic.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO [alembic.autogenerate] Detected added table &apos;roles&apos;</span><br><span class="line">INFO [alembic.autogenerate] Detected added table &apos;users&apos;</span><br><span class="line">INFO [alembic.autogenerate.compare] Detected added index</span><br><span class="line">&apos;ix_users_username&apos; on &apos;[&apos;username&apos;]&apos;</span><br><span class="line">Generating /home/flask/flasky/migrations/versions/1bc</span><br><span class="line">594146bb5_initial_migration.py...done</span><br></pre></td></tr></table></figure></p><h5 id="（3）更新数据库"><a href="#（3）更新数据库" class="headerlink" title="（3）更新数据库"></a>（3）更新数据库</h5><p>检查并修正好迁移脚本之后，我们可以使用db upgrade 命令把迁移应用到数据库中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py db upgrade</span><br><span class="line">INFO [alembic.migration] Context impl SQLiteImpl.</span><br><span class="line">INFO [alembic.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO [alembic.migration] Running upgrade None -&gt; 1bc594146bb5, initial migration</span><br></pre></td></tr></table></figure></p><p>对第一个迁移来说， 其作用和调用db.create_all() 方法一样。但在后续的迁移中，upgrade 命令能把改动应用到数据库中，且不影响其中保存的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask-SQLAlchemy 是一个Flask 扩展，简化了在Flask 程序中使用SQLAlchemy 的操作。SQLAlchemy 是一个很强大的关系型数据库框架，支持多种数据库后台。SQLAlchemy 提供了高层ORM，也提供了使用数据库原生SQL 的低层功能。&lt;/p&gt;
&lt;p&gt;和其他大多数扩展一样，Flask-SQLAlchemy 也使用pip 安装：&lt;br&gt;　　&lt;code&gt;(venv) $ pip install flask-sqlalchemy&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 数据库概述</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-数据库概述/</id>
    <published>2018-03-05T08:02:31.000Z</published>
    <updated>2018-03-06T02:27:36.004Z</updated>
    
    <content type="html"><![CDATA[<p>数据库按照一定规则保存程序数据，程序再发起查询取回所需的数据。Web 程序最常用基于关系模型的数据库，这种数据库也称为SQL 数据库，因为它们使用结构化查询语言。不过最近几年文档数据库和键值对数据库成了流行的替代选择，这两种数据库合称NoSQL数据库。</p><h4 id="1、SQL数据库"><a href="#1、SQL数据库" class="headerlink" title="1、SQL数据库"></a>1、SQL数据库</h4><p>关系型数据库把数据存储在表中，表模拟程序中不同的实体。例如，订单管理程序的数据库中可能有表customers、products 和orders。<br><a id="more"></a><br>表的列数是固定的，行数是可变的。列定义表所表示的实体的数据属性。例如，customers表中可能有name、address、phone 等列。表中的行定义各列对应的真实数据。</p><p>表中有个特殊的列，称为主键，其值为表中各行的唯一标识符。表中还可以有称为外键的列，引用同一个表或不同表中某行的主键。行之间的这种联系称为关系，这是关系型数据库模型的基础。</p><p>图5-1 展示了一个简单数据库的关系图。这个数据库中有两个表，分别存储用户和用户角色。连接两个表的线代表两个表之间的关系。<br><img src="/uploads/2018/03/flask_database_sql.JPG" alt="" title="图5-1　关系型数据库示例"></p><p>在这个数据库关系图中，roles 表存储所有可用的用户角色，每个角色都使用一个唯一的id 值（即表的主键）进行标识。users 表包含用户列表，每个用户也有唯一的id 值。除了id 主键之外，roles 表中还有name 列，users 表中还有username 列和password 列。users表中的role_id 列是外键，引用角色的id，通过这种方式为每个用户指定角色。</p><p>从这个例子可以看出，关系型数据库存储数据很高效，而且避免了重复。将这个数据库中的用户角色重命名也很简单，因为角色名只出现在一个地方。一旦在roles 表中修改完角色名，所有通过role_id 引用这个角色的用户都能立即看到更新。</p><p>但从另一方面来看，把数据分别存放在多个表中还是很复杂的。生成一个包含角色的用户列表会遇到一个小问题，因为在此之前要分别从两个表中读取用户和用户角色，再将其联结起来。关系型数据库引擎为联结操作提供了必要的支持。</p><h4 id="2、NoSQL数据库"><a href="#2、NoSQL数据库" class="headerlink" title="2、NoSQL数据库"></a>2、NoSQL数据库</h4><p>所有不遵循上节所述的关系模型的数据库统称为NoSQL 数据库。NoSQL 数据库一般使用集合代替表，使用文档代替记录。NoSQL 数据库采用的设计方式使联结变得困难，所以大多数数据库根本不支持这种操作。对于结构如图5-1 所示的NoSQL 数据库，若要列出各用户及其角色，就需要在程序中执行联结操作，即先读取每个用户的role_id，再在roles表中搜索对应的记录。</p><p>NoSQL 数据库更适合设计成如图5-2 所示的结构。这是执行反规范化操作得到的结果，它减少了表的数量，却增加了数据重复量。<br><img src="/uploads/2018/03/flask_database_nosql.JPG" alt="" title="图5-2　NoSQL 数据库示例"></p><p>这种结构的数据库要把角色名存储在每个用户中。如此一来，将角色重命名的操作就变得很耗时，可能需要更新大量文档。</p><p>使用NoSQL 数据库当然也有好处。数据重复可以提升查询速度。列出用户及其角色的操作很简单，因为无需联结。</p><h4 id="3、使用SQL还是使用NoSQL"><a href="#3、使用SQL还是使用NoSQL" class="headerlink" title="3、使用SQL还是使用NoSQL"></a>3、使用SQL还是使用NoSQL</h4><p>SQL 数据库擅于用高效且紧凑的形式存储结构化数据。这种数据库需要花费大量精力保证数据的一致性。NoSQL 数据库放宽了对这种一致性的要求，从而获得性能上的优势。</p><p>对不同类型数据库的全面分析、对比待续。对中小型程序来说，SQL 和NoSQL数据库都是很好的选择，而且性能相当。</p><h4 id="4、Python数据库框架"><a href="#4、Python数据库框架" class="headerlink" title="4、Python数据库框架"></a>4、Python数据库框架</h4><p>大多数的数据库引擎都有对应的Python 包，包括开源包和商业包。Flask 并不限制你使用何种类型的数据库包，因此可以根据自己的喜好选择使用MySQL、Postgres、SQLite、Redis、MongoDB 或者CouchDB。</p><p>如果这些都无法满足需求，还有一些数据库抽象层代码包供选择，例如SQLAlchemy 和MongoEngine。你可以使用这些抽象包直接处理高等级的Python 对象，而不用处理如表、文档或查询语言此类的数据库实体。</p><p>选择数据库框架时，你要考虑很多因素。</p><p><strong>易用性</strong><br>如果直接比较数据库引擎和数据库抽象层，显然后者取胜。抽象层，也称为对象关系映射（Object-Relational Mapper，ORM） 或对象文档映射（Object-Document Mapper，ODM），在用户不知觉的情况下把高层的面向对象操作转换成低层的数据库指令。</p><p><strong>性能</strong><br>ORM 和ODM 把对象业务转换成数据库业务会有一定的损耗。大多数情况下，这种性能的降低微不足道，但也不一定都是如此。一般情况下，ORM 和ODM 对生产率的提升远远超过了这一丁点儿的性能降低，所以性能降低这个理由不足以说服用户完全放弃ORM 和ODM。真正的关键点在于如何选择一个能直接操作低层数据库的抽象层，以防特定的操作需要直接使用数据库原生指令优化。</p><p><strong>可移植性</strong><br>选择数据库时，必须考虑其是否能在你的开发平台和生产平台中使用。例如，如果你打算利用云平台托管程序，就要知道这个云服务提供了哪些数据库可供选择。<br>可移植性还针对ORM 和ODM。尽管有些框架只为一种数据库引擎提供抽象层，但其他框架可能做了更高层的抽象，它们支持不同的数据库引擎，而且都使用相同的面向对象接口。SQLAlchemy ORM 就是一个很好的例子，它支持很多关系型数据库引擎，包括流行的MySQL、Postgres 和SQLite。</p><p><strong>FLask集成度</strong><br>选择框架时，你不一定非得选择已经集成了Flask 的框架，但选择这些框架可以节省你编写集成代码的时间。使用集成了Flask 的框架可以简化配置和操作，所以专门为Flask 开发的扩展是你的首选。</p><p>基于以上因素，选择使用的数据库框架是Flask-SQLAlchemy（<a href="http://pythonhosted.org/Flask-SQLAlchemy/），这个Flask" target="_blank" rel="noopener">http://pythonhosted.org/Flask-SQLAlchemy/），这个Flask</a> 扩展包装了SQLAlchemy（<a href="http://www.sqlalchemy.org/）框架。" target="_blank" rel="noopener">http://www.sqlalchemy.org/）框架。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库按照一定规则保存程序数据，程序再发起查询取回所需的数据。Web 程序最常用基于关系模型的数据库，这种数据库也称为SQL 数据库，因为它们使用结构化查询语言。不过最近几年文档数据库和键值对数据库成了流行的替代选择，这两种数据库合称NoSQL数据库。&lt;/p&gt;
&lt;h4 id=&quot;1、SQL数据库&quot;&gt;&lt;a href=&quot;#1、SQL数据库&quot; class=&quot;headerlink&quot; title=&quot;1、SQL数据库&quot;&gt;&lt;/a&gt;1、SQL数据库&lt;/h4&gt;&lt;p&gt;关系型数据库把数据存储在表中，表模拟程序中不同的实体。例如，订单管理程序的数据库中可能有表customers、products 和orders。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 表单(Flask-WTF)</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E8%A1%A8%E5%8D%95-Flask-WTF/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-表单-Flask-WTF/</id>
    <published>2018-03-05T08:02:19.000Z</published>
    <updated>2018-03-06T02:23:51.143Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、引入模块"><a href="#1、引入模块" class="headerlink" title="1、引入模块"></a>1、引入模块</h4><p>Flask-WTF（<a href="http://pythonhosted.org/Flask-WTF/）扩展可以把处理Web" target="_blank" rel="noopener">http://pythonhosted.org/Flask-WTF/）扩展可以把处理Web</a> 表单的过程变成一种愉悦的体验。这个扩展对独立的WTForms（<a href="http://wtforms.simplecodes.com）包进行了包装，方便集成到Flask" target="_blank" rel="noopener">http://wtforms.simplecodes.com）包进行了包装，方便集成到Flask</a> 程序中。</p><p>Flask-WTF 及其依赖可使用pip 安装：<br>　　<code>(venv) $ pip install flask-wtf</code><br><a id="more"></a></p><h4 id="2、跨站请求伪造保护"><a href="#2、跨站请求伪造保护" class="headerlink" title="2、跨站请求伪造保护"></a>2、跨站请求伪造保护</h4><p>默认情况下，Flask-WTF 能保护所有表单免受跨站请求伪造（Cross-Site Request Forgery，CSRF）的攻击。恶意网站把请求发送到被攻击者已登录的其他网站时就会引发CSRF 攻击。</p><p>为了实现CSRF 保护，Flask-WTF 需要程序设置一个密钥。Flask-WTF 使用这个密钥生成加密令牌，再用令牌验证请求中表单数据的真伪。设置密钥的方法如示例4-1 所示。</p><p>示例4-1　hello.py：设置Flask-WTF<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[&apos;SECRET_KEY&apos;] = &apos;hard to guess string&apos;</span><br></pre></td></tr></table></figure></p><p><strong>（注：SECRET_KEY 常量一般放在配置文件中，而常量的值一般放在环境变量中，配置文件从环境变量中获取值。防止他人获取配置文件拿到SECRET_KEY值）</strong></p><h4 id="3、表单类"><a href="#3、表单类" class="headerlink" title="3、表单类"></a>3、表单类</h4><p>使用Flask-WTF 时，每个Web 表单都由一个继承自Form 的类表示。这个类定义表单中的一组字段，每个字段都用对象表示。字段对象可附属一个或多个验证函数。验证函数用来验证用户提交的输入值是否符合要求。<br>示例4-2 是一个简单的Web 表单，包含一个文本字段和一个提交按钮。</p><p>示例4-2 是一个简单的Web 表单，包含一个文本字段和一个提交按钮。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例4-2　hello.py：定义表单类</span><br><span class="line">from flask_wtf import Form</span><br><span class="line">from wtforms import StringField, SubmitField</span><br><span class="line">from wtforms.validators import Required</span><br><span class="line"></span><br><span class="line">class NameForm(Form):</span><br><span class="line">    name = StringField(&apos;What is your name?&apos;, validators=[Required()])</span><br><span class="line">    submit = SubmitField(&apos;Submit&apos;)</span><br></pre></td></tr></table></figure></p><p>这个表单中的字段都定义为类变量，类变量的值是相应字段类型的对象。在这个示例中，NameForm 表单中有一个名为name 的文本字段和一个名为submit 的提交按钮。StringField类表示属性为type=”text” 的<code>&lt;input&gt;</code> 元素。SubmitField 类表示属性为type=”submit” 的<code>&lt;input&gt;</code> 元素。字段构造函数的第一个参数是把表单渲染成HTML 时使用的标号。</p><p>StringField 构造函数中的可选参数validators 指定一个由验证函数组成的列表，在接受用户提交的数据之前验证数据。验证函数Required() 确保提交的字段不为空。<br><strong>（注：Form 基类由Flask-WTF 扩展定义，所以从flask.ext.wtf 中导入。字段和验证函数却可以直接从WTForms 包中导入。）</strong></p><p><strong>表4-1　WTForms支持的HTML标准字段</strong></p><table><thead><tr><th>字段类型</th><th>说　　明</th></tr></thead><tbody><tr><td>StringField</td><td>文本字段</td></tr><tr><td>TextAreaField</td><td>多行文本字段</td></tr><tr><td>PasswordField</td><td>密码文本字段</td></tr><tr><td>HiddenField</td><td>隐藏文本字段</td></tr><tr><td>DateField</td><td>文本字段，值为datetime.date 格式</td></tr><tr><td>DateTimeField</td><td>文本字段，值为datetime.datetime 格式</td></tr><tr><td>IntegerField</td><td>文本字段，值为整数</td></tr><tr><td>DecimalField</td><td>文本字段，值为decimal.Decimal</td></tr><tr><td>FloatField</td><td>文本字段，值为浮点数</td></tr><tr><td>BooleanField</td><td>复选框，值为True 和False</td></tr><tr><td>RadioField</td><td>一组单选框</td></tr><tr><td>SelectField</td><td>下拉列表</td></tr><tr><td>SelectMultipleField</td><td>下拉列表，可选择多个值</td></tr><tr><td>FileField</td><td>文件上传字段</td></tr><tr><td>SubmitField</td><td>表单提交按钮</td></tr><tr><td>FormField</td><td>把表单作为字段嵌入另一个表单</td></tr><tr><td>FieldList</td><td>一组指定类型的字段</td></tr></tbody></table><p><strong>表4-2　WTForms验证函数</strong></p><table><thead><tr><th>验证函数</th><th>说　　明</th></tr></thead><tbody><tr><td>Email</td><td>验证电子邮件地址</td></tr><tr><td>EqualTo</td><td>比较两个字段的值；常用于要求输入两次密码进行确认的情况</td></tr><tr><td>IPAddress</td><td>验证IPv4 网络地址</td></tr><tr><td>Length</td><td>验证输入字符串的长度</td></tr><tr><td>NumberRange</td><td>验证输入的值在数字范围内</td></tr><tr><td>Optional</td><td>无输入值时跳过其他验证函数</td></tr><tr><td>Required</td><td>确保字段中有数据</td></tr><tr><td>Regexp</td><td>使用正则表达式验证输入值</td></tr><tr><td>URL</td><td>验证URL</td></tr><tr><td>AnyOf</td><td>确保输入值在可选值列表中</td></tr><tr><td>NoneOf</td><td>确保输入值不在可选值列表中</td></tr></tbody></table><h4 id="4、把表单渲染成HTML"><a href="#4、把表单渲染成HTML" class="headerlink" title="4、把表单渲染成HTML"></a>4、把表单渲染成HTML</h4><h5 id="（1）手工方式渲染"><a href="#（1）手工方式渲染" class="headerlink" title="（1）手工方式渲染"></a>（1）手工方式渲染</h5><p>表单字段是可调用的，在模板中调用后会渲染成HTML。假设视图函数把一个NameForm 实例通过参数form 传入模板，在模板中可以生成一个简单的表单，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot;&gt;</span><br><span class="line">&#123;&#123; form.hidden_tag() &#125;&#125;</span><br><span class="line">&#123;&#123; form.name.label &#125;&#125; &#123;&#123; form.name() &#125;&#125;</span><br><span class="line">&#123;&#123; form.submit() &#125;&#125;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><p>当然，这个表单还很简陋。要想改进表单的外观，可以把参数传入渲染字段的函数，传入的参数会被转换成字段的HTML 属性。例如，可以为字段指定id 或class 属性，然后定义CSS 样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot;&gt;</span><br><span class="line">&#123;&#123; form.hidden_tag() &#125;&#125;</span><br><span class="line">&#123;&#123; form.name.label &#125;&#125; &#123;&#123; form.name(id=&apos;my-text-field&apos;) &#125;&#125;</span><br><span class="line">&#123;&#123; form.submit() &#125;&#125;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><p>即便能指定HTML 属性，但按照这种方式渲染表单的工作量还是很大，所以在条件允许的情况下最好能使用Bootstrap 中的表单样式。</p><h5 id="（2）使用Bootstrap表单样式渲染"><a href="#（2）使用Bootstrap表单样式渲染" class="headerlink" title="（2）使用Bootstrap表单样式渲染"></a>（2）使用Bootstrap表单样式渲染</h5><p>Flask-Bootstrap 提供了一个非常高端的辅助函数，可以使用Bootstrap 中预先定义好的表单样式渲染整个Flask-WTF 表单，而这些操作只需一次调用即可完成。使用Flask-Bootstrap，上述表单可使用下面的方式渲染：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% import &quot;bootstrap/wtf.html&quot; as wtf %&#125;</span><br><span class="line">&#123;&#123; wtf.quick_form(form) &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>import 指令的使用方法和普通Python 代码一样，允许导入模板中的元素并用在多个模板中。导入的bootstrap/wtf.html 文件中定义了一个使用Bootstrap 渲染Falsk-WTF 表单对象的辅助函数。wtf.quick_form() 函数的参数为Flask-WTF 表单对象，使用Bootstrap 的默认样式渲染传入的表单。</p><h4 id="5、在视图函数中处理表单"><a href="#5、在视图函数中处理表单" class="headerlink" title="5、在视图函数中处理表单"></a>5、在视图函数中处理表单</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例4-4　hello.py：路由方法</span><br><span class="line">@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line">def index():</span><br><span class="line">    name = None</span><br><span class="line">    form = NameForm()</span><br><span class="line">    if form.validate_on_submit():</span><br><span class="line">        name = form.name.data</span><br><span class="line">        form.name.data = &apos;&apos;</span><br><span class="line">    return render_template(&apos;index.html&apos;, form=form, name=name)</span><br></pre></td></tr></table></figure><p>app.route 修饰器中添加的methods 参数告诉Flask 在URL 映射中把这个视图函数注册为GET 和POST 请求的处理程序。如果没指定methods 参数，就只把视图函数注册为GET 请求的处理程序。</p><p>把POST 加入方法列表很有必要，因为将提交表单作为POST 请求进行处理更加便利。表单也可作为GET 请求提交，不过GET 请求没有主体，提交的数据以查询字符串的形式附加到URL 中，可在浏览器的地址栏中看到。基于这个以及其他多个原因，提交表单大都作为POST 请求进行处理。</p><p>局部变量name 用来存放表单中输入的有效名字，如果没有输入，其值为None。如上述代码所示，在视图函数中创建一个NameForm 类实例用于表示表单。提交表单后，如果数据能被所有验证函数接受，那么validate_on_submit() 方法的返回值为True，否则返回False。这个函数的返回值决定是重新渲染表单还是处理表单提交的数据。</p><p>用户第一次访问程序时，服务器会收到一个没有表单数据的GET 请求，所以validate_on_submit() 将返回False。if 语句的内容将被跳过，通过渲染模板处理请求，并传入表单对象和值为None 的name 变量作为参数。用户会看到浏览器中显示了一个表单。</p><p>用户提交表单后，服务器收到一个包含数据的POST 请求。validate_on_submit() 会调用name 字段上附属的Required() 验证函数。如果名字不为空，就能通过验证，validate_on_submit() 返回True。现在，用户输入的名字可通过字段的data 属性获取。在if 语句中，把名字赋值给局部变量name，然后再把data 属性设为空字符串，从而清空表单字段。最后一行调用render_template() 函数渲染模板，但这一次参数name 的值为表单中输入的名字，因此会显示一个针对该用户的欢迎消息。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、引入模块&quot;&gt;&lt;a href=&quot;#1、引入模块&quot; class=&quot;headerlink&quot; title=&quot;1、引入模块&quot;&gt;&lt;/a&gt;1、引入模块&lt;/h4&gt;&lt;p&gt;Flask-WTF（&lt;a href=&quot;http://pythonhosted.org/Flask-WTF/）扩展可以把处理Web&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pythonhosted.org/Flask-WTF/）扩展可以把处理Web&lt;/a&gt; 表单的过程变成一种愉悦的体验。这个扩展对独立的WTForms（&lt;a href=&quot;http://wtforms.simplecodes.com）包进行了包装，方便集成到Flask&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://wtforms.simplecodes.com）包进行了包装，方便集成到Flask&lt;/a&gt; 程序中。&lt;/p&gt;
&lt;p&gt;Flask-WTF 及其依赖可使用pip 安装：&lt;br&gt;　　&lt;code&gt;(venv) $ pip install flask-wtf&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 模板续(集成 Twitter Bootstrap)</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E6%A8%A1%E6%9D%BF%E7%BB%AD-%E9%9B%86%E6%88%90-Twitter-Bootstrap/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-模板续-集成-Twitter-Bootstrap/</id>
    <published>2018-03-05T08:02:02.000Z</published>
    <updated>2018-03-06T02:23:07.749Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、集成-Bootstrap"><a href="#1、集成-Bootstrap" class="headerlink" title="1、集成 Bootstrap"></a>1、集成 Bootstrap</h4><p>Bootstrap（<a href="http://getbootstrap.com/）是Twitter" target="_blank" rel="noopener">http://getbootstrap.com/）是Twitter</a> 开发的一个开源框架，它提供的用户界面组件可用于创建整洁且具有吸引力的网页，而且这些网页还能兼容所有现代Web 浏览器。</p><p>Bootstrap 是客户端框架，因此不会直接涉及服务器。服务器需要做的只是提供引用了Bootstrap 层叠样式表（CSS） 和JavaScript 文件的HTML 响应， 并在HTML、CSS 和JavaScript 代码中实例化所需组件。这些操作最理想的执行场所就是模板。</p><p>Flask-Bootstrap 使用pip安装：<br><code>(venv) $ pip install flask-bootstrap</code><br><a id="more"></a><br>Flask 扩展一般都在创建程序实例时初始化。示例3-4 是Flask-Bootstrap 的初始化方法。<br>示例3-4　hello.py：初始化Flask-Bootstrap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from flask_bootstrap import Bootstrap</span><br><span class="line"># ...</span><br><span class="line">bootstrap = Bootstrap(app)</span><br></pre></td></tr></table></figure></p><p>初始化Flask-Bootstrap 之后，就可以在程序中使用一个包含所有Bootstrap 文件的基模板。这个模板利用Jinja2 的模板继承机制，让程序扩展一个具有基本页面结构的基模板，其中就有用来引入Bootstrap 的元素。</p><p>Jinja2 的模板继承机制可以帮助我们解决这一问题。Flask-Bootstrap 提供了一个具有页面基本布局的基模板，同样，程序可以定义一个具有更完整页面布局的基模板，其中包含导航条，而页面内容则可留到衍生模板中定义。示例3-7 展示了templates/base.html 的内容，这是一个继承自bootstrap/base.html 的新模板，其中定义了导航条。这个模板本身也可作为其他模板的基模板，例如templates/user.html、templates/404.html 和templates/500.html。</p><p>示例3-7　templates/base.html：包含导航条的程序基模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;bootstrap/base.html&quot; %&#125;</span><br><span class="line">&#123;% block title %&#125;Flasky&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block navbar %&#125;</span><br><span class="line">&lt;div class=&quot;navbar navbar-inverse&quot; role=&quot;navigation&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;navbar-header&quot;&gt;</span><br><span class="line">            &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; </span><br><span class="line">            data-target=&quot;.navbar-collapse&quot;&gt;</span><br><span class="line">                &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;</span><br><span class="line">                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;Flasky&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;navbar-collapse collapse&quot;&gt;</span><br><span class="line">&lt;ul class=&quot;nav navbar-nav&quot;&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&#123;% block page_content %&#125;&#123;% endblock %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>这个模板的content 块中只有一个<code>&lt;div&gt;</code> 容器，其中包含了一个名为page_content 的新的空块，块中的内容由衍生模板定义。</p><p>Jinja2 中的extends 指令从Flask-Bootstrap 中导入bootstrap/base.html， 从而实现模板继承。Flask-Bootstrap 中的基模板提供了一个网页框架，引入了Bootstrap 中的所有CSS 和JavaScript 文件。</p><p>基模板中定义了可在衍生模板中重定义的块。block 和endblock 指令定义的块中的内容可添加到基模板中。</p><p>上面这个base.html 模板定义了3 个块，分别名为title、navbar 和content。这些块都是基模板提供的，可在衍生模板中重新定义。title 块的作用很明显，其中的内容会出现在渲染后的HTML 文档头部，放在<code>&lt;title&gt;</code> 标签中。navbar 和content 这两个块分别表示页面中的导航条和主体内容。</p><p>在这个模板中，navbar 块使用Bootstrap 组件定义了一个简单的导航条。content 块中有个<code>&lt;div&gt;</code> 容器，其中包含一个页面头部。之前版本的模板中的欢迎信息，现在就放在这个页面头部。</p><p>Flask-Bootstrap 的base.html 模板还定义了很多其他块，都可在衍生模板中使用。表3-2 列出了所有可用的快。<br><strong>表3-2 　Flask-Bootstrap基模板中定义的块</strong></p><table><thead><tr><th>块　　名</th><th>说　　明</th></tr></thead><tbody><tr><td>doc</td><td>整个HTML 文档</td></tr><tr><td>html_attribs</td><td><html> 标签的属性</html></td></tr><tr><td>html</td><td><html> 标签中的内容</html></td></tr><tr><td>head</td><td><head> 标签中的内容</head></td></tr><tr><td>title</td><td><title> 标签中的内容</title></td></tr><tr><td>metas</td><td>一组<meta> 标签</td></tr><tr><td>styles</td><td>层叠样式表定义</td></tr><tr><td>body_attribs</td><td><body> 标签的属性</body></td></tr><tr><td>body</td><td><body> 标签中的内容</body></td></tr><tr><td>navbar</td><td>用户定义的导航条</td></tr><tr><td>content</td><td>用户定义的页面内容</td></tr><tr><td>scripts</td><td>文档底部的JavaScript 声明</td></tr></tbody></table><p>表3-2 中的很多块都是Flask-Bootstrap 自用的，如果直接重定义可能会导致一些问题。例如，Bootstrap 所需的文件在styles 和scripts 块中声明。如果程序需要向已经有内容的块中添加新内容，必须使用Jinja2 提供的super() 函数。例如，如果要在衍生模板中添加新的JavaScript 文件，需要这么定义scripts 块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block scripts %&#125;</span><br><span class="line">    &#123;&#123; super() &#125;&#125;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;my-script.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、自定义错误页面"><a href="#2、自定义错误页面" class="headerlink" title="2、自定义错误页面"></a>2、自定义错误页面</h4><p>像常规路由一样，Flask 允许程序使用基于模板的自定义错误页面。最常见的错误代码有两个：404，客户端请求未知页面或路由时显示；500，有未处理的异常时显示。为这两个错误代码指定自定义处理程序的方式如示例3-6 所示。</p><p>示例3-6　hello.py：自定义错误页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@app.errorhandler(404)</span><br><span class="line">def page_not_found(e):</span><br><span class="line">    return render_template(&apos;404.html&apos;), 404</span><br><span class="line">@app.errorhandler(500)</span><br><span class="line">def internal_server_error(e):</span><br><span class="line">    return render_template(&apos;500.html&apos;), 500</span><br></pre></td></tr></table></figure></p><p>和视图函数一样，错误处理程序也会返回响应。它们还返回与该错误对应的数字状态码。</p><p>错误处理程序中引用的模板也需要编写。这些模板应该和常规页面使用相同的布局，因此要有一个导航条和显示错误消息的页面头部。</p><p>现在，程序使用的模板继承自 templates/base.html 模板，而不直接继承自Flask-Bootstrap 的基模板。通过继承templates/base.html 模板编写自定义的404 错误页面很简单，如示例3-8 所示。</p><p>示例3-8　templates/404.html：使用模板继承机制自定义404 错误页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line">&#123;% block title %&#125;Flasky - Page Not Found&#123;% endblock %&#125;</span><br><span class="line">&#123;% block page_content %&#125;</span><br><span class="line">    &lt;div class=&quot;page-header&quot;&gt;</span><br><span class="line">        &lt;h1&gt;Not Found&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>templates/user.html 现在可以通过继承这个基模板来简化内容，如示例3-9 所示。<br>示例3-9　templates/user.html：使用模板继承机制简化页面模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line">&#123;% block title %&#125;Flasky&#123;% endblock %&#125;</span><br><span class="line">&#123;% block page_content %&#125;</span><br><span class="line">&lt;div class=&quot;page-header&quot;&gt;</span><br><span class="line">&lt;h1&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、链接"><a href="#3、链接" class="headerlink" title="3、链接"></a>3、链接</h4><p>在模板中直接编写简单路由的URL 链接不难，但对于包含可变部分的动态路由，在模板中构建正确的URL 就很困难。而且，直接编写URL 会对代码中定义的路由产生不必要的依赖关系。如果重新定义路由，模板中的链接可能会失效。</p><p>为了避免这些问题，Flask 提供了url_for() 辅助函数，它可以使用程序URL 映射中保存的信息生成URL。</p><p>url_for() 函数最简单的用法是以视图函数名（或者app.add_url_route() 定义路由时使用的端点名）作为参数，返回对应的URL。例如，在当前版本的hello.py 程序中调用url_for(‘index’) 得到的结果是/。调用url_for(‘index’, _external=True) 返回的则是绝对地址，在这个示例中是<a href="http://localhost:5000/。" target="_blank" rel="noopener">http://localhost:5000/。</a></p><p>使用url_for() 生成动态地址时， 将动态部分作为关键字参数传入。例如，url_for(‘user’, name=’john’, _external=True) 的返回结果是<a href="http://localhost:5000/user/john。传入url_for(" target="_blank" rel="noopener">http://localhost:5000/user/john。传入url_for(</a>) 的关键字参数不仅限于动态路由中的参数。函数能将任何额外参数添加到查询字符串中。例如，url_for(‘index’, page=2) 的返回结果是/?page=2。</p><h4 id="4、静态文件"><a href="#4、静态文件" class="headerlink" title="4、静态文件"></a>4、静态文件</h4><p>Web 程序不是仅由Python 代码和模板组成。大多数程序还会使用静态文件，例如HTML代码中引用的图片、JavaScript 源码文件和CSS。</p><p>默认设置下，Flask 在程序根目录中名为static 的子目录中寻找静态文件。如果需要，可在static 文件夹中使用子文件夹存放文件。服务器收到前面那个URL 后，会生成一个响应，包含文件系统中static/css/styles.css 文件的内容。</p><p>示例3-10 展示了如何在程序的基模板中放置favicon.ico 图标。这个图标会显示在浏览器的地址栏中。<br>示例3-10　templates/base.html：定义收藏夹图标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block head %&#125;</span><br><span class="line">&#123;&#123; super() &#125;&#125;</span><br><span class="line">&lt;link rel=&quot;shortcut icon&quot; href=&quot;&#123;&#123; url_for(&apos;static&apos;, filename = &apos;favicon.ico&apos;) &#125;&#125;&quot;</span><br><span class="line"> type=&quot;image/x-icon&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;icon&quot; href=&quot;&#123;&#123; url_for(&apos;static&apos;, filename = &apos;favicon.ico&apos;) &#125;&#125;&quot;</span><br><span class="line"> type=&quot;image/x-icon&quot;&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>图标的声明会插入head 块的末尾。注意如何使用super() 保留基模板中定义的块的原始内容。</p><h4 id="5、使用Flask-Moment-本地化日期和时间"><a href="#5、使用Flask-Moment-本地化日期和时间" class="headerlink" title="5、使用Flask-Moment 本地化日期和时间"></a>5、使用Flask-Moment 本地化日期和时间</h4><p>服务器需要统一时间单位，这和用户所在的地理位置无关，所以一般使用协调世界时（Coordinated Universal Time，UTC）。不过用户看到UTC 格式的时间会感到困惑，他们更希望看到当地时间，而且采用当地惯用的格式。</p><p>要想在服务器上只使用UTC 时间，一个优雅的解决方案是，把时间单位发送给Web 浏览器，转换成当地时间，然后渲染。Web 浏览器可以更好地完成这一任务，因为它能获取用户电脑中的时区和区域设置。</p><p>有一个使用JavaScript 开发的优秀客户端开源代码库，名为moment.js（<a href="http://momentjs.com/），它可以在浏览器中渲染日期和时间。Flask-Moment" target="_blank" rel="noopener">http://momentjs.com/），它可以在浏览器中渲染日期和时间。Flask-Moment</a> 是一个Flask 程序扩展，能把moment.js 集成到Jinja2 模板中。Flask-Moment 可以使用pip 安装：<br><code>(venv) $ pip install flask-moment</code></p><p>这个扩展的初始化方法如示例3-11 所示。<br>示例3-11　hello.py：初始化Flask-Moment<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.moment import Moment</span><br><span class="line">moment = Moment(app)</span><br></pre></td></tr></table></figure></p><p>除了moment.js，Flask-Moment 还依赖jquery.js。要在HTML 文档的某个地方引入这两个库，可以直接引入，这样可以选择使用哪个版本，也可使用扩展提供的辅助函数，从内容分发网络（Content Delivery Network，CDN）中引入通过测试的版本。Bootstrap 已经引入了jquery.js，因此只需引入moment.js 即可。示例3-12 展示了如何在基模板的scripts 块中引入这个库。<br>示例3-12　templates/base.html：引入moment.js 库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block scripts %&#125;</span><br><span class="line">&#123;&#123; super() &#125;&#125;</span><br><span class="line">&#123;&#123; moment.include_moment() &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>为了处理时间戳，Flask-Moment 向模板开放了moment 类。示例3-13 中的代码把变量current_time 传入模板进行渲染。</p><p>示例3-13　hello.py：加入一个datetime 变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&apos;index.html&apos;, current_time=datetime.utcnow())</span><br></pre></td></tr></table></figure></p><p>示例3-14 展示了如何在模板中渲染current_time。<br>代码3-14　templates/index.html：使用Flask-Moment 渲染时间戳<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;The local date and time is &#123;&#123; moment(current_time).format(&apos;LLL&apos;) &#125;&#125;.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;That was &#123;&#123; moment(current_time).fromNow(refresh=True) &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>format(‘LLL’) 根据客户端电脑中的时区和区域设置渲染日期和时间。参数决定了渲染的方式，’L’ 到’LLLL’ 分别对应不同的复杂度。format() 函数还可接受自定义的格式说明符。</p><p>第二行中的fromNow() 渲染相对时间戳，而且会随着时间的推移自动刷新显示的时间。这个时间戳最开始显示为“a few seconds ago”，但指定refresh 参数后，其内容会随着时间的推移而更新。如果一直待在这个页面，几分钟后，会看到显示的文本变成“a minuteago”“2 minutes ago”等。</p><p>Flask-Moment 实现了moment.js 中的format()、fromNow()、fromTime()、calendar()、valueOf()和unix() 方法。你可查阅文档（<a href="http://momentjs.com/docs/#/displaying/）学习moment.js" target="_blank" rel="noopener">http://momentjs.com/docs/#/displaying/）学习moment.js</a> 提供的全部格式化选项。</p><p>Flask-Moment 渲染的时间戳可实现多种语言的本地化。语言可在模板中选择，把语言代码传给lang() 函数即可：<br><code>\{\{ moment.lang(&#39;es&#39;) \}\}</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、集成-Bootstrap&quot;&gt;&lt;a href=&quot;#1、集成-Bootstrap&quot; class=&quot;headerlink&quot; title=&quot;1、集成 Bootstrap&quot;&gt;&lt;/a&gt;1、集成 Bootstrap&lt;/h4&gt;&lt;p&gt;Bootstrap（&lt;a href=&quot;http://getbootstrap.com/）是Twitter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://getbootstrap.com/）是Twitter&lt;/a&gt; 开发的一个开源框架，它提供的用户界面组件可用于创建整洁且具有吸引力的网页，而且这些网页还能兼容所有现代Web 浏览器。&lt;/p&gt;
&lt;p&gt;Bootstrap 是客户端框架，因此不会直接涉及服务器。服务器需要做的只是提供引用了Bootstrap 层叠样式表（CSS） 和JavaScript 文件的HTML 响应， 并在HTML、CSS 和JavaScript 代码中实例化所需组件。这些操作最理想的执行场所就是模板。&lt;/p&gt;
&lt;p&gt;Flask-Bootstrap 使用pip安装：&lt;br&gt;&lt;code&gt;(venv) $ pip install flask-bootstrap&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 模板(Jinjia2)</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E6%A8%A1%E6%9D%BF-Jinjia2/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-模板-Jinjia2/</id>
    <published>2018-03-05T08:01:35.000Z</published>
    <updated>2018-03-06T02:23:37.458Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、渲染模板"><a href="#1、渲染模板" class="headerlink" title="1、渲染模板"></a>1、渲染模板</h4><p>默认情况下，Flask 在程序文件夹中的templates 子文件夹中寻找模板。在下一个hello.py版本中，要把前面定义的模板保存在templates 文件夹中，并分别命名为index.html 和user.html。</p><p>示例3-3　hello.py：渲染模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, render_template</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&apos;index.html&apos;)</span><br><span class="line">@app.route(&apos;/user/&lt;name&gt;&apos;)</span><br><span class="line">def user(name):</span><br><span class="line">    return render_template(&apos;user.html&apos;, name=name)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>Flask 提供的render_template 函数把Jinja2 模板引擎集成到了程序中。<font color="red">render_template 函数的第一个参数是模板的文件名。随后的参数都是键值对，表示模板中变量对应的真实值。</font>在这段代码中，第二个模板收到一个名为name 的变量。</p><h4 id="2、变量"><a href="#2、变量" class="headerlink" title="2、变量"></a>2、变量</h4><p>在模板中使用的 结构表示一个变量，它是一种特殊的占位符，告诉模板引擎这个位置的值从渲染模板时使用的数据中获取。</p><p>Jinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。在模板中使用变量的一些示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;A value from a dictionary: &#123;&#123; mydict[&apos;key&apos;] &#125;&#125;.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;A value from a list: &#123;&#123; mylist[3] &#125;&#125;.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;A value from a list, with a variable index: &#123;&#123; mylist[myintvar] &#125;&#125;.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;A value from an object&apos;s method: &#123;&#123; myobj.somemethod() &#125;&#125;.&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>可以使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述<br>模板以首字母大写形式显示变量name 的值：<br>　　<code>Hello, \{\{ name|capitalize \}\}</code></p><p><strong>表3-1 列出了Jinja2 提供的部分常用过滤器。</strong></p><table><thead><tr><th>过滤器名</th><th>说　　明</th></tr></thead><tbody><tr><td>safe</td><td>渲染值时不转义</td></tr><tr><td>capitalize</td><td>把值的首字母转换成大写，其他字母转换成小写</td></tr><tr><td>lower</td><td>把值转换成小写形式</td></tr><tr><td>upper</td><td>把值转换成大写形式</td></tr><tr><td>title</td><td>把值中每个单词的首字母都转换成大写</td></tr><tr><td>trim</td><td>把值的首尾空格去掉</td></tr><tr><td>striptags</td><td>渲染之前把值中所有的HTML 标签都删掉</td></tr></tbody></table><p>safe 过滤器值得特别说明一下。默认情况下，出于安全考虑，Jinja2 会转义所有变量。例如，如果一个变量的值为<code>&lt;h1&gt;Hello&lt;/h1&gt;</code>，Jinja2 会将其渲染成<code>&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;</code>，浏览器能显示这个h1 元素，但不会进行解释。很多情况下需要显示变量中存储的HTML 代码，这时就可使用safe 过滤器。</p><p>完整的过滤器列表可在Jinja2 文档（<a href="http://jinja.pocoo.org/docs/templates/#builtin-filters）中查看。" target="_blank" rel="noopener">http://jinja.pocoo.org/docs/templates/#builtin-filters）中查看。</a></p><h4 id="3、控制结构"><a href="#3、控制结构" class="headerlink" title="3、控制结构"></a>3、控制结构</h4><p>Jinja2 提供了多种控制结构，可用来改变模板的渲染流程。<br>下面这个例子展示了如何在模板中使用条件控制语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if user %&#125;</span><br><span class="line">    Hello, &#123;&#123; user &#125;&#125;!</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    Hello, Stranger!</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>另一种常见需求是在模板中渲染一组元素。下例展示了如何使用for 循环实现这一需求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for comment in comments %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>Jinja2 还支持宏。宏类似于Python 代码中的函数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% macro render_comment(comment) %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for comment in comments %&#125;</span><br><span class="line">        &#123;&#123; render_comment(comment) &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>为了重复使用宏，我们可以将其保存在单独的文件中，然后在需要使用的模板中导入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% import &apos;macros.html&apos; as macros %&#125;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for comment in comments %&#125;</span><br><span class="line">        &#123;&#123; macros.render_comment(comment) &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>需要在多处重复使用的模板代码片段可以写入单独的文件，再包含在所有模板中，以避免重复：<br><code>include &quot;comment.html&quot;</code></p><p>另一种重复使用代码的强大方式是模板继承，它类似于Python 代码中的类继承。首先，创建一个名为base.html 的基模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &#123;% block head %&#125;</span><br><span class="line">    &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - My Application&lt;/title&gt;</span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;% block body %&#125;</span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>block 标签定义的元素可在衍生模板中修改。在本例中，我们定义了名为head、title 和body 的块。注意，title 包含在head 中。下面这个示例是基模板的衍生模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line">&#123;% block title %&#125;Index&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block head %&#125;</span><br><span class="line">    &#123;&#123; super() &#125;&#125;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block body %&#125;</span><br><span class="line">    &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>extends 指令声明这个模板衍生自base.html。在extends 指令之后，基模板中的3 个块被重新定义，模板引擎会将其插入适当的位置。注意新定义的head 块，在基模板中其内容不是空的，所以使用super() 获取原来的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、渲染模板&quot;&gt;&lt;a href=&quot;#1、渲染模板&quot; class=&quot;headerlink&quot; title=&quot;1、渲染模板&quot;&gt;&lt;/a&gt;1、渲染模板&lt;/h4&gt;&lt;p&gt;默认情况下，Flask 在程序文件夹中的templates 子文件夹中寻找模板。在下一个hello.py版本中，要把前面定义的模板保存在templates 文件夹中，并分别命名为index.html 和user.html。&lt;/p&gt;
&lt;p&gt;示例3-3　hello.py：渲染模板&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;from flask import Flask, render_template&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app = Flask(__name__)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@app.route(&amp;apos;/&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def index():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return render_template(&amp;apos;index.html&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@app.route(&amp;apos;/user/&amp;lt;name&amp;gt;&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def user(name):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return render_template(&amp;apos;user.html&amp;apos;, name=name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if __name__ == &amp;apos;__main__&amp;apos;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    app.run()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Flask  整体概述-一个完整的程序</title>
    <link href="http://yoursite.com/2018/03/02/Flask-%E6%95%B4%E4%BD%93%E6%A6%82%E8%BF%B0-%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/03/02/Flask-整体概述-一个完整的程序/</id>
    <published>2018-03-02T08:25:45.000Z</published>
    <updated>2018-03-02T08:46:49.632Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Flask-简介"><a href="#一、Flask-简介" class="headerlink" title="一、Flask 简介"></a>一、Flask 简介</h3><p>Flask(<a href="http://flask.pocoo.org/)是一种小型框架，小到可以称为“微框架”。但是，小并不意味着它比其他框架的功能少。Flask" target="_blank" rel="noopener">http://flask.pocoo.org/)是一种小型框架，小到可以称为“微框架”。但是，小并不意味着它比其他框架的功能少。Flask</a> 自开发伊始就被设计为可扩展的框架，它具有一个包含基本服务的强健核心，其他功能则可通过扩展实现。你可以自己挑选所需的扩展包，组成一个没有附加功能的精益组合，从而完全精确满足自身需求。</p><p>Flask 有两个主要依赖：路由、调试和Web 服务器网关接口（Web Server Gateway Interface，WSGI）子系统由Werkzeug（<a href="http://werkzeug.pocoo.org/）提供；模板系统由Jinja2（http://jinja.pocoo.org/）提供。Werkzeug" target="_blank" rel="noopener">http://werkzeug.pocoo.org/）提供；模板系统由Jinja2（http://jinja.pocoo.org/）提供。Werkzeug</a> 和Jinjia2 都是由Flask 的核心开发者开发而成。</p><p>Flask 并不原生支持数据库访问、Web 表单验证和用户认证等高级功能。这些功能以及其他大多数Web 程序中需要的核心服务都以扩展的形式实现，然后再与核心包集成。开发者可以任意挑选符合项目需求的扩展，甚至可以自行开发。这和大型框架的做法相反，大型框架往往已经替你做出了大多数决定，难以（有时甚至不允许）使用替代方案。<br><a id="more"></a></p><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><h4 id="1、使用虚拟环境"><a href="#1、使用虚拟环境" class="headerlink" title="1、使用虚拟环境"></a>1、使用虚拟环境</h4><p>安装Flask 最便捷的方式是使用虚拟环境。虚拟环境是Python解释器的一个私有副本，在这个环境中你可以安装私有包，而且不会影响系统中安装的全局Python 解释器。</p><p>虚拟环境非常有用，可以在系统的Python 解释器中避免包的混乱和版本的冲突。为每个程序单独创建虚拟环境可以保证程序只能访问虚拟环境中的包，从而保持全局解释器的干净整洁，使其只作为创建（更多）虚拟环境的源。</p><p>虚拟环境使用第三方实用工具virtualenv 创建。输入以下命令可以检查系统是否安装了virtualenv：<br>　　<code>$ virtualenv --version</code><br>如果结果显示错误，你就需要安装这个工具。</p><h5 id="（1）安装virtualenv"><a href="#（1）安装virtualenv" class="headerlink" title="（1）安装virtualenv"></a>（1）安装virtualenv</h5><p>① 大多数Linux 发行版都提供了virtualenv 包。例如，Ubuntu 用户可以使用下述命令安装它：<br>　　<code>$ sudo apt-get install python-virtualenv</code><br>② 如果你的电脑是Mac OS X 系统，就可以使用easy_install 安装virtualenv：<br>　　<code>$ sudo easy_install virtualenv</code><br>③ 如果你使用微软的Windows 系统或其他没有官方virtualenv 包的操作系统，那么安装过程要稍微复杂一点。<br>在浏览器中输入网址<a href="https://bitbucket.org/pypa/setuptools，回车后会进入setuptools" target="_blank" rel="noopener">https://bitbucket.org/pypa/setuptools，回车后会进入setuptools</a> 安装程序的主页。在这个页面中找到下载安装脚本的链接，脚本名为ez_setup.py。把这个文件保存到电脑的一个临时文件夹中，然后在这个文件夹中执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python ez_setup.py</span><br><span class="line">$ easy_install virtualenv</span><br></pre></td></tr></table></figure></p><h5 id="（2）创建虚拟环境"><a href="#（2）创建虚拟环境" class="headerlink" title="（2）创建虚拟环境"></a>（2）创建虚拟环境</h5><p>下一步是使用virtualenv 命令在flasky 文件夹中创建Python 虚拟环境。这个命令只有一个必需的参数，即虚拟环境的名字。创建虚拟环境后，当前文件夹中会出现一个子文件夹，名字就是上述命令中指定的参数，与虚拟环境相关的文件都保存在这个子文件夹中。<br>按照惯例，一般虚拟环境会被命名为venv：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv venv</span><br><span class="line">New python executable in venv/bin/python2.7</span><br><span class="line">Also creating executable in venv/bin/python</span><br><span class="line">Installing setuptools............done.</span><br><span class="line">Installing pip...............done.</span><br></pre></td></tr></table></figure></p><h5 id="（3）激活虚拟环境"><a href="#（3）激活虚拟环境" class="headerlink" title="（3）激活虚拟环境"></a>（3）激活虚拟环境</h5><p>现在，flasky 文件夹中就有了一个名为venv 的子文件夹，它保存一个全新的虚拟环境，其中有一个私有的Python 解释器。在使用这个虚拟环境之前，你需要先将其“激活”。如果你使用bash 命令行（Linux 和Mac OS X 用户），可以通过下面的命令激活这个虚拟环境：<br>　　<code>$ source venv/bin/activate</code><br>如果使用微软Windows 系统，激活命令是：<br>　　<code>$ venv\Scripts\activate</code><br>虚拟环境被激活后，其中Python 解释器的路径就被添加进PATH 中，但这种改变不是永久性的，它只会影响当前的命令行会话。为了提醒你已经激活了虚拟环境，激活虚拟环境的命令会修改命令行提示符，加入环境名：<br>　　<code>(venv) $</code><br>当虚拟环境中的工作完成后，如果你想回到全局Python 解释器中，可以在命令行提示符下输入deactivate。</p><h4 id="2、使用pip安装Python包（Flask）"><a href="#2、使用pip安装Python包（Flask）" class="headerlink" title="2、使用pip安装Python包（Flask）"></a>2、使用pip安装Python包（Flask）</h4><p>大多数Python 包都使用pip 实用工具安装，使用virtualenv 创建虚拟环境时会自动安装pip。激活虚拟环境后，pip 所在的路径会被添加进PATH。<br>执行下述命令可在虚拟环境中安装Flask：<br>　　<code>(venv) $ pip install flask</code><br>执行上述命令，你就在虚拟环境中安装Flask 及其依赖了。要想验证Flask 是否正确安装，你可以启动Python 解释器，尝试导入Flask：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python</span><br><span class="line">&gt;&gt;&gt; import flask</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>如果没有看到错误提醒，那恭喜你——你已经可以安装完成了。</p><h3 id="三、程序的基本结构"><a href="#三、程序的基本结构" class="headerlink" title="三、程序的基本结构"></a>三、程序的基本结构</h3><p>首先，来梳理一下Flask的工作流程。</p><h4 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h4><p>所有Flask 程序都必须创建一个程序实例。Web 服务器使用一种名为Web 服务器网关接口（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这个对象处理。程序实例是Flask 类的对象，经常使用下述代码创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure></p><p>Flask 类的构造函数<font color="red">只有一个必须指定的参数，即程序主模块或包的名字</font>。在大多数程序中，Python 的<strong>name</strong> 变量就是所需的值。</p><h4 id="2、路由和视图函数"><a href="#2、路由和视图函数" class="headerlink" title="2、路由和视图函数"></a>2、路由和视图函数</h4><p>客户端（例如Web 浏览器）把请求发送给Web 服务器，Web 服务器再把请求发送给Flask程序实例。程序实例需要知道对每个URL 请求运行哪些代码，所以保存了一个URL 到Python 函数的映射关系。<font color="red">处理URL和函数之间关系的程序称为路由</font>。</p><p>在Flask 程序中定义路由的最简便方式，是使用程序实例提供的app.route 修饰器，把修<br>饰的函数注册为路由。下面的例子说明了如何使用这个修饰器声明路由：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos;</span><br></pre></td></tr></table></figure></p><p><strong>（注：修饰器是Python 语言的标准特性，可以使用不同的方式修改函数的行为。惯常用法是使用修饰器把函数注册为事件的处理程序。）</strong></p><p>前例把index() 函数注册为程序根地址的处理程序，即将跟地址映射到index() 函数处理程序。在浏览器中访问<a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a> 后，会触发服务器执行index() 函数。这个函数的返回值称为响应，是客户端接收到的内容。如果客户端是Web 浏览器，响应就是显示给用户查看的文档。</p><p>像index() 这样的函数称为<font color="red">视图函数（view function）</font>。视图函数返回的响应可以是包含HTML 的简单字符串，也可以是复杂的表单，当然也可以是接口所需的数据格式（JSON或XML）。</p><p>此处再扩展一下，route 修饰器也支持动态URL，下例定义的路由中就有一部分是动态名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/user/&lt;name&gt;&apos;)</span><br><span class="line">def user(name):</span><br><span class="line">    return &apos;&lt;h1&gt;Hello, %s!&lt;/h1&gt;&apos; % name</span><br></pre></td></tr></table></figure></p><p>尖括号中的内容就是动态部分，任何能匹配静态部分的URL 都会映射到这个路由上。调用视图函数时，Flask 会将动态部分作为参数传入函数。在这个视图函数中，参数用于生成针对个人的欢迎消息。</p><p>路由中的动态部分默认使用字符串，不过也可使用类型定义。例如，路由/user/<int:id>只会匹配动态片段id 为整数的URL。Flask 支持在路由中使用int、float 和path 类型。path 类型也是字符串，但不把斜线视作分隔符，而将其当作动态片段的一部分。</int:id></p><h4 id="3、启动服务器"><a href="#3、启动服务器" class="headerlink" title="3、启动服务器"></a>3、启动服务器</h4><p>程序实例用run 方法启动Flask 集成的开发Web 服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">app.run(debug=True)</span><br></pre></td></tr></table></figure></p><p>__name__==’__main__‘ 是Python 的惯常用法，在这里确保直接执行这个脚本时才启动开发Web 服务器。如果这个脚本由其他脚本引入，程序假定父级脚本会启动不同的服务器，因此不会执行app.run()。</p><p>服务器启动后，会进入轮询，等待并处理请求。轮询会一直运行，直到程序停止，比如按Ctrl-C 键。</p><p>有一些选项参数可被app.run() 函数接受用于设置Web 服务器的操作模式。在开发过程中启用调试模式会带来一些便利，比如说激活调试器和重载程序。要想启用调试模式，我们可以把debug 参数设为True。</p><h4 id="4、一个完整的程序"><a href="#4、一个完整的程序" class="headerlink" title="4、一个完整的程序"></a>4、一个完整的程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># hello.py</span><br><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos;</span><br><span class="line"></span><br><span class="line">@app.route(&apos;user/&lt;name&gt;&apos;)</span><br><span class="line">def user(name):</span><br><span class="line">    return &apos;&lt;h1&gt;Hello, %s&lt;/h1&gt;&apos; % self.name</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>然后使用下述命令启动程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py</span><br><span class="line">* Running on http://127.0.0.1:5000/</span><br><span class="line">* Restarting with reloader</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Flask-简介&quot;&gt;&lt;a href=&quot;#一、Flask-简介&quot; class=&quot;headerlink&quot; title=&quot;一、Flask 简介&quot;&gt;&lt;/a&gt;一、Flask 简介&lt;/h3&gt;&lt;p&gt;Flask(&lt;a href=&quot;http://flask.pocoo.org/)是一种小型框架，小到可以称为“微框架”。但是，小并不意味着它比其他框架的功能少。Flask&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://flask.pocoo.org/)是一种小型框架，小到可以称为“微框架”。但是，小并不意味着它比其他框架的功能少。Flask&lt;/a&gt; 自开发伊始就被设计为可扩展的框架，它具有一个包含基本服务的强健核心，其他功能则可通过扩展实现。你可以自己挑选所需的扩展包，组成一个没有附加功能的精益组合，从而完全精确满足自身需求。&lt;/p&gt;
&lt;p&gt;Flask 有两个主要依赖：路由、调试和Web 服务器网关接口（Web Server Gateway Interface，WSGI）子系统由Werkzeug（&lt;a href=&quot;http://werkzeug.pocoo.org/）提供；模板系统由Jinja2（http://jinja.pocoo.org/）提供。Werkzeug&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://werkzeug.pocoo.org/）提供；模板系统由Jinja2（http://jinja.pocoo.org/）提供。Werkzeug&lt;/a&gt; 和Jinjia2 都是由Flask 的核心开发者开发而成。&lt;/p&gt;
&lt;p&gt;Flask 并不原生支持数据库访问、Web 表单验证和用户认证等高级功能。这些功能以及其他大多数Web 程序中需要的核心服务都以扩展的形式实现，然后再与核心包集成。开发者可以任意挑选符合项目需求的扩展，甚至可以自行开发。这和大型框架的做法相反，大型框架往往已经替你做出了大多数决定，难以（有时甚至不允许）使用替代方案。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 模块之cPickle</title>
    <link href="http://yoursite.com/2018/02/05/Python-%E6%A8%A1%E5%9D%97%E4%B9%8BcPickle/"/>
    <id>http://yoursite.com/2018/02/05/Python-模块之cPickle/</id>
    <published>2018-02-05T09:28:00.000Z</published>
    <updated>2018-02-05T10:00:09.263Z</updated>
    
    <content type="html"><![CDATA[<p>在python中，一般可以使用pickle类来进行python对象的序列化，而cPickle提供了一个更快速简单的接口，如python文档所说的：“cPickle – A faster pickle”。使用cPickle模块永久地把这些对象储存在你的硬盘上。</p><blockquote><p><strong>对象持久化：</strong><br>如果希望透明地存储 Python 对象，而不丢失其身份和类型等信息，则需要某种形式的对象序列化：它是一个将任意复杂的对象转成对象的文本或二进制表示的过程。同样，必须能够将对象经过序列化后的形式恢复到原有的对象。在 Python 中，这种序列化过程称为 pickle，可以将对象 pickle 成字符串、磁盘上的文件或者任何类似于文件的对象，也可以将这些字符串、文件或任何类似于文件的对象 unpickle 成原来的对象。</p></blockquote><a id="more"></a><p>cPickle可以对任意一种类型的python对象进行序列化操作，比如list，dict，甚至是一个类的对象等。 pickle 模块提供了以下函数对： dumps(object) 返回一个字符串，它包含一个 pickle 格式的对象； loads(string) 返回包含在 pickle 字符串中的对象； dump(object, file) 将对象写到文件，这个文件可以是实际的物理文件，但也可以是任何类似于文件的对象，这个对象具有 write() 方法，可以接受单个的字符串参数； load(file) 返回包含在 pickle 文件中的对象。</p><h5 id="dump-和-load"><a href="#dump-和-load" class="headerlink" title="dump() 和 load()"></a>dump() 和 load()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a1 = &apos;apple&apos;</span><br><span class="line">&gt;&gt;&gt; b1 = &#123;1: &apos;One&apos;, 2: &apos;Two&apos;, 3: &apos;Three&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; c1 = [&apos;fee&apos;, &apos;fie&apos;, &apos;foe&apos;, &apos;fum&apos;]</span><br><span class="line">&gt;&gt;&gt; f1 = file(&apos;temp.pkl&apos;, &apos;wb&apos;)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(a1, f1, True)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(b1, f1, True)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(c1, f1, True)</span><br><span class="line">&gt;&gt;&gt; f1.close()</span><br><span class="line">&gt;&gt;&gt; f2 = file(&apos;temp.pkl&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; a2 = pickle.load(f2)</span><br><span class="line">&gt;&gt;&gt; a2</span><br><span class="line">&apos;apple&apos;</span><br><span class="line">&gt;&gt;&gt; b2 = pickle.load(f2)</span><br><span class="line">&gt;&gt;&gt; b2</span><br><span class="line">&#123;1: &apos;One&apos;, 2: &apos;Two&apos;, 3: &apos;Three&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; c2 = pickle.load(f2)</span><br><span class="line">&gt;&gt;&gt; c2</span><br><span class="line">[&apos;fee&apos;, &apos;fie&apos;, &apos;foe&apos;, &apos;fum&apos;]</span><br><span class="line">&gt;&gt;&gt; f2.close()</span><br></pre></td></tr></table></figure><blockquote><p><strong>dump： 将python对象序列化保存到本地的文件</strong><br>dump函数需要指定两个参数，第一个是需要序列化的python对象名称，第二个是本地的文件，需要注意的是，在这里需要使用open函数打开一个文件，并指定“写”操作<br><strong>load：载入本地文件，恢复python对象</strong><br>同dump一样，这里需要使用open函数打开本地的一个文件，并指定“读”操作 </p></blockquote><h5 id="dumps-和-loads"><a href="#dumps-和-loads" class="headerlink" title="dumps() 和 loads()"></a>dumps() 和 loads()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import cPickle as pickle</span><br><span class="line">&gt;&gt;&gt; t1 = (&apos;this is a string&apos;, 42, [1, 2, 3], None)</span><br><span class="line">&gt;&gt;&gt; t1</span><br><span class="line">(&apos;this is a string&apos;, 42, [1, 2, 3], None)</span><br><span class="line">&gt;&gt;&gt; p1 = pickle.dumps(t1)</span><br><span class="line">&gt;&gt;&gt; p1</span><br><span class="line">&quot;(S&apos;this is a string&apos;/nI42/n(lp1/nI1/naI2/naI3/naNtp2/n.&quot;</span><br><span class="line">&gt;&gt;&gt; print p1</span><br><span class="line">(S&apos;this is a string&apos;</span><br><span class="line">I42</span><br><span class="line">(lp1</span><br><span class="line">I1</span><br><span class="line">aI2</span><br><span class="line">aI3</span><br><span class="line">aNtp2</span><br><span class="line">.</span><br><span class="line">&gt;&gt;&gt; t2 = pickle.loads(p1)</span><br><span class="line">&gt;&gt;&gt; t2</span><br><span class="line">(&apos;this is a string&apos;, 42, [1, 2, 3], None)</span><br><span class="line">&gt;&gt;&gt; p2 = pickle.dumps(t1, True)</span><br><span class="line">&gt;&gt;&gt; p2</span><br><span class="line">&apos;(U/x10this is a stringK*]q/x01(K/x01K/x02K/x03eNtq/x02.&apos;</span><br><span class="line">&gt;&gt;&gt; t3 = pickle.loads(p2)</span><br><span class="line">&gt;&gt;&gt; t3</span><br><span class="line">(&apos;this is a string&apos;, 42, [1, 2, 3], None)</span><br></pre></td></tr></table></figure><blockquote><p><strong>dumps：将python对象序列化保存到一个字符串变量中</strong><br><strong>loads：从字符串变量中载入python对象</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在python中，一般可以使用pickle类来进行python对象的序列化，而cPickle提供了一个更快速简单的接口，如python文档所说的：“cPickle – A faster pickle”。使用cPickle模块永久地把这些对象储存在你的硬盘上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对象持久化：&lt;/strong&gt;&lt;br&gt;如果希望透明地存储 Python 对象，而不丢失其身份和类型等信息，则需要某种形式的对象序列化：它是一个将任意复杂的对象转成对象的文本或二进制表示的过程。同样，必须能够将对象经过序列化后的形式恢复到原有的对象。在 Python 中，这种序列化过程称为 pickle，可以将对象 pickle 成字符串、磁盘上的文件或者任何类似于文件的对象，也可以将这些字符串、文件或任何类似于文件的对象 unpickle 成原来的对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python模块" scheme="http://yoursite.com/tags/Python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python 基础小程序实践</title>
    <link href="http://yoursite.com/2018/02/05/Python-%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/02/05/Python-基础小程序实践/</id>
    <published>2018-02-05T08:54:59.000Z</published>
    <updated>2018-02-05T09:27:05.312Z</updated>
    
    <content type="html"><![CDATA[<p><strong>要求：</strong></p><blockquote><p>创建你自己的命令行 地址簿 程序。在这个程序中，你可以添加、修改、删除和搜索你的联系人（朋友、家人和同事等等）以及它们的信息（诸如电子邮件地址和/或电话号码）。这些详细信息应该被保存下来以便以后提取。</p></blockquote><p><strong>提示：</strong></p><blockquote><p>创建一个类来表示一个人的信息。使用字典储存每个人的对象，把他们的名字作为键。使用cPickle模块永久地把这些对象储存在你的硬盘上。使用字典内建的方法添加、删除和修改人员信息。</p></blockquote><p><font color="red">一旦你完成了这个程序，你就可以说是一个Python程序员了。</font><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#coding=utf-8</span><br><span class="line"># Filename: address.py</span><br><span class="line"></span><br><span class="line">import cPickle as p</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    &apos;&apos;&apos;Person class </span><br><span class="line">    save information of email,phone,name.&apos;&apos;&apos;</span><br><span class="line">    contacts = &#123;&#125;</span><br><span class="line">    contactfile = &apos;contact.data&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        f = file(Person.contactfile)</span><br><span class="line">        Person.contacts = p.load(f)</span><br><span class="line">        f.close()</span><br><span class="line">    </span><br><span class="line">    def add(self, name, email, phone):</span><br><span class="line">        Person.contacts[name] = &#123;&apos;email&apos;: email, &apos;phone&apos;: phone&#125;</span><br><span class="line">        f = file(Person.contactfile, &apos;w&apos;)</span><br><span class="line">        p.dump(Person.contacts, f)</span><br><span class="line">        f.close()</span><br><span class="line">        print &apos;optetor success!&apos;</span><br><span class="line"></span><br><span class="line">    def search(self, name):</span><br><span class="line">        if Person.contacts.has_key(name):</span><br><span class="line">            print &apos;Name: %s Email: %s Phone: %s&apos; % (name, Person.contacts[name][&apos;email&apos;], Person.contacts[name][&apos;phone&apos;])</span><br><span class="line">        else:</span><br><span class="line">            print &apos;search faild!&apos;</span><br><span class="line"></span><br><span class="line">    def delete(self, name):</span><br><span class="line">        if Person.contacts.has_key(name):</span><br><span class="line">            Person.contacts.pop(name)</span><br><span class="line">            f = file(Person.contactfile, &apos;w&apos;)</span><br><span class="line">            p.dump(Person.contacts, f)</span><br><span class="line">            f.close()</span><br><span class="line">            print &apos;delete success!&apos;</span><br><span class="line">        else:</span><br><span class="line">            print &apos;name is not exists!&apos;</span><br><span class="line"></span><br><span class="line">    def modify(self, name, email, phone):</span><br><span class="line">        if Person.contacts.has_key(name):</span><br><span class="line">            if email:</span><br><span class="line">                Person.contacts[name][&apos;email&apos;] = email</span><br><span class="line">            if phone:</span><br><span class="line">                Person.contacts[name][&apos;phone&apos;] = phone</span><br><span class="line">            f = file(Person.contactfile, &apos;w&apos;)</span><br><span class="line">            p.dump(Person.contacts, f)</span><br><span class="line">            f.close()</span><br><span class="line">            print &apos;modify success!&apos;</span><br><span class="line">        else:</span><br><span class="line">            print &apos;name is not exists!&apos;</span><br><span class="line"></span><br><span class="line">def p_add():</span><br><span class="line">    print &quot;Pleace input add information&quot;</span><br><span class="line">    name = raw_input(&apos;name:&apos;)</span><br><span class="line">    email = raw_input(&apos;email:&apos;)</span><br><span class="line">    phone = raw_input(&apos;phone:&apos;)</span><br><span class="line">    person = Person()</span><br><span class="line">    person.add(name, email, phone)</span><br><span class="line"></span><br><span class="line">def p_modify():</span><br><span class="line">    name = raw_input(&apos;Pleace input modify name:&apos;)</span><br><span class="line">    email = raw_input(&apos;email:&apos;)</span><br><span class="line">    phone = raw_input(&apos;phone:&apos;)</span><br><span class="line">    person = Person()</span><br><span class="line">    person.modify(name, email, phone)</span><br><span class="line"></span><br><span class="line">def p_delete():</span><br><span class="line">    name = raw_input(&apos;Pleace input search name:&apos;)</span><br><span class="line">    person = Person()</span><br><span class="line">    person.delete(name)</span><br><span class="line"></span><br><span class="line">def p_search():</span><br><span class="line">    name = raw_input(&apos;Pleace input search name:&apos;)</span><br><span class="line">    person = Person()</span><br><span class="line">    person.search(name)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&apos;&apos;&apos;What would you want to do ?</span><br><span class="line">    a=add, m=modify, d=delete, s=search&apos;&apos;&apos;)</span><br><span class="line">    optetor = raw_input(&apos;pleace input a character:&apos;)</span><br><span class="line">    if(optetor == &apos;a&apos;):</span><br><span class="line">        p_add()</span><br><span class="line">    elif(optetor == &apos;m&apos;):</span><br><span class="line">        p_modify()</span><br><span class="line">    elif(optetor == &apos;d&apos;):</span><br><span class="line">        p_delete()</span><br><span class="line">    elif(optetor == &apos;s&apos;):</span><br><span class="line">        p_search()</span><br><span class="line">    else:</span><br><span class="line">        print &apos;input error&apos;</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    try:</span><br><span class="line">        main()</span><br><span class="line">    except Exception,e:</span><br><span class="line">        print e</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;要求：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建你自己的命令行 地址簿 程序。在这个程序中，你可以添加、修改、删除和搜索你的联系人（朋友、家人和同事等等）以及它们的信息（诸如电子邮件地址和/或电话号码）。这些详细信息应该被保存下来以便以后提取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建一个类来表示一个人的信息。使用字典储存每个人的对象，把他们的名字作为键。使用cPickle模块永久地把这些对象储存在你的硬盘上。使用字典内建的方法添加、删除和修改人员信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;一旦你完成了这个程序，你就可以说是一个Python程序员了。&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python实践" scheme="http://yoursite.com/tags/Python%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级整理（Python中文手册）</title>
    <link href="http://yoursite.com/2018/02/05/Python-%E9%AB%98%E7%BA%A7%E6%95%B4%E7%90%86%EF%BC%88Python%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/02/05/Python-高级整理（Python中文手册）/</id>
    <published>2018-02-05T05:52:23.000Z</published>
    <updated>2018-02-05T06:30:38.424Z</updated>
    
    <content type="html"><![CDATA[<p>记住，Python把在程序中用到的任何东西都称为 对象 。这是从广义上说的。因此我们不会说“某某 东西 ”，我们说“某个 对象 ”。<br><strong>给面向对象编程用户的注释：</strong></p><blockquote><p>就每一个东西包括数、字符串甚至函数都是对象这一点来说，Python是极其完全地面向对象的。 </p></blockquote><a id="more"></a><h3 id="1、模块"><a href="#1、模块" class="headerlink" title="1、模块"></a>1、模块</h3><h4 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>你已经学习了如何在你的程序中定义一次函数而重用代码。如果你想要在其他程序中重用很多函数，那么你该如何编写程序呢？你可能已经猜到了，答案是使用模块。模块基本上就是一个包含了所有你定义的函数和变量的文件。为了在其他程序中重用模块，模块的文件名必须以.py为扩展名。</p><p>模块可以从其他程序 输入 以便利用它的功能。这也是我们使用Python标准库的方法。<br>模块的用处在于它能为你在别的程序中重用它提供的服务和功能。Python附带的标准库就是这样一组模块的例子。</p><h4 id="（2）字节编译的-pyc文件"><a href="#（2）字节编译的-pyc文件" class="headerlink" title="（2）字节编译的.pyc文件"></a>（2）字节编译的.pyc文件</h4><p>输入一个模块相对来说是一个比较费时的事情，所以Python做了一些技巧，以便使输入模块更加快一些。一种方法是创建 字节编译的文件 ，这些文件以.pyc作为扩展名。字节编译的文件与Python变换程序的中间状态有关。当你在下次从别的程序输入这个模块的时候，.pyc文件是十分有用的——它会快得多，因为一部分输入模块所需的处理已经完成了。另外，这些字节编译的文件也是与平台无关的。</p><h4 id="（3）from-import-语句"><a href="#（3）from-import-语句" class="headerlink" title="（3）from..import 语句"></a>（3）from..import 语句</h4><p>如果你想要直接输入argv变量到你的程序中（避免在每次使用它时打sys.），那么你可以使用from sys import argv语句。如果你想要输入所有sys模块使用的名字，那么你可以使用from sys import *语句。这对于所有模块都适用。<strong>一般说来，应该避免使用from..import而使用import语句，因为这样可以使你的程序更加易读，也可以避免名称的冲突。</strong></p><h4 id="（4）模块的-name"><a href="#（4）模块的-name" class="headerlink" title="（4）模块的 __name__"></a>（4）模块的 __name__</h4><p>每个模块都有一个名称，在模块中可以通过语句来找出模块的名称。这在一个场合特别有用——就如前面所提到的，当一个模块被第一次输入的时候，这个模块的主块将被运行。假如我们只想在程序本身被使用的时候运行主块，而在它被别的模块输入的时候不运行主块，我们该怎么做呢？这可以通过模块的__name__属性完成。</p><p><strong>例8.2 使用模块的__name__</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: using_name.py</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print &apos;This program is being run by itself&apos;</span><br><span class="line">else:</span><br><span class="line">    print &apos;I am being imported from another module&apos;</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python using_name.py</span><br><span class="line">This program is being run by itself</span><br><span class="line"></span><br><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import using_name</span><br><span class="line">I am being imported from another module</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>每个Python模块都有它的__name__，如果它是’__main__‘，这说明这个模块被用户单独运行，我们可以进行相应的恰当操作。</p><h4 id="（5）dir-函数"><a href="#（5）dir-函数" class="headerlink" title="（5）dir() 函数"></a>（5）dir() 函数</h4><p>你可以使用内建的dir函数来列出模块定义的标识符。标识符有函数、类和变量。<br>当你为dir()提供一个模块名的时候，它返回模块定义的名称列表。如果不提供参数，它返回当前模块中定义的名称列表。</p><h3 id="2、面向对象的编程"><a href="#2、面向对象的编程" class="headerlink" title="2、面向对象的编程"></a>2、面向对象的编程</h3><h4 id="（1）简介-1"><a href="#（1）简介-1" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>在我们的程序中，我们根据操作数据的函数或语句块来设计程序的。这被称为 面向过程的 编程。还有一种把数据和功能结合起来，用称为对象的东西包裹起来组织程序的方法。这种方法称为 面向对象的 编程理念。在大多数时候你可以使用过程性编程，但是有些时候当你想要编写大型程序或是寻求一个更加合适的解决方案的时候，你就得使用面向对象的编程技术。</p><p>类和对象是面向对象编程的两个主要方面。<strong>类</strong>创建一个新类型，而<strong>对象</strong>这个类的 实例 。这类似于你有一个int类型的变量，这存储整数的变量是int类的实例（对象）。</p><p><em>注意，即便是整数也被作为对象（属于int类）。这和C++、Java（1.5版之前）把整数纯粹作为类型是不同的。通过help(int)了解更多这个类的详情。</em></p><p>对象可以使用普通的 属于 对象的变量存储数据。属于一个对象或类的变量被称为<strong>域</strong>。对象也可以使用 属于 类的函数来具有功能。这样的函数被称为类的方法。这些术语帮助我们把它们与孤立的函数和变量区分开来。域和方法可以合称为类的<strong>属性</strong>。</p><p>域有两种类型——属于每个实例/类的对象或属于类本身。它们分别被称为<strong>实例变量</strong>和<strong>类变量</strong>。</p><p>类使用class关键字创建。类的域和方法被列在一个缩进块中。</p><h4 id="（2）self"><a href="#（2）self" class="headerlink" title="（2）self"></a>（2）self</h4><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，但是在调用这个方法的时候你不为这个参数赋值，Python会提供这个值。这个特别的变量指对象本身，按照惯例它的名称是self。</p><p>虽然你可以给这个参数任何名称，但是 强烈建议 你使用self这个名称——其他名称都是不赞成你使用的。使用一个标准的名称有很多优点——你的程序读者可以迅速识别它，如果使用self的话，还有些IDE（集成开发环境）也可以帮助你。</p><p>你一定很奇怪Python如何给self赋值以及为何你不需要给它赋值。举一个例子会使此变得清晰。假如你有一个类称为MyClass和这个类的一个实例MyObject。当你调用这个对象的方法MyObject.method(arg1, arg2)的时候，这会由Python自动转为MyClass.method(MyObject, arg1, arg2)——这就是self的原理了。</p><p><strong>（注：这也意味着如果你有一个不需要参数的方法，你还是得给这个方法定义一个self参数。）</strong></p><h4 id="（3）创建一个类"><a href="#（3）创建一个类" class="headerlink" title="（3）创建一个类"></a>（3）创建一个类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例11.1 创建一个类</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: simplestclass.py</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    pass # An empty block</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">print p</span><br></pre></td></tr></table></figure><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python simplestclass.py</span><br><span class="line">&lt;__main__.Person instance at 0xf6fcb18c&gt;</span><br></pre></td></tr></table></figure></p><p>我们使用class语句后跟类名，创建了一个新的类。这后面跟着一个缩进的语句块形成类体。在这个例子中，我们使用了一个空白块，它由pass语句表示。</p><p>接下来，我们使用类名后跟一对圆括号来创建一个对象/实例。为了验证，我们简单地打印了这个变量的类型。它告诉我们我们已经在__main__模块中有了一个Person类的实例。</p><p>可以注意到存储对象的计算机内存地址也打印了出来。这个地址在你的计算机上会是另外一个值，因为Python可以在任何空位存储对象。</p><h4 id="（4）init方法"><a href="#（4）init方法" class="headerlink" title="（4）init方法"></a>（4）<strong>init</strong>方法</h4><p>在Python的类中有很多方法的名字有特殊的重要意义。现在我们将学习__init__方法的意义。</p><p>__init__方法在类的一个对象被建立时，马上运行。这个方法可以用来对你的对象做一些你希望的 初始化 。注意，这个名称的开始和结尾都是双下划线。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例11.3 使用__init__方法</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: class_init.py</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def sayHi(self):</span><br><span class="line">        print &apos;Hello, my name is&apos;, self.name</span><br><span class="line"></span><br><span class="line">p = Person(&apos;Swaroop&apos;)</span><br><span class="line">p.sayHi()</span><br><span class="line"></span><br><span class="line"># This short example can also be written as Person(&apos;Swaroop&apos;).sayHi()</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python class_init.py</span><br><span class="line">Hello, my name is Swaroop</span><br></pre></td></tr></table></figure></p><p>这里，我们把__init__方法定义为取一个参数name（以及普通的参数self）。在这个__init__里，我们只是创建一个新的域，也称为name。注意它们是两个不同的变量，尽管它们有相同的名字。点号使我们能够区分它们。</p><p>最重要的是，我们没有专门调用__init__方法，只是在创建一个类的新实例的时候，把参数包括在圆括号内跟在类名后面，从而传递给__init__方法。这是这种方法的重要之处。与 <em>construct</em> 的概念类似。</p><p>现在，我们能够在我们的方法中使用self.name域。这在sayHi方法中得到了验证。</p><h4 id="（5）类与对象的方法"><a href="#（5）类与对象的方法" class="headerlink" title="（5）类与对象的方法"></a>（5）类与对象的方法</h4><p>我们已经讨论了类与对象的功能部分，现在我们来看一下它的数据部分。事实上，它们只是与类和对象的<strong>名称空间</strong> 绑定 的普通变量，即这些名称只在这些类与对象的前提下有效。</p><p>有两种类型的 <strong>域</strong> ——类的变量和对象的变量，它们根据是类还是对象 拥有 这个变量而区分。</p><p><strong>类的变量</strong> 由一个类的所有对象（实例）共享使用。只有一个类变量的拷贝，所以当某个对象对类的变量做了改动的时候，这个改动会反映到所有其他的实例上。</p><p><strong>对象的变量</strong> 由类的每个对象/实例拥有。因此每个对象有自己对这个域的一份拷贝，即它们不是共享的，在同一个类的不同实例中，虽然对象的变量有相同的名称，但是是互不相关的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">例11.4 使用类与对象的变量</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: objvar.py</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    &apos;&apos;&apos;Represents a person.&apos;&apos;&apos;</span><br><span class="line">    population = 0</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        &apos;&apos;&apos;Initializes the person&apos;s data.&apos;&apos;&apos;</span><br><span class="line">        self.name = name</span><br><span class="line">        print &apos;(Initializing %s)&apos; % self.name</span><br><span class="line"></span><br><span class="line">        # When this person is created, he/she</span><br><span class="line">        # adds to the population</span><br><span class="line">        Person.population += 1</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        &apos;&apos;&apos;I am dying.&apos;&apos;&apos;</span><br><span class="line">        print &apos;%s says bye.&apos; % self.name</span><br><span class="line"></span><br><span class="line">        Person.population -= 1</span><br><span class="line"></span><br><span class="line">        if Person.population == 0:</span><br><span class="line">            print &apos;I am the last one.&apos;</span><br><span class="line">        else:</span><br><span class="line">            print &apos;There are still %d people left.&apos; % Person.population</span><br><span class="line"></span><br><span class="line">    def sayHi(self):</span><br><span class="line">        &apos;&apos;&apos;Greeting by the person.</span><br><span class="line"></span><br><span class="line">        Really, that&apos;s all it does.&apos;&apos;&apos;</span><br><span class="line">        print &apos;Hi, my name is %s.&apos; % self.name</span><br><span class="line"></span><br><span class="line">    def howMany(self):</span><br><span class="line">        &apos;&apos;&apos;Prints the current population.&apos;&apos;&apos;</span><br><span class="line">        if Person.population == 1:</span><br><span class="line">            print &apos;I am the only person here.&apos;</span><br><span class="line">        else:</span><br><span class="line">            print &apos;We have %d persons here.&apos; % Person.population</span><br><span class="line"></span><br><span class="line">swaroop = Person(&apos;Swaroop&apos;)</span><br><span class="line">swaroop.sayHi()</span><br><span class="line">swaroop.howMany()</span><br><span class="line"></span><br><span class="line">kalam = Person(&apos;Abdul Kalam&apos;)</span><br><span class="line">kalam.sayHi()</span><br><span class="line">kalam.howMany()</span><br><span class="line"></span><br><span class="line">swaroop.sayHi()</span><br><span class="line">swaroop.howMany()</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python objvar.py</span><br><span class="line">(Initializing Swaroop)</span><br><span class="line">Hi, my name is Swaroop.</span><br><span class="line">I am the only person here.</span><br><span class="line">(Initializing Abdul Kalam)</span><br><span class="line">Hi, my name is Abdul Kalam.</span><br><span class="line">We have 2 persons here.</span><br><span class="line">Hi, my name is Swaroop.</span><br><span class="line">We have 2 persons here.</span><br><span class="line">Abdul Kalam says bye.</span><br><span class="line">There are still 1 people left.</span><br><span class="line">Swaroop says bye.</span><br><span class="line">I am the last one.</span><br></pre></td></tr></table></figure></p><p>这是一个很长的例子，但是它有助于说明类与对象的变量的本质。这里，population属于Person类，因此是一个类的变量。name变量属于对象（它使用self赋值）因此是对象的变量。</p><p>观察可以发现__init__方法用一个名字来初始化Person实例。在这个方法中，我们让population增加1，这是因为我们增加了一个人。同样可以发现，self.name的值根据每个对象指定，这表明了它作为对象的变量的本质。</p><p>记住，你只能使用self变量来参考同一个对象的变量和方法。这被称为 属性参考 。</p><p>在这个程序中，我们还看到docstring对于类和方法同样有用。我们可以在运行时使用Person.__doc__和Person.sayHi.__doc__来分别访问类与方法的文档字符串。</p><p>就如同__init__方法一样，还有一个特殊的方法__del__，它在对象消逝的时候被调用。对象消逝即对象不再被使用，它所占用的内存将返回给系统作它用。在这个方法里面，我们只是简单地把Person.population减1。</p><p>当对象不再被使用时，__del__方法运行，但是很难保证这个方法究竟在 什么时候 运行。如果你想要指明它的运行，你就得使用del语句，就如同我们在以前的例子中使用的那样。</p><p><strong>给C++/Java/C#程序员的注释</strong><br>Python中所有的类成员（包括数据成员）都是 公共的 ，所有的方法都是 有效的 。<br>只有一个例外：如果你使用的数据成员名称以 双下划线前缀 比如__privatevar，Python的名称管理体系会有效地把它作为私有变量。<br>这样就有一个惯例，如果某个变量只想在类或对象中使用，就应该以单下划线前缀。而其他的名称都将作为公共的，可以被其他类/对象使用。记住这只是一个惯例，并不是Python所要求的（与双下划线前缀不同）。<br>同样，注意__del__方法与 destructor 的概念类似。</p><p><strong>一些特殊的方法：</strong></p><style type="text/css">    table th:first-of-type {        width: 100px;    }</style><table><thead><tr><th>名称</th><th>说明 </th></tr></thead><tbody><tr><td><strong>init</strong>(self,…)</td><td>这个方法在新建对象恰好要被返回使用之前被调用。 </td></tr><tr><td><strong>del</strong>(self)</td><td>恰好在对象要被删除之前调用。 </td></tr><tr><td><strong>str</strong>(self)</td><td>在我们对对象使用print语句或是使用str()的时候调用。 </td></tr><tr><td><strong>lt</strong>(self,other)</td><td>当使用 小于 运算符（&lt;）的时候调用。类似地，对于所有的运算符（+，&gt;等等）都有特殊的方法。 </td></tr><tr><td><strong>getitem</strong>(self,key)</td><td>使用x[key]索引操作符的时候调用。 </td></tr><tr><td><strong>len</strong>(self)</td><td>对序列对象使用内建的len()函数的时候调用。 </td></tr></tbody></table><h4 id="（6）继承"><a href="#（6）继承" class="headerlink" title="（6）继承"></a>（6）继承</h4><p>面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过 继承 机制。继承完全可以理解成类之间的 类型和子类型 关系。</p><p>假设你想要写一个程序来记录学校之中的教师和学生情况。他们有一些共同属性，比如姓名、年龄和地址。他们也有专有的属性，比如教师的薪水、课程和假期，学生的成绩和学费。</p><p>你可以为教师和学生建立两个独立的类来处理它们，但是这样做的话，如果要增加一个新的共有属性，就意味着要在这两个独立的类中都增加这个属性。这很快就会显得不实用。</p><p>一个比较好的方法是创建一个共同的类称为SchoolMember然后让教师和学生的类 继承 这个共同的类。即它们都是这个类型（类）的子类型，然后我们再为这些子类型添加专有的属性。</p><p>使用这种方法有很多优点。如果我们增加/改变了SchoolMember中的任何功能，它会自动地反映到子类型之中。例如，你要为教师和学生都增加一个新的身份证域，那么你只需简单地把它加到SchoolMember类中。然而，在一个子类型之中做的改动不会影响到别的子类型。另外一个优点是你可以把教师和学生对象都作为SchoolMember对象来使用，这在某些场合特别有用，比如统计学校成员的人数。一个子类型在任何需要父类型的场合可以被替换成父类型，即对象可以被视作是父类的实例，这种现象被称为多态现象。</p><p>另外，我们会发现在 重用 父类的代码的时候，我们无需在不同的类中重复它。而如果我们使用独立的类的话，我们就不得不这么做了。</p><p>在上述的场合中，SchoolMember类被称为 基本类 或 超类 。而Teacher和Student类被称为 导出类 或 子类 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">例11.5 使用继承</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: inherit.py</span><br><span class="line"></span><br><span class="line">class SchoolMember:</span><br><span class="line">    &apos;&apos;&apos;Represents any school member.&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        print &apos;(Initialized SchoolMember: %s)&apos; % self.name</span><br><span class="line"></span><br><span class="line">    def tell(self):</span><br><span class="line">        &apos;&apos;&apos;Tell my details.&apos;&apos;&apos;</span><br><span class="line">        print &apos;Name:&quot;%s&quot; Age:&quot;%s&quot;&apos; % (self.name, self.age),</span><br><span class="line"></span><br><span class="line">class Teacher(SchoolMember):</span><br><span class="line">    &apos;&apos;&apos;Represents a teacher.&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, name, age, salary):</span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.salary = salary</span><br><span class="line">        print &apos;(Initialized Teacher: %s)&apos; % self.name</span><br><span class="line"></span><br><span class="line">    def tell(self):</span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        print &apos;Salary: &quot;%d&quot;&apos; % self.salary</span><br><span class="line"></span><br><span class="line">class Student(SchoolMember):</span><br><span class="line">    &apos;&apos;&apos;Represents a student.&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, name, age, marks):</span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.marks = marks</span><br><span class="line">        print &apos;(Initialized Student: %s)&apos; % self.name</span><br><span class="line"></span><br><span class="line">    def tell(self):</span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        print &apos;Marks: &quot;%d&quot;&apos; % self.marks</span><br><span class="line"></span><br><span class="line">t = Teacher(&apos;Mrs. Shrividya&apos;, 40, 30000)</span><br><span class="line">s = Student(&apos;Swaroop&apos;, 22, 75)</span><br><span class="line"></span><br><span class="line">print # prints a blank line</span><br><span class="line"></span><br><span class="line">members = [t, s]</span><br><span class="line">for member in members:</span><br><span class="line">    member.tell() # works for both Teachers and Students</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python inherit.py</span><br><span class="line">(Initialized SchoolMember: Mrs. Shrividya)</span><br><span class="line">(Initialized Teacher: Mrs. Shrividya)</span><br><span class="line">(Initialized SchoolMember: Swaroop)</span><br><span class="line">(Initialized Student: Swaroop)</span><br><span class="line"></span><br><span class="line">Name:&quot;Mrs. Shrividya&quot; Age:&quot;40&quot; Salary: &quot;30000&quot;</span><br><span class="line">Name:&quot;Swaroop&quot; Age:&quot;22&quot; Marks: &quot;75&quot;</span><br></pre></td></tr></table></figure></p><p>为了使用继承，我们把基本类的名称作为一个元组跟在定义类时的类名称之后。然后，我们注意到基本类的<strong>init</strong>方法专门使用self变量调用，这样我们就可以初始化对象的基本类部分。这一点十分重要——Python不会自动调用基本类的constructor，你得亲自专门调用它。</p><p>我们还观察到我们在方法调用之前加上类名称前缀，然后把self变量及其他参数传递给它。</p><p>注意，在我们使用SchoolMember类的tell方法的时候，我们把Teacher和Student的实例仅仅作为SchoolMember的实例。</p><p>另外，在这个例子中，我们调用了子类型的tell方法，而不是SchoolMember类的tell方法。可以这样来理解，Python总是首先查找对应类型的方法，在这个例子中就是如此。如果它不能在导出类中找到对应的方法，它才开始到基本类中逐个查找。基本类是在类定义的时候，在元组之中指明的。</p><p>一个术语的注释——如果在继承元组中列了一个以上的类，那么它就被称作 多重继承 。</p><h3 id="3、输入-输出"><a href="#3、输入-输出" class="headerlink" title="3、输入/输出"></a>3、输入/输出</h3><p>在很多时候，你会想要让你的程序与用户（可能是你自己）交互。你会从用户那里得到输入，然后打印一些结果。我们可以分别使用raw_input和print语句来完成这些功能。对于输出，你也可以使用多种多样的str（字符串）类。例如，你能够使用rjust方法来得到一个按一定宽度右对齐的字符串。利用help(str)获得更多详情。</p><p>另一个常用的输入/输出类型是处理文件。创建、读和写文件的能力是许多程序所必需的，我们将会在这章探索如何实现这些功能。</p><h4 id="（1）文件"><a href="#（1）文件" class="headerlink" title="（1）文件"></a>（1）文件</h4><p>你可以通过创建一个file类的对象来打开一个文件，分别使用file类的read、readline或write方法来恰当地读写文件。对文件的读写能力依赖于你在打开文件时指定的模式。最后，当你完成对文件的操作的时候，你调用close方法来告诉Python我们完成了对文件的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">例12.1 使用文件</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: using_file.py</span><br><span class="line"></span><br><span class="line">poem = &apos;&apos;&apos;\</span><br><span class="line">Programming is fun</span><br><span class="line">When the work is done</span><br><span class="line">if you wanna make your work also fun:</span><br><span class="line">        use Python!</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">f = file(&apos;poem.txt&apos;, &apos;w&apos;) # open for &apos;w&apos;riting</span><br><span class="line">f.write(poem) # write text to file</span><br><span class="line">f.close() # close the file</span><br><span class="line"></span><br><span class="line">f = file(&apos;poem.txt&apos;)</span><br><span class="line"># if no mode is specified, &apos;r&apos;ead mode is assumed by default</span><br><span class="line">while True:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    if len(line) == 0: # Zero length indicates EOF</span><br><span class="line">        break</span><br><span class="line">    print line,</span><br><span class="line">    # Notice comma to avoid automatic newline added by Python</span><br><span class="line">f.close() # close the file</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python using_file.py</span><br><span class="line">Programming is fun</span><br><span class="line">When the work is done</span><br><span class="line">if you wanna make your work also fun:</span><br><span class="line">        use Python!</span><br></pre></td></tr></table></figure></p><p>首先，我们通过指明我们希望打开的文件和模式来创建一个file类的实例。模式可以为读模式（’r’）、写模式（’w’）或追加模式（’a’）。事实上还有多得多的模式可以使用，你可以使用help(file)来了解它们的详情。</p><p>我们首先用写模式打开文件，然后使用file类的write方法来写文件，最后我们用close关闭这个文件。</p><p>接下来，我们再一次打开同一个文件来读文件。如果我们没有指定模式，读模式会作为默认的模式。在一个循环中，我们使用readline方法读文件的每一行。这个方法返回包括行末换行符的一个完整行。所以，当一个 空的 字符串被返回的时候，即表示文件末已经到达了，于是我们停止循环。</p><p>注意，因为从文件读到的内容已经以换行符结尾，所以我们在print语句上<strong>使用逗号来消除自动换行</strong>。最后，我们用close关闭这个文件。</p><p>现在，来看一下poem.txt文件的内容来验证程序确实工作正常了。</p><h4 id="（2）存储器"><a href="#（2）存储器" class="headerlink" title="（2）存储器"></a>（2）存储器</h4><p>Python提供一个标准的模块，称为pickle。使用它你可以在一个文件中储存任何Python对象，之后你又可以把它完整无缺地取出来。这被称为 持久地 储存对象。</p><p>还有另一个模块称为cPickle，它的功能和pickle模块完全相同，只不过它是用C语言编写的，因此要快得多（比pickle快1000倍）。你可以使用它们中的任一个，而我们在这里将使用cPickle模块。记住，我们把这两个模块都简称为pickle模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">例12.2 储存与取储存</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: pickling.py</span><br><span class="line"></span><br><span class="line">import cPickle as p</span><br><span class="line">#import pickle as p</span><br><span class="line"></span><br><span class="line">shoplistfile = &apos;shoplist.data&apos;</span><br><span class="line"># the name of the file where we will store the object</span><br><span class="line"></span><br><span class="line">shoplist = [&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;]</span><br><span class="line"></span><br><span class="line"># Write to the file</span><br><span class="line">f = file(shoplistfile, &apos;w&apos;)</span><br><span class="line">p.dump(shoplist, f) # dump the object to a file</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">del shoplist # remove the shoplist</span><br><span class="line"></span><br><span class="line"># Read back from the storage</span><br><span class="line">f = file(shoplistfile)</span><br><span class="line">storedlist = p.load(f)</span><br><span class="line">print storedlist</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python pickling.py</span><br><span class="line">[&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;]</span><br></pre></td></tr></table></figure></p><p>首先，请注意我们使用了import..as语法。这是一种便利方法，以便于我们可以使用更短的模块名称。在这个例子中，它还让我们能够通过简单地改变一行就切换到另一个模块（cPickle或者pickle）！在程序的其余部分的时候，我们简单地把这个模块称为p。</p><p>为了在文件里储存一个对象，首先以写模式打开一个file对象，然后调用储存器模块的dump函数，把对象储存到打开的文件中。这个过程称为 储存 。</p><p>接下来，我们使用pickle模块的load函数的返回来取回对象。这个过程称为 取储存 。</p><h3 id="4、异常"><a href="#4、异常" class="headerlink" title="4、异常"></a>4、异常</h3><p>当你的程序中出现某些 异常的 状况的时候，异常就发生了。例如，当你想要读某个文件的时候，而那个文件不存在。或者在程序运行的时候，你不小心把它删除了。上述这些情况可以使用异常来处理。</p><p>假如你的程序中有一些无效的语句，会怎么样呢？Python会引发并告诉你那里有一个错误，从而处理这样的情况。</p><h4 id="（1）处理异常"><a href="#（1）处理异常" class="headerlink" title="（1）处理异常"></a>（1）处理异常</h4><p>我们可以使用try..except语句来处理异常。我们把通常的语句放在try-块中，而把我们的错误处理语句放在except-块中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">例13.1 处理异常</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: try_except.py</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    s = raw_input(&apos;Enter something --&gt; &apos;)</span><br><span class="line">except EOFError:</span><br><span class="line">    print &apos;\nWhy did you do an EOF on me?&apos;</span><br><span class="line">    sys.exit() # exit the program</span><br><span class="line">except:</span><br><span class="line">    print &apos;\nSome error/exception occurred.&apos;</span><br><span class="line">    # here, we are not exiting the program</span><br><span class="line"></span><br><span class="line">print &apos;Done&apos;</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python try_except.py</span><br><span class="line">Enter something --&gt;</span><br><span class="line">Why did you do an EOF on me?</span><br><span class="line"></span><br><span class="line">$ python try_except.py</span><br><span class="line">Enter something --&gt; Python is exceptional!</span><br><span class="line">Done</span><br></pre></td></tr></table></figure></p><p>我们把所有可能引发错误的语句放在try块中，然后在except从句/块中处理所有的错误和异常。except从句可以专门处理单一的错误或异常，或者一组包括在圆括号内的错误/异常。如果没有给出错误或异常的名称，它会处理 所有的 错误和异常。对于每个try从句，至少都有一个相关联的except从句。</p><p>如果某个错误或异常没有被处理，默认的Python处理器就会被调用。它会终止程序的运行，并且打印一个消息，我们已经看到了这样的处理。</p><p>你还可以让try..catch块关联上一个else从句。当没有异常发生的时候，else从句将被执行。</p><p>我们还可以得到异常对象，从而获取更多有个这个异常的信息。</p><h4 id="（2）引发异常"><a href="#（2）引发异常" class="headerlink" title="（2）引发异常"></a>（2）引发异常</h4><p>你可以使用raise语句 引发 异常。你还得指明错误/异常的名称和伴随异常 触发的 异常对象。你可以引发的错误或异常应该分别是一个Error或Exception类的直接或间接导出类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">例13.2 如何引发异常</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: raising.py</span><br><span class="line"></span><br><span class="line">class ShortInputException(Exception):</span><br><span class="line">    &apos;&apos;&apos;A user-defined exception class.&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, length, atleast):</span><br><span class="line">        Exception.__init__(self)</span><br><span class="line">        self.length = length</span><br><span class="line">        self.atleast = atleast</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    s = raw_input(&apos;Enter something --&gt; &apos;)</span><br><span class="line">    if len(s) &lt; 3:</span><br><span class="line">        raise ShortInputException(len(s), 3)</span><br><span class="line">    # Other work can continue as usual here</span><br><span class="line">except EOFError:</span><br><span class="line">    print &apos;\nWhy did you do an EOF on me?&apos;</span><br><span class="line">except ShortInputException, x:</span><br><span class="line">    print &apos;ShortInputException: The input was of length %d, \</span><br><span class="line">          was expecting at least %d&apos; % (x.length, x.atleast)</span><br><span class="line">else:</span><br><span class="line">    print &apos;No exception was raised.&apos;</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python raising.py</span><br><span class="line">Enter something --&gt;</span><br><span class="line">Why did you do an EOF on me?</span><br><span class="line"></span><br><span class="line">$ python raising.py</span><br><span class="line">Enter something --&gt; ab</span><br><span class="line">ShortInputException: The input was of length 2, was expecting at least 3</span><br><span class="line"></span><br><span class="line">$ python raising.py</span><br><span class="line">Enter something --&gt; abc</span><br><span class="line">No exception was raised.</span><br></pre></td></tr></table></figure></p><p>这里，我们创建了我们自己的异常类型，其实我们可以使用任何预定义的异常/错误。这个新的异常类型是ShortInputException类。它有两个域——length是给定输入的长度，atleast则是程序期望的最小长度。</p><p>在except从句中，我们提供了错误类和用来表示错误/异常对象的变量。这与函数调用中的形参和实参概念类似。在这个特别的except从句中，我们使用异常对象的length和atleast域来为用户打印一个恰当的消息。</p><h4 id="（3）try-finally"><a href="#（3）try-finally" class="headerlink" title="（3）try..finally"></a>（3）try..finally</h4><p>假如你在读一个文件的时候，希望在无论异常发生与否的情况下都关闭文件，该怎么做呢？这可以使用finally块来完成。注意，在一个try块下，你可以同时使用except从句和finally块。如果你要同时使用它们的话，需要把一个嵌入另外一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">例13.3 使用finally</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: finally.py</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    f = file(&apos;poem.txt&apos;)</span><br><span class="line">    while True: # our usual file-reading idiom</span><br><span class="line">        line = f.readline()</span><br><span class="line">        if len(line) == 0:</span><br><span class="line">            break</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print line,</span><br><span class="line">finally:</span><br><span class="line">    f.close()</span><br><span class="line">    print &apos;Cleaning up...closed the file&apos;</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python finally.py</span><br><span class="line">Programming is fun</span><br><span class="line">When the work is done</span><br><span class="line">Cleaning up...closed the file</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;finally.py&quot;, line 12, in ?</span><br><span class="line">    time.sleep(2)</span><br><span class="line">KeyboardInterrupt</span><br></pre></td></tr></table></figure></p><p>我们进行通常的读文件工作，但是我有意在每打印一行之前用time.sleep方法暂停2秒钟。这样做的原因是让程序运行得慢一些（Python由于其本质通常运行得很快）。在程序运行的时候，按Ctrl-c中断/取消程序。</p><p>我们可以观察到KeyboardInterrupt异常被触发，程序退出。但是在程序退出之前，finally从句仍然被执行，把文件关闭</p><h3 id="5、其它知识点"><a href="#5、其它知识点" class="headerlink" title="5、其它知识点"></a>5、其它知识点</h3><h4 id="（1）在函数中接收元组和列表"><a href="#（1）在函数中接收元组和列表" class="headerlink" title="（1）在函数中接收元组和列表"></a>（1）在函数中接收元组和列表</h4><p>当要使函数接收元组或字典形式的参数的时候，有一种特殊的方法，它分别使用<em>和*</em>前缀。这种方法在函数需要获取可变数量的参数的时候特别有用。</p><p>由于在args变量前有<em>前缀，所有多余的函数参数都会作为一个元组存储在args中。如果使用的是*</em>前缀，多余的参数则会被认为是一个字典的键/值对。</p><h4 id="（2）lambda形式"><a href="#（2）lambda形式" class="headerlink" title="（2）lambda形式"></a>（2）lambda形式</h4><p>lambda语句被用来创建新的函数对象，并且在运行时返回它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例15.2 使用lambda形式</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: lambda.py</span><br><span class="line"></span><br><span class="line">def make_repeater(n):</span><br><span class="line">    return lambda s: s*n</span><br><span class="line"></span><br><span class="line">twice = make_repeater(2)</span><br><span class="line"></span><br><span class="line">print twice(&apos;word&apos;)</span><br><span class="line">print twice(5)</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python lambda.py</span><br><span class="line">wordword</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p><p>这里，我们使用了make_repeater函数在运行时创建新的函数对象，并且返回它。lambda语句用来创建函数对象。本质上，lambda需要一个参数，后面仅跟单个表达式作为函数体，而表达式的值被这个新建的函数返回。注意，即便是print语句也不能用在lambda形式中，只能使用表达式。</p><h4 id="（3）exec-和-eval-语句"><a href="#（3）exec-和-eval-语句" class="headerlink" title="（3）exec 和 eval 语句"></a>（3）exec 和 eval 语句</h4><p>exec语句用来执行储存在字符串或文件中的Python语句。例如，我们可以在运行时生成一个包含Python代码的字符串，然后使用exec语句执行这些语句。下面是一个简单的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; exec &apos;print &quot;Hello World&quot;&apos;</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p><p>eval语句用来计算存储在字符串中的有效Python表达式。下面是一个简单的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; eval(&apos;2*3&apos;)</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记住，Python把在程序中用到的任何东西都称为 对象 。这是从广义上说的。因此我们不会说“某某 东西 ”，我们说“某个 对象 ”。&lt;br&gt;&lt;strong&gt;给面向对象编程用户的注释：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就每一个东西包括数、字符串甚至函数都是对象这一点来说，Python是极其完全地面向对象的。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python知识点" scheme="http://yoursite.com/tags/Python%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Python 基础整理（Python中文手册）</title>
    <link href="http://yoursite.com/2018/02/02/Python-%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88Python%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/02/02/Python-基础整理（Python中文手册）/</id>
    <published>2018-02-02T10:39:07.000Z</published>
    <updated>2018-02-05T06:14:09.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Python概述"><a href="#1、Python概述" class="headerlink" title="1、Python概述"></a>1、Python概述</h3><p>Python语言是少有的一种可以称得上即简单又功能强大的编程语言。你将惊喜地发现Python语言是多么地简单，它注重的是如何解决问题而不是编程语言的语法和结构。</p><p><strong>Python的官方介绍是：</strong></p><blockquote><p>Python是一种简单易学，功能强大的编程语言，它有高效率的高层数据结构，简单而有效地实现面向对象编程。Python简洁的语法和对动态输入的支持，再加上解释性语言的本质，使得它在大多数平台上的许多领域都是一个理想的脚本语言，特别适用于快速的应用程序开发。</p></blockquote><a id="more"></a><h3 id="2、基本数据类型：数和字符串"><a href="#2、基本数据类型：数和字符串" class="headerlink" title="2、基本数据类型：数和字符串"></a>2、基本数据类型：数和字符串</h3><h4 id="（1）数"><a href="#（1）数" class="headerlink" title="（1）数"></a>（1）数</h4><p>在Python中有4种类型的数——整数、长整数、浮点数和复数。</p><h4 id="（2）字符串"><a href="#（2）字符串" class="headerlink" title="（2）字符串"></a>（2）字符串</h4><p>字符串是 字符的序列 。字符串基本上就是一组单词。</p><blockquote><p>下面有几种方式使用字符串：<br><strong>使用单引号（’） </strong><br>你可以用单引号指示字符串，就如同’Quote me on this’这样。所有的空白，即空格和制表符都照原样保留。<br><strong>使用双引号（”） </strong><br>在双引号中的字符串与单引号中的字符串的使用完全相同，例如”What’s your name?”。<br><strong>使用三引号（’’’或”””） </strong><br>利用三引号，你可以指示一个多行的字符串。你可以在三引号中自由的使用单引号和双引号。例如：<br>‘’’This is a multi-line string. This is the first line.<br>This is the second line.<br>“What’s your name?,” I asked.<br>He said “Bond, James Bond.”<br>‘’’<br><em>（注意：使用转义符来输出特殊字符。）</em></p></blockquote><p><strong>自然字符串与Unicode字符串：</strong><br>自然字符串：如果你想要指示某些不需要如转义符那样的特别处理的字符串，那么你需要指定一个自然字符串。自然字符串通过给字符串加上前缀r或R来指定。例如r”Newlines are indicated by \n”。<br>Unicode字符串：在你处理文本文件的时候使用Unicode字符串，特别是当你知道这个文件含有用非英语的语言写的文本。Python允许你处理Unicode文本——你只需要在字符串前加上前缀u或U。例如，u”This is a Unicode string.”。<br><em>（注：字符串是不可变的，这意味着一旦你创造了一个字符串，你就不能再改变它了。）</em><br><em>（注：相邻的字符串会被Python自动级连。）</em></p><h3 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h3><p>变量就是我们想要的东西——它们的值可以变化，即你可以使用变量存储任何东西。变量只是你的计算机中存储信息的一部分内存。<br><em>（注：使用变量时只需要给它们赋一个值。不需要声明或定义数据类型。）</em><br><strong>标示符命名：</strong><br>标识符 是用来标识 某样东西 的名字。在命名标识符的时候，你要遵循这些规则：</p><ul><li>标示符由字母(大写或小写)、下划线(‘_’)或数字(0-9)组成。</li><li>标示符的第一个字符必须是字母或者下划线。</li><li>标示符名称是对大小写敏感的。例如，myname和myName不是一个标识符。</li></ul><h3 id="4、逻辑行与物理行"><a href="#4、逻辑行与物理行" class="headerlink" title="4、逻辑行与物理行"></a>4、逻辑行与物理行</h3><p>（1）Python默认是每个物理行对应一个逻辑行。如果你想要在一个物理行中使用多于一个逻辑行，那么你需要使用分号（;）来特别地标明这种用法。分号表示一个逻辑行/语句的结束。<br>（2）如果多个物理行中写一个逻辑行，可以使用反斜杠（’\’）来连接，被称为明确的行连接。有一种暗示的假设，可以使你不需要使用反斜杠。这种情况出现在逻辑行中使用了圆括号、方括号或波形括号的时候。这被称为暗示的行连接。</p><h3 id="5、缩进"><a href="#5、缩进" class="headerlink" title="5、缩进"></a>5、缩进</h3><p>空白在Python中是重要的。事实上行首的空白是重要的。它称为缩进。在逻辑行首的空白（空格和制表符）用来决定逻辑行的缩进层次，从而用来决定语句的分组。<br>这意味着同一层次的语句必须有相同的缩进。每一组这样的语句称为一个块。<br><strong>如何缩进</strong><br>不要混合使用制表符和空格来缩进，因为这在跨越不同的平台的时候，无法正常工作。我 强烈建议 你在每个缩进层次使用 单个制表符 或 两个 或 四个空格 。<br>选择这三种缩进风格之一。更加重要的是，选择一种风格，然后一贯地使用它，即 只 使用这一种风格。 </p><h3 id="6、运算符与表达式"><a href="#6、运算符与表达式" class="headerlink" title="6、运算符与表达式"></a>6、运算符与表达式</h3><h4 id="（1）运算符与它们的用法"><a href="#（1）运算符与它们的用法" class="headerlink" title="（1）运算符与它们的用法"></a>（1）运算符与它们的用法</h4><style type="text/css">    table th:first-of-type {        width: 50px;    }    table th:nth-of-type(2) {        width: 50px;    }</style><table><thead><tr><th>运算符</th><th>名称</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>两个对象相加</td><td>3 + 5得到8。’a’ + ‘b’得到’ab’。 </td></tr><tr><td>-</td><td>减</td><td>得到负数或是一个数减去另一个数</td><td>-5.2得到一个负数。50 - 24得到26。 </td></tr><tr><td>*</td><td>乘</td><td>两个数相乘或是返回一个被重复若干次的字符串</td><td>2 <em> 3得到6。’la’ </em> 3得到’lalala’。 </td></tr><tr><td>**</td><td>幂</td><td>返回x的y次幂</td><td>3 <em>* 4得到81（即3 </em> 3 <em> 3 </em> 3） </td></tr><tr><td>/</td><td>除</td><td>x除以y</td><td>4/3得到1（整数的除法得到整数结果）。4.0/3或4/3.0得到1.3333333333333333 </td></tr><tr><td>//</td><td>取整除</td><td>返回商的整数部分</td><td>4 // 3.0得到1.0 </td></tr><tr><td>%</td><td>取模</td><td>返回除法的余数</td><td>8%3得到2。-25.5%2.25得到1.5 </td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>把一个数的比特向左移一定数目（每个数在内存中都表示为比特或二进制数字，即0和1）</td><td>2 &lt;&lt; 2得到8。——2按比特表示为10 </td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>把一个数的比特向右移一定数目</td><td>11 &gt;&gt; 1得到5。——11按比特表示为1011，向右移动1比特后得到101，即十进制的5。 </td></tr><tr><td>&amp;</td><td>按位与</td><td>数的按位与</td><td>5 &amp; 3得到1。 </td></tr><tr><td>&#124;</td><td>按位或</td><td>数的按位或</td><td>5 &#124; 3得到7。 </td></tr><tr><td>^</td><td>按位异或</td><td>数的按位异或</td><td>5 ^ 3得到6 </td></tr><tr><td>~</td><td>按位翻转</td><td>x的按位翻转是-(x+1)</td><td>~5得到6。 </td></tr><tr><td>&lt;</td><td>小于</td><td>返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td>5 &lt; 3返回0（即False）而3 &lt; 5返回1（即True）。比较可以被任意连接：3 &lt; 5 &lt; 7返回True。 </td></tr><tr><td>&gt;</td><td>大于</td><td>返回x是否大于y</td><td>5 &gt; 3返回True。如果两个操作数都是数字，它们首先被转换为一个共同的类型。否则，它总是返回False。 </td></tr><tr><td>&lt;=</td><td>小于等于</td><td>返回x是否小于等于y</td><td>x = 3; y = 6; x &lt;= y返回True。 </td></tr><tr><td>&gt;=</td><td>大于等于</td><td>返回x是否大于等于y</td><td>x = 4; y = 3; x &gt;= y返回True。 </td></tr><tr><td>==</td><td>等于</td><td>比较对象是否相等</td><td>x = 2; y = 2; x == y返回True。x = ‘str’; y = ‘stR’; x == y返回False。x = ‘str’; y = ‘str’; x == y返回True。 </td></tr><tr><td>!=</td><td>不等于</td><td>比较两个对象是否不相等</td><td>x = 2; y = 3; x != y返回True。 </td></tr><tr><td>not</td><td>布尔“非”</td><td>如果x为True，返回False。如果x为False，它返回True。</td><td>x = True; not y返回False。 </td></tr><tr><td>and</td><td>布尔“与”</td><td>如果x为False，x and y返回False，否则它返回y的计算值。</td><td>x = False; y = True; x and y，由于x是False，返回False。在这里，Python不会计算y，因为它知道这个表达式的值肯定是False（因为x是False）。这个现象称为短路计算。 </td></tr><tr><td>or</td><td>布尔“或”</td><td>如果x是True，它返回True，否则它返回y的计算值。</td><td>x = True; y = False; x or y返回True。短路计算在这里也适用。 </td></tr></tbody></table><h4 id="（2）下面这个表给出Python的运算符优先级，从最低的优先级（最松散地结合）到最高的优先级（最紧密地结合）。"><a href="#（2）下面这个表给出Python的运算符优先级，从最低的优先级（最松散地结合）到最高的优先级（最紧密地结合）。" class="headerlink" title="（2）下面这个表给出Python的运算符优先级，从最低的优先级（最松散地结合）到最高的优先级（最紧密地结合）。"></a>（2）下面这个表给出Python的运算符优先级，从最低的优先级（最松散地结合）到最高的优先级（最紧密地结合）。</h4><table><thead><tr><th>运算符</th><th>描述 </th></tr></thead><tbody><tr><td>lambda</td><td>Lambda表达式 </td></tr><tr><td>or</td><td>布尔“或” </td></tr><tr><td>and</td><td>布尔“与” </td></tr><tr><td>not x</td><td>布尔“非” </td></tr><tr><td>in，not in</td><td>成员测试 </td></tr><tr><td>is，is not</td><td>同一性测试 </td></tr><tr><td>&lt;，&lt;=，&gt;，&gt;=，!=，==</td><td>比较 </td></tr><tr><td>&#124;</td><td>按位或 </td></tr><tr><td>^</td><td>按位异或 </td></tr><tr><td>&amp;</td><td>按位与 </td></tr><tr><td>&lt;&lt;，&gt;&gt;</td><td>移位 </td></tr><tr><td>+，-</td><td>加法与减法 </td></tr><tr><td>*，/，%</td><td>乘法、除法与取余 </td></tr><tr><td>+x，-x</td><td>正负号 </td></tr><tr><td>~x</td><td>按位翻转 </td></tr><tr><td>**</td><td>指数 </td></tr><tr><td>x.attribute</td><td>属性参考 </td></tr><tr><td>x[index]</td><td>下标 </td></tr><tr><td>x[index:index]</td><td>寻址段 </td></tr><tr><td>f(arguments…)</td><td>函数调用 </td></tr><tr><td>(experession,…)</td><td>绑定或元组显示 </td></tr><tr><td>[expression,…]</td><td>列表显示 </td></tr><tr><td>{key:datum,…}</td><td>字典显示 </td></tr><tr><td>‘expression,…’</td><td>字符串转换 </td></tr></tbody></table><h4 id="（3）一个表达式可以分解为运算符和操作数。"><a href="#（3）一个表达式可以分解为运算符和操作数。" class="headerlink" title="（3）一个表达式可以分解为运算符和操作数。"></a>（3）一个表达式可以分解为运算符和操作数。</h4><p>运算符 的功能是完成某件事，它们由如+这样的符号或者其他特定的关键字表示。运算符需要数据来进行运算，这样的数据被称为 操作数 。</p><h3 id="7、控制流"><a href="#7、控制流" class="headerlink" title="7、控制流"></a>7、控制流</h3><p>Python中的控制语句与PHP中的控制语句大概意义上都是一致的，不过要注意Python中没有switch语句结构，而且for语句结构有一些区别，如果你想要写for (int i = 0; i &lt; 5; i++)，那么用Python，你写成for i in range(0,5)。还有一点要注意的是，依据Python语言的特性，每个控制语句的结尾处都要包含一个冒号————我们通过它告诉Python下面跟着一个语句块。</p><h4 id="（1）if-语句"><a href="#（1）if-语句" class="headerlink" title="（1）if 语句"></a>（1）if 语句</h4><p>if语句用来检验一个条件， 如果 条件为真，我们运行一块语句（称为 if-块 ）， 否则 我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。<br>（注：在Python中没有switch语句。你可以使用if..elif..else语句来完成同样的工作（在某些场合，使用字典会更加快捷。） ）</p><h4 id="（2）for-语句"><a href="#（2）for-语句" class="headerlink" title="（2）for 语句"></a>（2）for 语句</h4><p>for..in是另外一个循环语句，它在一序列的对象上 递归 即逐一使用队列中的每个项目。</p><h4 id="（3）while-语句"><a href="#（3）while-语句" class="headerlink" title="（3）while 语句"></a>（3）while 语句</h4><p>只要在一个条件为真的情况下，while语句允许你重复执行一块语句。while语句是所谓 循环 语句的一个例子。<strong>while语句有一个可选的else从句。</strong></p><h4 id="（4）break-语句"><a href="#（4）break-语句" class="headerlink" title="（4）break 语句"></a>（4）break 语句</h4><p>break语句是用来 终止 循环语句的，即哪怕循环条件没有称为False或序列还没有被完全递归，也停止执行循环语句。</p><font color="red">一个重要的注释是，如果你从for或while循环中 终止 ，任何对应的循环else块将不执行。</font><h4 id="（5）continue-语句"><a href="#（5）continue-语句" class="headerlink" title="（5）continue 语句"></a>（5）continue 语句</h4><p>continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后 继续 进行下一轮循环。</p><h3 id="8、函数"><a href="#8、函数" class="headerlink" title="8、函数"></a>8、函数</h3><h4 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>函数是重用的程序段。它们允许你给一块语句一个名称，然后你可以在你的程序的任何地方使用这个名称任意多次地运行这个语句块。这被称为 调用 函数。我们已经使用了许多内建的函数，比如len和range。</p><p>函数通过def关键字定义。def关键字后跟一个函数的 标识符 名称，然后跟一对圆括号。圆括号之中可以包括一些变量名，该行以冒号结尾。接下来是一块语句，它们是函数体。</p><p>下面这个例子（定义函数）将说明这事实上是十分简单的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: function1.py</span><br><span class="line"></span><br><span class="line">def sayHello():</span><br><span class="line">    print &apos;Hello World!&apos; # block belonging to the function</span><br><span class="line"></span><br><span class="line">sayHello() # call the function</span><br></pre></td></tr></table></figure></p><p>我们使用上面解释的语法定义了一个称为sayHello的函数。这个函数不使用任何参数，因此在圆括号中没有声明任何变量。参数对于函数而言，只是给函数的输入，以便于我们可以传递不同的值给函数，然后得到相应的结果。</p><h4 id="（2）函数的形参"><a href="#（2）函数的形参" class="headerlink" title="（2）函数的形参"></a>（2）函数的形参</h4><p>函数取得的参数是你提供给函数的值，这样函数就可以利用这些值 做 一些事情。这些参数就像变量一样，只不过它们的值是在我们调用函数的时候定义的，而非在函数本身内赋值。</p><p>参数在函数定义的圆括号对内指定，用逗号分割。当我们调用函数的时候，我们以同样的方式提供值。注意我们使用过的术语——函数中的参数名称为 形参 而你提供给函数调用的值称为 实参 。</p><h4 id="（3）变量作用域"><a href="#（3）变量作用域" class="headerlink" title="（3）变量作用域"></a>（3）变量作用域</h4><p><strong>局部变量：</strong><br>当你在函数定义内声明变量的时候，它们与函数外具有相同名称的其他变量没有任何关系，即变量名称对于函数来说是 局部 的。这称为变量的 作用域 。所有变量的作用域是它们被定义的块，从它们的名称被定义的那点开始。</p><p><strong>全局变量：</strong><br>如果你想要为一个定义在函数外的变量赋值，那么你就得告诉Python这个变量名不是局部的，而是 全局 的。我们使用global语句完成这一功能。没有global语句，是不可能为定义在函数外的变量赋值的。<br>你可以使用定义在函数外的变量的值（假设在函数内没有同名的变量）。然而，我并不鼓励你这样做，并且你应该尽量避免这样做，因为这使得程序的读者会不清楚这个变量是在哪里定义的。使用global语句可以清楚地表明变量是在外面的块定义的。</p><h4 id="（4）函数的参数类型"><a href="#（4）函数的参数类型" class="headerlink" title="（4）函数的参数类型"></a>（4）函数的参数类型</h4><p><strong>默认参数：</strong><br>对于一些函数，你可能希望它的一些参数是 可选 的，如果用户不想要为这些参数提供值的话，这些参数就使用默认值。这个功能借助于默认参数值完成。你可以在函数定义的形参名后加上赋值运算符（=）和默认值，从而给形参指定默认参数值。<br>（注意，默认参数值应该是一个参数。更加准确的说，默认参数值应该是不可变的。）<br>（<strong>重要</strong><br>只有在形参表末尾的那些参数可以有默认参数值，即你不能在声明函数形参的时候，先声明有默认值的形参而后声明没有默认值的形参。<br>这是因为赋给形参的值是根据位置而赋值的。例如，def func(a, b=5)是有效的，但是def func(a=5, b)是 无效 的。）</p><p><strong>关键参数：</strong><br>如果你的某个函数有许多参数，而你只想指定其中的一部分，那么你可以通过命名来为这些参数赋值——这被称作 关键参数 ——我们使用名字（关键字）而不是位置（我们前面所一直使用的方法）来给函数指定实参。</p><p>这样做有两个 优势 ——一，由于我们不必担心参数的顺序，使用函数变得更加简单了。二、假设其他参数都有默认值，我们可以只给我们想要的那些参数赋值。</p><h4 id="（5）return-语句"><a href="#（5）return-语句" class="headerlink" title="（5）return 语句"></a>（5）return 语句</h4><p>return语句用来从一个函数 返回 即跳出函数。我们也可选从函数 返回一个值 。<br>（注：pass语句在Python中表示一个空的语句块。）</p><h4 id="（6）DocStrings"><a href="#（6）DocStrings" class="headerlink" title="（6）DocStrings"></a>（6）DocStrings</h4><p>Python有一个很奇妙的特性，称为 文档字符串 ，它通常被简称为 docstrings 。DocStrings是一个重要的工具，由于它帮助你的程序文档更加简单易懂，你应该尽量使用它。你甚至可以在程序运行的时候，从函数恢复文档字符串！<br>例7.8 使用DocStrings<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: func_doc.py</span><br><span class="line"></span><br><span class="line">def printMax(x, y):</span><br><span class="line">    &apos;&apos;&apos;Prints the maximum of two numbers.</span><br><span class="line"></span><br><span class="line">    The two values must be integers.&apos;&apos;&apos;</span><br><span class="line">    x = int(x) # convert to integers, if possible</span><br><span class="line">    y = int(y)</span><br><span class="line"></span><br><span class="line">    if x &gt; y:</span><br><span class="line">        print x, &apos;is maximum&apos;</span><br><span class="line">    else:</span><br><span class="line">        print y, &apos;is maximum&apos;</span><br><span class="line"></span><br><span class="line">printMax(3, 5)</span><br><span class="line">print printMax.__doc__</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python func_doc.py</span><br><span class="line">5 is maximum</span><br><span class="line">Prints the maximum of two numbers.</span><br><span class="line"></span><br><span class="line">        The two values must be integers.</span><br></pre></td></tr></table></figure></p><p>在函数的第一个逻辑行的字符串是这个函数的 文档字符串 。注意，DocStrings也适用于模块和类。<br>文档字符串的惯例是一个多行字符串，它的首行以大写字母开始，句号结尾。第二行是空行，从第三行开始是详细的描述。 强烈建议 你在你的函数中使用文档字符串时遵循这个惯例。</p><p>你可以使用__doc__（注意双下划线）调用printMax函数的文档字符串属性（属于函数的名称）。请记住Python把 每一样东西 都作为对象，包括这个函数。</p><p>如果你已经在Python中使用过help()，那么你已经看到过DocStings的使用了！它所做的只是抓取函数的__doc__属性，然后整洁地展示给你。你可以对上面这个函数尝试一下——只是在你的程序中包括help(printMax)。记住按q退出help。</p><p>自动化工具也可以以同样的方式从你的程序中提取文档。因此，我 强烈建议 你对你所写的任何正式函数编写文档字符串。随你的Python发行版附带的pydoc命令，与help()类似地使用DocStrings。</p><h3 id="9、数据结构"><a href="#9、数据结构" class="headerlink" title="9、数据结构"></a>9、数据结构</h3><p>数据结构基本上就是——它们是可以处理一些 数据 的 结构 。或者说，它们是用来存储一组相关数据的。<br>在Python中有三种内建的数据结构——列表、元组和字典。</p><h4 id="（1）列表"><a href="#（1）列表" class="headerlink" title="（1）列表"></a>（1）列表</h4><p>list是处理一组有序项目的数据结构，即你可以在一个列表中存储一个 序列 的项目（列表也是一个序列）。假想你有一个购物列表，上面记载着你要买的东西，你就容易理解列表了。只不过在你的购物表上，可能每样东西都独自占有一行，而在Python中，你在每个项目之间用逗号分割。</p><p>列表中的项目应该包括在方括号中，这样Python就知道你是在指明一个列表。一旦你创建了一个列表，你可以添加、删除或是搜索列表中的项目。由于你可以增加或删除项目，我们说列表是 <strong>可变的 数据类型，即这种类型是可以被改变的。</strong><br><em>（注：我们使用列表的sort方法来对列表排序。需要理解的是，这个方法影响列表本身，而不是返回一个修改后的列表——这与字符串工作的方法不同。这就是我们所说的<strong>列表是 可变的</strong> 而<strong>字符串是 不可变的</strong>。）</em></p><h4 id="（2）元组"><a href="#（2）元组" class="headerlink" title="（2）元组"></a>（2）元组</h4><p>元组和列表十分类似，只不过元组和字符串一样是 不可变的 即你不能修改元组。元组通过圆括号中用逗号分割的项目定义。元组通常用在使语句或用户定义的函数能够安全地采用一组值的时候，即被使用的元组的值不会改变。<br><em>（注：变量zoo是一个元组，我们看到len函数可以用来获取元组的长度。这也表明<strong>元组也是一个序列</strong>。）</em></p><p><strong>含有0个或1个项目的元组。</strong>一个空的元组由一对空的圆括号组成，如myempty = ()。然而，含有单个元素的元组就不那么简单了。你必须在第一个（唯一一个）项目后跟一个逗号，这样Python才能区分元组和表达式中一个带圆括号的对象。即如果你想要的是一个包含项目2的元组的时候，你应该指明singleton = (2 , )。<br><strong>注：元组最通常的用法是用在打印语句中，例如：print ‘%s is %d years old’ % (name, age) </strong></p><h4 id="（3）序列"><a href="#（3）序列" class="headerlink" title="（3）序列"></a>（3）序列</h4><p>列表、元组和字符串都是序列，但是序列是什么，它们为什么如此特别呢？序列的两个主要特点是索引操作符和切片操作符。索引操作符让我们可以从序列中抓取一个特定项目。切片操作符让我们能够获取序列的一个切片，即一部分序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">例9.5 使用序列</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: seq.py</span><br><span class="line"></span><br><span class="line">shoplist = [&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]</span><br><span class="line"></span><br><span class="line"># Indexing or &apos;Subscription&apos; operation</span><br><span class="line">print &apos;Item 0 is&apos;, shoplist[0]</span><br><span class="line">print &apos;Item 1 is&apos;, shoplist[1]</span><br><span class="line">print &apos;Item 2 is&apos;, shoplist[2]</span><br><span class="line">print &apos;Item 3 is&apos;, shoplist[3]</span><br><span class="line">print &apos;Item -1 is&apos;, shoplist[-1]</span><br><span class="line">print &apos;Item -2 is&apos;, shoplist[-2]</span><br><span class="line"></span><br><span class="line"># Slicing on a list</span><br><span class="line">print &apos;Item 1 to 3 is&apos;, shoplist[1:3]</span><br><span class="line">print &apos;Item 2 to end is&apos;, shoplist[2:]</span><br><span class="line">print &apos;Item 1 to -1 is&apos;, shoplist[1:-1]</span><br><span class="line">print &apos;Item start to end is&apos;, shoplist[:]</span><br><span class="line"></span><br><span class="line"># Slicing on a string</span><br><span class="line">name = &apos;swaroop&apos;</span><br><span class="line">print &apos;characters 1 to 3 is&apos;, name[1:3]</span><br><span class="line">print &apos;characters 2 to end is&apos;, name[2:]</span><br><span class="line">print &apos;characters 1 to -1 is&apos;, name[1:-1]</span><br><span class="line">print &apos;characters start to end is&apos;, name[:]</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ python seq.py</span><br><span class="line">Item 0 is apple</span><br><span class="line">Item 1 is mango</span><br><span class="line">Item 2 is carrot</span><br><span class="line">Item 3 is banana</span><br><span class="line">Item -1 is banana</span><br><span class="line">Item -2 is carrot</span><br><span class="line">Item 1 to 3 is [&apos;mango&apos;, &apos;carrot&apos;]</span><br><span class="line">Item 2 to end is [&apos;carrot&apos;, &apos;banana&apos;]</span><br><span class="line">Item 1 to -1 is [&apos;mango&apos;, &apos;carrot&apos;]</span><br><span class="line">Item start to end is [&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]</span><br><span class="line">characters 1 to 3 is wa</span><br><span class="line">characters 2 to end is aroop</span><br><span class="line">characters 1 to -1 is waroo</span><br><span class="line">characters start to end is swaroop</span><br></pre></td></tr></table></figure></p><p>首先，我们来学习如何使用索引来取得序列中的单个项目。这也被称作是下标操作。每当你用方括号中的一个数来指定一个序列的时候，Python会为你抓取序列中对应位置的项目。记住，Python从0开始计数。因此，shoplist[0]抓取第一个项目，shoplist[3]抓取shoplist序列中的第四个元素。</p><p>索引同样可以是负数，在那样的情况下，位置是从序列尾开始计算的。因此，shoplist[-1]表示序列的最后一个元素而shoplist[-2]抓取序列的倒数第二个项目。</p><p>切片操作符是序列名后跟一个方括号，方括号中有一对可选的数字，并用冒号分割。注意这与你使用的索引操作符十分相似。记住数是可选的，而冒号是必须的。</p><p>切片操作符中的第一个数（冒号之前）表示切片开始的位置，第二个数（冒号之后）表示切片到哪里结束。如果不指定第一个数，Python就从序列首开始。如果没有指定第二个数，则Python会停止在序列尾。注意，返回的序列从开始位置 开始 ，刚好在 结束 位置之前结束。即开始位置是包含在序列切片中的，而结束位置被排斥在切片外。</p><p>这样，shoplist[1:3]返回从位置1开始，包括位置2，但是停止在位置3的一个序列切片，因此返回一个含有两个项目的切片。类似地，shoplist[:]返回整个序列的拷贝。</p><p>你可以用负数做切片。负数用在从序列尾开始计算的位置。例如，shoplist[:-1]会返回除了最后一个项目外包含所有项目的序列切片。</p><p>使用Python解释器交互地尝试不同切片指定组合，即在提示符下你能够马上看到结果。序列的神奇之处在于你可以用相同的方法访问元组、列表和字符串。</p><h4 id="（4）字典"><a href="#（4）字典" class="headerlink" title="（4）字典"></a>（4）字典</h4><p>字典类似于你通过联系人名字查找地址和联系人详细情况的地址簿，即，我们把<strong>键</strong>（名字）和<strong>值</strong>（详细情况）联系在一起。注意，键必须是唯一的，就像如果有两个人恰巧同名的话，你无法找到正确的信息。</p><p>注意，你只能使用不可变的对象（比如字符串）来作为字典的键，但是你可以不可变或可变的对象作为字典的值。基本说来就是，你应该只使用简单的对象作为键。</p><p>键值对在字典中以这样的方式标记：d = {key1 : value1, key2 : value2 }。注意它们的键/值对用冒号分割，而各个对用逗号分割，所有这些都包括在花括号中。</p><p>记住字典中的键/值对是没有顺序的。如果你想要一个特定的顺序，那么你应该在使用前自己对它们排序。</p><p>字典是dict类的实例/对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">例9.4 使用字典</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename: using_dict.py</span><br><span class="line"></span><br><span class="line"># &apos;ab&apos; is short for &apos;a&apos;ddress&apos;b&apos;ook</span><br><span class="line"></span><br><span class="line">ab = &#123;       &apos;Swaroop&apos;   : &apos;swaroopch@byteofpython.info&apos;,</span><br><span class="line">             &apos;Larry&apos;     : &apos;larry@wall.org&apos;,</span><br><span class="line">             &apos;Matsumoto&apos; : &apos;matz@ruby-lang.org&apos;,</span><br><span class="line">             &apos;Spammer&apos;   : &apos;spammer@hotmail.com&apos;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">print &quot;Swaroop&apos;s address is %s&quot; % ab[&apos;Swaroop&apos;]</span><br><span class="line"></span><br><span class="line"># Adding a key/value pair</span><br><span class="line">ab[&apos;Guido&apos;] = &apos;guido@python.org&apos;</span><br><span class="line"></span><br><span class="line"># Deleting a key/value pair</span><br><span class="line">del ab[&apos;Spammer&apos;]</span><br><span class="line"></span><br><span class="line">print &apos;\nThere are %d contacts in the address-book\n&apos; % len(ab)</span><br><span class="line">for name, address in ab.items():</span><br><span class="line">    print &apos;Contact %s at %s&apos; % (name, address)</span><br><span class="line"></span><br><span class="line">if &apos;Guido&apos; in ab: # OR ab.has_key(&apos;Guido&apos;)</span><br><span class="line">    print &quot;\nGuido&apos;s address is %s&quot; % ab[&apos;Guido&apos;]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python using_dict.py</span><br><span class="line">Swaroop&apos;s address is swaroopch@byteofpython.info</span><br><span class="line"></span><br><span class="line">There are 4 contacts in the address-book</span><br><span class="line"></span><br><span class="line">Contact Swaroop at swaroopch@byteofpython.info</span><br><span class="line">Contact Matsumoto at matz@ruby-lang.org</span><br><span class="line">Contact Larry at larry@wall.org</span><br><span class="line">Contact Guido at guido@python.org</span><br><span class="line"></span><br><span class="line">Guido&apos;s address is guido@python.org</span><br></pre></td></tr></table></figure></p><p>我们使用已经介绍过的标记创建了字典ab。然后我们使用在列表和元组章节中已经讨论过的索引操作符来指定键，从而使用键/值对。我们可以看到字典的语法同样十分简单。</p><p>我们可以使用索引操作符来寻址一个键并为它赋值，这样就增加了一个新的键/值对，就像在上面的例子中我们对Guido所做的一样。</p><p>我们可以使用我们的老朋友——del语句来删除键/值对。我们只需要指明字典和用索引操作符指明要删除的键，然后把它们传递给del语句就可以了。执行这个操作的时候，我们无需知道那个键所对应的值。</p><p>接下来，我们使用字典的items方法，来使用字典中的每个键/值对。这会返回一个元组的列表，其中每个元组都包含一对项目——键与对应的值。我们抓取这个对，然后分别赋给for..in循环中的变量name和address然后在for－块中打印这些值。</p><p>我们可以使用in操作符来检验一个键/值对是否存在，或者使用dict类的has_key方法。你可以使用help(dict)来查看dict类的完整方法列表。</p><p><strong>关键字参数与字典。</strong>如果换一个角度看待你在函数中使用的关键字参数的话，你已经使用了字典了！只需想一下——你在函数定义的参数列表中使用的键/值对。当你在函数中使用变量的时候，它只不过是使用一个字典的键（这在编译器设计的术语中被称作 符号表 ）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、Python概述&quot;&gt;&lt;a href=&quot;#1、Python概述&quot; class=&quot;headerlink&quot; title=&quot;1、Python概述&quot;&gt;&lt;/a&gt;1、Python概述&lt;/h3&gt;&lt;p&gt;Python语言是少有的一种可以称得上即简单又功能强大的编程语言。你将惊喜地发现Python语言是多么地简单，它注重的是如何解决问题而不是编程语言的语法和结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python的官方介绍是：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python是一种简单易学，功能强大的编程语言，它有高效率的高层数据结构，简单而有效地实现面向对象编程。Python简洁的语法和对动态输入的支持，再加上解释性语言的本质，使得它在大多数平台上的许多领域都是一个理想的脚本语言，特别适用于快速的应用程序开发。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python知识点" scheme="http://yoursite.com/tags/Python%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP预定义变量梳理（PHP手册版）</title>
    <link href="http://yoursite.com/2018/01/31/PHP%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E6%A2%B3%E7%90%86%EF%BC%88PHP%E6%89%8B%E5%86%8C%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/31/PHP预定义变量梳理（PHP手册版）/</id>
    <published>2018-01-31T09:46:04.000Z</published>
    <updated>2018-02-01T08:38:42.422Z</updated>
    
    <content type="html"><![CDATA[<p><strong>预定义变量</strong><br>超全局数组：$GLOBALS<br>服务器和执行环境信息：$_SERVER （详解）<br>URL参数获取变量数组：$_GET<br>表单参数获取变量数组：$_POST<br>上传数据获取：$_FILES<br>$_REQUEST（包含$_GET、$_POST和$_COOKIE）<br>SESSION变量的数组：$_SESSION<br>环境变量数组：$_ENV<br>COOKIE变量的数组：$_COOKIE<br><a id="more"></a><br><strong>下面只对$_SERVER这个变量进行详细说明其参数及其意义：</strong><br>$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。<br><strong>Note:</strong>  PHP 5.4.0 之前，$HTTP_SERVER_VARS 包含着相同的信息，但它不是一个超全局变量。 (注意 $HTTP_SERVER_VARS 与 $_SERVER 是不同的变量，PHP处理它们的方式不同) </p><p>在 $_SERVER 中，你也许能够，也许不能够找到下面的这些元素。注意，如果以命令行方式运行 PHP，下面列出的元素几乎没有有效的(或是没有任何实际意义的)。 </p><h5 id="‘PHP-SELF’"><a href="#‘PHP-SELF’" class="headerlink" title="‘PHP_SELF’"></a>‘PHP_SELF’</h5><p>当前执行脚本的文件名，与 document root 有关。例如，在地址为 <a href="http://example.com/foo/bar.php" target="_blank" rel="noopener">http://example.com/foo/bar.php</a> 的脚本中使用 $_SERVER[‘PHP_SELF’] 将得到 /foo/bar.php。<strong>FILE</strong> 常量包含当前(例如包含)文件的完整路径和文件名。   从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。</p><h5 id="‘argv’"><a href="#‘argv’" class="headerlink" title="‘argv’"></a>‘argv’</h5><p>传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。</p><h5 id="‘argc’"><a href="#‘argc’" class="headerlink" title="‘argc’"></a>‘argc’</h5><p>包含命令行模式下传递给该脚本的参数的数目(如果运行在命令行模式下)。</p><h5 id="‘GATEWAY-INTERFACE’"><a href="#‘GATEWAY-INTERFACE’" class="headerlink" title="‘GATEWAY_INTERFACE’"></a>‘GATEWAY_INTERFACE’</h5><p>服务器使用的 CGI 规范的版本；例如，”CGI/1.1”。</p><h5 id="‘SERVER-ADDR’"><a href="#‘SERVER-ADDR’" class="headerlink" title="‘SERVER_ADDR’"></a>‘SERVER_ADDR’</h5><p>当前运行脚本所在的服务器的 IP 地址。</p><h5 id="‘SERVER-NAME’"><a href="#‘SERVER-NAME’" class="headerlink" title="‘SERVER_NAME’"></a>‘SERVER_NAME’</h5><p>当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。<br>　　<strong>Note:</strong> 在 Apache 2 里，必须设置 UseCanonicalName = On 和 ServerName。 否则该值会由客户端提供，就有可能被伪造。 上下文有安全性要求的环境里，不应该依赖此值。</p><h5 id="‘SERVER-SOFTWARE’"><a href="#‘SERVER-SOFTWARE’" class="headerlink" title="‘SERVER_SOFTWARE’"></a>‘SERVER_SOFTWARE’</h5><p>服务器标识字符串，在响应请求时的头信息中给出。  ‘SERVER_PROTOCOL’请求页面时通信协议的名称和版本。例如，”HTTP/1.0”。</p><h5 id="‘REQUEST-METHOD’"><a href="#‘REQUEST-METHOD’" class="headerlink" title="‘REQUEST_METHOD’"></a>‘REQUEST_METHOD’</h5><p>访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”。<br>　　<strong>Note:</strong> 如果请求方法为 HEAD，PHP 脚本将在发送 Header 头信息之后终止(这意味着在产生任何输出后，不再有输出缓冲)。</p><h5 id="‘REQUEST-TIME’"><a href="#‘REQUEST-TIME’" class="headerlink" title="‘REQUEST_TIME’"></a>‘REQUEST_TIME’</h5><p>请求开始时的时间戳。从 PHP 5.1.0 起可用。</p><h5 id="‘REQUEST-TIME-FLOAT’"><a href="#‘REQUEST-TIME-FLOAT’" class="headerlink" title="‘REQUEST_TIME_FLOAT’"></a>‘REQUEST_TIME_FLOAT’</h5><p>请求开始时的时间戳，微秒级别的精准度。 自 PHP 5.4.0 开始生效。</p><h5 id="‘QUERY-STRING’"><a href="#‘QUERY-STRING’" class="headerlink" title="‘QUERY_STRING’"></a>‘QUERY_STRING’</h5><p>query string（查询字符串），如果有的话，通过它进行页面访问。</p><h5 id="‘DOCUMENT-ROOT’"><a href="#‘DOCUMENT-ROOT’" class="headerlink" title="‘DOCUMENT_ROOT’"></a>‘DOCUMENT_ROOT’</h5><p>当前运行脚本所在的文档根目录。在服务器配置文件中定义。</p><h5 id="‘HTTP-ACCEPT’"><a href="#‘HTTP-ACCEPT’" class="headerlink" title="‘HTTP_ACCEPT’"></a>‘HTTP_ACCEPT’</h5><p>当前请求头中 Accept: 项的内容，如果存在的话。</p><h5 id="‘HTTP-ACCEPT-CHARSET’"><a href="#‘HTTP-ACCEPT-CHARSET’" class="headerlink" title="‘HTTP_ACCEPT_CHARSET’"></a>‘HTTP_ACCEPT_CHARSET’</h5><p>当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。</p><h5 id="‘HTTP-ACCEPT-ENCODING’"><a href="#‘HTTP-ACCEPT-ENCODING’" class="headerlink" title="‘HTTP_ACCEPT_ENCODING’"></a>‘HTTP_ACCEPT_ENCODING’</h5><p>当前请求头中 Accept-Encoding: 项的内容，如果存在的话。例如：”gzip”。</p><h5 id="‘HTTP-ACCEPT-LANGUAGE’"><a href="#‘HTTP-ACCEPT-LANGUAGE’" class="headerlink" title="‘HTTP_ACCEPT_LANGUAGE’"></a>‘HTTP_ACCEPT_LANGUAGE’</h5><p>当前请求头中 Accept-Language: 项的内容，如果存在的话。例如：”en”。</p><h5 id="‘HTTP-CONNECTION’"><a href="#‘HTTP-CONNECTION’" class="headerlink" title="‘HTTP_CONNECTION’"></a>‘HTTP_CONNECTION’</h5><p>当前请求头中 Connection: 项的内容，如果存在的话。例如：”Keep-Alive”。</p><h5 id="‘HTTP-HOST’"><a href="#‘HTTP-HOST’" class="headerlink" title="‘HTTP_HOST’"></a>‘HTTP_HOST’</h5><p>当前请求头中 Host: 项的内容，如果存在的话。</p><h5 id="‘HTTP-REFERER’"><a href="#‘HTTP-REFERER’" class="headerlink" title="‘HTTP_REFERER’"></a>‘HTTP_REFERER’</h5><p>引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。</p><h5 id="‘HTTP-USER-AGENT’"><a href="#‘HTTP-USER-AGENT’" class="headerlink" title="‘HTTP_USER_AGENT’"></a>‘HTTP_USER_AGENT’</h5><p>当前请求头中 User-Agent: 项的内容，如果存在的话。该字符串表明了访问该页面的用户代理的信息。一个典型的例子是：Mozilla/4.5 [en] (X11; U; Linux 2.2.9 i586)。除此之外，你可以通过 get_browser() 来使用该值，从而定制页面输出以便适应用户代理的性能。  ‘HTTPS’如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。<br>　　<strong>Note:</strong> 注意当使用 IIS 上的 ISAPI 方式时，如果不是通过 HTTPS 协议被访问，这个值将为 off。</p><h5 id="‘REMOTE-ADDR’"><a href="#‘REMOTE-ADDR’" class="headerlink" title="‘REMOTE_ADDR’"></a>‘REMOTE_ADDR’</h5><p>浏览当前页面的用户的 IP 地址。</p><h5 id="‘REMOTE-HOST’"><a href="#‘REMOTE-HOST’" class="headerlink" title="‘REMOTE_HOST’"></a>‘REMOTE_HOST’</h5><p>浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。<br>　　<strong>Note:</strong> 你的服务器必须被配置以便产生这个变量。例如在 Apache 中，你需要在 httpd.conf 中设置 HostnameLookups On 来产生它。参见 gethostbyaddr()。</p><h5 id="‘REMOTE-PORT’"><a href="#‘REMOTE-PORT’" class="headerlink" title="‘REMOTE_PORT’"></a>‘REMOTE_PORT’</h5><p>用户机器上连接到 Web 服务器所使用的端口号。</p><h5 id="‘REMOTE-USER’"><a href="#‘REMOTE-USER’" class="headerlink" title="‘REMOTE_USER’"></a>‘REMOTE_USER’</h5><p>经验证的用户</p><h5 id="‘REDIRECT-REMOTE-USER’"><a href="#‘REDIRECT-REMOTE-USER’" class="headerlink" title="‘REDIRECT_REMOTE_USER’"></a>‘REDIRECT_REMOTE_USER’</h5><p>验证的用户，如果请求已在内部重定向。</p><h5 id="‘SCRIPT-FILENAME’"><a href="#‘SCRIPT-FILENAME’" class="headerlink" title="‘SCRIPT_FILENAME’"></a>‘SCRIPT_FILENAME’</h5><p>当前执行脚本的绝对路径。<br>　　<strong>Note:</strong> 如果在命令行界面（Command Line Interface, CLI）使用相对路径执行脚本，例如 file.php 或 ../file.php，那么 $_SERVER[‘SCRIPT_FILENAME’] 将包含用户指定的相对路径。</p><h5 id="‘SERVER-ADMIN’"><a href="#‘SERVER-ADMIN’" class="headerlink" title="‘SERVER_ADMIN’"></a>‘SERVER_ADMIN’</h5><p>该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。</p><h5 id="‘SERVER-PORT’"><a href="#‘SERVER-PORT’" class="headerlink" title="‘SERVER_PORT’"></a>‘SERVER_PORT’</h5><p>Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。<br>　　<strong>Note:</strong> 在 Apache 2 里，为了获取真实物理端口，必须设置 UseCanonicalName = On 以及 UseCanonicalPhysicalPort = On。 否则此值可能被伪造，不一定会返回真实端口值。 上下文有安全性要求的环境里，不应该依赖此值。</p><h5 id="‘SERVER-SIGNATURE’"><a href="#‘SERVER-SIGNATURE’" class="headerlink" title="‘SERVER_SIGNATURE’"></a>‘SERVER_SIGNATURE’</h5><p>包含了服务器版本和虚拟主机名的字符串。</p><h5 id="‘PATH-TRANSLATED’"><a href="#‘PATH-TRANSLATED’" class="headerlink" title="‘PATH_TRANSLATED’"></a>‘PATH_TRANSLATED’</h5><p>当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。<br>　　<strong>Note:</strong> 自 PHP 4.3.2 起，PATH_TRANSLATED 在 Apache 2 SAPI 模式下不再和 Apache 1 一样隐含赋值，而是若 Apache 不生成此值，PHP 便自己生成并将其值放入 SCRIPT_FILENAME 服务器常量中。这个修改遵守了 CGI 规范，PATH_TRANSLATED 仅在 PATH_INFO 被定义的条件下才存在。  Apache 2 用户可以在 httpd.conf 中设置 AcceptPathInfo = On 来定义 PATH_INFO。</p><h5 id="‘SCRIPT-NAME’"><a href="#‘SCRIPT-NAME’" class="headerlink" title="‘SCRIPT_NAME’"></a>‘SCRIPT_NAME’</h5><p>包含当前脚本的路径。这在页面需要指向自己时非常有用。<strong>FILE</strong> 常量包含当前脚本(例如包含文件)的完整路径和文件名。</p><h5 id="‘REQUEST-URI’"><a href="#‘REQUEST-URI’" class="headerlink" title="‘REQUEST_URI’"></a>‘REQUEST_URI’</h5><p>URI 用来指定要访问的页面。例如 “/index.html”。</p><h5 id="‘PHP-AUTH-DIGEST’"><a href="#‘PHP-AUTH-DIGEST’" class="headerlink" title="‘PHP_AUTH_DIGEST’"></a>‘PHP_AUTH_DIGEST’</h5><p>当作为 Apache 模块运行时，进行 HTTP Digest 认证的过程中，此变量被设置成客户端发送的”Authorization” HTTP 头内容（以便作进一步的认证操作）。</p><h5 id="‘PHP-AUTH-USER’"><a href="#‘PHP-AUTH-USER’" class="headerlink" title="‘PHP_AUTH_USER’"></a>‘PHP_AUTH_USER’</h5><p>当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名。</p><h5 id="‘PHP-AUTH-PW’"><a href="#‘PHP-AUTH-PW’" class="headerlink" title="‘PHP_AUTH_PW’"></a>‘PHP_AUTH_PW’</h5><p>当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码。</p><h5 id="‘AUTH-TYPE’"><a href="#‘AUTH-TYPE’" class="headerlink" title="‘AUTH_TYPE’"></a>‘AUTH_TYPE’</h5><p>当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型。</p><h5 id="‘PATH-INFO’"><a href="#‘PATH-INFO’" class="headerlink" title="‘PATH_INFO’"></a>‘PATH_INFO’</h5><p>包含由客户端提供的、跟在真实脚本名称之后并且在查询语句（query string）之前的路径信息，如果存在的话。例如，如果当前脚本是通过 URL <a href="http://www.example.com/php/path_info.php/some/stuff?foo=bar" target="_blank" rel="noopener">http://www.example.com/php/path_info.php/some/stuff?foo=bar</a> 被访问，那么 $_SERVER[‘PATH_INFO’] 将包含 /some/stuff。</p><h5 id="‘ORIG-PATH-INFO’"><a href="#‘ORIG-PATH-INFO’" class="headerlink" title="‘ORIG_PATH_INFO’"></a>‘ORIG_PATH_INFO’</h5><p>在被 PHP 处理之前，”PATH_INFO” 的原始版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;预定义变量&lt;/strong&gt;&lt;br&gt;超全局数组：$GLOBALS&lt;br&gt;服务器和执行环境信息：$_SERVER （详解）&lt;br&gt;URL参数获取变量数组：$_GET&lt;br&gt;表单参数获取变量数组：$_POST&lt;br&gt;上传数据获取：$_FILES&lt;br&gt;$_REQUEST（包含$_GET、$_POST和$_COOKIE）&lt;br&gt;SESSION变量的数组：$_SESSION&lt;br&gt;环境变量数组：$_ENV&lt;br&gt;COOKIE变量的数组：$_COOKIE&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP高级整理（PHP手册版）</title>
    <link href="http://yoursite.com/2018/01/31/PHP%E9%AB%98%E7%BA%A7%E6%95%B4%E7%90%86%EF%BC%88PHP%E6%89%8B%E5%86%8C%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/31/PHP高级整理（PHP手册版）/</id>
    <published>2018-01-31T09:45:52.000Z</published>
    <updated>2018-02-01T03:54:22.488Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>（1）用户自定义函数：</p><p>（2）函数的参数：<br>值传递（默认情况）<br>引用传递：在该参数前面加上符号 &amp;</p><p>（3）类型声明<br>在PHP 5中，类型声明也被称为类型提示。<br>类型声明允许函数在调用时要求参数为特定类型。 如果给出的值类型不对，那么将会产生一个错误： 在PHP 5中，这将是一个可恢复的致命错误，而在PHP 7中将会抛出一个TypeError异常。<br><a id="more"></a><br>（4）返回值：return</p><p>（5）匿名函数<br>匿名函数（Anonymous functions），也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。 </p><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><h5 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h5><p>每个类的定义都以关键字 class 开头，后面跟着类名，后面跟着一对花括号，里面包含有类的属性与方法的定义。<br>一个类可以包含有属于自己的常量，变量（称为”属性”）以及函数（称为”方法”）。<br>当一个方法在类定义内部被调用时，有一个可用的伪变量 $this。$this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象静态调用时也可能是另一个对象）。</p><p><strong>new</strong><br>要创建一个类的实例，必须使用 new 关键字。当创建新对象时该对象总是被赋值，除非该对象定义了构造函数并且在出错时抛出了一个异常。类应在被实例化之前定义（某些情况下则必须这样）。<br>如果在 new 之后跟着的是一个包含有类名的字符串，则该类的一个实例被创建。如果该类属于一个名字空间，则必须使用其完整名称。</p><p>在类定义内部，可以用 new self 和 new parent 创建新对象。<br>当把一个对象已经创建的实例赋给一个新变量时，新变量会访问同一个实例，就和用该对象赋值一样。此行为和给函数传递入实例时一样。可以用克隆给一个已创建的对象建立一个新实例。</p><p><strong>extends</strong><br>一个类可以在声明中用 extends 关键字继承另一个类的方法和属性。PHP不支持多重继承，一个类只能继承一个基类。<br>被继承的方法和属性可以通过用同样的名字重新声明被覆盖。但是如果父类定义方法时使用了 final，则该方法不可被覆盖。可以通过 parent:: 来访问被覆盖的方法或属性。<br>当覆盖方法时，参数必须保持一致否则 PHP 将发出 E_STRICT 级别的错误信息。但构造函数例外，构造函数可在被覆盖时使用不同的参数。</p><p><strong>匿名类</strong><br>PHP 7 开始支持匿名类。 匿名类很有用，可以创建一次性的简单对象。 </p><h5 id="（2）属性"><a href="#（2）属性" class="headerlink" title="（2）属性"></a>（2）属性</h5><p>类的变量成员叫做”属性”，或者叫”字段”、”特征”，在本文档统一称为”属性”。属性声明是由关键字 public，protected 或者 private 开头，然后跟一个普通的变量声明来组成。属性中的变量可以初始化，但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。</p><p>在类的成员方法里面，可以用 -&gt;（对象运算符）：$this-&gt;property（其中 property 是该属性名）这种方式来访问非静态属性。静态属性则是用 ::（双冒号）：self::$property 来访问。</p><p><strong>类常量：</strong><br>可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。<br>常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。<br>接口（interface）中也可以定义常量。</p><h5 id="（3）构造函数与析构函数"><a href="#（3）构造函数与析构函数" class="headerlink" title="（3）构造函数与析构函数"></a>（3）构造函数与析构函数</h5><p>PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 </p><p><strong>Note: </strong>如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。</p><p>PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p><p>和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 parent::__destruct()。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。<br>析构函数即使在使用 exit() 终c止脚本运行时也会被调用。在析构函数中调用 exit() 将会中止其余关闭操作的运行。 </p><h5 id="（4）访问控制符"><a href="#（4）访问控制符" class="headerlink" title="（4）访问控制符"></a>（4）访问控制符</h5><p>对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。<br><strong>final关键字：</strong><br>PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。</p><p><em>（注：类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有。类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。 ）</em></p><h5 id="（5）对象继承"><a href="#（5）对象继承" class="headerlink" title="（5）对象继承"></a>（5）对象继承</h5><p>继承已为大家所熟知的一个程序设计特性，PHP 的对象模型也使用了继承。继承将会影响到类与类，对象与对象之间的关系。<br>比如，当扩展一个类，子类就会继承父类所有公有的和受保护的方法。除非子类覆盖了父类的方法，被继承的方法都会保留其原有功能。<br>继承对于功能的设计和抽象是非常有用的，而且对于类似的对象增加新功能就无须重新再写这些公用的功能。</p><h5 id="（6）静态关键字-static"><a href="#（6）静态关键字-static" class="headerlink" title="（6）静态关键字 static"></a>（6）静态关键字 static</h5><p>声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。<br><em>（注：由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。）</em><br><strong>注意事项：</strong></p><ul><li>静态属性不可以由对象通过 -&gt; 操作符来访问。 </li><li>用静态方式调用一个非静态方法会导致一个 E_STRICT 级别的错误。 </li><li>就像其它所有的 PHP 静态变量一样，静态属性只能被初始化为文字或常量，不能使用表达式。所以可以把静态属性初始化为整数或数组，但不能初始化为另一个变量或函数返回值，也不能指向一个对象。 </li></ul><h5 id="（7）抽象类"><a href="#（7）抽象类" class="headerlink" title="（7）抽象类"></a>（7）抽象类</h5><p>PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。 </p><p>继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。 </p><h5 id="（8）对象接口"><a href="#（8）对象接口" class="headerlink" title="（8）对象接口"></a>（8）对象接口</h5><p>使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。<br>接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。<br>接口中定义的所有方法都必须是公有，这是接口的特性。 </p><p><strong>实现（implements）</strong><br>要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。 </p><p><strong>Note: </strong><br>实现多个接口时，接口中的方法不能有重名。<br><strong>Note: </strong><br>接口也可以继承，通过使用 extends 操作符。<br><strong>Note: </strong><br>类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。 </p><p><strong>常量</strong><br>接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所覆盖。</p><h5 id="（9）魔术方法"><a href="#（9）魔术方法" class="headerlink" title="（9）魔术方法"></a>（9）魔术方法</h5><p>__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()， __invoke()， __set<em>state()， \</em>_clone() 和 __debugInfo() 等方法在 PHP 中被称为”魔术方法”（Magic methods）。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。 </p><h4 id="10、命名空间"><a href="#10、命名空间" class="headerlink" title="10、命名空间"></a>10、命名空间</h4><h5 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h5><p>什么是命名空间？从广义上来说，命名空间是一种封装事物的方法。在很多地方都可以见到这种抽象概念。例如，在操作系统中目录用来将相关文件分组，对于目录中的文件来说，它就扮演了命名空间的角色。具体举个例子，文件 foo.txt 可以同时在目录/home/greg 和 /home/other 中存在，但在同一个目录中不能存在两个 foo.txt 文件。另外，在目录 /home/greg 外访问 foo.txt 文件时，我们必须将目录名以及目录分隔符放在文件名之前得到 /home/greg/foo.txt。这个原理应用到程序设计领域就是命名空间的概念。 </p><p>在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题： </p><ol><li>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。  </li><li>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</li></ol><h5 id="（2）定义命名空间-PHP-5-gt-5-3-0-PHP-7"><a href="#（2）定义命名空间-PHP-5-gt-5-3-0-PHP-7" class="headerlink" title="（2）定义命名空间(PHP 5 &gt;= 5.3.0, PHP 7)"></a>（2）定义命名空间(PHP 5 &gt;= 5.3.0, PHP 7)</h5><p>虽然任意合法的PHP代码都可以包含在命名空间中，但只有以下类型的代码受命名空间的影响，它们是：类（包括抽象类和traits）、接口、函数和常量。 </p><p>命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，除了一个以外：declare关键字。<br><em>（注：在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。另外，所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前）</em></p><h5 id="（3）使用命名空间：基础"><a href="#（3）使用命名空间：基础" class="headerlink" title="（3）使用命名空间：基础"></a>（3）使用命名空间：基础</h5><p>在讨论如何使用命名空间之前，必须了解 PHP 是如何知道要使用哪一个命名空间中的元素的。可以将 PHP 命名空间与文件系统作一个简单的类比。在文件系统中访问一个文件有三种方式： </p><ol><li>相对文件名形式如foo.txt。它会被解析为 currentdirectory/foo.txt，其中 currentdirectory 表示当前目录。因此如果当前目录是 /home/foo，则该文件名被解析为/home/foo/foo.txt。  </li><li>相对路径名形式如subdirectory/foo.txt。它会被解析为 currentdirectory/subdirectory/foo.txt。  </li><li>绝对路径名形式如/main/foo.txt。它会被解析为/main/foo.txt。  </li></ol><p>PHP 命名空间中的元素使用同样的原理。例如，类名可以通过三种方式引用：</p><ol><li><strong>非限定名称</strong>，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。   警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。详情参见 使用命名空间：后备全局函数名称/常量名称。  </li><li><strong>限定名称</strong>,或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。  </li><li><strong>完全限定名称</strong>，或包含了全局前缀操作符的名称，例如， $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。</li></ol><h5 id="（4）使用命名空间：别名-导入"><a href="#（4）使用命名空间：别名-导入" class="headerlink" title="（4）使用命名空间：别名/导入"></a>（4）使用命名空间：别名/导入</h5><p>允许通过别名引用或导入外部的完全限定名称，是命名空间的一个重要特征。这有点类似于在类 unix 文件系统中可以创建对其它的文件或目录的符号连接。<br>所有支持命名空间的PHP版本支持三种别名或导入方式：为类名称使用别名、为接口使用别名或为命名空间名称使用别名。PHP 5.6开始允许导入函数或常量或者为它们设置别名。<br>在PHP中，别名是通过操作符 use 来实现的. 下面是一个使用所有可能的五种导入方式的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Example #1 使用use操作符导入/使用别名</span><br><span class="line">&lt;?php</span><br><span class="line">namespace foo;</span><br><span class="line">use My\Full\Classname as Another;</span><br><span class="line"></span><br><span class="line">// 下面的例子与 use My\Full\NSname as NSname 相同</span><br><span class="line">use My\Full\NSname;</span><br><span class="line"></span><br><span class="line">// 导入一个全局类</span><br><span class="line">use ArrayObject;</span><br><span class="line"></span><br><span class="line">// importing a function (PHP 5.6+)</span><br><span class="line">use function My\Full\functionName;</span><br><span class="line"></span><br><span class="line">// aliasing a function (PHP 5.6+)</span><br><span class="line">use function My\Full\functionName as func;</span><br><span class="line"></span><br><span class="line">// importing a constant (PHP 5.6+)</span><br><span class="line">use const My\Full\CONSTANT;</span><br><span class="line"></span><br><span class="line">$obj = new namespace\Another; // 实例化 foo\Another 对象</span><br><span class="line">$obj = new Another; // 实例化 My\Full\Classname　对象</span><br><span class="line">NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func</span><br><span class="line">$a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象</span><br><span class="line">// 如果不使用 &quot;use \ArrayObject&quot; ，则实例化一个 foo\ArrayObject 对象</span><br><span class="line">func(); // calls function My\Full\functionName</span><br><span class="line">echo CONSTANT; // echoes the value of My\Full\CONSTANT</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>注意对命名空间中的名称（包含命名空间分隔符的完全限定名称如 Foo\Bar以及相对的不包含命名空间分隔符的全局名称如 FooBar）来说，前导的反斜杠是不必要的也不推荐的，因为导入的名称必须是完全限定的，不会根据当前的命名空间作相对解析。</p><h5 id="（5）名称解析规则"><a href="#（5）名称解析规则" class="headerlink" title="（5）名称解析规则"></a>（5）名称解析规则</h5><p>在说明名称解析规则之前，我们先看一些重要的定义： </p><blockquote><p>命名空间名称定义<br>① 非限定名称Unqualified name<br>    名称中不包含命名空间分隔符的标识符，例如 Foo<br>② 限定名称Qualified name<br>    名称中含有命名空间分隔符的标识符，例如 Foo\Bar<br>③ 完全限定名称Fully qualified name<br>    名称中包含命名空间分隔符，并以命名空间分隔符开始的标识符，例如 \Foo\Bar。 namespace\Foo 也是一个完全限定名称。 </p></blockquote><p>名称解析遵循下列规则： </p><ol><li>对完全限定名称的函数，类和常量的调用在编译时解析。例如 new \A\B 解析为类 A\B。  </li><li>所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 A\B\C 被导入为 C，那么对 C\D\e() 的调用就会被转换为 A\B\C\D\e()。  </li><li>在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 A\B 内部调用 C\D\e()，则 C\D\e() 会被转换为 A\B\C\D\e() 。  </li><li>非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 A\B\C 导入为C，则 new C() 被转换为 new A\B\C() 。  </li><li>在命名空间内部（例如A\B），对非限定名称的函数调用是在运行时解析的。例如对函数 foo() 的调用是这样解析的：  <ol><li>在当前命名空间中查找名为 A\B\foo() 的函数  </li><li>尝试查找并调用 全局(global) 空间中的函数 foo()。  </li></ol></li><li>在命名空间（例如A\B）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 new C() 及 new D\E() 的解析过程： new C()的解析:  <ol><li>在当前命名空间中查找A\B\C类。  </li><li>尝试自动装载类A\B\C。<br>new D\E()的解析:  </li><li>在类名称前面加上当前命名空间名称变成：A\B\D\E，然后查找该类。  </li><li>尝试自动装载类 A\B\D\E。<br>为了引用全局命名空间中的全局类，必须使用完全限定名称 new \C()。 </li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h4&gt;&lt;p&gt;（1）用户自定义函数：&lt;/p&gt;
&lt;p&gt;（2）函数的参数：&lt;br&gt;值传递（默认情况）&lt;br&gt;引用传递：在该参数前面加上符号 &amp;amp;&lt;/p&gt;
&lt;p&gt;（3）类型声明&lt;br&gt;在PHP 5中，类型声明也被称为类型提示。&lt;br&gt;类型声明允许函数在调用时要求参数为特定类型。 如果给出的值类型不对，那么将会产生一个错误： 在PHP 5中，这将是一个可恢复的致命错误，而在PHP 7中将会抛出一个TypeError异常。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP数据类型详解（PHP手册版）</title>
    <link href="http://yoursite.com/2018/01/31/PHP%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88PHP%E6%89%8B%E5%86%8C%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/31/PHP数据类型详解（PHP手册版）/</id>
    <published>2018-01-31T09:45:42.000Z</published>
    <updated>2018-02-01T03:26:47.510Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据类型</strong><br>四种标量类型：</p><blockquote><p>boolean（布尔型）、integer（整型）、float（浮点型，也称为double）、string（字符串）</p></blockquote><p>两种复合类型：</p><blockquote><p>array（数组）、object（对象）</p></blockquote><p>两种特殊类型：</p><blockquote><p>resource（资源）、Null</p></blockquote><p>其它伪类型：</p><blockquote><p>mixed（混合类型）、number（数字类型）、callback（回调类型）、void（无类型）</p></blockquote><a id="more"></a><h4 id="布尔型（boolean）："><a href="#布尔型（boolean）：" class="headerlink" title="布尔型（boolean）："></a>布尔型（boolean）：</h4><p>（1）指定一个布尔值，使用常量 TRUE 或 FALSE。两个都不区分大小写。<br>（2）强制转换为布尔型，用 (bool) 或 (boolean) 来强制转换。但是很多情况下不需要强制转换，会被自动转换。<br>当转换为 boolean 时，以下值被认为是 FALSE： </p><ul><li>布尔值 FALSE 本身  </li><li>整型值 0（零）  </li><li>浮点型值 0.0（零）  </li><li>空字符串，以及字符串 “0”  </li><li>不包括任何元素的数组  </li><li>特殊类型 NULL（包括尚未赋值的变量）  </li><li>从空标记生成的 SimpleXML 对象  </li></ul><p>所有其它值都被认为是 TRUE（包括任何资源 和 NAN）。</p><h4 id="整型（interger）："><a href="#整型（interger）：" class="headerlink" title="整型（interger）："></a>整型（interger）：</h4><p>（1）整型值可以使用十进制，十六进制，八进制或二进制表示，前面可以加上可选的符号（- 或者 +）。<br>要使用八进制表达，数字前必须加上 0（零）。要使用十六进制表达，数字前必须加上 0x。要使用二进制表达，数字前必须加上 0b。<br>（2）要明确地将一个值转换为 integer，用 (int) 或 (integer) 强制转换。不过大多数情况下都不需要强制转换，因为当运算符，函数或流程控制需要一个 integer 参数时，值会自动转换。还可以通过函数 intval() 来将一个值转换成整型。<br>当从浮点数转换成整数时，将向下取整。 </p><h4 id="浮点型（float）："><a href="#浮点型（float）：" class="headerlink" title="浮点型（float）："></a>浮点型（float）：</h4><p>（1）浮点型（也叫浮点数 float，双精度数 double 或实数 real）。<br>（2）浮点数的精度<br>浮点数的精度有限。尽管取决于系统，PHP 通常使用 IEEE 754 双精度格式，则由于取整而导致的最大相对误差为 1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运算时的误差传递。<br>（3）NaN<br>某些数学运算会产生一个由常量 NAN 所代表的结果。此结果代表着一个在浮点数运算中未定义或不可表述的值。任何拿此值与其它任何值（除了 TRUE）进行的松散或严格比较的结果都是 FALSE。<br>由于 NAN 代表着任何不同值，不应拿 NAN 去和其它值进行比较，包括其自身，应该用 is_nan() 来检查。 </p><h4 id="字符串（string）："><a href="#字符串（string）：" class="headerlink" title="字符串（string）："></a>字符串（string）：</h4><p>（1）一个字符串 string 就是由一系列的字符组成，其中每个字符等同于一个字节。这意味着 PHP 只能支持 256 的字符集，因此不支持 Unicode 。<br>（注：Note: string 最大可以达到 2GB。）<br>（2）一个字符串可以用 4 种方式表达： </p><ul><li>单引号  ：定义一个字符串的最简单的方法是用单引号把它包围起来（字符 ‘）。</li><li>双引号  ：如果字符串是包围在双引号（”）中， PHP 将对一些特殊的字符进行解析。</li><li>heredoc 语法结构  ：<br>第三种表达字符串的方法是用 heredoc 句法结构：&lt;&lt;&lt;。在该运算符之后要提供一个标识符，然后换行。接下来是字符串 string 本身，最后要用前面定义的标识符作为结束标志。<br>结束时所引用的标识符必须在该行的第一列，而且，标识符的命名也要像其它标签一样遵守 PHP 的规则：只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。<br>（Heredoc 结构就象是没有使用双引号的双引号字符串，这就是说在 heredoc 结构中单引号不用被转义，但是上文中列出的转义序列还可以使用。变量将被替换，但在 heredoc 结构中含有复杂的变量时要格外小心。 ）</li><li>nowdoc 语法结构（自 PHP 5.3.0 起）<br>就象 heredoc 结构类似于双引号字符串，Nowdoc 结构是类似于单引号字符串的。Nowdoc 结构很象 heredoc 结构，但是 nowdoc 中不进行解析操作。这种结构很适合用于嵌入 PHP 代码或其它大段文本而无需对其中的特殊字符进行转义。与 SGML 的 &lt;![CDATA[ ]]&gt; 结构是用来声明大段的不用解析的文本类似，nowdoc 结构也有相同的特征。<br>一个 nowdoc 结构也用和 heredocs 结构一样的标记 &lt;&lt;&lt;， 但是跟在后面的标识符要用单引号括起来，即 &lt;&lt;&lt;’EOT’。Heredoc 结构的所有规则也同样适用于 nowdoc 结构，尤其是结束标识符的规则。</li></ul><p><strong>（注：函数、方法、静态类变量和类常量只有在 PHP 5 以后才可在 {$} 中使用。然而，只有在该字符串被定义的命名空间中才可以将其值作为变量名来访问。只单一使用花括号 ({}) 无法处理从函数或方法的返回值或者类常量以及类静态变量的值。 ）</strong><br>（3）字符串可以用 ‘.’（点）运算符连接起来，注意 ‘+’（加号）运算符没有这个功能。对于 string 的操作有很多有用的函数，后面予以单独说明。</p><h4 id="数组（array）："><a href="#数组（array）：" class="headerlink" title="数组（array）："></a>数组（array）：</h4><p>PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。<br>（1）语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义数组 array()</span><br><span class="line">可以用 array() 语言结构来新建一个数组。它接受任意数量用逗号分隔的 键（key） =&gt; 值（value）对。 </span><br><span class="line">array(  key =&gt;  value</span><br><span class="line">     , ...</span><br><span class="line">     )</span><br><span class="line">// 键（key）可是是一个整数 integer 或字符串 string</span><br><span class="line">// 值（value）可以是任意类型的值</span><br></pre></td></tr></table></figure></p><p>最后一个数组单元之后的逗号可以省略。通常用于单行数组定义中，例如常用 array(1, 2) 而不是 array(1, 2, )。对多行数组定义通常保留最后一个逗号，这样要添加一个新单元时更方便。<br>自 5.4 起可以使用短数组定义语法，用 [] 替代 array()。<br><strong>（注：key 可以是 integer 或者 string。value 可以是任意类型。）</strong></p><p><strong>此外 key 会有如下的强制转换： </strong></p><ul><li>包含有合法整型值的字符串会被转换为整型。例如键名 “8” 实际会被储存为 8。但是 “08” 则不会强制转换，因为其不是一个合法的十进制数值。  </li><li>浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。  </li><li>布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。  </li><li>Null 会被转换为空字符串，即键名 null 实际会被储存为 “”。  </li><li>数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。  </li></ul><p>如果在数组定义中多个单元都使用了同一个键名，则只使用了最后一个，之前的都被覆盖了。</p><p>（2）注意事项：<br> ① 方括号和花括号可以互换使用来访问数组单元（例如 $array[42] 和 $array{42} 在上例中效果相同）。<br> ② 试图访问一个未定义的数组键名与访问任何未定义变量一样：会导致 E_NOTICE 级别错误信息，其结果为 NULL。<br> ③ 要修改某个值，通过其键名给该单元赋一个新值。要删除某键值对，对其调用 unset() 函数。<br> ④ 应该始终在用字符串表示的数组索引上加上引号。例如用 $foo[‘bar’] 而不是 $foo[bar]。原因是此代码中有一个未定义的常量（bar）而不是字符串（’bar’－注意引号），而 PHP 可能会在以后定义此常量，不幸的是你的代码中有同样的名字。它能运行，是因为 PHP 自动将裸字符串（没有引号的字符串且不对应于任何已知符号）转换成一个其值为该裸字符串的正常字符串。例如，如果没有常量定义为 bar，PHP 将把它替代为 ‘bar’ 并使用之。<br> 但这并不意味着总是给键名加上引号。用不着给键名为常量或变量的加上引号，否则会使 PHP 不能解析它们。</p><h4 id="对象类型（Object）："><a href="#对象类型（Object）：" class="headerlink" title="对象类型（Object）："></a>对象类型（Object）：</h4><p>要创建一个新的对象 object，使用 new 语句实例化一个类。<br>转换为对象：如果将一个对象转换成对象，它将不会有任何变化。如果其它任何类型的值被转换成对象，将会创建一个内置类 stdClass 的实例。如果该值为 NULL，则新的实例为空。 array 转换成 object 将使键名成为属性名并具有相对应的值，除了数字键，不迭代就无法被访问。 </p><h4 id="资源类型（resource）："><a href="#资源类型（resource）：" class="headerlink" title="资源类型（resource）："></a>资源类型（resource）：</h4><p>资源 resource 是一种特殊变量，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。<br>转换为资源：由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，因此将其它类型的值转换为资源没有意义。 </p><h4 id="NULL："><a href="#NULL：" class="headerlink" title="NULL："></a>NULL：</h4><p>特殊的 NULL 值表示一个变量没有值。NULL 类型唯一可能的值就是 NULL。<br><strong>（注：NULL 类型只有一个值，就是不区分大小写的常量 NULL。）</strong><br>在下列情况下一个变量被认为是 NULL： </p><ul><li>被赋值为 NULL。 </li><li>尚未被赋值。 </li><li>被 unset()。</li></ul><h4 id="许的强制转换有："><a href="#许的强制转换有：" class="headerlink" title="许的强制转换有："></a>许的强制转换有：</h4><ul><li>(int), (integer) - 转换为整形 integer </li><li>(bool), (boolean) - 转换为布尔类型 boolean </li><li>(float), (double), (real) - 转换为浮点型 float </li><li>(string) - 转换为字符串 string </li><li>(array) - 转换为数组 array </li><li>(object) - 转换为对象 object </li><li>(unset) - 转换为 NULL (PHP 5) </li><li>(binary) 转换和 b 前缀转换支持为 PHP 5.2.1 新增。 </li></ul><p><strong>（注意在括号内允许有空格和制表符）</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;br&gt;四种标量类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;boolean（布尔型）、integer（整型）、float（浮点型，也称为double）、string（字符串）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两种复合类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;array（数组）、object（对象）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两种特殊类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;resource（资源）、Null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其它伪类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mixed（混合类型）、number（数字类型）、callback（回调类型）、void（无类型）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP基础整理（PHP手册版）</title>
    <link href="http://yoursite.com/2018/01/31/PHP%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88PHP%E6%89%8B%E5%86%8C%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/31/PHP基础整理（PHP手册版）/</id>
    <published>2018-01-31T09:45:30.000Z</published>
    <updated>2018-02-01T03:40:09.541Z</updated>
    
    <content type="html"><![CDATA[<h4 id="PHP概述："><a href="#PHP概述：" class="headerlink" title="PHP概述："></a>PHP概述：</h4><p>PHP（“PHP: Hypertext Preprocessor”，超文本预处理器的字母缩写）是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML中，尤其适合 web 开发。<br>PHP常用于服务端脚本和命令行脚本。<br>服务端脚本。是 PHP 最传统，也是最主要的目标领域。开展这项工作需要具备以下三点：PHP 解析器（CGI 或者服务器模块）、web 服务器和 web 浏览器。需要在运行 web 服务器时，安装并配置 PHP，然后，可以用 web 浏览器来访问 PHP 程序的输出，即浏览服务端的 PHP 页面。一般做 web 开发和 api 开发。<br>命令行脚本。可以编写一段 PHP 脚本，并且不需要任何服务器或者浏览器来运行它。通过这种方式，仅仅只需要 PHP 解析器来执行。这种用法对于依赖 cron（Unix 或者 Linux 环境）或者 Task Scheduler（Windows 环境）的日常运行的脚本来说是理想的选择。这些脚本也可以用来处理简单的文本。<br><a id="more"></a></p><h4 id="基础语法："><a href="#基础语法：" class="headerlink" title="基础语法："></a>基础语法：</h4><h5 id="1、PHP标记："><a href="#1、PHP标记：" class="headerlink" title="1、PHP标记："></a>1、PHP标记：</h5><p>普通：&lt;?php ?&gt;<br>短标记：&lt;? ?&gt; 通过 php.ini 配置中的 short_open_tag 开启即可。</p><h5 id="2、注释"><a href="#2、注释" class="headerlink" title="2、注释"></a>2、注释</h5><p>单行：//<br>多行：/<em>  </em>/</p><h5 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h5><h6 id="（1）基础"><a href="#（1）基础" class="headerlink" title="（1）基础"></a>（1）基础</h6><p>PHP 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。<br>变量名与 PHP 中其它的标签一样遵循相同的规则。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。</p><p>变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。<br>PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用（换言之，”成为其别名” 或者 “指向”）了原始变量。改动新的变量将影响到原始变量，反之亦然。<br>使用引用赋值，简单地将一个 &amp; 符号加到将要赋值的变量前（源变量）。</p><p>虽然在 PHP 中并不需要初始化变量，但对变量进行初始化是个好习惯。未初始化的变量具有其类型的默认值 - 布尔类型的变量默认值是 FALSE，整形和浮点型变量默认值是零，字符串型变量（例如用于 echo 中）默认值是空字符串以及数组变量的默认值是空数组。 </p><h6 id="（2）变量范围："><a href="#（2）变量范围：" class="headerlink" title="（2）变量范围："></a>（2）变量范围：</h6><p>变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的 PHP 变量只有一个单独的范围。这个单独的范围跨度同样包含了 include 和 require 引入的文件。</p><p>局部变量：局部函数内部的变量将被限制在局部函数范围内。<br>全局变量：PHP 中全局变量在函数中使用时必须声明为 global。<br>超全局变量：PHP自定义特殊的数组。$GLOBALS、$_POST、$_GET、$_REQUEST、$_COOKIE。<br>静态变量：静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。</p><h6 id="（3）可变变量："><a href="#（3）可变变量：" class="headerlink" title="（3）可变变量："></a>（3）可变变量：</h6><p>有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &apos;hello&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。在上面的例子中 hello 使用了两个美元符号（$）以后，就可以作为一个可变变量的变量了。例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$$a = &apos;world&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这时，两个变量都被定义了：$a 的内容是”hello”并且 $hello 的内容是”world”。</p><p>要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下 $$a[1] 时，解析器需要知道是想要 $a[1] 作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 [1] 的值。解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1]。<br>类的属性也可以通过可变属性名来访问。可变属性名将在该调用所处的范围内被解析。例如，对于 $foo-&gt;$bar 表达式，则会在本地范围来解析 $bar 并且其值将被用于 $foo 的属性名。对于 $bar 是数组单元时也是一样。<br>也可使用花括号来给属性名清晰定界。最有用是在属性位于数组中，或者属性名包含有多个部分或者属性名包含有非法字符时。<br><strong>（注意，在 PHP 的函数和类的方法中，超全局变量不能用作可变变量。$this 变量也是一个特殊变量，不能被动态引用。）</strong></p><h5 id="5、常量"><a href="#5、常量" class="headerlink" title="5、常量"></a>5、常量</h5><p>常量是一个简单值的标识符（名字）。如同其名称所暗示的，在脚本执行期间该值不能改变（除了所谓的魔术常量，它们其实不是常量）。常量默认为大小写敏感。传统上常量标识符总是大写的。<br>常量名和其它任何 PHP 标签遵循同样的命名规则。合法的常量名以字母或下划线开始，后面跟着任何字母，数字或下划线。</p><h6 id="（1）语法"><a href="#（1）语法" class="headerlink" title="（1）语法"></a>（1）语法</h6><p>可以用 define() 函数来定义常量，在 PHP 5.3.0 以后，可以使用 const 关键字在类定义之外定义常量。一个常量一旦被定义，就不能再改变或者取消定义。如果只想检查是否定义了某常量，用 defined() 函数。</p><p>常量只能包含标量数据（boolean，integer，float 和 string）。可以定义 resource 常量，但应尽量避免，因为会造成不可预料的结果。 </p><p>可以简单的通过指定其名字来取得常量的值，与变量不同，不应该在常量前面加上 $ 符号。如果常量名是动态的，也可以用函数 constant() 来获取常量的值。用 get_defined_constants() 可以获得所有已定义的常量列表。<br><strong>（注: 常量和（全局）变量在不同的名字空间中。这意味着例如 TRUE 和 $TRUE 是不同的。）</strong></p><p>如果使用了一个未定义的常量，PHP 假定想要的是该常量本身的名字，如同用字符串调用它一样（CONSTANT 对应 “CONSTANT”）。此时将发出一个 E_NOTICE 级的错误。参见手册中为什么 $foo[bar] 是错误的（除非事先用 define() 将 bar 定义为一个常量）。 </p><p><strong>常量和变量有如下不同： </strong></p><ul><li>常量前面没有美元符号（$）；  </li><li>常量只能用 define() 函数定义，而不能通过赋值语句；  </li><li>常量可以不用理会变量的作用域而在任何地方定义和访问；  </li><li>常量一旦定义就不能被重新定义或者取消定义；  </li><li>常量的值只能是标量。</li></ul><p><strong>define() 与 const 区别：</strong><br>和使用 define() 来定义常量相反的是，使用 const 关键字定义常量必须处于最顶端的作用区域，因为用此方法是在编译时定义的。这就意味着不能在函数内，循环内以及 if 语句之内用 const 来定义常量。</p><h6 id="（2）魔术常量"><a href="#（2）魔术常量" class="headerlink" title="（2）魔术常量"></a>（2）魔术常量</h6><p>PHP 向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。<br>有八个魔术常量它们的值随着它们在代码中的位置改变而改变。例如 <strong>LINE</strong> 的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下： </p><p>几个 PHP 的”魔术常量”</p><style type="text/css">    table th:first-of-type{        width: 100px;    }</style><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>LINE</strong></td><td>文件中的当前行号。  </td></tr><tr><td><strong>FILE</strong></td><td>文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，<strong>FILE</strong> 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。  </td></tr><tr><td><strong>DIR</strong></td><td>文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(<strong>FILE</strong>)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增） =  </td></tr><tr><td><strong>FUNCTION</strong></td><td>函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。  </td></tr><tr><td><strong>CLASS</strong></td><td>类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 <strong>CLASS</strong> 对 trait 也起作用。当用在 trait 方法中时，<strong>CLASS</strong> 是调用 trait 方法的类的名字。  </td></tr><tr><td><strong>TRAIT</strong></td><td>Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4 起此常量返回 trait 被定义时的名字（区分大小写）。Trait 名包括其被声明的作用区域（例如 Foo\Bar）。  </td></tr><tr><td><strong>METHOD</strong></td><td>类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。  </td></tr><tr><td><strong>NAMESPACE</strong></td><td>当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。 </td></tr></tbody></table><h5 id="6、运算符"><a href="#6、运算符" class="headerlink" title="6、运算符"></a>6、运算符</h5><p>运算符优先级</p><table><thead><tr><th>结合方向</th><th>运算符</th><th>附加信息</th></tr></thead><tbody><tr><td>无</td><td>clone new</td><td>clone 和 new </td></tr><tr><td>左</td><td>[</td><td>array() </td></tr><tr><td>右</td><td>**</td><td>算术运算符 </td></tr><tr><td>右</td><td>++ – ~ (int) (float) (string) (array) (object) (bool) @</td><td>类型和递增／递减  </td></tr><tr><td>无</td><td>instanceof</td><td>类型  </td></tr><tr><td>右</td><td>!</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>* / %</td><td>算术运算符  </td></tr><tr><td>左</td><td>+ - .</td><td>算术运算符和字符串运算符 </td></tr><tr><td>左</td><td>&lt;&lt; &gt;&gt;</td><td>位运算符  </td></tr><tr><td>无</td><td>&lt; &lt;= &gt; &gt;=</td><td>比较运算符  </td></tr><tr><td>无</td><td>== != === !== &lt;&gt; &lt;=&gt;</td><td>比较运算符  </td></tr><tr><td>左</td><td>&amp;</td><td>位运算符和引用 </td></tr><tr><td>左</td><td>^</td><td>位运算符  </td></tr><tr><td>左</td><td>&#124;</td><td>位运算符  </td></tr><tr><td>左</td><td>&amp;&amp;</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>&#124;&#124;</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>??</td><td>比较运算符  </td></tr><tr><td>左</td><td>? :</td><td>ternary  </td></tr><tr><td>右</td><td>= += -= <em>= *</em>= /= .= %= &amp;= &#124;= ^= &lt;&lt;= &gt;&gt;=</td><td>赋值运算符  </td></tr><tr><td>左</td><td>and</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>xor</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>or</td><td>逻辑运算符  </td></tr></tbody></table><h5 id="7、流程控制"><a href="#7、流程控制" class="headerlink" title="7、流程控制"></a>7、流程控制</h5><h6 id="（1）条件判断"><a href="#（1）条件判断" class="headerlink" title="（1）条件判断"></a>（1）条件判断</h6><p><strong>if语句：</strong><br>单分支if语句：if(){}else{}<br>多分支if语句：if(){}elseif(){}else{}<br>分支嵌套语句：if(){if(){}}else{}</p><p><strong>switch语句：</strong><br>switch(expr){<br>    case 0:<br>        statement<br>        break;<br>    case 1:<br>        statement<br>        break;<br>    default:<br>        statement<br>        break;<br>}</p><h6 id="（2）循环判断"><a href="#（2）循环判断" class="headerlink" title="（2）循环判断"></a>（2）循环判断</h6><p><strong>for循环：</strong><br>for(expr1; expr2; expr3){</p><p>}</p><p><strong>foreach循环：</strong><br>仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。<br>foreach(array_expression as $value){<br>    statement<br>}<br>foreach(array_expression as $key=&gt;$value){<br>    statement<br>}</p><p><strong>while循环：</strong><br>while(){</p><p>}</p><p><strong>do-while循环：</strong><br>do{</p><p>}while();</p><h6 id="（3）中止语句"><a href="#（3）中止语句" class="headerlink" title="（3）中止语句"></a>（3）中止语句</h6><p>跳出循环语句：break;<br>跳出本次循环，执行下一个循环：continue;<br>结束函数的执行并将它的值返回：return;</p><h6 id="（4）加载语句"><a href="#（4）加载语句" class="headerlink" title="（4）加载语句"></a>（4）加载语句</h6><p>require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include 只产生警告（E_WARNING），脚本会继续运行。<br>require：<br>include：<br>唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。<br>require_once：<br>include_once：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;PHP概述：&quot;&gt;&lt;a href=&quot;#PHP概述：&quot; class=&quot;headerlink&quot; title=&quot;PHP概述：&quot;&gt;&lt;/a&gt;PHP概述：&lt;/h4&gt;&lt;p&gt;PHP（“PHP: Hypertext Preprocessor”，超文本预处理器的字母缩写）是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML中，尤其适合 web 开发。&lt;br&gt;PHP常用于服务端脚本和命令行脚本。&lt;br&gt;服务端脚本。是 PHP 最传统，也是最主要的目标领域。开展这项工作需要具备以下三点：PHP 解析器（CGI 或者服务器模块）、web 服务器和 web 浏览器。需要在运行 web 服务器时，安装并配置 PHP，然后，可以用 web 浏览器来访问 PHP 程序的输出，即浏览服务端的 PHP 页面。一般做 web 开发和 api 开发。&lt;br&gt;命令行脚本。可以编写一段 PHP 脚本，并且不需要任何服务器或者浏览器来运行它。通过这种方式，仅仅只需要 PHP 解析器来执行。这种用法对于依赖 cron（Unix 或者 Linux 环境）或者 Task Scheduler（Windows 环境）的日常运行的脚本来说是理想的选择。这些脚本也可以用来处理简单的文本。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Linux VPS、Linux系统防止DDOS攻击脚本[转]</title>
    <link href="http://yoursite.com/2018/01/25/Linux-VPS%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E9%98%B2%E6%AD%A2DDOS%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC-%E8%BD%AC/"/>
    <id>http://yoursite.com/2018/01/25/Linux-VPS、Linux系统防止DDOS攻击脚本-转/</id>
    <published>2018-01-25T07:00:10.000Z</published>
    <updated>2018-01-25T07:04:52.803Z</updated>
    
    <content type="html"><![CDATA[<p>转载地址：<a href="http://www.1987.name/33.html" target="_blank" rel="noopener">http://www.1987.name/33.html</a></p><p>互联网上明争暗斗如同现实社会一样，DDOS攻击屡见不鲜，是很多站长烦恼的事情，尤其是个人站长，资金有限，没有硬件防火墙那只能使用软件。Linux系统上第一个想到的替代软件肯定是iptables，但是它不会智能屏蔽攻击IP，需要手动执行，这样也是不现实。本文主要介绍一款配合iptables来智能抵御DDOS攻击的软件：<strong>DDoS Deflate。</strong><br><a id="more"></a></p><h4 id="关于DDOS-Deflate脚本"><a href="#关于DDOS-Deflate脚本" class="headerlink" title="关于DDOS Deflate脚本"></a>关于DDOS Deflate脚本</h4><p>DDOS deflate是一个轻量级的脚本，以协助阻止拒绝服务攻击的过程中的bash shell脚本。它使用下面的命令来创建一个连接到服务器的IP地址列表，以及与它们的连接总数 。这是最简单的安装软件的解决方案之一。我已经使用一年多，抵御一般性的DDOS攻击效果还是不错的。</p><p>主要原理是超过了预先配置的连接数的IP地址自动被服务器防火墙（iptables）阻止！<br><code>netstat -ntu | awk &#39;{print $5}&#39; | cut -d: -f1 | sort | uniq -c | sort -n</code></p><h4 id="DDOS-Deflate的5个主要功能"><a href="#DDOS-Deflate的5个主要功能" class="headerlink" title="DDOS Deflate的5个主要功能"></a>DDOS Deflate的5个主要功能</h4><ol><li>可以配置白名单的IP地址文件，配置文件路径：/usr/local/ddos/ignore.ip.list</li><li>配置文件简单明了，文件路径：/usr/local/ddos/ddos.conf</li><li>可以设置被防火墙（iptables）屏蔽的IP地址封锁时间（默认：600秒后自动解除封锁）</li><li>可以修改配置文件，脚本可以定时周期性运行（默认是：1分钟）</li><li>当遇到攻击，IP被封锁之后可以为指定的邮箱接收电子邮件警报。</li></ol><h4 id="DDOS-Deflate的安装方法"><a href="#DDOS-Deflate的安装方法" class="headerlink" title="DDOS Deflate的安装方法"></a>DDOS Deflate的安装方法</h4><p>DDOS Deflate非常简单，下载脚本后，直接执行脚本，结束后会显示安装信息，按ESC退出即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.inetbase.com/scripts/ddos/install.sh</span><br><span class="line">chmod +x install.sh</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure></p><p>安装结束后，配置主配文件ddos.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">##### Paths of the script and other files</span><br><span class="line">PROGDIR=&quot;/usr/local/ddos&quot; #软件文件存放位置</span><br><span class="line">PROG=&quot;/usr/local/ddos/ddos.sh&quot; #主要功能脚本路径</span><br><span class="line">IGNORE_IP_LIST=&quot;/usr/local/ddos/ignore.ip.list&quot; #白名单列表路径</span><br><span class="line">CRON=&quot;/etc/cron.d/ddos.cron&quot; #定时任务脚本路径</span><br><span class="line">APF=&quot;/etc/apf/apf&quot; #APF路径</span><br><span class="line">IPT=&quot;/sbin/iptables&quot; #iptables路径</span><br><span class="line"></span><br><span class="line">##### frequency in minutes for running the script</span><br><span class="line">##### Caution: Every time this setting is changed, run the script with --cron</span><br><span class="line">##### option so that the new frequency takes effect</span><br><span class="line">FREQ=1 #检查周期时间，默认1分钟</span><br><span class="line"></span><br><span class="line">##### How many connections define a bad IP? Indicate that below.</span><br><span class="line">NO_OF_CONNECTIONS=150 #允许客户端与服务器的最大连接数，超过IP就会被屏蔽，一般保持默认即可</span><br><span class="line"></span><br><span class="line">##### APF_BAN=1 (Make sure your APF version is atleast 0.96)</span><br><span class="line">##### APF_BAN=0 (Uses iptables for banning ips instead of APF)</span><br><span class="line">APF_BAN=0  #数字1为使用APF，数字0为使用iptables，这里推荐使用iptables </span><br><span class="line"></span><br><span class="line">##### KILL=0 (Bad IPs are&apos;nt banned, good for interactive execution of script)</span><br><span class="line">##### KILL=1 (Recommended setting)</span><br><span class="line">KILL=1 #是否屏蔽IP，当然是屏蔽，默认即可</span><br><span class="line"></span><br><span class="line">##### An email is sent to the following address when an IP is banned.</span><br><span class="line">##### Blank would suppress sending of mails</span><br><span class="line">EMAIL_TO=&quot;admin@1987.name&quot; #指定一个 电子邮件，用于发送警报 </span><br><span class="line"></span><br><span class="line">##### Number of seconds the banned ip should remain in blacklist.</span><br><span class="line">BAN_PERIOD=600 #屏蔽时间，这里自由设定</span><br></pre></td></tr></table></figure></p><p>配置文件中提到的APF，它也是linux系统中防火墙之一，这里稍作介绍：APF（Advanced Policy Firewall），是 Rf-x Networks 出品的Linux环境下的软件防火墙。APF采用Linux系统默认的 iptables 规则。APF可以算是Linux中最出名的软件防火墙之一。</p><h4 id="为DDOS-Deflate开启相关服务"><a href="#为DDOS-Deflate开启相关服务" class="headerlink" title="为DDOS Deflate开启相关服务"></a>为DDOS Deflate开启相关服务</h4><p>开启iptables<br><code>service iptables start</code><br>开启crontab，定时任务<br><code>service crond start</code></p><h4 id="如何卸载DDOS-Deflate"><a href="#如何卸载DDOS-Deflate" class="headerlink" title="如何卸载DDOS Deflate"></a>如何卸载DDOS Deflate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.inetbase.com/scripts/ddos/uninstall.ddos</span><br><span class="line">chmod +x uninstall.ddos</span><br><span class="line">./uninstall.ddos</span><br></pre></td></tr></table></figure><p>希望遇到DDOS攻击的朋友使用此软件能解决头疼问题，也感谢软件作者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载地址：&lt;a href=&quot;http://www.1987.name/33.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.1987.name/33.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;互联网上明争暗斗如同现实社会一样，DDOS攻击屡见不鲜，是很多站长烦恼的事情，尤其是个人站长，资金有限，没有硬件防火墙那只能使用软件。Linux系统上第一个想到的替代软件肯定是iptables，但是它不会智能屏蔽攻击IP，需要手动执行，这样也是不现实。本文主要介绍一款配合iptables来智能抵御DDOS攻击的软件：&lt;strong&gt;DDoS Deflate。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
