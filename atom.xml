<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-29T10:20:49.638Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>认识与学习BASH之awk命令</title>
    <link href="http://yoursite.com/2017/12/29/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8Bawk%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/12/29/认识与学习BASH之awk命令/</id>
    <published>2017-12-29T09:56:49.000Z</published>
    <updated>2017-12-29T10:20:49.638Z</updated>
    
    <content type="html"><![CDATA[<h4 id="awk：好用的数据处理工具"><a href="#awk：好用的数据处理工具" class="headerlink" title="awk：好用的数据处理工具"></a>awk：好用的数据处理工具</h4><p>awk 也是一个非常棒的数据处理工具。相较于 sed 常常作用于一整个行的处理，awk 则比较倾向于一行当中分成数个【字段】来处理。因此，awk 相当的适合处理小型的数据数据处理。awk 通常运作的模式是这样的：<br><code>[root@www ~]# awk &#39;条件类型1{动作1} 条件类型2{动作2} ...&#39; filename</code></p><p>awk 后面接两个单引号并加上大括号 {} 来设定想要对数据进行的处理动作。awk 可以处理后续接的档案，也可以读取来自前个指令的 standard output 。但如前面说的，awk 主要是处理【每一行的字段内的数据】，而默认的【字段的分隔符为 “空格键” 或 “[tab]键”】。<br><a id="more"></a><br>举例来说，我们用 last 可以将登入者的数据取出来，结果如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# last -n 5 &lt;==仅取出前五行</span><br><span class="line">root pts/1 192.168.1.100 Tue Feb 10 11:21 still logged in</span><br><span class="line">root pts/1 192.168.1.100 Tue Feb 10 00:46 - 02:28 (01:41)</span><br><span class="line">root pts/1 192.168.1.100 Mon Feb 9 11:41 - 18:30 (06:48)</span><br><span class="line">dmtsai pts/1 192.168.1.100 Mon Feb 9 11:41 - 11:41 (00:00)</span><br><span class="line">root tty1 Fri Sep 5 14:09 - 14:10 (00:01)</span><br></pre></td></tr></table></figure></p><p>若我想要取出账号与登入者的 IP ，且账号与 IP 之间以 [tab] 隔开，则会变成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# last -n 5 | awk &apos;&#123;print $1 &quot;\t&quot; $3&#125;&apos;</span><br><span class="line">root 192.168.1.100</span><br><span class="line">root 192.168.1.100</span><br><span class="line">root 192.168.1.100</span><br><span class="line">dmtsai 192.168.1.100</span><br><span class="line">root Fri</span><br></pre></td></tr></table></figure></p><p>上表是 awk 最常使用的动作。透过 print 的功能将字段数据列出来，字段的分隔则以空格键或 [tab] 按键来隔开。因为不论哪一行我都要处理，因此，就不需要有 “条件类型” 的限制。我所想要的是第一栏以及第三栏，但是，第五行的内容怪怪的，这是因为数据格式的问题。所以，使用 awk 的时候，请先确认一下你的数据当中，如果是连续性的数据，请不要有空格或 [tab] 在内，否则，就会像这个例子这样，会发生误判。</p><p>另外，由上面这个例子你也会知道，在每一行的每个字段都是有变量名称的，那就是 $1, $2… 等变量名称。以上面的例子来说，root 是 $1 ，因为他是第一栏。至于 192.168.1.100 是第三栏，所以他就是 $3，后面以此类推。还有个变数，那就是 $0 ，$0 代表【一整列资料】的意思。以上面的例子来说，第一行的 $0 代表的就是【root ….】那一行。 由此可知，刚刚上面五行当中，整个 awk 的处理流程是：</p><pre><code>1. 读入第一行，并将第一行的资料填入 $0, $1, $2.... 等变数当中；2. 依据 &quot;条件类型&quot; 的限制，判断是否需要进行后面的 &quot;动作&quot;；3. 做完所有的动作与条件类型；4. 若还有后续的【行】的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。</code></pre><p>经过这样的步骤，你会晓得，awk 是【以行为一次处理的单位】，而【以字段为最小的处理单位】。那么 awk 怎么知道我到底这个数据有几行？有几栏？这就需要 awk 的内建变量的帮忙了。</p><table><thead><tr><th>变量名称</th><th>代表意义</th></tr></thead><tbody><tr><td>NF</td><td>每一行 ($0) 拥有的字段总数</td></tr><tr><td>NR</td><td>目前 awk 所处理的是【第几行】数据</td></tr><tr><td>FS</td><td>目前的分隔字符，默认是空格键</td></tr></tbody></table><p>我们继续以上面 last -n 5 的例子来做说明，如果我想要：</p><ul><li>列出每一行的账号(就是 $1)；</li><li>列出目前处理的行数(就是 awk 内的 NR 变量)</li><li>并且说明，该行有多少字段(就是 awk 内的 NF 变量)</li></ul><p><em>（注：awk 后续的所有动作是以单引号【 ‘ 】括住的，由于单引号与双引号都必须是成对的，所以，awk的格式内容如果想要以print打印时，记得非变量的文字部分，包含printf的格式中，都需要使用双引号来定义出来。因为单引号已经是 awk 的指令固定用法了！）</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# last -n 5| awk &apos;&#123;print $1 &quot;\t lines: &quot; NR &quot;\t columes: &quot; NF&#125;&apos;</span><br><span class="line">root lines: 1 columes: 10</span><br><span class="line">root lines: 2 columes: 10</span><br><span class="line">root lines: 3 columes: 10</span><br><span class="line">dmtsai lines: 4 columes: 10</span><br><span class="line">root lines: 5 columes: 9</span><br><span class="line"># 注意，在 awk 内的 NR, NF 等变量要用大写，且不需要有钱字号 $</span><br></pre></td></tr></table></figure><h4 id="awk-的逻辑运算字符"><a href="#awk-的逻辑运算字符" class="headerlink" title="awk 的逻辑运算字符"></a>awk 的逻辑运算字符</h4><p>既然有需要用到 “条件” 的类别，自然就需要一些逻辑运算。例如底下这些：<br><img src="/uploads/2017/12/linux_shell_awk_01.png" alt=""><br>值得注意的是那个【 == 】的符号，因为：    </p><ul><li>逻辑运算上面亦即所谓的大于、小于、等于等判断式上面，习惯上是以【 == 】来表示；</li><li>如果是直接给予一个值，例如变量设定时，就直接使用 = 而已。</li></ul><p>举例来说，在 /etc/passwd 当中是以冒号 “:” 来作为字段的分隔，该档案中第一字段为账号，第三字段则是UID。那假设我要查阅，第三栏小于 10 以下的数据，并且仅列出账号与第三栏，那么可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat /etc/passwd | awk &apos;&#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&apos;</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin 1</span><br><span class="line">daemon 2</span><br><span class="line">....(以下省略)....</span><br></pre></td></tr></table></figure></p><p>另外，如果要用 awk 来进行【计算功能】呢？以底下的例子来看，假设我有一个薪资数据表档名为 pay.txt ，内容是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name 1st 2nd 3th</span><br><span class="line">VBird 23000 24000 25000</span><br><span class="line">DMTsai 21000 20000 23000</span><br><span class="line">Bird2 43000 42000 41000</span><br></pre></td></tr></table></figure></p><p>如何帮我计算每个人的总额呢？而且我还想要格式化输出。我们可以这样考虑：</p><ul><li>第一行只是说明，所以第一行不要进行加总 (NR==1 时处理)；</li><li>第二行以后就会有加总的情况出现 (NR&gt;=2 以后处理)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat pay.txt | \</span><br><span class="line">&gt; awk &apos;NR==1&#123;printf</span><br><span class="line">&quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot; &#125;</span><br><span class="line">NR&gt;=2&#123;total = $2 + $3 + $4</span><br><span class="line">printf &quot;%10s %10d %10d %10d %10.2f\n&quot;, $1, $2, $3, $4, total&#125;&apos;</span><br><span class="line">Name 1st 2nd 3th Total</span><br><span class="line">VBird 23000 24000 25000 72000.00</span><br><span class="line">DMTsai 21000 20000 23000 64000.00</span><br><span class="line">Bird2 43000 42000 41000 126000.00</span><br></pre></td></tr></table></figure><p>上面的例子有几个重要事项应该要先说明的：</p><ul><li>awk 的指令间隔：所有 awk 的动作，亦即在 {} 内的动作，如果有需要多个指令辅助时，可利用分号【;】间隔，或者直接以 [Enter] 按键来隔开每个指令</li><li>逻辑运算当中，如果是【等于】的情况，则务必使用两个等号【==】！</li><li>格式化输出时，在 printf 的格式设定当中，务必加上 \n ，才能进行分行！</li><li>与 bash shell 的变量不同，在 awk 当中，变量可以直接使用，不需加上 $ 符号。</li></ul><p>利用 awk 这个玩意儿，就可以帮我们处理很多日常工作了呢！真是好用的很。此外，awk 的输出格式当中，常常会以 printf 来辅助，所以，最好你对 printf 也稍微熟悉一下比较好。另外，awk 的动作内 {} 也是支持 if (条件) 的。举例来说，上面的指令可以修订成为这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat pay.txt | \</span><br><span class="line">&gt; awk &apos;&#123;if(NR==1) printf</span><br><span class="line">&quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot;&#125;</span><br><span class="line">NR&gt;=2&#123;total = $2 + $3 + $4</span><br><span class="line">printf &quot;%10s %10d %10d %10d %10.2f\n&quot;, $1, $2, $3, $4, total&#125;&apos;</span><br></pre></td></tr></table></figure></p><h4 id="格式化打印：printf"><a href="#格式化打印：printf" class="headerlink" title="格式化打印：printf"></a>格式化打印：printf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# printf &apos;打印格式&apos; 实际内容</span><br><span class="line">选项与参数：</span><br><span class="line">关于格式方面的几个特殊样式：</span><br><span class="line">\a 警告声音输出</span><br><span class="line">\b 退格键(backspace)</span><br><span class="line">\f 清除屏幕 (form feed)</span><br><span class="line">\n 输出新的一行</span><br><span class="line">\r 亦即 Enter 按键</span><br><span class="line">\t 水平的 [tab] 按键</span><br><span class="line">\v 垂直的 [tab] 按键</span><br><span class="line">\xNN NN 为两位数的数字，可以转换数字成为字符。</span><br><span class="line">关于 C 程序语言内，常见的变数格式</span><br><span class="line">%ns 那个 n 是数字， s 代表 string ，亦即多少个字符；</span><br><span class="line">%ni 那个 n 是数字， i 代表 integer ，亦即多少整数字数；</span><br><span class="line">%N.nf 那个 n 与 N 都是数字， f 代表 floating (浮点)，如果有小数字数，假设我共要十个位数，但小数点有两位，即为 %10.2f</span><br></pre></td></tr></table></figure><p><strong>（注：printf 不是管线命令）</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;awk：好用的数据处理工具&quot;&gt;&lt;a href=&quot;#awk：好用的数据处理工具&quot; class=&quot;headerlink&quot; title=&quot;awk：好用的数据处理工具&quot;&gt;&lt;/a&gt;awk：好用的数据处理工具&lt;/h4&gt;&lt;p&gt;awk 也是一个非常棒的数据处理工具。相较于 sed 常常作用于一整个行的处理，awk 则比较倾向于一行当中分成数个【字段】来处理。因此，awk 相当的适合处理小型的数据数据处理。awk 通常运作的模式是这样的：&lt;br&gt;&lt;code&gt;[root@www ~]# awk &amp;#39;条件类型1{动作1} 条件类型2{动作2} ...&amp;#39; filename&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;awk 后面接两个单引号并加上大括号 {} 来设定想要对数据进行的处理动作。awk 可以处理后续接的档案，也可以读取来自前个指令的 standard output 。但如前面说的，awk 主要是处理【每一行的字段内的数据】，而默认的【字段的分隔符为 “空格键” 或 “[tab]键”】。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="书籍 《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D-%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/tags/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之sed命令</title>
    <link href="http://yoursite.com/2017/12/29/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8Bsed%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/12/29/认识与学习BASH之sed命令/</id>
    <published>2017-12-29T09:56:35.000Z</published>
    <updated>2017-12-29T10:08:08.412Z</updated>
    
    <content type="html"><![CDATA[<p>sed 本身也是一个管线命令，可以分析 standard input 的，而且 sed 还可以将数据进行取代、删除、新增、撷取特定行等等的功能。我们先来了解一下 sed 的用法，再来聊他的用途。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sed [-nefr] [动作]</span><br><span class="line">选项与参数：</span><br><span class="line">    -n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。</span><br><span class="line">         但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">    -e ：直接在指令列模式上进行 sed 的动作编辑；</span><br><span class="line">    -f ：直接将 sed 的动作写在一个档案内，-f filename 则可以执行 filename 内的 sed 动作；</span><br><span class="line">    -r ：sed 的动作支持的是延伸型正规表示法的语法。(预设是基础正规表示法语法)</span><br><span class="line">    -i ：直接修改读取的档案内容，而不是由屏幕输出。</span><br><span class="line"></span><br><span class="line">动作说明： [n1[,n2]]function</span><br><span class="line">n1, n2 ：不见得会存在，一般代表【选择进行动作的行数】，</span><br><span class="line">        举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则【 10,20[动作行为] 】</span><br><span class="line">function 有底下这些咚咚：</span><br><span class="line">    a ：新增， a 的后面可以接字符串，而这些字符串会在新的一行出现(目前的下一行)</span><br><span class="line">    c ：取代， c 的后面可以接字符串，这些字符串可以取代 n1,n2 之间的行！</span><br><span class="line">    d ：删除，因为是删除，所以 d 后面通常不接任何咚咚；</span><br><span class="line">    i ：插入， i 的后面可以接字符串，而这些字符串会在新的一行出现(目前的上一行)；</span><br><span class="line">    p ：打印，亦即将某个选择的数据打印出。通常 p 会与参数 sed -n 一起运作</span><br><span class="line">    s ：取代，可以直接进行取代的工作。通常这个 s 的动作可以搭配正规表示法。例如 1,20s/old/new/g 就是</span><br></pre></td></tr></table></figure></p><p>下面进行一些示例：</p><h4 id="1、以行为单位的新增-删除功能"><a href="#1、以行为单位的新增-删除功能" class="headerlink" title="1、以行为单位的新增/删除功能"></a>1、以行为单位的新增/删除功能</h4><h5 id="范例一：将-etc-passwd-的内容列出并且打印行号，同时，请将第-2-5-行删除"><a href="#范例一：将-etc-passwd-的内容列出并且打印行号，同时，请将第-2-5-行删除" class="headerlink" title="范例一：将 /etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删除"></a>范例一：将 /etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删除</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed &apos;2,5d&apos;</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>sed 的动作为 ‘2,5d’ ，那个 d 就是删除。因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行了。另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行。同时也要注意的是，sed 后面接的动作，请务必以 ‘’ 两个单引号括住。</p><p>如果题型变化一下，举例来说，如果只要删除第 2 行，可以使用<code>【 nl /etc/passwd | sed &#39;2d&#39; 】</code>来达成，至于若是要删除第 3 到最后一行，则是<code>【 nl /etc/passwd | sed &#39;3,$d&#39; 】</code>，那个钱字号【 $ 】代表最后一行。</p><h5 id="范例二：承上题，在第二行后-亦即是加在第三行-加上【drink-tea-】字样"><a href="#范例二：承上题，在第二行后-亦即是加在第三行-加上【drink-tea-】字样" class="headerlink" title="范例二：承上题，在第二行后(亦即是加在第三行)加上【drink tea?】字样"></a>范例二：承上题，在第二行后(亦即是加在第三行)加上【drink tea?】字样</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed &apos;2a drink tea&apos;</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2 bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">drink tea</span><br><span class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>在 a 后面加上的字符串就已将出现在第二行后面。那如果是要在第二行前呢？<code>【 nl /etc/passwd | sed &#39;2i drink tea&#39; 】</code>就对了。就是将【 a 】变成【 i 】即可。增加一行很简单，那如果是要增将两行以上呢？</p><h5 id="范例三：在第二行后面加入两行字，例如【Drink-tea-or-…-】与【drink-beer-】"><a href="#范例三：在第二行后面加入两行字，例如【Drink-tea-or-…-】与【drink-beer-】" class="headerlink" title="范例三：在第二行后面加入两行字，例如【Drink tea or …..】与【drink beer?】"></a>范例三：在第二行后面加入两行字，例如【Drink tea or …..】与【drink beer?】</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed &apos;2a Drink tea or ......\</span><br><span class="line">&gt; drink beer ?&apos;</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2 bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">Drink tea or ......</span><br><span class="line">drink beer ?</span><br><span class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>这个范例的重点是【我们可以新增不只一行，可以新增好几行】但是每一行之间都必须要以反斜杠【 \ 】来进行新行的增加。所以，上面的例子中，我们可以发现在第一行的最后面就有 \ 存在，那是一定要的。</p><h4 id="2、以行为单位的取代与显示功能"><a href="#2、以行为单位的取代与显示功能" class="headerlink" title="2、以行为单位的取代与显示功能"></a>2、以行为单位的取代与显示功能</h4><h5 id="范例四：我想将第-2-5-行的内容取代成为【No-2-5-number】"><a href="#范例四：我想将第-2-5-行的内容取代成为【No-2-5-number】" class="headerlink" title="范例四：我想将第 2-5 行的内容取代成为【No 2-5 number】"></a>范例四：我想将第 2-5 行的内容取代成为【No 2-5 number】</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed &apos;2,5c No 2-5 number&apos;</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">No 2-5 number</span><br><span class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>透过这个方法我们就能够将数据整行取代了，非常容易吧，sed 还有更好用的。我们以前想要列出第 11~20 行，得要透过<code>【head -n 20 | tail -n 10】</code>之类的方法来处理，很麻烦。sed 则可以简单的直接取出你想要的那几行，是透过行号来的。看看底下的范例：</p><h5 id="范例五：仅列出-etc-passwd-档案内的第-5-7-行"><a href="#范例五：仅列出-etc-passwd-档案内的第-5-7-行" class="headerlink" title="范例五：仅列出 /etc/passwd 档案内的第 5-7 行"></a>范例五：仅列出 /etc/passwd 档案内的第 5-7 行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed -n &apos;5,7p&apos;</span><br><span class="line">5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br></pre></td></tr></table></figure><p>上述的指令中有个重要的选项【 -n 】，按照说明文件，这个 -n 代表的是【安静模式】。那么为什么要使用安静模式呢？你可以自行下达 sed ‘5,7p’ 就知道了 (5-7 行会重复输出)。有没有加上 -n 的参数时，输出的数据可是差很多的。你可以透过这个 sed 的以行为单位的显示功能，就能够将某一个档案内的某些行号捉出来查阅。很棒的功能！</p><h4 id="3、部分数据的搜寻并取代的功能"><a href="#3、部分数据的搜寻并取代的功能" class="headerlink" title="3、部分数据的搜寻并取代的功能"></a>3、部分数据的搜寻并取代的功能</h4><p>除了整行的处理模式之外，sed 还可以用行为单位进行部分数据的搜寻并取代的功能。基本上 sed 的搜寻与取代的与 vi 相当的类似！他有点像这样：<br><code>sed &#39;s/要被取代的字符串/新的字符串/g&#39;</code></p><p>我们使用底下这个取得 ifconfig 中 IP 数据的范例来了解一下什么是咱们所谓的搜寻并取代：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">步骤一：先观察原始讯息，利用 /sbin/ifconfig 查询 IP 为何？</span><br><span class="line">[root@www ~]# /sbin/ifconfig eth0</span><br><span class="line">eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84</span><br><span class="line">inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line">inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:Link</span><br><span class="line">UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line">.....(以下省略).....</span><br><span class="line"># 我们的重点在第二行，也就是 192.168.1.100 这一行。先利用关键词捉出那一行！</span><br><span class="line"></span><br><span class="line">步骤二：利用关键词配合 grep 撷取出关键的一行数据</span><br><span class="line">[root@www ~]# /sbin/ifconfig eth0 | grep &apos;inet addr&apos;</span><br><span class="line">inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line"># 当场仅剩下一行，接下来，我们要将开始到 addr: 通通删除，就是像底下这样：</span><br><span class="line"># inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line"># 上面的删除关键在于【 ^.*inet addr: 】。正规表示法出现！</span><br><span class="line"></span><br><span class="line">步骤三：将 IP 前面的部分予以删除</span><br><span class="line">[root@www ~]# /sbin/ifconfig eth0 | grep &apos;inet addr&apos; | \</span><br><span class="line">&gt; sed &apos;s/^.*addr://g&apos;</span><br><span class="line">192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line"># 仔细与上个步骤比较一下，前面的部分不见了！接下来则是删除后续的部分，亦即：</span><br><span class="line"># 192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line"># 此时所需的正规表示法为：【 Bcast.*$ 】</span><br><span class="line"></span><br><span class="line">步骤四：将 IP 后面的部分予以删除</span><br><span class="line">[root@www ~]# /sbin/ifconfig eth0 | grep &apos;inet addr&apos; | \</span><br><span class="line">&gt; sed &apos;s/^.*addr://g&apos; | sed &apos;s/Bcast.*$//g&apos;</span><br><span class="line">192.168.1.100</span><br></pre></td></tr></table></figure></p><h4 id="4、直接修改档案内容-危险动作"><a href="#4、直接修改档案内容-危险动作" class="headerlink" title="4、直接修改档案内容(危险动作)"></a>4、直接修改档案内容(危险动作)</h4><p>sed 甚至可以直接修改档案的内容。而不必使用管线命令或数据流重导向。不过，由于这个动作会直接修改到原始的档案，所以千万不要随便拿系统配置文件来测试，可以使用测试档案 regular_express.txt 来测试看看。</p><h5 id="范例六：利用-sed-将-regular-express-txt-内每一行结尾若为-则换成"><a href="#范例六：利用-sed-将-regular-express-txt-内每一行结尾若为-则换成" class="headerlink" title="范例六：利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !"></a>范例六：利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sed -i &apos;s/\.$/\!/g&apos; regular_express.txt</span><br><span class="line"># 上头的 -i 选项可以让你的 sed 直接去修改后面接的档案内容而不是由屏幕输出</span><br><span class="line"># 这个范例是用在取代，可自行 cat 该档案去查阅结果</span><br></pre></td></tr></table></figure><h5 id="范例七：利用-sed-直接在-regular-express-txt-最后一行加入【-This-is-a-test】"><a href="#范例七：利用-sed-直接在-regular-express-txt-最后一行加入【-This-is-a-test】" class="headerlink" title="范例七：利用 sed 直接在 regular_express.txt 最后一行加入【# This is a test】"></a>范例七：利用 sed 直接在 regular_express.txt 最后一行加入【# This is a test】</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sed -i &apos;$a # This is a test&apos; regular_express.txt</span><br><span class="line"># 由于 $ 代表的是最后一行，而 a 的动作是新增，因此该档案是最后新增</span><br></pre></td></tr></table></figure><p>sed 的【 -i 】选项可以直接修改档案内容，这功能非常有帮助。举例来说，如果你有一个 100 万行的档案，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为档案太大了！那怎办？就利用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修订。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sed 本身也是一个管线命令，可以分析 standard input 的，而且 sed 还可以将数据进行取代、删除、新增、撷取特定行等等的功能。我们先来了解一下 sed 的用法，再来聊他的用途。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="书籍 《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D-%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/tags/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之正规表示法与延伸正规表示法</title>
    <link href="http://yoursite.com/2017/12/29/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8B%E6%AD%A3%E8%A7%84%E8%A1%A8%E7%A4%BA%E6%B3%95%E4%B8%8E%E5%BB%B6%E4%BC%B8%E6%AD%A3%E8%A7%84%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/29/认识与学习BASH之正规表示法与延伸正规表示法/</id>
    <published>2017-12-29T07:55:29.000Z</published>
    <updated>2017-12-29T08:29:08.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、正规表示法"><a href="#一、正规表示法" class="headerlink" title="一、正规表示法"></a>一、正规表示法</h2><p>正规表示法 (Regular Expression, RE, 或称为常规表示法)是透过一些特殊字符的排列，用以【搜寻/取代/删除】一列或多列文字字符串，简单的说，正规表示法就是用在字符串的处理上面的一项【表示式】。正规表示法并不是一个工具程序，而是一个字符串处理的标准依据，如果您想要以正规表示法的方式处理字符串，就得要使用支持正规表示法的工具程序才行，这类的工具程序很多，例如 vi, sed, awk 等等。</p><h3 id="1、什么是正规表示法"><a href="#1、什么是正规表示法" class="headerlink" title="1、什么是正规表示法"></a>1、什么是正规表示法</h3><p>简单的说，正规表示法就是处理字符串的方法，他是以行为单位来进行字符串的处理行为，正规表示法透过一些特殊符号的辅助，可以让使用者轻易的达到【搜寻/删除/取代】某特定字符串的处理程序。<br><a id="more"></a><br>举个系统常见的例子，假如你发现系统在开机的时候，出现一个关于 mail 程序的错误，而开机过程的相关程序都是在 /etc/init.d/ 底下，也就是说，在该目录底下的某个档案内具有 mail 这个关键词，你想要将该档案捉出来进行查询修改的动作。此时你怎么找出来含有这个关键词的档案？你当然可以一个档案一个档案的开启，然后去搜寻 mail 这个关键词，只是…..该目录底下的档案可能不止100 个。如果了解正规表示法的相关技巧，那么只要一行指令就找出来：<code>【grep &#39;mail&#39; /etc/init.d/*】</code>那个 grep 就是支持正规表示法的工具程序之一。</p><p>谈到这里就得要进一步说明，正规表示法基本上是一种【表示法】，只要工具程序支持这种表示法，那么该工具程序就可以用来作为正规表示法的字符串处理之用。例如 vi, grep, awk ,sed 等等工具，因为她们有支持正规表示法，所以，这些工具就可以使用正规表示法的特殊字符来进行字符串的处理。但例如 cp, ls 等指令并未支持正规表示法，所以就只能使用 bash 自己本身的通配符而已。</p><h3 id="2、正规表示法与Shell在Linux当中的角色定位："><a href="#2、正规表示法与Shell在Linux当中的角色定位：" class="headerlink" title="2、正规表示法与Shell在Linux当中的角色定位："></a>2、正规表示法与Shell在Linux当中的角色定位：</h3><p>我们谈到的这个正规表示法，就有点像是数学的九九表一样，是 Linux 基础当中的基础，虽然也是最难的部分，不过，如果学成了之后，一定是【大大的有帮助】的。这就好像是金庸小说里面的学武难关：任督二脉！ 打通任督二脉之后，武功立刻成倍成长！所以，不论是对于系统的认识与系统的管理部分，他都有很棒的辅助。</p><h3 id="3、延伸的正规表示法："><a href="#3、延伸的正规表示法：" class="headerlink" title="3、延伸的正规表示法："></a>3、延伸的正规表示法：</h3><p>正规表示法的字符串表示方式依照不同的严谨度而分为： 基础正规表示法与延伸正规表示法。延伸型正规表示法除了简单的一组字符串处理之外，还可以作群组的字符串处理，例如进行搜寻VBird 或 netman 或 lman 的搜寻，注意，是【或(or)】而不是【和(and)】的处理，此时就需要延伸正规表示法的帮助，藉由特殊的【 ( 】与【 | 】等字符的协助，就能够达到这样的目的。不过，我们在这里主要介绍最基础的基础正规表示法。<br><strong>（注：有一点要向大家报告说明清楚，那就是：【正规表示法与通配符是完全不一样的东西！】这很重要。因为【通配符 (wildcard) 代表的是 bash 操作接口的一个功能】，但正规表示法则是一种字符串处理的表示方式，这两者要分的很清楚才行。)</strong></p><h3 id="4、通过grep实例演示来学习正规表示法："><a href="#4、通过grep实例演示来学习正规表示法：" class="headerlink" title="4、通过grep实例演示来学习正规表示法："></a>4、通过grep实例演示来学习正规表示法：</h3><p>新建regular_express.txt文档及测试内容：</p><blockquote><p>“Open Source” is a good mechanism to develop programs.<br>apple is my favorite food.<br>Football game is not use feet only.<br>this dress doesn’t fit me.<br>However, this dress is about $ 3183 dollars.<br>GNU is free air not free beer.<br>Her hair is very beauty.<br>I can’t finish the test.<br>Oh! The soup taste good.<br>motorcycle is cheap than car.<br>This window is clear.<br>the symbol ‘*’ is represented as start.<br>Oh!    My god!<br>The gd software is a library for drafting programs.<br>You are the best is mean you are the no. 1.<br>The world <happy> is the same with “glad”.<br>I like dog.<br>google is the best tools for search keyword.<br>goooooogle yes!<br>go! go! Let’s go.<br># I am VBird</happy></p></blockquote><p>共有22行，最底下一行为空白行！现在开始我们一个案例一个案例的来介绍。</p><h4 id="例题一：搜寻特定字符串"><a href="#例题一：搜寻特定字符串" class="headerlink" title="例题一：搜寻特定字符串"></a>例题一：搜寻特定字符串</h4><p>假设我们要从刚刚的档案当中取得 the 这个特定字符串，最简单的方式就是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;the&apos; regular_express.txt</span><br><span class="line">8:I can&apos;t finish the test.</span><br><span class="line">12:the symbol &apos;*&apos; is represented as start.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br><span class="line">16:The world &lt;Happy&gt; is the same with &quot;glad&quot;.</span><br><span class="line">18:google is the best tools for search keyword.</span><br></pre></td></tr></table></figure></p><p>那如果想要【反向选择】呢？也就是说，当该行没有 ‘the’ 这个字符串时才显示在屏幕上，那就直接使用：<br><code>[root@www ~]# grep -vn &#39;the&#39; regular_express.txt</code></p><p>接下来，如果你想要取得不论大小写的 the 这个字符串，则：<br><code>[root@www ~]# grep -in &#39;the&#39; regular_express.txt</code></p><h4 id="例题二、利用中括号-来搜寻集合字符"><a href="#例题二、利用中括号-来搜寻集合字符" class="headerlink" title="例题二、利用中括号 [] 来搜寻集合字符"></a>例题二、利用中括号 [] 来搜寻集合字符</h4><p>如果我想要搜寻 test 或 taste 这两个单字时，可以发现到，其实她们有共通的 ‘t?st’ 存在。这个时候，我可以这样来搜寻：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;t[ae]st&apos; regular_express.txt</span><br><span class="line">8:I can&apos;t finish the test.</span><br><span class="line">9:Oh! The soup taste good.</span><br></pre></td></tr></table></figure></p><p>其实 [] 里面不论有几个字符，他都谨代表某【一个】字符，所以，上面的例子说明了，我需要的字符串是【tast】或【test】两个字符串而已。</p><p>而如果想要搜寻到有 oo 的字符时，则使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;oo&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure></p><p>但是，如果我不想要 oo 前面有 g 的话呢？此时，可以利用在集合字符的反向选择 [^] 来达成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;[^g]oo&apos; regular_express.txt</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure></p><p>假设我 oo 前面不想要有小写字符，所以，我可以这样写 [^abcd….z]oo ，但是这样似乎不怎么方便，由于小写字符的 ASCII 上编码的顺序是连续的，因此，我们可以将之简化为底下这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;[^a-z]oo&apos; regular_express.txt</span><br><span class="line">3:Football game is not use feet only.</span><br></pre></td></tr></table></figure></p><p>也就是说，当我们在一组集合字符中，如果该字符组是连续的，例如大写英文/小写英文/数字等等，就可以使用<code>[a-z],[A-Z],[0-9]</code>等方式来书写，那么如果我们的要求字符串是数字与英文呢？就将他全部写在一起，变成：<code>[a-zA-Z0-9]</code>。</p><h4 id="例题三、行首与行尾字符"><a href="#例题三、行首与行尾字符" class="headerlink" title="例题三、行首与行尾字符 ^ $"></a>例题三、行首与行尾字符 ^ $</h4><p>我们在例题一当中，可以查询到一行字符串里面有 the 的，那如果我想要让 the 只在行首列出呢？这个时候就得要使用制表符了。我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;^the&apos; regular_express.txt</span><br><span class="line">12:the symbol &apos;*&apos; is represented as start.</span><br></pre></td></tr></table></figure></p><p>那如果我不想要开头是英文字母，则可以是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;^[^a-zA-Z]&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">21:# I am VBird</span><br></pre></td></tr></table></figure></p><p>注意到了吧？那个 ^ 符号，在字符集合符号(括号[])之内与之外是不同的！在 [] 内代表【反向选择】，在 [] 之外则代表定位在行首的意义！</p><p>如果我想要找出来，行尾结束为小数点 (.) 的那一行，该如何处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;\.$&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">4:this dress doesn&apos;t fit me.</span><br><span class="line">10:motorcycle is cheap than car.</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>特别注意到，因为小数点具有其他意义(底下会介绍)，所以必须要使用跳脱字符<code>(\)</code>来加以解除其特殊意义！</p><p>那么如果我想要找出来，哪一行是【空白行】，也就是说，该行并没有输入任何数据，该如何搜寻？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;^$&apos; regular_express.txt</span><br><span class="line">22:</span><br></pre></td></tr></table></figure></p><p>因为只有行首跟行尾 (^$)，所以，这样就可以找出空白行了。</p><p>假设你已经知道在一个程序脚本(shell script)或者是配置文件当中，空白行与开头为 # 的那一行是批注，因此如果你要将资料列出给别人参考时，可以将这些数据省略掉以节省保贵的纸张，那么你可以怎么作呢？我们以<code>/etc/syslog.conf</code> 这个档案来作范例，你可以自行参考一下输出的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat -n /etc/syslog.conf</span><br><span class="line"># 在 CentOS 中，结果可以发现有 26 行的输出，很多空白行与 # 开头</span><br><span class="line">[root@www ~]# grep -v &apos;^$&apos; /etc/syslog.conf | grep -v &apos;^#&apos;</span><br><span class="line"># 结果仅有 7 行，其中第一个【 -v &apos;^$&apos; 】代表【不要空白行】，</span><br><span class="line"># 第二个【 -v &apos;^#&apos; 】代表【不要开头是 # 的那行】</span><br></pre></td></tr></table></figure></p><h4 id="例题四、任意一个字符-与重复字符"><a href="#例题四、任意一个字符-与重复字符" class="headerlink" title="例题四、任意一个字符 . 与重复字符 *"></a>例题四、任意一个字符 . 与重复字符 *</h4><p>我们知道通配符 * 可以用来代表任意(0 或多个)字符，但是正规表示法并不是通配符，两者之间是不相同的。至于正规表示法当中的【 . 】则代表【绝对有一个任意字符】的意思。这两个符号在正规表示法的意义如下：</p><pre><code>. (小数点)：代表【一定有一个任意字符】的意思；* (星星号)：代表【重复前一个 0 到无穷多次】的意思，为组合形态</code></pre><p>我们直接做个练习吧。假设我需要找出 g??d 的字符串，亦即共有四个字符，起头是 g 而结束是 d ，我可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;g..d&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">16:The world &lt;Happy&gt; is the same with &quot;glad&quot;.</span><br></pre></td></tr></table></figure></p><p>因为 * 代表的是【重复 0 个或多个前面的 RE 字符】的意义，因此，【o*】代表的是：【拥有空字符或一个 o 以上的字符】，特别注意，因为允许空字符(就是有没有字符都可以的意思)，因此，<code>【 grep -n &#39;o*&#39; regular_express.txt 】</code>将会把所有的数据都打印出到屏幕上。因此，当我们需要【至少两个 o 以上的字符串】时，就需要 ooo* ，亦即是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;ooo*&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure></p><h4 id="例题五、限定连续-RE-字符范围"><a href="#例题五、限定连续-RE-字符范围" class="headerlink" title="例题五、限定连续 RE 字符范围 {}"></a>例题五、限定连续 RE 字符范围 {}</h4><p>在上个例题当中，我们可以利用 . 与 RE 字符及 * 来设定 0 个到无限多个重复字符，那如果我想要限制一个范围区间内的重复字符数呢？举例来说，我想要找出两个到五个 o 的连续字符串，该如何作？这时候就得要使用到限定范围的字符 {} 了。但因为 { 与 } 的符号在 shell 是有特殊意义的，因此，我们必须要使用跳脱字符 \ 来让他失去特殊意义才行。至于 {} 的语法是这样的，假设我要找到两个 o 的字符串，可以是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;o\&#123;2\&#125;&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure></p><p>这样看似乎与 ooo* 的字符没有什么差异？因为第 19 行有多个 o 依旧也出现了。那么换个搜寻的字符串，假设我们要找出 g 后面接 2 到 5 个 o ，然后再接一个 g 的字符串，他会是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;go\&#123;2,5\&#125;g&apos; regular_express.txt</span><br><span class="line">18:google is the best tools for search keyword.</span><br></pre></td></tr></table></figure></p><h3 id="5、基础正规表示法字符汇整-characters"><a href="#5、基础正规表示法字符汇整-characters" class="headerlink" title="5、基础正规表示法字符汇整 (characters)"></a>5、基础正规表示法字符汇整 (characters)</h3><p>经过了上面的几个简单的范例，我们可以将基础的正规表示法特殊字符汇整如下：</p><style>table th:first-of-type {    width: 100px;}</style><table><thead><tr><th>RE字符</th><th>意义与范例</th></tr></thead><tbody><tr><td>^word</td><td>意义：待搜寻的字符串(word)在行首！<br> 范例：搜寻行首为 # 开始的那一行，并列出行号 <br> <code>grep -n &#39;^#&#39; regular_express.txt</code></td></tr><tr><td>word$</td><td>意义：待搜寻的字符串(word)在行尾！ <br> 范例：将行尾为 ! 的那一行打印出来，并列出行号 <br> <code>grep -n &#39;!$&#39; regular_express.txt</code></td></tr><tr><td> .</td><td>意义：代表【一定有一个任意字符】的字符！ <br> 范例：搜寻的字符串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间【一定】仅有一个字符，而空格符也是字符！ <br> <code>grep -n &#39;e.e&#39; regular_express.txt</code></td></tr><tr><td> \</td><td>意义：跳脱字符，将特殊符号的特殊意义去除！ <br> 范例：搜寻含有单引号 ‘ 的那一行！ <br> <code>grep -n \&#39; regular_express.txt</code></td></tr><tr><td>  *</td><td>意义：重复零个到无穷多个的前一个 RE 字符 <br> 范例：找出含有 (es) (ess) (esss) 等等的字符串，注意，因为 <em> 可以是 0 个，所以 es 也是符合带搜寻字符串。另外，因为 </em> 为重复【前一个 RE 字符】的符号，因此，在 <em> 之前必须要紧接着一个 RE 字符。例如任意字符则为【.</em>】！ <br> <code>grep -n &#39;ess*&#39; regular_express.txt</code></td></tr><tr><td>[list]</td><td>意义：字符集合的 RE 字符，里面列出想要撷取的字符！ <br> 范例：搜寻含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在 [] 当中【谨代表一个待搜寻的字符】，例如【 a[afl]y 】代表搜寻的字符串可以是 aay, afy, aly 即[afl] 代表 a 或 f 或 l 的意思！ <br> <code>grep -n &#39;g[ld]&#39; regular_express.txt</code></td></tr><tr><td>[n1-n2]</td><td>意义：字符集合的 RE 字符，里面列出想要撷取的字符范围！ <br> 范例：搜寻含有任意数字的那一行！需特别留意，在字符集合 [] 中的减号 - 是有特殊意义的，他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码有关，因此，你的编码需要设定正确(在 bash 当中，需要确定 LANG 与 LANGUAGE 的变量是否正确！) 例如所有大写字符则为 [A-Z] <br> <code>grep -n &#39;[0-9]&#39; regular_express.txt</code></td></tr><tr><td>[^list]</td><td>意义：字符集合的 RE 字符，里面列出不要的字符串或范围！ <br> 范例：搜寻的字符串可以是 (oog) (ood) 但不能是 (oot) ，那个 ^ 在 [] 内时，代表的意义是【反向选择】的意思。 例如，我不要大写字符，则为 [^A-Z]。但是，需要特别注意的是，如果以 <code>grep -n [^A-Z] regular_express.txt</code>来搜寻，即发现该档案内的所有行都被列出，为什么？因为这个 [^A-Z] 是【非大写字符】的意思，因为每一行均有非大写字符，例如第一行的 “Open Source” 就有 p,e,n,o….等等的小写字 <br> <code>grep -n &#39;oo[^t]&#39; regular_express.txt</code></td></tr><tr><td>\{n,m\}</td><td>意义：连续 n 到 m 个的【前一个 RE 字符】 <br> 意义：若为 \{n\} 则是连续 n 个的前一个 RE 字符， <br> 意义：若是 \{n,\} 则是连续 n 个以上的前一个 RE 字符！ 范例：在 g 与 g 之间有2 个到 3 个的 o 存在的字符串，亦即 (goog)(gooog) <br> <code>grep -n &#39;go\\{2,3\\}g&#39; regular_express.txt</code></td></tr></tbody></table><p>再次强调：【正规表示法的特殊字符】与一般在指令列输入指令的【通配符】并不相同，例如，在通配符当中的 * 代表的是【 0 ~ 无限多个字符】的意思，但是在正规表示法当中， * 则是【重复 0 到无穷多个的前一个 RE 字符】的意思。使用的意义并不相同，不要搞混了。</p><h2 id="二、延伸正规表示法"><a href="#二、延伸正规表示法" class="headerlink" title="二、延伸正规表示法"></a>二、延伸正规表示法</h2><p>事实上，一般读者只要了解基础型的正规表示法大概就已经相当足够了，不过，某些时刻为了要简化整个指令操作，了解一下使用范围更广的延伸型正规表示法的表示式会更方便。举个简单的例子，我们要去除空白行与行首为 # 的行列，使用的是<br><code>grep -v &#39;^$&#39; regular_express.txt | grep -v &#39;^#&#39;</code><br>需要使用到管线命令来搜寻两次！那么如果使用延伸型的正规表示法，我们可以简化为：<br><code>egrep -v &#39;^$|^#&#39; regular_express.txt</code><br>延伸型正规表示法可以透过群组功能【 | 】来进行一次搜寻！那个在单引号内的管线意义为【或 or】。此外，grep 预设仅支持基础正规表示法，如果要使用延伸型正规表示法，你可以使用 grep -E ，不过更建议直接使用 egrep ！直接区分指令比较好记忆！其实 egrep 与 grep -E 是类似命令别名的关系。</p><table><thead><tr><th>RE字符</th><th>意义与范例</th></tr></thead><tbody><tr><td> +</td><td>意义：重复【一个或一个以上】的前一个 RE 字符 <br> 范例：搜寻 (god) (good) (goood)… 等等的字符串。那个 o+ 代表【一个以上的 o 】所以，底下的执行成果会将第 1, 9, 13 行列出来。 <br> <code>egrep -n &#39;go+d&#39; regular_express.txt</code></td></tr><tr><td> ?</td><td>意义：【零个或一个】的前一个 RE 字符 <br> 范例：搜寻 (gd) (god) 这两个字符串。 那个 o? 代表【空的或 1 个 o 】所以，上面的执行成果会将第 13, 14 行列出来。有没有发现到，这两个案例( ‘go+d’ 与 ‘go?d’ )的结果集合与 ‘go*d’ 相同？想想看，这是为什么！ <br> <code>egrep -n &#39;go?d&#39; regular_express.txt</code></td></tr><tr><td>  &#124;</td><td>意义：用或( or )的方式找出数个字符串 <br> 范例：搜寻 gd 或 good 这两个字符串，注意，是【或】！ 所以，第 1,9,14 这三行都可以被打印出来。那如果还想要找出 dog 呢？ <br> <code>egrep -n &#39;gd&amp;#124;good&#39; regular_express.txt</code> <br> <code>egrep -n &#39;gd&amp;#124;good&amp;#124;dog&#39; regular_express.txt</code></td></tr><tr><td> ()</td><td>意义：找出【群组】字符串 <br> 范例：搜寻 (glad) 或 (good) 这两个字符串，因为 g 与 d 是重复的，所以，我就可以将 la 与 oo 列于 ( ) 当中，并以 &#124; 来分隔开来，就可以。 <br> <code>egrep -n &#39;g(la&amp;#124;oo)d&#39; regular_express.txt</code></td></tr><tr><td> ()+</td><td>意义：多个重复群组的判别 <br> 范例：将【AxyzxyzxyzxyzC】用 echo 叫出，然后再使用如下的方法搜寻一下！ <br> echo ‘AxyzxyzxyzxyzC’ &#124; egrep ‘A(xyz)+C’ <br> 上面的例子意思是说，我要找开头是 A 结尾是 C ，中间有一个以上的 “xyz” 字符串的意思</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、正规表示法&quot;&gt;&lt;a href=&quot;#一、正规表示法&quot; class=&quot;headerlink&quot; title=&quot;一、正规表示法&quot;&gt;&lt;/a&gt;一、正规表示法&lt;/h2&gt;&lt;p&gt;正规表示法 (Regular Expression, RE, 或称为常规表示法)是透过一些特殊字符的排列，用以【搜寻/取代/删除】一列或多列文字字符串，简单的说，正规表示法就是用在字符串的处理上面的一项【表示式】。正规表示法并不是一个工具程序，而是一个字符串处理的标准依据，如果您想要以正规表示法的方式处理字符串，就得要使用支持正规表示法的工具程序才行，这类的工具程序很多，例如 vi, sed, awk 等等。&lt;/p&gt;
&lt;h3 id=&quot;1、什么是正规表示法&quot;&gt;&lt;a href=&quot;#1、什么是正规表示法&quot; class=&quot;headerlink&quot; title=&quot;1、什么是正规表示法&quot;&gt;&lt;/a&gt;1、什么是正规表示法&lt;/h3&gt;&lt;p&gt;简单的说，正规表示法就是处理字符串的方法，他是以行为单位来进行字符串的处理行为，正规表示法透过一些特殊符号的辅助，可以让使用者轻易的达到【搜寻/删除/取代】某特定字符串的处理程序。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/tags/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之管线命令</title>
    <link href="http://yoursite.com/2017/12/28/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8B%E7%AE%A1%E7%BA%BF%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/12/28/认识与学习BASH之管线命令/</id>
    <published>2017-12-28T11:11:21.000Z</published>
    <updated>2017-12-29T06:40:39.369Z</updated>
    
    <content type="html"><![CDATA[<p>就如同《数据流导向》所说的，bash 命令执行的时候有输出的数据会出现，那么如果这群数据必需要经过几道手续之后才能得到我们所想要的格式，应该如何来设定？这就牵涉到管线命令的问题(pipe) ，管线命令使用的是【 | 】这个界定符号。另外，管线命令与【连续下达命令】是不一样的。这点底下我们会再说明。底下我们先举一个例子来说明一下简单的管线命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：显示/etc/地下有多少个档案，并且利用less指令来分页显示</span><br><span class="line">[root@www ~]# ls -al /etc | less</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>其实这个管线命令【 | 】仅能处理经由前面一个指令传来的正确信息，也就是 standard output 的信息，对于 stdandard error 并没有直接处理的能力。那么整体的管线命令可以使用下图表示：<br><img src="/uploads/2017/12/linux_pipe_command.JPG" alt=""></p><p><font color="red">在每个管线后面接的第一个数据必定是【指令】(管线指令)。</font>而且这个指令必须要能够接收 standard input 的数据才行，这样的指令才可以是为【管线命令】，例如 less, more, head, tail 等都是可以接收 standard input 的管线命令。至于例如 ls, cp, mv 等就不是管线命令。因为 ls, cp, mv 并不会接收来自 stdin的数据。也就是说，管线命令主要有两个比较需要注意的地方：</p><blockquote><p>1.管线命令仅会处理 standard output，对于 standard error output 会予以忽略<br>2.管线命令必须要能够接收来自前一个指令的数据成为 standard input 继续处理才行。</p></blockquote><h3 id="1、撷取命令：-cut-grep"><a href="#1、撷取命令：-cut-grep" class="headerlink" title="1、撷取命令： cut, grep"></a>1、撷取命令： cut, grep</h3><p>什么是撷取命令？就是将一段数据经过分析后，取出我们所想要的。或者是经由分析关键词，取得我们所想要的那一行。不过，要注意的是，一般来说，撷取讯息通常是针对【一行一行】来分析的，并不是整篇讯息分析的，底下我们介绍两个很常用的讯息撷取命令：</p><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>这个指令可以将一段讯息的某一段给他【切】出来，处理的讯息是以【行】为单位，底下我们就来谈一谈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cut -d&apos;分隔字符&apos; -f fields &lt;==用于有特定分隔字符</span><br><span class="line">[root@www ~]# cut -c 字符区间 &lt;==用于排列整齐的讯息</span><br><span class="line">选项与参数：</span><br><span class="line">    -d ：后面接分隔字符。与 -f 一起使用；</span><br><span class="line">    -f ：依据 -d 的分隔字符将一段讯息分割成为数段，用 -f 取出第几段的意思；</span><br><span class="line">    -c ：以字符 (characters) 的单位取出固定字符区间；</span><br><span class="line">范例一：将 PATH 变量取出，我要找出第五个路径。</span><br><span class="line">[root@www ~]# echo $PATH</span><br><span class="line">/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games:</span><br><span class="line"># 1 | 2 | 3 | 4 | 5 | 6 | 7</span><br><span class="line"></span><br><span class="line">[root@www ~]# echo $PATH | cut -d &apos;:&apos; -f 5</span><br><span class="line"># 如同上面的数字显示，我们是以【 : 】作为分隔，因此会出现 /usr/local/bin</span><br><span class="line"># 那么如果想要列出第 3 与第 5 呢？，就是这样：</span><br><span class="line">[root@www ~]# echo $PATH | cut -d &apos;:&apos; -f 3,5</span><br><span class="line">范例二：将 export 输出癿讯息，取得第 12 字符以后的所有字符串</span><br><span class="line">[root@www ~]# export</span><br><span class="line">declare -x HISTSIZE=&quot;1000&quot;</span><br><span class="line">declare -x INPUTRC=&quot;/etc/inputrc&quot;</span><br><span class="line">declare -x KDEDIR=&quot;/usr&quot;</span><br><span class="line">declare -x LANG=&quot;zh_TW.big5&quot;</span><br><span class="line">.....(其他省略).....</span><br><span class="line"># 注意看，每个数据都是排列整齐的输出！如果我们不想要【declare -x】时，就得这么做：</span><br><span class="line">[root@www ~]# export | cut -c 12-</span><br><span class="line">HISTSIZE=&quot;1000&quot;</span><br><span class="line">INPUTRC=&quot;/etc/inputrc&quot;</span><br><span class="line">KDEDIR=&quot;/usr&quot;</span><br><span class="line">LANG=&quot;zh_TW.big5&quot;</span><br><span class="line">.....(其他省略).....</span><br><span class="line"># 知道怎么回事了吧？用 -c 可以处理比较具有格式的输出数据！</span><br><span class="line"># 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等等！</span><br></pre></td></tr></table></figure></p><p><em>cut 主要的用途在于将【同一行里面的数据进行分解！】最常使用在分析一些数据或文字数据的时候！这是因为有时候我们会以某些字符当作分割的参数，然后来将数据加以切割，以取得我们所需要的数据。</em></p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>刚刚的 cut 是将一行讯息当中，取出某部分我们想要的，而 grep 则是分析一行讯息，若当中有我们所需要的信息，就将该行拿出来，简单的语法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep [-acinv] [--color=auto] &apos;搜寻字符串&apos; filename</span><br><span class="line">选项与参数：</span><br><span class="line">    -a ：将 binary 档案以 text 档案的方式搜寻数据</span><br><span class="line">    -c ：计算找到 &apos;搜寻字符串&apos; 的次数</span><br><span class="line">    -i ：忽略大小写的不同，所以大小写视为相同</span><br><span class="line">    -n ：顺便输出行号</span><br><span class="line">    -v ：反向选择，亦即显示出没有 &apos;搜寻字符串&apos; 内容的那一行！</span><br><span class="line">    --color=auto ：可以将找到的关键词部分加上颜色的显示。</span><br><span class="line"></span><br><span class="line">范例一：将 last 当中，有出现 root 的那一行就取出来；</span><br><span class="line">[root@www ~]# last | grep &apos;root&apos;</span><br><span class="line">范例二：与范例一相反，只要没有 root 的就取出！</span><br><span class="line">[root@www ~]# last | grep -v &apos;root&apos;</span><br><span class="line">范例三：在 last 的输出讯息中，只要有 root 就取出，并且仅取第一栏</span><br><span class="line">[root@www ~]# last | grep &apos;root&apos; |cut -d &apos; &apos; -f1</span><br><span class="line">范例四：取出 /etc/man.config 内含 MANPATH 的那几行</span><br><span class="line">[root@www ~]# grep --color=auto &apos;MANPATH&apos; /etc/man.config</span><br><span class="line">....(前面省略)....</span><br><span class="line">MANPATH_MAP /usr/X11R6/bin /usr/X11R6/man</span><br><span class="line">MANPATH_MAP /usr/bin/X11 /usr/X11R6/man</span><br><span class="line">MANPATH_MAP /usr/bin/mh /usr/share/man</span><br><span class="line">（如果加上 --color=auto 的选项，找到的关键词部分会用特殊颜色显示。）</span><br></pre></td></tr></table></figure></p><h3 id="2、排序命令：-sort-wc-uniq"><a href="#2、排序命令：-sort-wc-uniq" class="headerlink" title="2、排序命令： sort, wc, uniq"></a>2、排序命令： sort, wc, uniq</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>他可以帮我们进行排序，而且可以依据不同的数据型态来排序。例如数字与文字的排序就不一样。此外，排序的字符与语系的编码有关，因此，如果您需要排序时，建议使用LANG=C来让语系统一，数据排序会比较好一些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sort [-fbMnrtuk] [file or stdin]</span><br><span class="line">选项与参数：</span><br><span class="line">    -f ：忽略大小写的差异，例如 A 与 a 规为编码相同；</span><br><span class="line">    -b ：忽略最前面的空格符部分；</span><br><span class="line">    -M ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；</span><br><span class="line">    -n ：使用【纯数字】进行排序(默认是以文字型态来排序的)；</span><br><span class="line">    -r ：反向排序；</span><br><span class="line">    -u ：就是 uniq ，相同的数据中，仅出现一行代表；</span><br><span class="line">    -t ：分隔符，预设是用 [tab] 键来分隔；</span><br><span class="line">    -k ：以那个区间 (field) 来进行排序的意思</span><br><span class="line"></span><br><span class="line">范例一：个人账号都记录在 /etc/passwd 下，请将账号进行排序。</span><br><span class="line">[root@www ~]# cat /etc/passwd | sort</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">apache:x:48:48:Apache:/var/www:/sbin/nologin</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">#由上面的数据看起来，sort 是预设【以第一个】数据来排序，而且默认是以【文字】型态来排序的。所以由a开始排到最后。</span><br><span class="line">范例二：/etc/passwd 内容是以 : 来分割的，我想以第三栏来排序，该如何？</span><br><span class="line">[root@www ~]# cat /etc/passwd | sort -t &apos;:&apos; -k 3</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line"># 如果是以文字型态来排序的，就是会这样，想要使用数字排序：</span><br><span class="line"># cat /etc/passwd | sort -t &apos;:&apos; -k 3 -n</span><br><span class="line"># 这样才行。用那个 -n 来告知 sort 以数字来排序。</span><br></pre></td></tr></table></figure></p><h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>如果我排序完成了，想要将重复的资料仅列出一个显示，可以怎么做呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# uniq [-ic]</span><br><span class="line">选项与参数：</span><br><span class="line">    -i ：忽略大小写字符的不同；</span><br><span class="line">    -c ：进行计数</span><br><span class="line">范例一：使用 last 将账号列出，仅取出账号栏，进行排序后仅取出一位；</span><br><span class="line">[root@www ~]# last | cut -d &apos; &apos; -f1 | sort | uniq</span><br><span class="line">范例二：承上题，如果我还想要知道每个人的登入总次数</span><br><span class="line">[root@www ~]# last | cut -d &apos; &apos; -f1 | sort | uniq -c</span><br><span class="line">1</span><br><span class="line">12 reboot</span><br><span class="line">41 root</span><br><span class="line">1 wtmp</span><br><span class="line"># 从上面的结果可以发现 reboot 有 12 次， root 登入则有 41 次。wtmp与第一行的空白都是last的默认字符，那两个可以忽略。</span><br></pre></td></tr></table></figure></p><p><em>这个指令用来将【重复的行删除掉只显示一个】，举个例子来说，你要知道这个月份登入你主机的用户有谁，而不在乎他的登入次数，那么就使用上面的范例，(1)先将所有的数据列出；(2)再将人名独立出来；(3)经过排序；(4)只显示一个！由于这个指令是在将重复的东西减少，所以当然需要【配合排序过的档案】来处理。</em></p><h3 id="3、统计命令：wc"><a href="#3、统计命令：wc" class="headerlink" title="3、统计命令：wc"></a>3、统计命令：wc</h3><p>如果我想要知道 /etc/man.config这个档案里面有多少字？多少行？多少字符的话，可以利用wc这个指令来达成，他可以帮我们计算输出的讯息的整体数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# wc [-lwm]</span><br><span class="line">选项与参数：</span><br><span class="line">    -l ：仅列出行；</span><br><span class="line">    -w ：仅列出多少字(英文单字)；</span><br><span class="line">    -m ：多少字符；</span><br></pre></td></tr></table></figure></p><p><em>当你要知道目前你的账号档案中有多少个账号时，就使用这个方法：【cat /etc/passwd | wc -l】。因为/etc/passwd里头一行代表一个使用者。所以知道行数就晓得有多少账号在里头。而如果要计算一个档案里头有多少个字符时，就使用 wc -c 这个选项。</em></p><h3 id="4、字符转换命令：-tr-col-join-paste-expand"><a href="#4、字符转换命令：-tr-col-join-paste-expand" class="headerlink" title="4、字符转换命令： tr, col, join, paste, expand"></a>4、字符转换命令： tr, col, join, paste, expand</h3><p>我们在 vim 程序编辑器当中，提到过 DOS 断行字符与 Unix 断行字符的不同，并且可以使用 dos2unix 与 unix2dos 来完成转换。当然，还有其他的替代方案，底下我们就来介绍一下这些字符转换命令在管线当中的使用方法：</p><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# tr [-ds] SET1 ...</span><br><span class="line">选项与参数：</span><br><span class="line">    -d ：删除讯息当中的 SET1 这个字符串；</span><br><span class="line">    -s ：取代掉重复的字符！</span><br><span class="line">范例一：将 last 输出的讯息中，所有的小写变成大写字符：</span><br><span class="line">[root@www ~]# last | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;</span><br><span class="line"># 事实上，没有加上单引号也是可以执行的，如：【 last | tr [a-z] [A-Z] 】</span><br><span class="line">范例二：将 /etc/passwd 输出的讯息中，将冒号 (:) 删除</span><br><span class="line">[root@www ~]# cat /etc/passwd | tr -d &apos;:&apos;</span><br></pre></td></tr></table></figure></p><p>相信处理 Linux &amp; Windows 系统中的人们最麻烦的一件事就是 DOS 底下会自动的在每行行尾加入^M 这个断行符号。使用 tr 将 ^M 可以使用 \r 来代替就可以去除 DOS 档案留下来的 ^M 这个断行的符号。这东西相当的有用！</p><h4 id="col"><a href="#col" class="headerlink" title="col"></a>col</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# col [-xb]</span><br><span class="line">选项与参数：</span><br><span class="line">    -x ：将 tab 键转换成对等的空格键</span><br><span class="line">    -b ：在文字内有反斜杠 (/) 时，仅保留反斜杠最后接的那个字符</span><br></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>join 看字面上的意义 (加入/参加) 就可以知道，他是在处理两个档案之间的数据，而且，主要是在处理【两个档案当中，有”相同数据”的那一行，才将他加在一起】的意思。我们利用底下的简单例子来说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# join [-ti12] file1 file2</span><br><span class="line">选项与参数：</span><br><span class="line">    -t ：join 默认以空格符分隔数据，并且比对【第一个字段】的数据，如果两个档案相同，则将两笔数据联成一行，且第一个字段放在第一个</span><br><span class="line">    -i ：忽略大小写的差异；</span><br><span class="line">    -1 ：这个是数字的 1 ，代表【第一个档案要用那个字段来分析】的意思；</span><br><span class="line">    -2 ：代表【第二个档案要用那个字段来分析】的意思。</span><br><span class="line"></span><br><span class="line">范例一：用 root 的身份，将 /etc/passwd 与 /etc/shadow 相关数据整合成一栏</span><br><span class="line">[root@www ~]# join -t &apos;:&apos; /etc/passwd /etc/shadow</span><br><span class="line"># 透过上面这个动作，我们可以将两个档案第一字段相同者整合成一行。第二个档案的相同字段并不会显示</span><br><span class="line">范例二：我们知道 /etc/passwd 第四个字段是 GID ，那个 GID 记录在 /etc/group 当中的第三个字段</span><br><span class="line">[root@www ~]# join -t &apos;:&apos; -1 4 /etc/passwd -2 3 /etc/group</span><br><span class="line"># 同样的，相同的字段部分被移动到最前面了。所以第二个档案的内容就没再显示</span><br></pre></td></tr></table></figure></p><h4 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h4><p>这个 paste 就要比 join 简单多了。相对于 join 必须要比对两个档案的数据相关性，paste 就直接【将两行贴在一起，且中间以 [tab] 键隔开】而已。简单的使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# paste [-d] file1 file2</span><br><span class="line">选项与参数：</span><br><span class="line">    -d ：后面可以接分隔字符。预设是以 [tab] 来分隔的</span><br><span class="line">    - ：如果 file 部分写成 - ，表示来自 standard input 的资料的意思。</span><br></pre></td></tr></table></figure></p><h4 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h4><p>将 [tab] 按键转成空格键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# expand [-t] file</span><br><span class="line">选项与参数：</span><br><span class="line">    -t ：后面可以接数字。一般来说，一个 tab 按键可以用 8 个空格键取代。我们也可以自行定义一个 [tab] 按键代表多少个字符</span><br></pre></td></tr></table></figure></p><h3 id="5、分割命令：-split"><a href="#5、分割命令：-split" class="headerlink" title="5、分割命令： split"></a>5、分割命令： split</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# split [-bl] file PREFIX</span><br><span class="line">选项与参数：</span><br><span class="line">    -b ：后面可接欲分割成的档案大小，可加单位，例如 b, k, m 等；</span><br><span class="line">    -l ：以行数来进行分割。</span><br><span class="line">    PREFIX ：代表前导符的意思，可作为分割档案的前导文字。</span><br></pre></td></tr></table></figure><h3 id="6、参数代换：-xargs"><a href="#6、参数代换：-xargs" class="headerlink" title="6、参数代换： xargs"></a>6、参数代换： xargs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# xargs [-0epn] command</span><br><span class="line">选项与参数：</span><br><span class="line">    -0 ：如果输入的 stdin 含有特殊字符，例如 `, \, 空格键等等字符时，这个 -0 参数可以将他还原成一般字符。这个参数可以用于特殊状态</span><br><span class="line">    -e ：这个是 EOF (end of file) 的意思。后面可以接一个字符串，当 xargs 分析到这个字符串时，就会停止继续工作</span><br><span class="line">    -p ：在执行每个指令的 argument 时，都会询问使用者的意思；</span><br><span class="line">    -n ：后面接次数，每次 command 指令执行时，要使用几个参数的意思。</span><br><span class="line">当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就如同《数据流导向》所说的，bash 命令执行的时候有输出的数据会出现，那么如果这群数据必需要经过几道手续之后才能得到我们所想要的格式，应该如何来设定？这就牵涉到管线命令的问题(pipe) ，管线命令使用的是【 | 】这个界定符号。另外，管线命令与【连续下达命令】是不一样的。这点底下我们会再说明。底下我们先举一个例子来说明一下简单的管线命令。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：显示/etc/地下有多少个档案，并且利用less指令来分页显示&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@www ~]# ls -al /etc | less&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/tags/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之数据流重导向</title>
    <link href="http://yoursite.com/2017/12/28/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AF%BC%E5%90%91/"/>
    <id>http://yoursite.com/2017/12/28/认识与学习BASH之数据流重导向/</id>
    <published>2017-12-28T11:11:09.000Z</published>
    <updated>2017-12-29T03:15:40.735Z</updated>
    
    <content type="html"><![CDATA[<p>数据流重导向就是将某个指令执行后应该要出现在屏幕上的数据，给他传输到其他的地方，例如档案或者是装置(例如打印机之类的)。</p><h3 id="1、什么是数据流导向？"><a href="#1、什么是数据流导向？" class="headerlink" title="1、什么是数据流导向？"></a>1、什么是数据流导向？</h3><p>这得要由指令的执行结果谈起。一般来说，如果你要执行一个指令，通常他会是这样的：<br><img src="/uploads/2017/12/linux_standard_input_output_error.JPG" alt=""><br><a id="more"></a><br>我们执行一个指令的时候，这个指令可能会由档案读入资料，经过处理之后，再将数据输出到屏幕上。在上图当中，standard output 与 standard error output 分别代表【标准输出】与【标准错误输出】，这两个默认都是输出到屏幕上面。那么什么是标准输出与标准错误输出呢？</p><h3 id="2、standard-output-与-standard-error-output"><a href="#2、standard-output-与-standard-error-output" class="headerlink" title="2、standard output 与 standard error output"></a>2、standard output 与 standard error output</h3><p>简单的说，标准输出指的是【指令执行所回传的正确的讯息】，而标准错误输出可理解为【指令执行失败后，所回传的错误讯息】。不管正确或错误的数据都是默认输出到屏幕上，所以屏幕当然是乱的。那能不能透过某些机制将这两股数据分开呢？答案是可以的。那就是数据流重导向的功能，数据流重导向可以将 standard output(简称 stdout) 与 standard error output (简称 stderr)分别传送到其他的档案或装置去，而分别传送所用的特殊字符则如下所示：</p><pre><code>1. 标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；2. 标准输出 (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；3. 标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；</code></pre><p><strong>（注：一个’&lt;’符号表示覆盖，两个’&lt;&lt;’表示追加。）</strong></p><h3 id="3、-dev-null-垃圾桶黑洞装置与特殊写法"><a href="#3、-dev-null-垃圾桶黑洞装置与特殊写法" class="headerlink" title="3、/dev/null 垃圾桶黑洞装置与特殊写法"></a>3、/dev/null 垃圾桶黑洞装置与特殊写法</h3><p>如果我知道错误讯息会发生，所以要将错误讯息忽略掉而不显示或储存，这个时候黑洞装置 /dev/null 就很重要了。这个 /dev/null 可以吃掉任何导向这个装置的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">[dmtsai@www ~]$ find /home -name .bashrc 2&gt; /dev/null</span><br><span class="line">/home/dmtsai/.bashrc &lt;==只有 stdout 会显示到屏幕上， stderr 被丢弃了</span><br></pre></td></tr></table></figure></p><p>如果我要将正确与错误数据通通写入同一个档案去，这个时候就得要使用特殊的写法了。我们同样用底下的案例来说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：将指令的数据全部写入名为 list 的档案中</span><br><span class="line">[dmtsai@www ~]$ find /home -name .bashrc &gt; list 2&gt; list &lt;==错误</span><br><span class="line">[dmtsai@www ~]$ find /home -name .bashrc &gt; list 2&gt;&amp;1 &lt;==正确</span><br><span class="line">[dmtsai@www ~]$ find /home -name .bashrc &amp;&gt; list &lt;==正确</span><br></pre></td></tr></table></figure></p><p>上述表格第一行错误的原因是，由于两股数据同时写入一个档案，又没有使用特殊的语法，此时两股数据可能会交叉写入该档案内，造成次序的错乱。所以虽然最终 list 档案还是会产生，但是里面的数据排列是乱的，而不是原本屏幕上的输出排序。至于写入同一个档案的特殊语法如上所示，你可以使用 2&gt;&amp;1 也可以使用 &amp;&gt; 。一般来说，比较常见的是 2&gt;&amp;1 的语法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据流重导向就是将某个指令执行后应该要出现在屏幕上的数据，给他传输到其他的地方，例如档案或者是装置(例如打印机之类的)。&lt;/p&gt;
&lt;h3 id=&quot;1、什么是数据流导向？&quot;&gt;&lt;a href=&quot;#1、什么是数据流导向？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是数据流导向？&quot;&gt;&lt;/a&gt;1、什么是数据流导向？&lt;/h3&gt;&lt;p&gt;这得要由指令的执行结果谈起。一般来说，如果你要执行一个指令，通常他会是这样的：&lt;br&gt;&lt;img src=&quot;/uploads/2017/12/linux_standard_input_output_error.JPG&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/tags/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之变量</title>
    <link href="http://yoursite.com/2017/12/28/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8B%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2017/12/28/认识与学习BASH之变量/</id>
    <published>2017-12-28T11:10:43.000Z</published>
    <updated>2017-12-29T03:12:06.146Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Shell-的变量"><a href="#1、Shell-的变量" class="headerlink" title="1、Shell 的变量"></a>1、Shell 的变量</h3><p>变量是 bash 环境中非常重要的一个知识点，我们知道 Linux 是多人多任务的环境，每个人登入系统都能取得一个 bash ，每个人都能够使用 bash 下达 mail 这个指令来收取【自己】的邮件，问题是，bash 是如何得知你的邮件信箱是哪个档案？这就需要【变量】的帮助。底下我们将介绍重要的环境变量、变量的取用与设定等数据。<br><a id="more"></a></p><h3 id="2、什么是变量"><a href="#2、什么是变量" class="headerlink" title="2、什么是变量"></a>2、什么是变量</h3><p>简单的说，就是让某一个特定字符串代表不固定的内容。<br><strong>（1）环境变量</strong><br>当我们登录到Linux之后，就会有一个bash的执行程序用来跟Linux沟通，而在进入 shell 之前，由于系统需要一些变量来提供其他数据的存取 (或者是一些环境的设定参数值，例如是否要显示彩色等等)，所以就有一些所谓的【环境变量】需要来读入系统中。这些环境变量例如 PATH、HOME、MAIL、SHELL 等等，都是很重要的，为了区别与自定义变量的不同，环境变量通常以大写字符来表示。</p><p><strong>（2）变量的取用与设定：echo, 取消变量设定规则：unset</strong><br>可以利用 echo 这个指令来取用变量，但是，变量在被取用时，前面必须要加上钱字号【$】才行，举例来说，要知道 PATH 的内容，该如何是好？</p><ol><li><p>变量的取用：</p><blockquote><p>[root@www ~]# echo $PATH<br>/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin<br>变量的取用就如同上面的范例，利用 ehco 就能够读出，只是需要在变量名称前面加上 $，或者是以${变量}的方式来取用都可以。</p></blockquote></li><li><p>变量的设定规则：</p><blockquote><p>1.变量与变量内容以一个等号【=】来连结，如下所示：<br>　　【myname=ben】<br>2.等号两边不能直接接空格符，如下所示为错误：<br>　　【myname = ben】或【myname=ben Tsai】<br>3.变量名称只能是英文字母与数字，但是开头字符不能是数字，如下为错误：<br>　　【2myname=ben】<br>4.变量内容若有空格符可使用双引号【”】或单引号【’】将变量内容结合起来，但双引号能够识别变量，单引号原样输出。<br>5.可用跳脱字符【\】将特殊符号(如 [Enter], $, \, 空格符, ‘等)变成一般字符；<br>6.在一串指令中，还需要藉由其他的指令提供的信息，可以使用反单引号【<code>指令</code>】或【$(指令)】。<br>　　【version=$(uname -r)】再【echo $version】可得【2.6.32_1-16-0-0_virtio】<br>7.若该变量为扩增变量内容时，则可用 “$变量名称” 或 ${变量} 累加内容，如下所示：<br>　　【PATH=”$PATH”:/home/bin】<br>8.若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境发量：<br>　　【export PATH】<br>9.通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断；<br>10.取消变量的方法为使用 unset ：【unset 变量名称】例如取消 version 的设定：<br>　　【unset version】</p></blockquote></li></ol><p><strong>（3）其它</strong></p><ol><li>什么是【子程序】呢？就是说，在我目前这个 shell 的情况下，去启用另一个新的 shell ，新的那个shell 就是子程序。在一般的状态下，父程序的自定义变量是无法在子程序内使用的。但是透过export 将变量变成环境发量后，就能够在子程序底下应用了。</li><li>在指令下达的过程中，反单引号( ` )这个符号代表的意义为何？<br>在一串指令中，在 ` 之内的指令将会被先执行，而其执行出来的结果将做为外部的输入信息。</li></ol><h3 id="3、环境变量的功能"><a href="#3、环境变量的功能" class="headerlink" title="3、环境变量的功能"></a>3、环境变量的功能</h3><p>用 env 观察环境变量与常见环境变量说明。env 是 environment (环境) 的简写，是列出来所有的环境变量的命令（此处就不贴出 env 命令显示数据）。<br>底下我们对一些常见变量来做一个说明：</p><blockquote><p>HOME<br>    代表用户的家目录。还记得我们可以使用 cd ~ 去到自己的家目录吗？或者利用 cd 就可以直接回到用户家目录了。那就是取用这个变量。有很多程序都可能会取用到这个变量的值。</p><p>SHELL<br>    告知我们，目前这个环境使用的 SHELL 是哪支程序？ Linux 预设使用 /bin/bash 。</p><p>HISTSIZE<br>    这个与【历史命令】有关，亦即是，我们曾经下达过的指令可以被系统记录下来，而记录的【笔数】则是由这个值来设定的。</p><p>MAIL<br>    当我们使用 mail 这个指令在收信时，系统会去读取的邮件信箱档案 (mailbox)。</p><p>PATH<br>    就是执行文件搜寻的路径，目录与目录中间以冒号(:)分隔，由于档案的搜寻是依序由 PATH 的变量内的目录来查询，所以目录的顺序也是重要的。</p><p>LANG<br>    这个重要。就是语系数据。很多讯息都会用到他，举例来说，当我们在启动某些 perl 的程序语言档案时，他会主动的去分析语系数据文件，如果发现有他无法解析的编码语系，可能会产生错误。一般来说，我们中文编码通常是 zh_TW.Big5 或者是 zh_TW.UTF-8，这两个编码偏偏不容易被解译出来，所以，有的时候，可能需要修订一下语系数据。</p><p>RANDOM<br>    这个就是【随机随机数】的变量。目前大多数的 distributions 都会有随机数生成器，那就是 /dev/random 这个档案。 我们可以透过这个随机数档案相关的变量 ($RANDOM) 来随机取得随机数值。在 BASH 的环境下，这个 RANDOM 变量的内容，介于 0~32767 之间，所以，你只要 echo $RANDOM 时，系统就会主动的随机取出一个介于 0~32767 的数值。万一我想要使用 0~9 之间的数值，利用 declare 宣告数值类型，然后这样做就可以了：<br>        <code>declare -i number=$RANDOM*10/32768 ; echo $number ##此时会随机取出 0~9 之间的数值</code></p></blockquote><h3 id="4、变量键盘的读取、数组与宣告"><a href="#4、变量键盘的读取、数组与宣告" class="headerlink" title="4、变量键盘的读取、数组与宣告"></a>4、变量键盘的读取、数组与宣告</h3><p>（1）要读取来自键盘输入的变量，就是用 read 这个指令。这个指令最常被用在 shell script 的撰写当中，想要跟使用者对谈？用这个指令就对了。</p><pre><code>语法：read [-pt] variable选项与参数：    -p ：后面可以接提示字符；    -t ：后面可以接等待的【秒数！】这个比较有趣。不会一直等待使用者</code></pre><p>read 之后不加任何参数，直接加上变量名称，那么底下就会主动出现一个空白行等待你的输入。如果加上 -t 后面接秒数，那么 t 秒之内没有任何动作时，该指令就会自动略过。如果是加上 -p ，在输入的光标前就会有比较多可以用的提示字符给我们参考。在指令的下达里面，比较美观。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">[root@www ~]# echo $atest</span><br><span class="line">This is a test &lt;==你刚刚输入的数据已经变成一个变量内容</span><br><span class="line">[root@www ~]# read -p &quot;Please keyin your name: &quot; -t 30 named</span><br><span class="line">Please keyin your name: VBird Tsai &lt;==提示使用者 30 秒内输入自己的大名，将该输入字符串作为名为 named的变量内容</span><br></pre></td></tr></table></figure></p><p>（2）declare 或 typeset 是一样的功能，就是在【宣告变量的类型】。如果使用 declare 后面并没有接任何参数，那么 bash 就会主动的将所有的变量名称与内容通通叫出来，就好像使用 set 一样。<br>declare / typeset</p><pre><code>语法：declare [-aixr] variable选项与参数：    -a ：将后面名为 variable 的变量定义成为数组 (array) 类型    -i ：将后面名为 variable 的变量定义成为整数数字 (integer) 类型    -x ：用法与 export 一样，就是将后面的 variable 变成环境变量；取消的话将[-x]变为[+x]即为取消。    -r ：将变量设定成为 readonly 类型，该变量不可被更改内容，也不能 unset</code></pre><h3 id="5、变量内容的删除、取代与替换"><a href="#5、变量内容的删除、取代与替换" class="headerlink" title="5、变量内容的删除、取代与替换"></a>5、变量内容的删除、取代与替换</h3><p><img src="/uploads/2017/12/linux_shell_variable_01.png" alt=""></p><h3 id="6、用户登入-shell-后读取的两个配置文件："><a href="#6、用户登入-shell-后读取的两个配置文件：" class="headerlink" title="6、用户登入 shell 后读取的两个配置文件："></a>6、用户登入 shell 后读取的两个配置文件：</h3><ol><li>/etc/profile：这是系统整体的设定，你最好不要修改这个档案；</li><li>~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于使用者个人设定，你要改自己的数据，就写入这里。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、Shell-的变量&quot;&gt;&lt;a href=&quot;#1、Shell-的变量&quot; class=&quot;headerlink&quot; title=&quot;1、Shell 的变量&quot;&gt;&lt;/a&gt;1、Shell 的变量&lt;/h3&gt;&lt;p&gt;变量是 bash 环境中非常重要的一个知识点，我们知道 Linux 是多人多任务的环境，每个人登入系统都能取得一个 bash ，每个人都能够使用 bash 下达 mail 这个指令来收取【自己】的邮件，问题是，bash 是如何得知你的邮件信箱是哪个档案？这就需要【变量】的帮助。底下我们将介绍重要的环境变量、变量的取用与设定等数据。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/tags/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之BASH概述</title>
    <link href="http://yoursite.com/2017/12/28/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8BBASH%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/12/28/认识与学习BASH之BASH概述/</id>
    <published>2017-12-28T11:10:35.000Z</published>
    <updated>2017-12-29T02:58:57.035Z</updated>
    
    <content type="html"><![CDATA[<p>为什么BASH叫做壳程序？ 理解这个就理解了BASH与操作系统的关系，以及BASH是什么，有什么用。</p><h3 id="1、认识BASH这个Shell"><a href="#1、认识BASH这个Shell" class="headerlink" title="1、认识BASH这个Shell"></a>1、认识BASH这个Shell</h3><p>管理整个计算机硬件的其实是操作系统的核心 (kernel)，这个核心是需要被保护的。所以我们一般使用者就只能透过 shell 来跟核心沟通，以让核心达到我们所想要达到的工作。那么系统有多少 shell 可用呢？为什么我们要使用 bash啊？底下分别来谈一谈。<br><a id="more"></a></p><h3 id="2、硬件、核心-与-Shell"><a href="#2、硬件、核心-与-Shell" class="headerlink" title="2、硬件、核心 与 Shell"></a>2、硬件、核心 与 Shell</h3><p>在认识 Shell 之前，我们先来了解一下计算机的运作状况吧。举个例子来说：当你要计算机传输出来【音乐】的时候，你的计算机需要什么东西呢？</p><pre><code>1. 硬件：当然就是需要你的硬件有【声卡芯片】这个配备，否则怎么会有声音；2. 核心管理：操作系统的核心可以支持这个芯片组，当然还需要提供芯片的驱动程序；3. 应用程序：需要使用者 (就是你) 输入发生声音的指令。</code></pre><p>这就是基本的一个输出声音所需要的步骤。也就是说，你必须要【输入】一个指令之后，【硬件】才会透过你下达的指令来工作。那么硬件如何知道你下达的指令呢？那就是 kernel (核心) 的控制工作了，也就是说，我们必须要透过【Shell】将我们输入的指令与 Kernel 沟通，好让 Kernel 可以控制硬件来正确无误的工作。</p><p>曾经提到过，操作系统其实是一组软件，由于这组软件在控制整个硬件与管理系统的活动监测，如果这组软件能被用户随意的操作，若使用者应用不当，将会使得整个系统崩溃！因为操作系统管理的就是整个硬件功能，所以当然不能够随便被一些没有管理能力的终端用户随意使用。但是我们总是需要让用户操作系统的，所以就有了在操作系统上面发展的应用程序。用户可以透过应用程序来指挥核心，让核心达成我们所需要的硬件任务！</p><p>我们可以发现应用程序其实是在最外局，就如同鸡蛋的外壳一样，因此这个咚咚也就被称呼为<font color="red">壳程序 (shell)</font>。其实壳程序的功能只是提供用户操作系统的一个接口，因此这个壳程序需要可以呼叫其他软件才好。我们知道有很多指令，例如 man, chmod, chown, vi, fdisk, mkfs 等指令，这些指令都是独立的应用程序，但是我们可以透过壳程序 (就是指令列模式)来操作这些应用程序，让这些应用程序呼叫核心来运作所需的工作。这样对于壳程序是否有了一定的概念了。</p><blockquote><p>也就是说，只要能够操作应用程序的接口都能够称为壳程序。狭义的壳程序指的是指令列方面的软件，包括本章要介绍的 bash 等。广义的壳程序则包括图形接口的软件，因为图形接口其实也能够操作各种应用程序来呼叫核心工作。</p></blockquote><h3 id="3、系统合法的shell与-etc-shells功能"><a href="#3、系统合法的shell与-etc-shells功能" class="headerlink" title="3、系统合法的shell与/etc/shells功能"></a>3、系统合法的shell与/etc/shells功能</h3><p>知道什么是 Shell 之后，那么我们来了解一下 Linux 使用的是哪一个 shell 。由于早年的 Unix 年代，发展者众，所以由于 shell 依据发展者的不同就有很多的版本，例如常听到的 Bourne SHell (sh) 、在 Sun 里头预设的 C SHell、 商业上常用的 K SHell、还有 TCSH 等等，每一种 Shell 都各有其特点。至于 Linux 使用的这一种版本就称为【Bourne Again SHell (简称 bash) 】，这个 Shell 是 Bourne Shell 的增强版本，也是基准于GNU 的架构下发展出来的。</p><p>在介绍 shell 的优点之前，先来说一说 shell 的简单历史：第一个流行的 shell 是由 Steven Bourne 发展出来的，为了纪念他所以就称为 Bourne shell ，或直接简称为 sh 。而后来另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计依附于 BSD 版的 Unix 系统中的 shell ，这个 shell 的语法有点类似 C 语言，所以才得名为 C shell ，简称为 csh 。由于在学术界 Sun 主机势力相当的庞大，而Sun 主要是 BSD 的分支之一，所以 C shell 也是另一个很重要而且流传很广的 shell 之一 。</p><blockquote><p>由于 Linux 为 C 程序语言撰写的，很多程序设计师使用 C 来开发软件，因此 C shell相对的就很热门了。Sun 公司的创始人就是 Bill Joy，而 BSD 最早就是 Bill Joy 发展出来的。</p></blockquote><p>那么目前我们的 Linux 有多少我们可以使用的 shells 呢？ 你可以检查一下/etc/shells 这个档案，至少就有底下这几个可以用的 shells：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh (已经被 /bin/bash 所取代)</span><br><span class="line">/bin/bash (就是 Linux 预设的 shell)</span><br><span class="line">/bin/ksh (Kornshell 由 AT&amp;T Bell lab. 发展出来的，兼容于 bash)</span><br><span class="line">/bin/tcsh (整合 C Shell ，提供更多的功能)</span><br><span class="line">/bin/csh (已经被 /bin/tcsh 所取代)</span><br><span class="line">/bin/zsh (基于 ksh 发展出来的，功能更强大的 shell)</span><br></pre></td></tr></table></figure></p><p>虽然各家 shell 的功能都差不多，但是在某些语法的下达方面则有所不同，因此建议你还是选择某一种 shell 来熟悉一下较佳。 Linux 预设就是使用 bash ，所以最初你只要学会 bash 就ok了。为什么我们系统上合法的 shell 要写入 /etc/shells 这个档案呢？ 这是因为系统某些服务在运作过程中，会去检查使用者能够使用的 shells ，而这些 shell 的查询就是藉由 /etc/shells 这个档案。</p><p>那么，我这个使用者取得shell工作后，预设会取得哪一个 shell 呢？当我登入的时候，系统就会给我一个 shell 让我来工作了。而这个登入取得的 shell 就记录在 /etc/passwd 这个档案内。这个档案的内容是啥？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">.....(底下省略).....</span><br></pre></td></tr></table></figure></p><p>如上所示，在每一行的最后一个数据，就是你登入后取得预设的 shell 。</p><h3 id="4、Bash-shell-的功能"><a href="#4、Bash-shell-的功能" class="headerlink" title="4、Bash shell 的功能"></a>4、Bash shell 的功能</h3><p>既然 /bin/bash 是 Linux 预设的 shell，那么总是得了解一下这个玩意儿。bash 是 GNU 计划中重要的工具软件之一，目前也是 Linux distributions 的标准 shell 。 bash 主要兼容于 sh ，并且依据一些使用者的需求，而加强的 shell 版本。不论你使用的是那个 distribution ，你都难逃需要学习 bash 的宿命。那么这个 shell 有什么好处，干嘛 Linux 要使用他作为预设的 shell 呢？ bash 主要的优点有底下几个：</p><p><strong>（1）命令编修能力 (history)：</strong><br>就是记忆使用过的指令，只要在指令列按【上下键】就可以找到前/后一个输入的指令。而在很多 distribution 里头，默认的指令记忆功能可以多达 1000 个。也就是说，你曾经下达过的指令几乎都被记录下来了。</p><p>这么多的指令记录在哪里呢？在你的家目录内的 .bash_history。不过，需要留意的是，~/.bash_history 记录的是前一次登入以前所执行过的指令，而至于这一次登入所执行的指令都被暂存在内存中，当你成功的注销系统后，该指令记忆才会记录到 .bash_history 当中。</p><p><strong>（2）命令与档案补全功能： ([tab] 按键的好处)</strong><br>常常在 bash 环境中使用 [tab] 是个很棒的习惯。因为至少可以让你 1)少打很多字； 2)确定输入的数据是正确的。使用 [tab] 按键的时机依据 [tab] 接在指令后或参数后而有所不同。<br>如下所示：</p><pre><code>1. [Tab] 接在一串指令的第一个字的后面，则为命令补全；2. [Tab] 接在一串指令的第二个字以后时，则为【档案补齐】。</code></pre><p>所以说，如果我想要知道我的环境中，所有可以执行的指令有几个？就直接在 bash 的提示字符后面连续按两次 [tab] 按键就能够显示所有的可执行指令了。 那如果想要知道系统当中所有以 c 为开头的指令呢？就按下【c[tab][tab]】就好了。</p><p><strong>（3）命令别名设定功能： (alias)</strong><br>假如我需要知道这个目录底下的所有档案 (包含隐藏档) 及所有的文件属性，那么我就必须要下达【ls -al】这样的指令串。如果使用命令别名，就可以自定义命令来取代长指令串命令，也就是说使用 alias 即可。你可以在指令列输入 alias 就可以知道目前的命令别名有哪些了。也可以直接下达命令来设定别名：<br>    <code>alias lm=&#39;ls -al&#39;</code></p><p><strong>（4）工作控制、前景背景控制： (job control, foreground, background)</strong><br>使用前、背景的控制可以让工作进行的更为顺利。至于工作控制(jobs)的用途则更广，可以让我们随时将工作丢到背景中执行。而不怕不小心使用了[Ctrl] + c 来停掉该程序。此外，也可以在单一登录的环境中，达到多任务的目的。</p><p><strong>（5）程序化脚本： (shell scripts)</strong><br>在 Linux 底下的 shell scripts 可以将你平时管理系统常需要下达的连续指令写成一个档案，该档案并且可以透过对谈交互式的方式来进行主机的侦测工作。也可以藉由 shell 提供的环境变量及相关指令来进行设计，整个设计下来几乎就是一个小型的程序语言。（该部分会单独详解）</p><p><strong>（6）通配符： (Wildcard)</strong><br>除了完整的字符串之外，bash 还支持很多的通配符来帮助用户查询与指令下达。举例来说，想要知道/usr/bin 底下有多少以 X 为开头的档案，使用：【ls -l /usr/bin/X*】就能够知道。</p><h3 id="5、Bash-shell-的内建命令：-type"><a href="#5、Bash-shell-的内建命令：-type" class="headerlink" title="5、Bash shell 的内建命令： type"></a>5、Bash shell 的内建命令： type</h3><p>如何知道这个指令是来自于外部指令(指的是其他非 bash 所提供的指令) 或是内建在 bash 当中的，利用 type 这个指令来观察即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：`type [-tpa] name`</span><br><span class="line">选项与参数：</span><br><span class="line">   ：不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内建指令</span><br><span class="line">-t ：当加入 -t 参数时，type 会将 name 以底下这些字眼显示出他的意义：</span><br><span class="line">file ：表示为外部指令；</span><br><span class="line">alias ：表示该指令为命令别名所设定的名称；</span><br><span class="line">builtin ：表示该指令为 bash 内建的指令功能；</span><br><span class="line">-p ：如果后面接的 name 为外部指令时，才会显示完整文件名；</span><br><span class="line">-a ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含alias</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么BASH叫做壳程序？ 理解这个就理解了BASH与操作系统的关系，以及BASH是什么，有什么用。&lt;/p&gt;
&lt;h3 id=&quot;1、认识BASH这个Shell&quot;&gt;&lt;a href=&quot;#1、认识BASH这个Shell&quot; class=&quot;headerlink&quot; title=&quot;1、认识BASH这个Shell&quot;&gt;&lt;/a&gt;1、认识BASH这个Shell&lt;/h3&gt;&lt;p&gt;管理整个计算机硬件的其实是操作系统的核心 (kernel)，这个核心是需要被保护的。所以我们一般使用者就只能透过 shell 来跟核心沟通，以让核心达到我们所想要达到的工作。那么系统有多少 shell 可用呢？为什么我们要使用 bash啊？底下分别来谈一谈。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/tags/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>vim程序编辑器</title>
    <link href="http://yoursite.com/2017/12/27/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://yoursite.com/2017/12/27/vim程序编辑器/</id>
    <published>2017-12-27T07:07:51.000Z</published>
    <updated>2017-12-27T09:11:12.689Z</updated>
    
    <content type="html"><![CDATA[<p>vi：文本编辑器<br>vim：程序编辑器</p><p>为什么要学vi？<br>因为所有的UNIX Like系统都会内建vi文本编辑器，其它的文本编辑器则不一定会存在。</p><p>vi与vim的区别？<br>其实你可以将 vim 规作 vi 的进阶版本，vim 可以用颜色或底线等方式来显示一些特殊的信息。举例来说，当你使用 vim 去编辑一个 C 程序语言的档案，或者是我们后续会谈到的shell script 程序时，vim 会依据档案的扩展名或者是档案内的开头信息，判断该档案的内容而自动的呼叫该程序的语法判断式，再以颜色来显示程序代码与一般信息。也就是说，这个 vim 是个【程序编辑器】。甚至一些 Linux 基础配置文件内的语法，都能够用 vim 来检查。<br><a id="more"></a><br>首先，先简单的对vi做个介绍，然后再说一下vim的额外功能与用法。</p><h2 id="vi的使用："><a href="#vi的使用：" class="headerlink" title="vi的使用："></a>vi的使用：</h2><p>基本上 vi 共分为三种模式，分别是【一般模式】、【编辑模式】与【指令列命令模式】。 这三种模式的作用分别是：</p><h3 id="一般模式："><a href="#一般模式：" class="headerlink" title="一般模式："></a>一般模式：</h3><p>以 vi 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用【上下左右】按键来移动光标，你可以使用【删除字符】或【删除整行】来处理档案内容，也可以使用【复制、粘贴】来处理你的文件数据。</p><h3 id="编辑模式："><a href="#编辑模式：" class="headerlink" title="编辑模式："></a>编辑模式：</h3><p>在一般模式中可以进行删除、复制、粘贴等等的动作，但是却无法编辑文件内容。要等到你按下【i, I, o, O, a, A, r, R】等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现【INSERT 或 REPLACE】的字样，此时才可以进行编辑。而如果要回到一般模式时，则必须要按下【Esc】这个按键即可退出编辑模式。</p><h3 id="指令列命令模式："><a href="#指令列命令模式：" class="headerlink" title="指令列命令模式："></a>指令列命令模式：</h3><p>在一般模式当中，输入【: / ?】三个中的任何一个按钮，就可以将光标移动到最底下那一行。在这个模式当中，可以提供你【搜寻资料】的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等等的动作则是在此模式中达成的。</p><p>简单的说，我们可以将这三个模式想成底下的图标来表示：<br><img src="/uploads/2017/12/linux_vi_01.JPG" alt=""><br>注意到上面的图标，你会发现一般模式可与编辑模式及指令列模式切换，但编辑模式与指令列模式之间不可互相切换。</p><h2 id="按键说明："><a href="#按键说明：" class="headerlink" title="按键说明："></a>按键说明：</h2><h3 id="第一部份：一般模式可用的按钮说明，光标移动、复制粘贴、搜寻取代等"><a href="#第一部份：一般模式可用的按钮说明，光标移动、复制粘贴、搜寻取代等" class="headerlink" title="第一部份：一般模式可用的按钮说明，光标移动、复制粘贴、搜寻取代等"></a>第一部份：一般模式可用的按钮说明，光标移动、复制粘贴、搜寻取代等</h3><p><img src="/uploads/2017/12/linux_vi_01.png" alt=""><br><img src="/uploads/2017/12/linux_vi_02.png" alt=""><br><img src="/uploads/2017/12/linux_vi_03.png" alt=""><br><img src="/uploads/2017/12/linux_vi_04.png" alt=""><br><img src="/uploads/2017/12/linux_vi_05.png" alt=""></p><h3 id="第二部份：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部份：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部份：一般模式切换到编辑模式的可用的按钮说明"></a>第二部份：一般模式切换到编辑模式的可用的按钮说明</h3><p><img src="/uploads/2017/12/linux_vi_06.png" alt=""></p><h3 id="第三部份：一般模式切换到指令列模式的可用的按钮说明"><a href="#第三部份：一般模式切换到指令列模式的可用的按钮说明" class="headerlink" title="第三部份：一般模式切换到指令列模式的可用的按钮说明"></a>第三部份：一般模式切换到指令列模式的可用的按钮说明</h3><p><img src="/uploads/2017/12/linux_vi_07.png" alt=""></p><h2 id="vim的暂存档、救援恢复与开启时的警告讯息"><a href="#vim的暂存档、救援恢复与开启时的警告讯息" class="headerlink" title="vim的暂存档、救援恢复与开启时的警告讯息"></a>vim的暂存档、救援恢复与开启时的警告讯息</h2><h3 id="什么是暂存档？"><a href="#什么是暂存档？" class="headerlink" title="什么是暂存档？"></a>什么是暂存档？</h3><p>当我们在使用 vim 编辑时， vim 会在不被编辑的档案的目录下，再建立一个名为 .filename.swp 的档案。当然，前提是由于各种原因导致的不正常的中断，才会产生该暂存档文件。如果对文件没有修改或正确存储则不会生成该暂存档文件。该暂存档文件的作用就是保留文件修改内容，防止文件因为系统或网络原因等导致丢失。</p><h3 id="警告讯息"><a href="#警告讯息" class="headerlink" title="警告讯息"></a>警告讯息</h3><p>团队工作中，有可能会有多人同时操作同一个文件的情况，这种情况就会产生警告讯息。至于这个发现暂存盘警告讯息的画面中，有出现六个可用按钮，各按钮的说明如下：</p><ul><li>[O]pen Read-Only：打开此档案成为只读档，可以用在你只是想要查阅该档案内容并不想要进行编辑行为时。一般来说，在上课时，如果你是登入到同学的计算机去看他的配置文件，结果发现其实同学他自己也在编辑时，可以使用这个模式；</li><li>(E)dit anyway：还是用正常的方式打开你要编辑的那个档案，并不会载入暂存盘的内容。不过很容易出现两个使用者互相改变对方的档案等问题！不好不好！</li><li>(R)ecover：就是加载暂存盘的内容，用在你要救回之前未储存的工作。不过当你救回来并且储存离开 vim 后，还是要手动自行删除那个暂存档。</li><li>(D)elete it：你确定那个暂存档是无用的。那么开启档案前会先将这个暂存盘删除！这个动作其实是比较常做的！因为你可能不确定这个暂存档是怎么来的，所以就删除掉他吧！</li><li>(Q)uit：按下 q 就离开 vim ，不会进行任何动作回到命令提示字符。</li><li>(A)bort：忽略这个编辑行为，感觉上与 quit 非常类似，也会送你回到命令提示字符。</li></ul><h2 id="vim的额外功能："><a href="#vim的额外功能：" class="headerlink" title="vim的额外功能："></a>vim的额外功能：</h2><p>查看vi是否被vim替代：alias<br>    <code>alias vi=&#39;vim&#39; &lt;==重点在这行</code><br>这表示当你使用 vi 这个指令时，其实就是执行 vim。如果你没有这一行，那么你就必须要使用 vimfilename 来启动 vim 。基本上， vim 的一般用法与 vi 完全一模一样。</p><h4 id="1、区块选择-Visual-Block"><a href="#1、区块选择-Visual-Block" class="headerlink" title="1、区块选择(Visual Block)"></a>1、区块选择(Visual Block)</h4><p>刚刚我们提到的简单的 vi 操作过程中，几乎提到的都是以行为单位的操作。那么如果我想要搞定的是一个区块范围呢？<br>那就使用区块选择 (Visual Block) 吧！当我们按下 v 或者 V 或者 [Ctrl]+v 时，这个时候光标移动过的地方就会开始反白，这三个按键的意义分别是：<br><img src="/uploads/2017/12/linux_vi_vb.png" alt=""><br>透过上述的功能，你可以复制一个区块，并且是贴在某个【区块的范围】内，而不是以行为单位来处理你的整份文件。</p><h4 id="2、多档案编辑"><a href="#2、多档案编辑" class="headerlink" title="2、多档案编辑"></a>2、多档案编辑</h4><p>如果我想要将 A 档案内的十条消息『移动』到 B 档案去，通常要开两个 vim 窗口来复制，偏偏每个 vim 都是独立的，因此并没有办法在 A 档案下达【nyy】再跑到 B 档案去【p】。 在这种情况下最常用的方法就是透过鼠标圈选， 复制后粘贴。不过这样一来还是有问题，因为用 [Tab] 按键进行编排对齐动作，透过鼠标却会将 [Tab] 转成空格键，这样内容就不一样了。此时这个多档案编辑就派上用场了！</p><p>我们可以使用 vim 后面同时接好几个档案来同时开启。相关的按键有：<br><img src="/uploads/2017/12/linux_vi_multifiles.png" alt=""></p><p>示例：将hosts 内的前四行 IP 资料复制到你的/etc/hosts 档案内，那可以怎么进行呢？可以这样：</p><pre><code>1. 透过【vim hosts /etc/hosts】指令来使用一个 vim 开启两个档案；2. 在 vim 中先使用【:files】察看一下编辑的档案数据有啥？结果如下所示。至于下图的最后一行显示的是【按下任意键】就会回到 vim 的一般模式中；3. 在第一行输入【4yy】复制前四行；4. 在 vim 的环境下输入【:n】会来到第二个编辑的档案，亦即 /etc/hosts 内；5. 在 /etc/hosts 下按【G】到最后一行，再输入【p】粘贴；6. 按下多次的【u】来还原原本的档案数据；7. 最终按下【:q】来离开 vim 的多档案编辑。</code></pre><h4 id="3、多窗口功能"><a href="#3、多窗口功能" class="headerlink" title="3、多窗口功能"></a>3、多窗口功能</h4><p>在开始这个小节前，先来想象两个情况：</p><ul><li>当我有一个档案非常的大，我查阅到后面的数据时，想要【对照】前面的数据，是否需要使用[ctrl]+f 与 [ctrl]+b (或 pageup, pagedown 功能键) 来跑前跑后查阅？</li><li>我有两个需要对照着看的档案，不想使用前一小节提到的多档案编辑功能；</li></ul><p>在一般窗口接口下的编辑软件大多有【分割窗口】或者是【冻结窗口】的功能来将一个档案分割成多个窗口的展现，那么 vim 能不能达到这个功能？可以啊。在指令列模式输入【:sp {filename}】即可！那个 filename 可有可无，如果想要在新窗口启动另一个档案，就加入档名，否则仅输入 :sp 时，出现的则是同一个档案在两个窗口。</p><p>这样的话，复制啊、查阅啊等等的，就变的很简单。分割窗口的相关指令功能有很多，不过只要记得这几个就好了：<br><img src="/uploads/2017/12/linux_vi_multiwindows.png" alt=""></p><h4 id="4、vim-环境设定与记录：-vimrc-viminfo"><a href="#4、vim-环境设定与记录：-vimrc-viminfo" class="headerlink" title="4、vim 环境设定与记录： ~/.vimrc, ~/.viminfo"></a>4、vim 环境设定与记录： ~/.vimrc, ~/.viminfo</h4><p>有没有发现，如果我们以 vim 软件来搜寻一个档案内部的某个字符串时，这个字符串会被反白，而下次我们再次以 vim 编辑这个档案时，该搜寻的字符串反白情况还是存在呢！甚至于在编辑其他档案时，如果其他档案内也存在这个字符串，竟然还是主动反白。另外，当我们重复编辑同一个档案时，当第二次进入该档案时，光标竟然就在上次离开的那一行上头，真是好方便。但是，怎么会这样呢？</p><p>这是因为我们的 vim 会主动的将你曾经做过的行为登录下来，好让你下次可以轻松的作业。那个记录动作的档案就是： ~/.viminfo ！如果你曾经使用过 vim，那你的家目录应该会存在这个档案才对。这个档案是自动产生的，你不必自行建立。而你在 vim 里头所做过的动作，就可以在这个档案内部查询到。</p><p>此外，每个 distributions 对 vim 的预设环境都不太相同，举例来说，某些版本在搜寻到关键词时并不会高亮度反白，有些版本则会主动的帮你进行缩排的行为。但这些其实都可以自行设定的，那就是vim 癿环境设定。vim 的环境设定参数有很多，如果你想要知道目前的设定值，可以在一般模式时输入【:set all】 来查阅，不过…..设定项目实在太多了。所以，在这里仅列出一些平时比较常用的一些简单的设定值，提供参考。<br><img src="/uploads/2017/12/linux_vi_environment_set_01.png" alt=""><br><img src="/uploads/2017/12/linux_vi_environment_set_02.png" alt=""></p><p>总之，这些设定值很有用处的。但是……我是否每次使用 vim 都要重新设定一次各个参数值？这不太合理吧。所以，我们可以透过配置文件来直接规定我们习惯的 vim 操作环境。整体 vim 的设定值一般是放置在 /etc/vimrc 这个档案，不过，不建议你修改该文件，你可以修改 ~/.vimrc 这个档案(预设不存在，可以自行手动建立！)，将你所希望的设定值写入！举例来说，可以是这样的一个档案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# vim ~/.vimrc</span><br><span class="line">&quot;这个档案的双引号 (&quot;) 是批注</span><br><span class="line">set hlsearch &quot;高亮度反白</span><br><span class="line">set backspace=2 &quot;可随时用退格键删除</span><br><span class="line">set autoindent &quot;自动缩排</span><br><span class="line">set ruler &quot;可显示最后一行的状态</span><br><span class="line">set showmode &quot;左下角那一行的状态</span><br><span class="line">set nu &quot;可以在每一行的最前面显示行号</span><br><span class="line">set bg=dark &quot;显示不同的底色色调</span><br><span class="line">syntax on &quot;进行语法检验，颜色显示。</span><br></pre></td></tr></table></figure></p><p>在这个档案中，使用【set hlsearch】或【:set hlsearch】，亦即最前面有没有冒号【:】效果都是一样的！至于双引号则是批注符号，不要用错批注符号，否则每次使用 vim 时都会发生警告讯息。建立好这个档案后，当你下次重新以 vim 编辑某个档案时，该档案的预设环境设定就是上头写的。这样，是否很方便你的操作，多多利用 vim 的环境设定功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vi：文本编辑器&lt;br&gt;vim：程序编辑器&lt;/p&gt;
&lt;p&gt;为什么要学vi？&lt;br&gt;因为所有的UNIX Like系统都会内建vi文本编辑器，其它的文本编辑器则不一定会存在。&lt;/p&gt;
&lt;p&gt;vi与vim的区别？&lt;br&gt;其实你可以将 vim 规作 vi 的进阶版本，vim 可以用颜色或底线等方式来显示一些特殊的信息。举例来说，当你使用 vim 去编辑一个 C 程序语言的档案，或者是我们后续会谈到的shell script 程序时，vim 会依据档案的扩展名或者是档案内的开头信息，判断该档案的内容而自动的呼叫该程序的语法判断式，再以颜色来显示程序代码与一般信息。也就是说，这个 vim 是个【程序编辑器】。甚至一些 Linux 基础配置文件内的语法，都能够用 vim 来检查。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/tags/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>文件系统的压缩详解</title>
    <link href="http://yoursite.com/2017/12/27/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/12/27/文件系统的压缩详解/</id>
    <published>2017-12-27T05:58:23.000Z</published>
    <updated>2017-12-27T05:59:48.850Z</updated>
    
    <content type="html"><![CDATA[<p>何为压缩？<br>何为压缩比？<br>为什么要压缩，压缩有什么好处？<br>带着这几个问题我们来学习一下。<br><a id="more"></a></p><h3 id="1、为什么要压缩："><a href="#1、为什么要压缩：" class="headerlink" title="1、为什么要压缩："></a>1、为什么要压缩：</h3><p>如果一个软件档案很多，或者文件档案太大，都会耗掉很多的磁盘空间，如果是网络传输也会耗掉很多带宽和时间，同时也不利于复制与携带。此时就需要【文件压缩】技术了。</p><h3 id="2、压缩的好处："><a href="#2、压缩的好处：" class="headerlink" title="2、压缩的好处："></a>2、压缩的好处：</h3><p>透过文件压缩的技术，最大的好处就是压缩过的档案容量变小了， 所以你的硬盘容量无形之中就可以容纳更多的资料。此外，在一些网络数据的传输中，也会由于数据量的降低，好让网络带宽可以用来作更多的工作。目前很多的 WWW 网站也是利用文件压缩的技术来进行数据的传送，好让网站带宽的可利用率上升。</p><h3 id="3、压缩的原理："><a href="#3、压缩的原理：" class="headerlink" title="3、压缩的原理："></a>3、压缩的原理：</h3><p>目前我们使用的计算机系统中都是使用所谓的 bytes（字节） 单位来计量的。不过，事实上，计算机最小的计量单位应该是 bits（比特） 才对。此外，我们也知道 1 byte = 8 bits 。但是如果今天我们只是记忆一个数字，亦即是 1 这个数字？他会如何记录？假设一个 byte 可以看成底下的模样：<br>　　　□□□□□□□□<br><em>（由于 1 byte = 8 bits ，所以每个 byte 当中会有 8 个空格，而每个空格可以是 0,1）</em></p><p>由于我们记录数字是 1 ，考虑计算机所谓的二进制，如此一来， 1 会在最右边占据 1 个 bit ，而其他的 7 个 bits 将会自动的被填上 0 。你看看，其实在这样的例子中，那 7 个 bits 应该是【空的】才对。不过，为了要满足目前我们的操作系统数据的存取（按字存取或按字节存取两种），所以就会将该数据转为 byte 的型态来记录。而一些聪明的计算机工程师就利用一些复杂的计算方式，将这些没有使用到的空间【丢】出去，以让档案占用的空间变小。这就是压缩的技术。</p><p>另外一种压缩技术也很有趣，他是将重复的数据进行统计记录的。举例来说，如果你的数据为【111….】共有100 个1 时， 那么压缩技术会记录为【100 个1】而不是真的有100 个1 的位存在！这样也能够精简档案记录的容量。</p><p>简单的说，你可以将他想成，其实档案里面有相当多的【空间】存在，并不是完全填满的， 而【压缩】的技术就是将这些【空间】填满，以让整个档案占用的容量下降。不过，这些【压缩过的档案】并无法直接被我们的操作系统所使用，因此， 若要使用这些被压缩过的档案数据，则必项将他【还原】回来未压缩前的模样， 那就是所谓的【解压缩】。而至于压缩前与压缩后的档案所占用的磁盘空间大小，就可以被称为是【压缩比】。</p><h3 id="4、压缩文件扩展名："><a href="#4、压缩文件扩展名：" class="headerlink" title="4、压缩文件扩展名："></a>4、压缩文件扩展名：</h3><p>在Linux中，文件的扩展名是没什么作用的，但是为什么不同的压缩文件有不同的扩展名呢？原因就是，因为 Linux 支持的压缩指令非常多，且不同的指令所用的压缩技术并不相同，当然彼此之间可能就无法互通压缩/解压缩文件。所以，当你下载到某个压缩文件时，自然就需要知道该档案是由哪种压缩指令所制作出来的，好用来对照着解压缩。也就是说，虽然 Linux 档案的属性基本上是与文件名没有绝对关系的，但是为了帮助我们人类小小的脑袋瓜子，所以适当的扩展名还是必要的。<br>底下我们就列出几个常见的压缩文件扩展名吧：</p><pre><code>*.Z compress 程序压缩的档案；*.gz gzip 程序压缩的档案；*.bz2 bzip2 程序压缩的档案；*.tar tar 程序打包的数据，并没有压缩过；*.tar.gz tar 程序打包的档案，其中并且经过 gzip 的压缩*.tar.bz2 tar 程序打包的档案，其中并且经过 bzip2 的压缩</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;何为压缩？&lt;br&gt;何为压缩比？&lt;br&gt;为什么要压缩，压缩有什么好处？&lt;br&gt;带着这几个问题我们来学习一下。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/tags/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之shutdown</title>
    <link href="http://yoursite.com/2017/12/26/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bshutdown/"/>
    <id>http://yoursite.com/2017/12/26/Linux命令之shutdown/</id>
    <published>2017-12-26T10:28:35.000Z</published>
    <updated>2017-12-26T10:41:21.671Z</updated>
    
    <content type="html"><![CDATA[<p>　　正常情况下，windows在令你不爽的时候，按着电源开关4秒就关机了，或者简单粗暴的方法，直接拔电源。但是在Linux下非常不建议这么做。在 Linux 底下，由于每个程序 (或者说是服务) 都是在背景下执行的，因此，在你看不到的屏幕背后其实可能有相当多人同时在你的主机上面工作，若不正常关机，则可能造成文件系统的毁损 （因为来不及将数据回写到档案中，所以有些服务的档案会有问题！）。<br><a id="more"></a><br>惯用的关机指令：shutdown</p><blockquote><p>shutdown 可以达成如下的工作：</p><ul><li>可以自由选择关机模式：是要关机、重新启动或进入单人操作模式均可；</li><li>可以设定关机时间: 可以设定成现在立刻关机, 也可以设定某一个特定的时间才关机。</li><li>可以自定义关机讯息：在关机之前，可以将自己设定的讯息传送给在线 user 。</li><li>可以仅发出警告讯息：有时有可能你要进行一些测试，而不想让其他的使用者干扰， 或者是明白的告诉使用者某段时间要注意一下！这个时候可以使用 shutdown 来吓一吓使用者，但不是真的要关机！</li><li>可以选择是否要 fsck 检查文件系统 。</li></ul></blockquote><p>简单的语法规则为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# /sbin/shutdown [-t 秒] [-arkhncfF] 时间 [警告讯息]</span><br><span class="line">选项不参数：</span><br><span class="line">-t sec ： -t 后面加秒数，亦即【过几秒后关机】的意思</span><br><span class="line">-k ： 不要真的关机，只是发送警告讯息出去！</span><br><span class="line">-r ： 在将系统的服务停掉之后就重新启动 (常用)</span><br><span class="line">-h ： 将系统的服务停掉后，立即关机。 (常用)</span><br><span class="line">-n ： 不经过 init 程序，直接以 shutdown 的功能来关机</span><br><span class="line">-f ： 关机并开机之后，强制略过 fsck 的磁盘检查</span><br><span class="line">-F ： 系统重新启动之后，强制进行 fsck 的磁盘检查</span><br><span class="line">-c ： 取消已经在进行的 shutdown 指令内容。</span><br><span class="line">时间 ： 这是一定要加入的参数！指定系统关机的时间！时间的范例底下会说明。</span><br></pre></td></tr></table></figure></p><p>示例：<br><code>[root@www ~]# /sbin/shutdown -h 10 &#39;I will shutdown after 10 mins&#39;</code><br>告诉大家，这部机器会在十分钟后关机！并且“警告讯息”会显示在目前登入者的屏幕前方！<br><code>[root@www ~]# shutdown -h now</code><br>立刻关机，其中 now 相当于时间为 0 的状态<br><code>[root@www ~]# shutdown -h 20:25</code><br>系统在今天的 20:25 分会关机，若在21:25 才下达此指令，则明天才关机<br><code>[root@www ~]# shutdown -h +10</code><br>系统再过十分钟后自动关机<br><code>[root@www ~]# shutdown -r now</code><br>系统立刻重新启动<br><code>[root@www ~]# shutdown -r +30 &#39;The system will reboot&#39;</code><br>再过三十分钟系统会重新启动，并显示后面的讯息给所有在在线的使用者<br><code>[root@www ~]# shutdown -k now &#39;This system will reboot&#39;</code><br>仅发出警告信件的参数！系统并不会关机！吓唬人！</p><p><strong>重新启动命令：reboot, halt, poweroff</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　正常情况下，windows在令你不爽的时候，按着电源开关4秒就关机了，或者简单粗暴的方法，直接拔电源。但是在Linux下非常不建议这么做。在 Linux 底下，由于每个程序 (或者说是服务) 都是在背景下执行的，因此，在你看不到的屏幕背后其实可能有相当多人同时在你的主机上面工作，若不正常关机，则可能造成文件系统的毁损 （因为来不及将数据回写到档案中，所以有些服务的档案会有问题！）。&lt;br&gt;
    
    </summary>
    
      <category term="每日一个Linux命令" scheme="http://yoursite.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>文件系统的概述</title>
    <link href="http://yoursite.com/2017/12/26/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/12/26/文件系统的概述/</id>
    <published>2017-12-26T09:39:48.000Z</published>
    <updated>2017-12-26T10:02:15.843Z</updated>
    
    <content type="html"><![CDATA[<p>由此文Get到的知识点：<br>inode 是什么？<br>　　记录档案的号码。<br>inode 有什么作用？<br>　　记录档案的属性，一个档案占用一个inode，同时记录此档案的数据所在的block号码（通过inode可查找block的位置）。通过<code>ls -i</code>指令可查询到档案对应的inode号码。<br>block 是什么？<br>　　存储档案内容的内存块，且每块block都对应一个号码。支持的block大小有1k、2k和4k。<br>block 有什么作用？<br>　　存储档案内容，且如果档案太大，会占用多个block。<br><a id="more"></a></p><h2 id="一、文件系统特性"><a href="#一、文件系统特性" class="headerlink" title="一、文件系统特性"></a>一、文件系统特性</h2><p>我们都知道磁盘分区完毕后还需要进行格式化(format)，之后操作系统才能够使用这个分割槽。为什么需要进行【格式化】呢？这是因为每种操作系统所设定的文件属性/权限并不相同， 为了存放这些档案所需的数据，因此就需要将分割槽进行格式化，以成为操作系统能够利用的【文件系统格式(filesystem)】。</p><p>传统的磁盘与文件系统在应用中，一个分割槽就是只能够被格式化成为一个文件系统，所以我们可以说一个 filesystem 就是一个 partition。但是由于新技术的利用，例如我们常听到的LVM 与软件磁盘阵列(software raid)， 这些技术可以将一个分割槽格式化为多个文件系统(例如LVM)，也能够将多个分割槽合成一个文件系统(LVM, RAID)！ 所以说，目前我们在格式化时已经不再说成针对 partition 来格式化了， 通常我们可以称呼一个可被挂载的数据为一个文件系统而不是一个分割槽。</p><p>由于操作系统的档案数据含有非常多的属性，例如 Linux 操作系统的档案权限(rwx)与文件属性(拥有者、群组、时间参数等)。文件系统通常会将这两部分的数据分别存放在不同的区块，权限与属性放置到 inode中，至于实际数据则放置到data block 区块中。 另外，还有一个超级区块 (superblock) 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。</p><p>每个 inode 与 block 都有编号，至于这三个数据的意义可以简略说明如下：</p><blockquote><p>① superblock：记录此 filesystem 的整体信息，包括inode/block 的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；<br>② <font color="red">inode：记录档案的属性，一个档案占用一个inode，同时记录此档案的数据所在的 block 号码；</font><br>③ <font color="red">block：实际记录档案的内容，若档案太大时，会占用多个 block 。</font></p></blockquote><p>由于每个 inode 与 block 都有编号，而每个档案都会占用一个 inode ，inode 内则有档案数据放置的block 号码。 因此，我们可以知道的是，如果能够找到档案的 inode 的话，那么自然就会知道这个档案所放置数据的 block 号码， 当然也就能够读出该档案的实际数据了。</p><p>我们将 inode 与 block 区块用图解来说明一下，如下图所示，文件系统先格式化出 inode 与 block 的区块，假设某一个档案的属性与权限数据是放置到 inode 4 号(下图较小方格内)，而这个 inode 记录了档案数据的实际放置点为 2, 7, 13, 15 这四个 block 号码，此时我们的操作系统就能够据此来排列磁盘的阅读顺序，可以一口气将四个 block 内容读出来！ 那么数据的读取就如同下图中的箭头所指定的模样了。<br><img src="/uploads/2017/12/linux_inode_block.JPG" alt=""></p><p>这种数据存取的方法我们称为索引式文件系统(indexed allocation)。 还有其他的惯用文件系统，例如随身碟(闪存)，随身碟使用的文件系统一般为 FAT 格式。FAT这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个档案的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中， 他的读取方式有点像底下这样：<br><img src="/uploads/2017/12/linux_fat.JPG" alt=""></p><p>上图中我们假设档案的数据依序写入1-&gt;7-&gt;4-&gt;15 号这四个 block 号码中， 但这个文件系统没有办法一口气就知道四个 block 的号码，他得要一个一个的将 block 读出后，才会知道下一个 block 在何处。 如果同一个档案数据写入的 block 分散的太过厉害时，则我们的磁盘读取头将无法在磁盘转一圈就读到所有的数据， 因此磁盘就会多转好几圈才能完整的读取到这个档案的内容！</p><p>常常会听到所谓的【碎片整理】吧？ 需要碎片整理的原因就是档案写入的 block 太过于离散了，此时档案读取的效能将会变的很差。 这个时候可以透过碎片整理将同一个档案所属的 blocks 汇整在一起，这样数据的读取会比较容易。</p><h2 id="二、EXT2文件系统："><a href="#二、EXT2文件系统：" class="headerlink" title="二、EXT2文件系统："></a>二、EXT2文件系统：</h2><p>如上所知，inode 的内容在记录档案的权限与相关属性，至于 block 区块则是在记录档案的实际内容。 而且文件系统一开始就将 inode 与 block 规划好了，除非重新格式化(或者利用resize2fs 等指令变更文件系统大小)，否则 inode 与 block 固定后就不再变动。但是如果仔细考虑一下，如果我的文件系统高达数百GB 时，那么将所有的 inode 与 block 通通放置在一起将是很不智的决定，因为 inode 与 block 的数量太庞大，不容易管理。</p><p>为此之故，因此 Ext2 文件系统在格式化的时候基本上是区分为多个区块群组 (block group) 的，每个区块群组都有独立的 inode/block/superblock 系统。感觉上就好像我们在当兵时，一个营里面有分成数个连，每个连有自己的联络系统， 但最终都向营部回报连上最正确的信息一般！这样分成一群群的比较好管理！整个来说，Ext2 格式化后有点像底下这样：<br><img src="/uploads/2017/12/linux_ext2.JPG" alt=""></p><p>在整体的规划当中，文件系统最前面有一个启动扇区(boot sector)，这个启动扇区可以安装开机管理程序， 这是个非常重要的设计，因为如此一来我们就能够将不同的开机管理程序安装到个别的文件系统最前端，而不用覆盖整颗硬盘唯一的 MBR（主要开机区，Master boot record, MBR）， 这样也才能够制作出多重引寻的环境！至于每一个区块群组(block group)的六个主要内容说明如下：</p><p>（1）data block (资料区块)<br>data block 是用来放置档案内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K三种而已。在格式化时 block 的大小就固定了，且每个 block 都有编号，以方便 inode 的记录。 不过要注意的是，由于 block 大小的差异，会寻致该文件系统能够支持的最大磁盘容量与最大单一档案容量并不相同。 因为 block 大小而产生的 Ext2 文件系统限制如下：</p><table><thead><tr><th>Block 大小</th><th>1KB</th><th>2KB</th><th>4KB</th></tr></thead><tbody><tr><td>最大单一档案限制</td><td>16GB</td><td>256GB</td><td>2TB</td></tr><tr><td>最大文件系统总容量</td><td>2TB</td><td>8TB</td><td>16TB</td></tr></tbody></table><p><em>（注：在进行文件系统的格式化之前，要想好该文件系统预计使用的情况来选择 Block 大小。过大会产生较严重的磁盘容量浪费，较小则大型档案会占用数量更多的block，而inode也要记录更多的block号码，将可能导致文件系统不良的读写效能。）</em></p><p>（2）inode table (inode 表格)<br>如前所述 inode 的内容在记录档案的属性以及该档案实际数据是放置在哪几号 block 内。基本上，inode 记录的档案数据至少有以下这些：</p><pre><code>该档案的存取模式(read/write/excute)；该档案的拥有者与群组(owner/group)；该档案的容量；该档案建立或状态改变的时间(ctime)；最近一次的读取时间(atime)；最近修改的时间(mtime)；定义档案特性的旗标(flag)，如 SetUID...；该档案真正内容的指向 (pointer)；</code></pre><p>inode 的数量与大小也是在格式化时就已经固定了，除此之外 inode 还有些什么特色呢？</p><pre><code>每个 inode 大小均固定为 128 bytes；每个档案都仅会占用一个 inode 而已；承上，因此文件系统能够建立的档案数量与 inode 的数量有关；系统读取档案时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够开始实际读取 block 的内容。</code></pre><p>inode 要记录的数据非常多，但偏偏又叧有 128bytes 而已， 而 inode 记录一个 block 号码要花掉 4byte ，假设我一个档案有 400MB 且每个block 为 4K 时， 那么至少也要十万笔 block 号码的记录呢！inode 哪有这么多可记录的信息？为此我们的系统很聪明的将 inode 记录 block 号码的区域定义为12 个直接，一个间接, 一个双间接与一个三间接记录区。这是啥？我们将 inode 的结构画一下好了。<br><img src="/uploads/2017/12/linux_inode.JPG" alt=""></p><p>上图最左边为 inode 本身 (128 bytes)，里面有 12 个直接指向 block 号码的对照，这 12 笔记录就能够直接取得 block 号码。 至于所谓的间接就是再拿一个 block 来当作记录 block 号码的记录区，如果档案太大时， 就会使用间接的 block 来记录编号。如上图，当中间接只是拿一个 block 来记录额外的号码而已。 同理，如果档案持续长大，那么就会利用所谓的双间接，第一个 block 仅再指出下一个记录编号的 block 在哪里， 实际记录的在第二个 block 当中。依此类推，三间接就是利用第三层block 来记录编号。</p><p>这样子 inode 能够指定多少个 block 呢？我们以较小的 1K block 来说明好了，可以指定的情况如下：</p><pre><code>12 个直接指向： 12*1K=12K　由于是直接指向，所以总共可记录 12 笔记录，因此总额大小为如上所示；间接： 256*1K=256K　每笔 block 号码的记录会花去 4bytes，因此 1K 的大小能够记录 256 笔记录，因此一个间接可以记录的档案大小如上；双间接： 256*256*1K=2562K　第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个号码，因此总额大小如上；三间接： 256*256*256*1K=2563K　第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个第三层，每个第三层可以指定256 个号码，因此总额大小如上；总额：将直接、间接、双间接、三间接加总，得到 12 + 256 + 256*256 + 256*256*256 (K) =16GB</code></pre><p>此时我们知道当文件系统将 block 格式化为 1K 大小时，能够容纳的最大档案为 16GB，比较一下文件系统限制表的结果可发现是一致的！但这个方法不能用在 2K 及 4K block 大小的计算中， 因为大于2K 的 block 将会受到 Ext2 文件系统本身的限制，所以计算的结果会不太符合。</p><p>（3）Superblock (超级区块)<br>Superblock 是记录整个 filesystem 相关信息的地方，没有 Superblock ，就没有这个 filesystem了。他记录的信息主要有：</p><pre><code>block 与 inode 的总量；未使用与已使用的 inode / block 数量；block 与 inode 的大小 (block 为 1, 2, 4K，inode 为 128 bytes)；filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 (fsck) 的时间等文件系统的相关信息；一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为1 。</code></pre><p>Superblock 是非常重要的，因为我们这个文件系统的基本信息都写在这里，因此，如果 superblock死掉了， 你的文件系统可能就需要花费很多时间去挽救。一般来说， superblock 的大小为1024bytes。相关的 superblock 信息可以使用 dumpe2fs 指令来查看。<br>此外，每个 block group 都可能含有 superblock 。但是我们也说一个文件系统应该仅有一个superblock 而已，那是怎么回事？ 事实上除了第一个 block group 内会含有 superblock 之外，后续的 block group 不一定含有 superblock ， 而若含有 superblock 则该 superblock 主要是做为第一个 block group 内 superblock 的备份，这样可以进行 superblock 的救援。</p><p>（4）Filesystem Description (文件系统描述说明)<br>这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段 (superblock,bitmap, inodemap, data block) 分别介于哪一个 block 号码之间。这部分也能够用 dumpe2fs 来查看。</p><p>（5）block bitmap (区块对照表)<br>如果你想要新增档案时会用到 block，那你要使用那个 block 来记录呢？当然是选择【空的block】来记录新档案的数据。 那你怎么知道那个 block 是空的？这就得要透过 block bitmap 的辅助。从 block bitmap 当中可以知道哪些 block 是空的，因此我们的系统就能够很快速的找到可使用的空间来处置新档案。<br>同样的，如果你删除某些档案时，那么那些档案原本占用的 block 号码就得要释放出来， 此时在block bitmpap 当中相对应到该 block 号码的标志就得要修改为【未使用中】。这就是 bitmap的功能。</p><p>（6）inode bitmap (inode 对照表)<br>这个其实与 block bitmap 是类似的功能，只是 block bitmap 记录的是使用与未使用的 block 号码，至于 inode bitmap 则是记录使用与未使用的 inode 号码。</p><p><strong>每个区段与 superblock 的信息都可以使用 dumpe2fs 这个指令来查询的，查询的方法与实际的观察如下：</strong><br>dumpe2fs [-bh] 装置文件名<br>选项与参数：<br>-b ：列出保留为坏轨的部分(一般用不到！？)<br>-h ：仅列出 superblock 的数据，不会列出其他的区段内容！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由此文Get到的知识点：&lt;br&gt;inode 是什么？&lt;br&gt;　　记录档案的号码。&lt;br&gt;inode 有什么作用？&lt;br&gt;　　记录档案的属性，一个档案占用一个inode，同时记录此档案的数据所在的block号码（通过inode可查找block的位置）。通过&lt;code&gt;ls -i&lt;/code&gt;指令可查询到档案对应的inode号码。&lt;br&gt;block 是什么？&lt;br&gt;　　存储档案内容的内存块，且每块block都对应一个号码。支持的block大小有1k、2k和4k。&lt;br&gt;block 有什么作用？&lt;br&gt;　　存储档案内容，且如果档案太大，会占用多个block。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/tags/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之man</title>
    <link href="http://yoursite.com/2017/12/25/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bman/"/>
    <id>http://yoursite.com/2017/12/25/Linux命令之man/</id>
    <published>2017-12-25T10:14:16.000Z</published>
    <updated>2017-12-25T10:19:58.728Z</updated>
    
    <content type="html"><![CDATA[<p>　　在文本模式下，你可以直接按下两个[Tab]按键，可以查看总共有多少指令可以使用。可以看到有将近2千个命令，那如何记忆呢？肯定不可能全部记下来，所以，软件的开发者为了让大家能够了解指令的用法， 都会自行制作很多的文件，而这些文件也可以直接在在线就能够轻易的被使用者查询出来。<br><a id="more"></a></p><h4 id="1、man-page"><a href="#1、man-page" class="headerlink" title="1、man page"></a>1、man page</h4><p>简单记忆就是，不会该指令，就找男人（man）呀！（注：man就是manual的缩写。）<br>示例：man date （结果自己操作，此处不贴图）<br>首先，在上个表格的第一行，你可以看到的是：【DATE(1)】，DATE 我们知道是指令的名称， 那么(1)代表什么呢？他代表的是【一般用户可使用的指令】的意思。<br>常见的几个数字的意义是这样的：</p><table><thead><tr><th>代号</th><th>代表内容</th></tr></thead><tbody><tr><td>1</td><td>用户在shell 环境中可以操作的挃令戒可执行文件</td></tr><tr><td>2</td><td>系统核心可呼叫的凼数不工具等</td></tr><tr><td>3</td><td>一些常用的凼数(function)不凼式库(library)，大部分为C 的凼式库(libc)</td></tr><tr><td>4</td><td>装置档案的说明，通常在/dev 下的档案</td></tr><tr><td>5</td><td>配置文件戒者是某些档案的格式</td></tr><tr><td>6</td><td>游戏(games)</td></tr><tr><td>7</td><td>惯例不协议等，例如Linux 文件系统、网绚协议、ASCII code 等等的说明</td></tr><tr><td>8</td><td>系统管理员可用的管理挃令</td></tr><tr><td>9</td><td>跟kernel 有关的文件</td></tr></tbody></table><p>上述的表格内容可以使用【man 7 man】来更详绅的取得说明。<br>再来，man page 的内容也分成好几个部分来加以介绍该指令呢！就是上头man date 那个表格内，以NAME 作为开始介绍，最后还有个SEE ALSO 来作为结束。基本上，man page 大致分成底下这几个部分：</p><table><thead><tr><th>代号</th><th>内容说明</th></tr></thead><tbody><tr><td>NAME</td><td>简短的指令、数据名称说明</td></tr><tr><td>SYNOPSIS</td><td>简短的指令下达诧法(syntax)简介</td></tr><tr><td>DESCRIPTION</td><td>较为完整的说明，这部分最好仔细看看！</td></tr><tr><td>OPTIONS</td><td>针对 SYNOPSIS 部分中，有列丼的所有可用的选项说明</td></tr><tr><td>COMMANDS</td><td>当这个程序(软件)在执行的时候，可以在此程序(软件)中下达的指令</td></tr><tr><td>FILES</td><td>这个程序或数据所使用或参考或连结到的某些档案</td></tr><tr><td>SEE ALSO</td><td>可以参考的，跟这个指令或数据有相关的其他说明！</td></tr><tr><td>EXAMPLE</td><td>一些可以参考的范例</td></tr><tr><td>BUGS</td><td>是否有相关的臭虫！</td></tr></tbody></table><p>有时候除了这些外，还可能会看到Authors与Copyright 等，不过也有很多时候仅有NAME与DESCRIPTION 等部分。<br>注：退出按q<br><em>（相对应的与man -f 等价的是 whatis ）</em></p><h4 id="2、info-page-（自我感觉不好用，就不做说明了）"><a href="#2、info-page-（自我感觉不好用，就不做说明了）" class="headerlink" title="2、info page （自我感觉不好用，就不做说明了）"></a>2、info page （自我感觉不好用，就不做说明了）</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　在文本模式下，你可以直接按下两个[Tab]按键，可以查看总共有多少指令可以使用。可以看到有将近2千个命令，那如何记忆呢？肯定不可能全部记下来，所以，软件的开发者为了让大家能够了解指令的用法， 都会自行制作很多的文件，而这些文件也可以直接在在线就能够轻易的被使用者查询出来。&lt;br&gt;
    
    </summary>
    
      <category term="每日一个Linux命令" scheme="http://yoursite.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux下文件与权限详解</title>
    <link href="http://yoursite.com/2017/12/25/Linux%E4%B8%8B%E6%96%87%E4%BB%B6%E4%B8%8E%E6%9D%83%E9%99%90%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/12/25/Linux下文件与权限详解/</id>
    <published>2017-12-25T06:48:56.000Z</published>
    <updated>2017-12-26T10:27:41.165Z</updated>
    
    <content type="html"><![CDATA[<p>　　首先，需要知道的是，“Linux下一切皆档案”。且Linux一般将档案可存取的身份分三个类别，分别是 owner/group/others，且三种身份各有 read/write/execute 等权限。<br>（注：对应的档案存储文件为： 用户记录在 /etc/passwd 档案； 用户密码记录在 /etc/shadow 档案；组名记录在 /etc/group 档案。）</p><ul><li>所有者（owner）：<br>一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者。（使用chown修改文件的所有者）</li><li>文件所在组（group）：<br>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组。（使用chgrp修改文件所在的组）</li><li>其它人（others）：<br>除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组<a id="more"></a><h3 id="档案信息详解"><a href="#档案信息详解" class="headerlink" title="档案信息详解"></a>档案信息详解</h3>由命令 ls -al查看档案的所有信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root 42304 Dec 25 17:26 install.log &lt;=范例说明处</span><br><span class="line">[权限] [链接数] [拥有者] [群组] [档案容量] [修改日期] [档名]</span><br></pre></td></tr></table></figure></li></ul><ol><li>第一栏代表这个档案的类型与权限(permission)：<br>第一个字符代表这个档案是『目录、档案或链接文件等等』：<ul><li>当为[ d ]则是目彔，例如上表档名为『.gconf』的那一行；</li><li>当为[ - ]则是档案，例如上表档名为『install.log』那一行；</li><li>若是[ l ]则表示为链接档(link file)；</li><li>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。<br>（其余字符没3个为一组，分别对应所有者、所属组、其他人。）</li></ul></li><li>第二栏表示有多少档名链接到此节点(i-node，即是索引节点)：<br>每个档案都会将他的权限与属性记录到文件系统的i-node 中，不过，我们使用的目录树却是使用文件名来记录， 因此每个档名就会连结到一个i-node！这个属性记录的，就是有多少不同的档名连结到相同的一个i-node 号码去就是了。</li><li>第三栏表示这个档案(或目录)的『拥有者账号』</li><li>第四栏表示这个档案的所属群组</li><li>第五栏为这个档案的容量大小，默认单位为bytes；</li><li>第六栏为这个档案的建档日期或者是最近的修改日期：</li><li>第七栏为这个档案的档名</li></ol><h3 id="改变档案属性与权限命令"><a href="#改变档案属性与权限命令" class="headerlink" title="改变档案属性与权限命令"></a>改变档案属性与权限命令</h3><p>1、chgrp（change group）：改变档案所属群组<br>语法：<code>chgrp [-R] dirname/filename ...</code><br>选项与参数：<br>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有档案、目录都更新成为这个群组之意。常常用在变更某一目录内所有的档案之情况。<br>范例：<br><code>[root@www ~]# chgrp users install.log</code><br>2、chown（change owner）：改变档案拥有者<br>语法：<code>chown [-R] 账号名称[:组名] 档案或目录</code><br>选项与参数：<br>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有档案都变更<br>范例：将install.log 的拥有者改为bin 这个账号：<br><code>[root@www ~]# chown bin install.log</code><br>3、chmod ：改变档案的权限, SUID, SGID, SBIT 等等的特性<br>语法：<code>chmod [-R] xyz 档案或目录</code><br>选项与参数：<br>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。<br>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有档案都会变更</p><ol><li>数字类型改变档案权限<br>我们可以使用数字来代表各个权限，各权限的分数对照表如下：<br>r:4<br>w:2<br>x:1<br><code>[root@www ~]# chmod 777 .bashrc</code></li><li>符号类型改变档案权限<br>基本上就九个权限分别是(1)user (2)group (3)others 三种身份。那么我们就可以藉由u, g, o 来代表三种身份的权限！此外，a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r, w, x。<br><img src="/uploads/2017/12/linux_permission_01.png" alt=""><br>假如我们要『限定』一个档案的权限成为『-rwxr-xr-x』时，基本上就是：<br> user (u)：具有可读、可写、可执行的权限；<br> group 不 others (g/o)：具有可读不执行的权限。<br><code>[root@www ~]# chmod u=rwx,go=rx .bashrc</code><br><em>注意：那个 u=rwx,go=rx 是连在一起的，中间并没有任何空格符！</em></li></ol><h3 id="权限对于文件与目录的作用"><a href="#权限对于文件与目录的作用" class="headerlink" title="权限对于文件与目录的作用"></a>权限对于文件与目录的作用</h3><h4 id="1、权限对文件的重要性："><a href="#1、权限对文件的重要性：" class="headerlink" title="1、权限对文件的重要性："></a>1、权限对文件的重要性：</h4><p>权限对于档案来说，他的意义是这样的：</p><pre><code>1. r (read)：可读取此一档案的实际内容，如读取文本文件的文字内容等；2. w (write)：可以编辑、新增或者是修改该档案的内容(但不能删除该档案)；3. x (eXecute)：该档案具有可以被系统执行的权限。</code></pre><p>　　Windows 底下一个档案是否具有执行的能力是藉由『 扩展名 』来判断的， 例如：.exe, .bat, .com 等等，但是在Linux 底下，我们的档案是否能被执行，则是藉由是否具有『x』这个权限来决定的！跟档名是没有绝对的关系的！</p><h4 id="2、权限对目录的重要性："><a href="#2、权限对目录的重要性：" class="headerlink" title="2、权限对目录的重要性："></a>2、权限对目录的重要性：</h4><p>目录主要的内容在记录文件名列表，文件名与目录有强烈的关连！所以如果是针对目录时，那个 r, w, x 对目录意义是这样的：</p><pre><code>1. r (read contents in directory)：表示具有读取目录结构列表的权限，如利用 ls 这个指令将该目录的内容列表显示出来；2. w (modify contents of directory)：表示你具有异动该目录结构列表的权限，也就是底下这些权限：    * 建立新的档案与目录；    * 删除已经存在的档案与目录(不论该档案的权限为何！)    * 将已存在的档案或目录进行更名；    * 搬移该目录内的档案、目录位置。3. x (access directory)：目录只是记录文件名而已，不可以被执行，目彔的x 代表的是用户能否进入该目录成为工作目录的用途。</code></pre><h3 id="Linux档案种类与扩展名"><a href="#Linux档案种类与扩展名" class="headerlink" title="Linux档案种类与扩展名"></a>Linux档案种类与扩展名</h3><h5 id="1、档案种类："><a href="#1、档案种类：" class="headerlink" title="1、档案种类："></a>1、档案种类：</h5><p>我们在刚刚提到使用『ls -l』观察到第一栏那十个字符中，第一个字符为档案的类型。 除了常见的一般档案(-)与；目录档案(d)之外，还有哪些种类的文件类型呢？<br>（1）正规档案(regular file )：<br>在由 ls -al 所显示出来的属性方面，第一个字符为 [-]，例如 [-rwxrwxrwx ]。另外，依照档案的内容，又大略可以分为：</p><blockquote><p>1、纯文本档(ASCII)：这是Linux 系统中最多的一种文件类型， 称为纯文本档是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。<br>2、二进制文件(binary)：你的Linux当中的可执行文件(scripts, 文字型批处理文件不算)就是这种格式。举例来说，刚刚下达的指令cat 就是一个binary file。<br>3、数据格式文件(data)：有些程序在运作的过程当中会读取某些特定格式的档案，那些特定格式的档案可以被称为数据文件 (data file)。</p></blockquote><p>（2）目录(directory)：<br>就是目录，第一个属性为 [ d ]，例如 [drwxrwxrwx]。<br>（3）链接档(link)：<br>就是类似Windows 系统底下的快捷方式，第一个属性为 <a href="英文L 的小写"> l </a>，例如[lrwxrwxrwx] ；<br>（4）设备与装置文件(device)：<br>与不系统周边及储存等相关的一些档案，通常都集中在/dev 这个目录之下！通常又分为两种：</p><blockquote><p>1、区块(block)设备档 ：就是一些储存数据，以提供系统随机存取的接口设备，举例来说，硬盘与软盘等。你可以自行查一下/dev/sda 看看， 会发现第一个属性为[ b ]。<br>2、字符(character)设备文件：亦即是一些串行端口的接口设备，例如键盘、鼠标等等。第一个属性为 [ c ]。</p></blockquote><p>（5）资料接口文件(sockets)：<br>既然被称为数据接口文件，这种类型的档案通常被用在网络上的数据承接。第一个属性为 [ s ]， 最常在/var/run 这个目录中看到这种文件类型了。<br>（6）数据输送文件(FIFO, pipe)：<br>FIFO 也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个档案所造成的错误问题。FIFO 是first-in-first-out 的缩写。第一个属性为[p] 。</p><h5 id="2、Linux-档案扩展名："><a href="#2、Linux-档案扩展名：" class="headerlink" title="2、Linux 档案扩展名："></a>2、Linux 档案扩展名：</h5><p>基本上，Linux 的档案是没有所谓的『扩展名』的，我们刚刚就谈过，一个Linux 档案能不能被执行，与他的第一栏的十个属性有关， 与文件名根本一点关系也没有。<br>通常我们还是会以适当的扩展名来表示该档案是什么种类的。底下有数种常用的扩展名：</p><blockquote><p>1、*.sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell 写成的，所以扩展名就编成 .sh；<br>2、*Z, *.tar, *.tar.gz, *.zip, *.tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由与不同的压缩软件，而取其相关的扩展名啰！<br>3、*.html, *.php：网页相关档案，分别代表 HTML 语法与 PHP 语法的网页档案。</p></blockquote><h5 id="3、Linux-文件名的限制："><a href="#3、Linux-文件名的限制：" class="headerlink" title="3、Linux 文件名的限制："></a>3、Linux 文件名的限制：</h5><p>由于Linux 在文字接口下的一些指令操作关系，一般来说，你在设定Linux 底下的文件名时， 最好可以避免一些特殊字符比较好！例如底下这些：<br>* ? &gt; &lt; ; &amp; ! [ ] | \ ‘ “ ` ( ) { }<br>因为这些符号在文字接口下，是有特殊意义的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　首先，需要知道的是，“Linux下一切皆档案”。且Linux一般将档案可存取的身份分三个类别，分别是 owner/group/others，且三种身份各有 read/write/execute 等权限。&lt;br&gt;（注：对应的档案存储文件为： 用户记录在 /etc/passwd 档案； 用户密码记录在 /etc/shadow 档案；组名记录在 /etc/group 档案。）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有者（owner）：&lt;br&gt;一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者。（使用chown修改文件的所有者）&lt;/li&gt;
&lt;li&gt;文件所在组（group）：&lt;br&gt;当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组。（使用chgrp修改文件所在的组）&lt;/li&gt;
&lt;li&gt;其它人（others）：&lt;br&gt;除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之date、cal、bc</title>
    <link href="http://yoursite.com/2017/12/22/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bdate%E3%80%81cal%E3%80%81bc/"/>
    <id>http://yoursite.com/2017/12/22/Linux命令之date、cal、bc/</id>
    <published>2017-12-22T09:42:39.000Z</published>
    <updated>2017-12-22T10:24:58.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、显示日期的指令：date"><a href="#1、显示日期的指令：date" class="headerlink" title="1、显示日期的指令：date"></a>1、显示日期的指令：date</h3><p>如果在文字接口中想要知道目前Linux 系统的时间，那举就直接在指令列模式输入date 即可显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[bluce-ben@www ~]$ date</span><br><span class="line">Fri Dec 22 16:06:43 CST 2017</span><br><span class="line">上面显示的是：星期五, 12月22日, 16:06 分, 43 秒，在 2017 年的 CST 时区！</span><br><span class="line">那如果我想要让这个程序显示出『2017/12/22』这样的日期显示方式呢？ 那就使用date 的格式化输出功能吧！</span><br><span class="line">[bluce-ben@www ~]$ date +%Y/%m/%d</span><br><span class="line">2017/12/22</span><br><span class="line">[bluce-ben@www ~]$ date +%H:%M</span><br><span class="line">16:09</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="2、显示日历的指令：cal"><a href="#2、显示日历的指令：cal" class="headerlink" title="2、显示日历的指令：cal"></a>2、显示日历的指令：cal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[bluce-ben@www ~]$ cal</span><br><span class="line">    December 2017</span><br><span class="line">Su Mo Tu We Th Fr Sa </span><br><span class="line">                            1   2</span><br><span class="line">3    4    5    6   7   8   9</span><br><span class="line">10  11  12  13 14 15 16</span><br><span class="line">17  18  19  20 21 22 23</span><br><span class="line">24  25  26  27 28 29 30</span><br><span class="line">31</span><br></pre></td></tr></table></figure><p>cal (calendar)这个指令可以做的事情还很多，例如你可以显示整年的月历情况：<code>cal 2018</code><br>基本上cal 这个指令可以接的语法为： <code>cal [month] [year]</code></p><h3 id="3、简单好用的计算器：bc"><a href="#3、简单好用的计算器：bc" class="headerlink" title="3、简单好用的计算器：bc"></a>3、简单好用的计算器：bc</h3><p>Linux提供了一支计算程序，就是bc。你在指令列输入bc 后，屏幕会显示出版本信息， 之后就进入到等待指示的阶段。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[bluce-ben@www ~]$ bc</span><br><span class="line">bc 1.06</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details type `warranty&apos;.</span><br><span class="line">_ &lt;==这个时候，光标会停留在这里等徃你的输入</span><br></pre></td></tr></table></figure></p><p>常用运算符：</p><ul><li>+ 加法</li><li>- 减法</li><li>* 乘法</li><li>/ 除法</li><li>^ 挃数</li><li>% 余数</li></ul><h3 id="补充一些小Tips："><a href="#补充一些小Tips：" class="headerlink" title="补充一些小Tips："></a>补充一些小Tips：</h3><ol><li>[Tab]：如果在command后按时，代表【命令补全】；如果在第二个字以后按，就变成【档案补齐】的功能了。</li><li>[Ctrl] + c：表示中断目前程序的按键。</li><li>[Ctrl] + d：表示【键盘输入结束】的意思，可以用来取代exit的输入。</li><li>在文本模式下，你可以直接按下两个[Tab]按键，可以查看总共有多少指令可以使用。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、显示日期的指令：date&quot;&gt;&lt;a href=&quot;#1、显示日期的指令：date&quot; class=&quot;headerlink&quot; title=&quot;1、显示日期的指令：date&quot;&gt;&lt;/a&gt;1、显示日期的指令：date&lt;/h3&gt;&lt;p&gt;如果在文字接口中想要知道目前Linux 系统的时间，那举就直接在指令列模式输入date 即可显示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[bluce-ben@www ~]$ date&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Fri Dec 22 16:06:43 CST 2017&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;上面显示的是：星期五, 12月22日, 16:06 分, 43 秒，在 2017 年的 CST 时区！&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;那如果我想要让这个程序显示出『2017/12/22』这样的日期显示方式呢？ 那就使用date 的格式化输出功能吧！&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[bluce-ben@www ~]$ date +%Y/%m/%d&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2017/12/22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[bluce-ben@www ~]$ date +%H:%M&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16:09&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="每日一个Linux命令" scheme="http://yoursite.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>道哥自述： 为什么弹性安全网络将诞生最大的人工智能？</title>
    <link href="http://yoursite.com/2017/12/21/%E9%81%93%E5%93%A5%E8%87%AA%E8%BF%B0%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%B9%E6%80%A7%E5%AE%89%E5%85%A8%E7%BD%91%E7%BB%9C%E5%B0%86%E8%AF%9E%E7%94%9F%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%9F%E2%80%94%E2%80%94%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    <id>http://yoursite.com/2017/12/21/道哥自述：为什么弹性安全网络将诞生最大的人工智能？——《2017阿里技术》/</id>
    <published>2017-12-21T09:50:54.000Z</published>
    <updated>2017-12-26T09:42:32.453Z</updated>
    
    <content type="html"><![CDATA[<p>　　阿里妹导读：前阵子，阿里科学家王刚、吴翰清同时入选MIT2017年度TR35 开创中国互联网企业先河一文刷爆了朋友圈，阿里巴巴人工智能实验室首席科学家王刚、阿里云首席安全科学家吴翰清同时入选MIT2017。这是自该奖项创立18年以来，第一次中国公司里同时有2人入选榜单。今天，阿里妹分享一篇来自吴翰清（也就是大家熟悉的道哥、小黑）的文章，让我们一起走进道哥的弹性安全网络世界。<br><a id="more"></a><br><img src="/uploads/2017/12/alibaba_daoge_01.png" alt=""><br>　　前些天得知自己入选了MIT的TR35，非常开心。我想这是中国安全技术在国际上被认可的一次证明。但这个荣誉不仅属于我一个人，更属于我团队中所有为此做出过努力和贡献的人，也属于那些敢于和我们一起尝试最新技术的客户们，因为新技术在诞生之初往往是生涩的，但缺少了孵化过程中的磨难，我们永远见不到美丽绽放的那天。我也非常感谢王坚博士、弓峰敏博士、华先胜老师、Dawn Song教授能够成为我的TR35推荐人，感谢你们对我所从事的工作的认可。<br>　　自从参加工作以来，我一直执着于将中国技术推向全球，我认为中国有着最好的安全技术和最好的人，只是缺乏了让他们成长的土壤和展示的舞台。所以我也希望这次MIT对我个人的认可，能够成为一次鼓励中国安全产业的优秀人才和优秀技术成果走向世界的契机。长期以来，我们享受了很多开源技术的红利，但中国技术对世界互联网发展的贡献却非常微薄。我认为这中间有语言的障碍，有文化的障碍，但没有能力的障碍。现在是时候让我们去跨越这些障碍，去解决全球互联网发展过程中遇到的那些问题了。只有中国本土的优秀人才成长起来，中国才会变得更加强大。<br>　　回顾我十多年的工作生涯，期间从事和研究过非常多的技术工作，但我认为唯有「弹性安全网络」的研究是最独特的。「弹性安全网络」不是对现有技术的一种应用， 它是真正的发明了一项此前所没有的技术，提出了一种全新的方法，采用了一个全新的角度来看待现有世界。也因此它能跳出现有的技术框架，带来一些突破性的惊喜。这些惊喜，往往连创造者都没有办法在一开始就想清楚。正如从比特币中抽象出了区块链技术一样，最早我们构建的产品「游戏盾」是用来防御超大流量DDoS攻击，最后抽象出来的「弹性安全网络」技术，却让我们看到了构建下一代互联网的可能性。<br>　　简单来说，弹性安全网络是将DDoS防御前置到网络边缘处。但是，未来真正要做的事情是通过端到端的连接，通过风险控制技术，重新构建一个干净的、安全的互联网。<br>　　前些天《麻省理工学院技术评论》的记者对我做了一次采访，我完整的阐述了一次关于弹性安全网络的构想。我把这次采访的录音放在这里，分享给所有对这项技术感兴趣的人，并附上整理后的文字稿（但依然强烈推荐听录音原文）。未来我希望有更多人参与到对「弹性安全网络」的建设中来。</p><h2 id="为什么要做弹性安全网络"><a href="#为什么要做弹性安全网络" class="headerlink" title="为什么要做弹性安全网络"></a>为什么要做弹性安全网络</h2><p>　　互联网的流量就像流淌在管道里的水，但互联网发展到今天，流量里已经掺杂了太多的东西，变得不再纯粹和健康了。比如说，这些流量里面包含了很多攻击请求，也有很多恶意爬虫请求和一些欺诈行为的请求。<br>　　理想状况下，我们希望未来的流量是干净、健康的，希望把所有的网络攻击前置到整个网络的边缘处。就是说进入这张网络的时候，流量本身就是干净的。这就是clear traffic的概念。<br>　　为了实现这个想法，我们遇到了很多的困难。我们在思考，需要用一个什么样的架构去实现它。刚巧这个时候，我们有一些客户尝试用快速切换的思路来对抗DDoS攻击。这给了我灵感。最终，我把两个东西结合起来，产生了做弹性安全网络的想法。</p><h2 id="什么是弹性安全网络"><a href="#什么是弹性安全网络" class="headerlink" title="什么是弹性安全网络"></a>什么是弹性安全网络</h2><p>　　弹性安全网络真正想要去做的，是替换掉整个互联网最核心的心脏，替换掉DNS，从而让网络变得有弹性，能够快速调度资源，形成一个全新的网络架构。<br>　　事实上，DNS诞生在互联网早期，是互联网1.0时代的产物，是一个开放的协议。到今天，也没有一个独立的运营商来运营整个互联网的DNS Server。它分散在各家不同的运营商。全球可能有上百家运营商，都在提供自己的DNS服务。运营商跟运营商之间的打通，是通过标准的DNS协议进行数据交换。<br>　　这也是为什么这么多年DNS协议都没办法进步的原因，过于碎片化。<br>　　目前，DNS有三个显著问题。第一个，是DNS完全解析的时间过长，这是整个DNS使用中遇到的一个非常大的痛点。<br>　　比如，对于一个大型网站，要把用户的所有流量指向一个新地址。把DNS的解析修改之后，可能需要花两到三天时间，流量才会百分之百的切到新地址去，不会在旧地址上还有残余流量。<br>　　为什么需要两到三天时间？原因是有很多运营商的DNS递归解析服务器，都需要更新自己的数据。而有的运营商还有自己的省级运营商，甚至更下面的地市级的DNS的递归解析。过于碎片化，使得难于进行统一的数据管理，这是今天现实存在的问题。<br>　　第二个问题是今天DNS Server软件中的解析数遇到了瓶颈，没有办法一个名字解析到几千个、甚至上万个，甚至未来十几万个不同地址。一个名字可能最多也就解析到十几个或几十个地址就不能再扩大了。这种瓶颈限制了我们的一些能力拓展。<br>　　第三个就是，原本可以基于DNS去实现的一些安全机制，比如风险控制，并没有建立起来。其实也比较好理解，在互联网1.0时代并没有如今天这般强大的数据能力和计算能力。<br>　　今天，我们要解决这些问题。在整个弹性安全网络的架构下面，我们在构思下一代的互联网应该是什么形态？答案就是通过可靠的快速调度技术把互联网心脏重构掉。<br>　　首先，就是它的快速解析的能力，一定要非常实时以及干净。其次，就是它本身支持的调度能力，要能达到上万的这个级别，规模特别的重要，就是一个名字能够解析到上万个地址、甚至是十几万个地址。<br>　　我们以防御DDoS攻击为切入点，进行尝试。过去防御DDoS攻击时，必须要做的是储备单点大带宽。因为IP是变不了的（在中国的网络环境下由于政策原因暂不考虑anycast的方案）。所以在DNS架构下，就是去硬抗这个IP遇到的流量攻击。比如说300G的流量打过来，必须要有300G的带宽在这里，才能够扛得住。如果只有100G的带宽，那整个机房就被堵死了，甚至可能会影响到运营商的网络稳定。<br>　　这是在过去攻防对抗的思路，就是你攻击打过来多少，我就必须要有多少带宽储备在这儿。这比的是资源，比的是单纯的带宽储备。<br>　　我们现在的思路是，你攻击这个IP，我马上就把这个IP拿掉，不要这个IP了，然后启用一个新的地址，并告诉所有客户，你来访问新地址。<br>　　当然，这时候攻击者会跟随，但是攻击者跟随是有成本的。一般，攻击者跟随到一个新地址，需要大概10多分钟。<br>　　在这个10分钟里，通过数据分析的方式，我们可以分析出攻击者到底是谁，把好人和坏人分离出来，阻止坏人的流量，并同时放干净的流量继续访问，这就是整个弹性安全网络的核心思想。</p><h2 id="如何实现弹性安全网络"><a href="#如何实现弹性安全网络" class="headerlink" title="如何实现弹性安全网络"></a>如何实现弹性安全网络</h2><p>　　弹性安全网络的实现，是通过快速完成上万个地址的调度，从根本上改变过去需要在单点储备大带宽的一种防御方式能力。<br>　　就是，你不需要在单点储备大带宽了，你需要的更多的地址，更强的数据分析能力。<br>　　要知道，单点储备大带宽的价格非常贵。改用这种方式之后，DDoS防御成本可以下降两到三个数量级，因为不需要再单点储备大带宽。<br>　　做完这个之后，我们就发现，其实这个事情，最重要的不是多了一种对抗DDoS攻击的方法，而是改变了DNS本身，这是本质的东西。所以，我们是用一种新技术去解决了一个老问题。</p><h2 id="弹性安全网络将诞生最大的人工智能"><a href="#弹性安全网络将诞生最大的人工智能" class="headerlink" title="弹性安全网络将诞生最大的人工智能"></a>弹性安全网络将诞生最大的人工智能</h2><p>　　沿着弹性安全网络的思路，我们希望通过风险控制来管理整个互联网的资源。<br>　　未来，弹性安全网络将重新定义互联网的入口。通过为每一个访问者建立“足迹库”，分析他是好人还是坏人的概率。一旦判断这次访问请求可能是有风险的，则可以随即让他访问不到这个资源。<br>　　所以，未来最大的人工智能应该是诞生在弹性安全网络，因为整个互联网的资源都被管理起来了，而且是基于每一个访问者的行为沉淀，来判断风险。<br>　　相当于想要进入这个封闭的网络，每个访客要先过安检。只有通过安检才能访问到这个资源。而且，访客所有的历史行为会被积累下来，为未来的风险判断做储备。而今天互联网的心脏– DNS，由于其开放性和碎片性，已经失去了将所有访问数据统一汇聚后进行分析的可能性。<br>　　在一个自成闭环的体系里面，由一家基础设施的提供商，去运营整个网络心脏的这种解析服务。然后也基于这种解析服务，它能够对整个网内的所有访客进行智能分析，最终就能够实现这张网内的所有访客的请求，都是在风险控制之下的，从而构建一个全新的互联网。</p><h2 id="弹性安全网络的未来"><a href="#弹性安全网络的未来" class="headerlink" title="弹性安全网络的未来"></a>弹性安全网络的未来</h2><p>　　今天，一些阿里云上的游戏客户，就是通过弹性安全网络的技术，来调度他们所有的游戏资源，同时对所有玩家进行风险控制的。<br>　　弹性安全网络自成闭环。也就是说，这些使用弹性安全网络的游戏，已经从我们现在的互联网，也就是今天以DNS为支撑的这个互联网里，消失掉了。<br>　　一个玩家，通过DNS，是访问不到弹性安全网络这张网里的所有资源的。未来我们要做的事情就是，不断地去扩大这张网，直到网内可调度的资源覆盖整个互联网的资源。<br>　　目前来看，主要机会就是在IoT和移动互联网，因为这两者实际上是没有DNS的需求的。过去，之所以需要DNS，是因为有一个浏览器，浏览器里面有一个地址栏，这个东西必须通过输入一个好记的地址，才能访问到资源。<br>　　在移动互联网时代，今天手机不需要浏览器，而是直接打开一个App。那这个App访问的是什么东西，它不一定需要DNS来解析。<br>　　这是我们看到今天这个技术有可能走下去的一个非常重要的原因。<br>　　延伸出来，在IoT时代，也是不需要有一个浏览器去访问你所需要访问的服务和资源的。<br>　　所以这是我看到，这张网在未来有可能升级今天整个互联网最重要的一个原因。</p><h2 id="阿里将开放弹性安全网络技术能力"><a href="#阿里将开放弹性安全网络技术能力" class="headerlink" title="阿里将开放弹性安全网络技术能力"></a>阿里将开放弹性安全网络技术能力</h2><p>　　未来，阿里会开放弹性安全网络的技术。<br>　　类似DNS，弹性安全网络本身也不涉及任何访问资源，它只是知道你今天到这个地方来了。就像，一个人今天到某个国家去，需要入关和出关，是一个道理。<br>　　事实上，在很多关键领域，弹性安全网络非常有价值。<br>　　比如，各个国家政府，或者大型企事业单位的专网或内网。如果它是以DNS为核心的话，那这是一个暴露在整张网内的弱点。因为DNS是一个公开的服务。一旦DNS这个单点被瘫痪掉，整张网可能就没法工作了，所以这是非常大的风险。<br>　　所以，弹性安全网络技术，不是为某一个客户设计的，它是为整个互联网设计的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　阿里妹导读：前阵子，阿里科学家王刚、吴翰清同时入选MIT2017年度TR35 开创中国互联网企业先河一文刷爆了朋友圈，阿里巴巴人工智能实验室首席科学家王刚、阿里云首席安全科学家吴翰清同时入选MIT2017。这是自该奖项创立18年以来，第一次中国公司里同时有2人入选榜单。今天，阿里妹分享一篇来自吴翰清（也就是大家熟悉的道哥、小黑）的文章，让我们一起走进道哥的弹性安全网络世界。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《2017阿里技术》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《2017阿里技术》" scheme="http://yoursite.com/tags/%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴CTO张建锋： 下一波创新机会，重点关注这三个领域</title>
    <link href="http://yoursite.com/2017/12/21/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4CTO%E5%BC%A0%E5%BB%BA%E9%94%8B%EF%BC%9A%E4%B8%8B%E4%B8%80%E6%B3%A2%E5%88%9B%E6%96%B0%E6%9C%BA%E4%BC%9A%EF%BC%8C%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E8%BF%99%E4%B8%89%E4%B8%AA%E9%A2%86%E5%9F%9F-%E2%80%94%E2%80%94%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    <id>http://yoursite.com/2017/12/21/阿里巴巴CTO张建锋：下一波创新机会，重点关注这三个领域-——《2017阿里技术》/</id>
    <published>2017-12-21T07:28:59.000Z</published>
    <updated>2017-12-26T09:42:23.173Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/2017/12/alibaba_damo_02.png" alt=""><br><a id="more"></a><br>　　2017杭州·云栖大会首日，阿里巴巴集团CTO张建锋宣布成立达摩院，将在全球各地建立实验室，并引入更多高校教授参与其中，未来三年投入1000亿元进行基础科学研发。<br>　　以下为演讲全文：<br>　　大家上午好，我想借这个机会，把阿里巴巴技术的一些想法和大家做一个分享。一年前马老师提出了“五新”战略，其中像“新零售”，我们看到盒马、无人咖啡店，得到了非常快速的发展。今天想首先跟大家分享一下“新技术”，以及“新技术”是怎么跟阿里巴巴的未来结合起来的。</p><h2 id="互联网的第三次波浪潮：智联网、人机自然交互、机器智能"><a href="#互联网的第三次波浪潮：智联网、人机自然交互、机器智能" class="headerlink" title="互联网的第三次波浪潮：智联网、人机自然交互、机器智能"></a>互联网的第三次波浪潮：智联网、人机自然交互、机器智能</h2><p>　　阿里巴巴是一家成长于互联网时代、扎根于互联网时代的一家公司，我们对技术有着非常深刻的体会跟理解。<br>　　互联网时代第一波浪潮，是把计算机从一个单一的工具变成了一个平台，它把信息都连接在一起了，比较有代表性的一些企业，比如作为搜索的像Google，它把全世界散落在单点的数据、信息都连成一个平台，这是它带来最大的价值。<br><img src="/uploads/2017/12/alibaba_zhangjianfeng_01.png" alt=""><br>　　第二波我认为是移动互联网的发展。移动互联网把信息分享、传递变得更加自然，这一波里面，我觉得最大的贡献就是今天我们在讲的，像社交、应用等等。阿里巴巴在这一波浪潮中做了一件跟大家想象中不一样的事情——我们做电子商务不仅提供一个货架，而是通过互联网这个平台，把消费者跟生产者连接在一起，把品牌跟消费者连接在一起。这个连接其实跟其他人说的做零售、做电子商务是有一个非常本质的区别的——这个连接是双向的，通过这个连接可以诞生出、创造出无数新的可能，而不仅仅是说我通过电子商务、从事互联网来提升零售效率。所以到今天为止，我们走出了一条非常独特的道路。<br>　　今天，PC的销量已经连续在下降，萎缩得比较厉害了。现在去电子市场，纯粹卖一台PC，基本上没有什么生存空间了；以手机为代表的无线互联网，手机从2016年开始，基本上稳定在四亿的出货量，在中国，也没有新的增量。手机操作界面已经决定了，这个界面只有一个屏幕，这个屏幕里面可以放的东西是有限的，现在的超级APP基本上占据了手机最主要的入口来源。<br>　　下一波机会来自于什么地方，我们思考后觉得有三个领域值得关注：<br>　　第一个，是智联网。因为现在还有这么多的设备、这么多的物体没有被连接。以IoT为代表的智联网应该是接下来最需要解决的一个问题。这上面我们也做了非常多的尝试，我们做的城市大脑，希望把城市里面所有的物体连接起来，小到井盖、电线杆，再到马路、到红绿灯，都能够通过物联网连接起来，但我们认为光连接是不够的，因为连接只是把所有的人、物聚在一起，我们还需要去感知，还需要去处理数据，最终我们还要实时做出决策，去控制被连接的主体，这才是有价值的智联网。<br><img src="/uploads/2017/12/alibaba_zhangjianfeng_02.png" alt=""><br>　　第二个，新一代人机自然交互。今天我们有了很多交互手段，包括现在非常热门的自动驾驶。自动驾驶目前要解决的主要是一个人机交互的问题。开车一定要拿一个方向盘吗，可能没有这个必要；控制空调就一定要拿摇控器吗，可能也没有这个必要。因为我们可以有更自然的方式，可能是语音，可能是其他的。以苹果手机为代表，它从原先的键盘式操作，升级到屏幕触摸式的操作，但它只是在一个范围之内的升级。我们希望能够把整个人机交互，从家里的一切应用到驾驶，都有全面的升级。<br>　　还有一个，就是机器智能。马老师非常强调我们做的是机器智能。为什么要说我们做的是机器智能，机器智能跟人工智能到底有什么区别？<br>　　我的理解，今天我们很多东西之所以这样做，是因为以前人类就是这么做的——以前的做法都是要人来控制，所以我今天不想让人来控制了，我要机器来控制，所以要模仿人类来控制。举个例子，现在人工智能里面最热门的是做图像识别，我们在交通上也好，在城市管理上也好，装了无数的摄像头，因为我们拍了这么多的照片， 现在我们人看不过来了，所以需要机器来看，所以机器又要模仿人的所有思考方法，重新认识这个图片。但是我们有没有想过，假如这个照片就是用机器来看的，那为什么一定要拍成现在这个照片的样子，它直接可以是机器认识的就可以了，机器可能不一定要4K、8K、高清、彩色，可能是从另外一个角度去理解这个世界。 王坚博士举过一个例子，人的东西一定是最好的吗，狗的嗅觉比人更好，你用机器来模仿，会做得更好吗？<br>　　所以，我们要做的是，把机器变得有智能，而且变成独立的智能，这个智能应该是机器的能力决定的，而不是人类的能力决定的。这也是为什么，我们今天一定要用机器智能这个概念，重新定义我们真正要的智能是怎么样的一个智能。</p><h2 id="平台化、实时化的数据是未来世界的血液"><a href="#平台化、实时化的数据是未来世界的血液" class="headerlink" title="平台化、实时化的数据是未来世界的血液"></a>平台化、实时化的数据是未来世界的血液</h2><p>　　我们今天要做这么多事情，要解决这么多连接的问题，不可避免的会产生大量数据。这个世界一定会被数字化的，我们对此深信不疑，因为只有数字化之后，才有自动化的可能，才有智能化的可能。九年前，阿里巴巴第一次提出阿里巴巴是一家大数据公司，数据是能源，但我今天想说的是，数据不仅是能源，如果机器智能、智联网，包括人机自然交互组成一个人体的话，数据就是血液，没有这个血液，所有上面的一切都没有创新的能量来源。数据，我们认为它远远不止于这个资源，它是组成所有未来一切的血液。这是我们怎么来看待未来这个世界一个非常重要的出发点。<br>　　今后的数据有两个特点非常重要：<br>　　一个是实时性。数据一定要非常实时。以前一个产品要推广，做广告。三个月之后，厂家才知道这个广告做得好不好，这个效果好不好，消费者买不买单，这个时候才能去组织生产、组织安排。现在我们这些数字化的广告，每一分钟都知道我这个效果怎么样。<br>　　第二个，数据一定要平台化，一定要融合贯通。阿里巴巴有三件事情是统一的，其中最重要的一件事情就是数据的统一，我们统一定义、清洗、处理。我举个例子，我们跟小黄车它们合作，把小黄车给联网了，我们知道每一个车的运行轨迹，我们也知道它的密度。知道这个小区到哪个小区，或者哪个小区到哪个地方，骑共享单车的人是不是特别多。这个数据拿到之后，一方面可以改进小黄车的运营效率，这个数据如果被公交公司知道了，公交公司可以优化它的公交线路，现在没有这些数据，公交公司说今天班车在开，我一直往前开好了。所以数据一定要平台化，它只有融会贯通之后，才能产生新的生产力，才能有新的创造力。<br>　　互联网公司跟传统公司有什么不一样，以前我们都讲互联网思维，互联网思维是一个什么样的思维？对于阿里巴巴来讲，我们觉得互联网思维，第一就是一个数据思维——你必须要有数据，你才能做出一些合理的决策。传统公司的CEO跟互联网公司的CEO有很大的不一样，传统公司的CEO，他做一个决定，他想知道这个决定正确还是错误，可能要验证很久。在互联网公司，逍遥子可能跟我们讨论，这个页面按钮应该是红色还是蓝色，为什么做这个决定，他有这个数据，他知道改了之后，这个数据有变化了，他敢于做这种决定。我觉得这就是互联网公司跟传统公司非常大的不一样。<br>　　我们有一个不成文的规定：我们开会，我跟他们讲，第一，你有数据说数据；没有数据，那就说案例；没有案例，就说观点。都没有，那就不要说了，说了也没用。数据是第一位的，有数据，你就跟CEO一样有这个Power，这是互联网思维里面非常重要的一个维度。</p><h2 id="汇聚全球智慧，以科技创新世界的阿里巴巴达摩院"><a href="#汇聚全球智慧，以科技创新世界的阿里巴巴达摩院" class="headerlink" title="汇聚全球智慧，以科技创新世界的阿里巴巴达摩院"></a>汇聚全球智慧，以科技创新世界的阿里巴巴达摩院</h2><p>　　今天我们要做这么多的东西，智联网、人机自然交互、机器智能等等等等，我们后面还有非常多的问题要解决。这些问题包括我们的计算能力、计算平台、算法，自然语言的处理、理解，安全，还有更底层的芯片，更底层的操作系统。因为今天对于阿里巴巴这家公司来说，你已经不可能从市面上买到商用的一些产品来支撑我们未来发展需要的技术。所以我们必须要自己去做更深层次、更高维度的研发。<br>　　科学是什么，科学是用来发现规律、掌握规律的；技术是什么，技术是来利用这个规律的；而工程是来实现这个规律的。阿里巴巴这么多年来，通过双11积累了非常强的工程技术能力。我们今天把双11这一天的技术保障称为“互联网的超级工程”。很多超级工程，比如造世界第一的高楼大桥。而阿里巴巴的双11技术支撑这套体系，要支撑那么大规模的业务，解决无数的技术问题，它就是一个“超级工程”。但今天我们想更进一步，我们觉得光解决工程技术问题不够，我们还想掌握规律、发现规律，这是我们真正能够引领未来、真正能够定义未来的核心要素。<br><img src="/uploads/2017/12/alibaba_zhangjianfeng_03.png" alt=""><br>　　今天，在这里，我们正式宣布成立阿里巴巴的全球研究院。因为我们需要有更多的人才，一起参与，一起来改变这个世界。我们这个研究院有一个独一无二的名字叫做阿里巴巴达摩院。<br>　　我们计划在三年之内，对新技术投资超过1000亿人民币，我们想要在技术上面，真正做一些原创性、根本性的探索。这么多钱干什么，我们想吸引全球一流的人才，我们也始终认为人才是真正的生产力。在阿里巴巴达摩院，不是叫你来做苦行僧的，是叫你来做骑士的，你们是新一代的骑士，你们不是壮士，科学工作者必须得到应得的尊重与荣誉，这就是阿里巴巴达摩院。<br>　　阿里巴巴有这么多的技术、这么多的平台，我们还有一个非常重要的思想，我们不仅去探索未来，不仅服务好我们自己的业务，我们还想通过阿里云这个平台去赋能所有创业者。因为我们是这么想的，所以我们八年前就这么做了——我们做了云计算。我们有这个Believe，我们相信这个事情一定会发生，我们才做这个事情，我们并不是像其它云计算公司一样，因为我要转型升级了，是因为这个东西非常流行。我做云计算，我们真的是因为坚信。<br><img src="/uploads/2017/12/alibaba_damo_03.png" alt=""><br>　　整个达摩院由三个部分组成：<br>　　第一部分，我们在全球各地建自己的实验室，这是阿里巴巴集团自己投资的。我们在以色列、新加坡、莫斯科、西雅图跟圣马特奥都建立了自己的研究机构。在数据智能、智联网、大数据处理等等方面，做一些前沿性的基础性研究，并且能够快速把这些研究成果变成我们业务上可以用的一些东西，也可以通过阿里云这个平台，变成所有人可以使用的一个技术基础设施。<br>　　第二部分，我们是跟高校建立联合研究所。我们跟浙江大学联合成立的前沿技术研究中心运行得非常好，有很多教授、博士在这个平台上工作。为什么吸引他们在这个平台上工作，因为我们有非常大的计算装置，我们有非常多的业务场景。我们采用非常与众不同的方法，别人可能是这样，我有一个项目建好了，然后交给别人来招投标，交给浙大，你来做。我们不是这样——今天这个时代，发现一个问题，跟解决一个问题的难度是一样的。我们在定义未来的世界，发现问题对我们来说也是很大的挑战。我们请他们进来，我们一起来看到底有什么问题，用你们的眼光来看有什么问题，我们一起来解决。我们今天跟浙大、跟伯克利、跟清华大学等都成立了联合实验室，一起来做这个事情。<br>　　第三部分，是我们的产学研平台。这个平台非常有意思，我们把要解决的非常多的问题做成一个列表，发给全球的所有高校、机构。高校、机构的教授、学者，对他们感兴趣的研究方向做一个匹配，然后来写他的Proposal，我们看这个Proposal跟我们是否匹配。我们现在有四十多个项目正在开始启动做，而且这个教授、机构，绝大部分来自于海外，国内很多高校也参加了。<br><img src="/uploads/2017/12/alibaba_damo_01.png" alt=""><br>　　最终我们这个达摩院会是三部分：我们自己会建实验室，跟高校做联合实验室，通过产学研平台这个项目，让更多的教授、机构能够参与进来。最终我们希望以科技来创新这个世界，来改变这个世界，这是我们达摩院的愿景。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/2017/12/alibaba_damo_02.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《2017阿里技术》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《2017阿里技术》" scheme="http://yoursite.com/tags/%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>达摩院：阿里巴巴的科技雄心</title>
    <link href="http://yoursite.com/2017/12/21/%E8%BE%BE%E6%91%A9%E9%99%A2%EF%BC%9A%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%9A%84%E7%A7%91%E6%8A%80%E9%9B%84%E5%BF%83-%E2%80%94%E2%80%94%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    <id>http://yoursite.com/2017/12/21/达摩院：阿里巴巴的科技雄心-——《2017阿里技术》/</id>
    <published>2017-12-21T07:03:44.000Z</published>
    <updated>2017-12-26T09:42:46.484Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/2017/12/alibaba_mayun_01.png" alt=""><br><a id="more"></a><br>　　10月11日，以“飞天·智能”为主题2017杭州·云栖大会在浙江杭州云栖小镇开幕，阿里巴巴董事局主席马云在开幕式上演讲。（本文来源：中国新闻周刊）<br>　　四名科学家同时盖上印章后，两名“武者”展开长卷，淡淡的水墨之间，“达摩院”三个大字跃然纸上。<br><img src="/uploads/2017/12/alibaba_damo_01.png" alt=""><br>　　在武侠世界里，“达摩院”代表着武林绝学和至尊，这是阿里巴巴董事局主席马云为新成立的研究院取的名字。就在2017云栖大会前两周，阿里巴巴集团首席人力官童文红给马云打电话，讨论研究院如何命名，马云灵光一闪，“达摩院”三字脱口而出。<br>　　而在此前长达半年的酝酿中，阿里巴巴内部都将这个新机构称做“阿里巴巴全球创新研究院”。<br>　　“为什么一定要研究院、实验室这样的说法，为什么不能创造一个自己的名字，我觉得达摩院就很好。”马云在给童文红的电话中说，他甚至连英文名都想好了，就是拼音DAMO。<br>　　正如在名称上独辟蹊径一样，马云希望达摩院能走出自己的模式，“我们会学习IBM，学习微软，学习贝尔实验室，学习在过去人类历史科技发展过程中取得的巨大的经验和教训，但我们必须走出自己的路。”<br>　　按照阿里巴巴在云栖大会上的说法，“达摩院”是探索人类科技未来的实验室，阿里巴巴将在研发投入1000亿元，用于涵盖基础科学和颠覆式技术创新的研究。<br>　　在阿里巴巴董事局主席马云看来，这是18岁的阿里巴巴应有的担当精神。他将“达摩院”视为阿里巴巴将留给世界最好的东西之一。有一天即使阿里巴巴不在了，希望“达摩院”还能继续存在。为了做到这一点，“达摩院”必须做到商业与科技、市场与研究的完美结合。</p><h2 id="“向技术要红利！”"><a href="#“向技术要红利！”" class="headerlink" title="“向技术要红利！”"></a>“向技术要红利！”</h2><p>　　在十年前，马云可不是这样想的。那时候的他，曾经坚决反对公司有任何研究室、实验室，因为在他看来，当时阿里巴巴还是一个初创公司，在还没有立足之前就考虑研发是大灾难。<br>　　在“达摩院”筹备组成员、阿里巴巴技术战略部总监刘湘雯的印象中，早在2008年，阿里巴巴就已经从战略层面考虑，从一家电商公司变成一家数据公司。尽管有这样一个愿景，大家却并不知道如何去做。当时，阿里巴巴的平台沉淀了很多数据，怎样去发挥数据的价值，从技术上怎么做，引发了阿里巴巴高层一系列的思考。<br>　　最终，马云选择了相信云计算，成立了阿里云计算有限公司。虽然没有被叫做“研究院”，但在刘湘雯看来，这是阿里巴巴第一次从战略上向科技进行转移。至此，阿里巴巴全面进入云计算，对自身的定位也从一家电商公司变成一家数据驱动的公司。<br>　　2014 年，阿里巴巴成立了iDST（Institute of Data Science&amp;Technologies），这是阿里巴巴集团专注于底层数据技术研究的机构。此前，马云已经把下一个时代命名为DT时代，也就是数据科技时代。而iDST以机器学习、深度学习技术为依托，打造图像视频、语音交互、自然语言理解、智能决策等人工智能核心技术， 为阿里巴巴集团的电商、金融、物流、社交、娱乐等业务提供强大的技术后盾。这些AI技术通过阿里云平台对外形成产品化的输出。<br>　　用刘湘雯的话说，“达摩院”的成立是一个水到渠成的过程，离不开“母体”阿里巴巴的发展。一个公司只有当业务发展到一定的阶段，有足够复杂的场景，足够多的业务体量，才会有足够多的科技难题出现，才能支撑一群科学家在里面做事情，才会产生一家机构，因此，“达摩院”的出现是阿里巴巴发展的必然。<br>　　“如果说阿里云让我们拥有了计算的能力，那么iDST则更多的是提供算法的能力。我们集中建设了这样一批能力，加上本身具有非常丰富的场景跟数据，然后才提出了向更纵深去发展。”刘湘雯解释道。<br>　　刘湘雯第一次听到马云谈到关于建立“达摩院”的设想是在今年3月，阿里巴巴内部召开了首次技术大会，会上马云分享了他的科技愿景。马云认为，此前18年，阿里巴巴的商业场景推动了技术升级，面向未来20年，核心技术升级才能推动商业模式创新，必须建立起NASA这样的机构。<br><img src="/uploads/2017/12/alibaba_damo_02.png" alt=""><br>　　“必须向技术要红利！”这句话，阿里巴巴首席技术官张建锋在会上重复了多次。而早在2016年云栖大会上，马云就提出过“五新”战略，即新零售、新金融、新制造、新技术和新能源。截至2017年3月，新零售已经在落实，新金融正在布局，“已经到半路了”，接下来“必须组建阿里的新技术”。<br>　　在这次技术大会上，马云动员全球两万多名科学家和工程师投身“新技术战略”，并启动“NASA”计划，“面向机器学习、芯片、物联网、操作系统、生物识别这些核心技术，我们将组建崭新的团队，建立新的机制和方法，全力以赴。”马云强调，“以前我们的技术跟着业务走，是‘兵工厂模式’，但手榴弹造得再好，也造不出导弹来。阿里巴巴必须思考建立导弹的机制，成立新技术研发体系，聚焦核心领域的研究。”<br>　　阿里巴巴有着巨大的野心——未来20年，阿里巴巴要构建世界第五大经济体，服务全球20亿消费者，创造1亿就业机会，帮助1000万家企业盈利。因此，“NASA”计划的目标也是面向未来20年，其产品或服务能够覆盖到20亿人。</p><h2 id="“NASA”计划"><a href="#“NASA”计划" class="headerlink" title="“NASA”计划"></a>“NASA”计划</h2><p>　　据刘湘雯介绍，“NASA”计划的2万多人，不仅是研究人员，也包括工程技术人员。近3年来，阿里巴巴人才数量年均增长40％以上，目前拥有2.5万名工程师和科学家，500多位博士。在36位合作人中，有9位拥有工程师背景。<br>　　同时，阿里巴巴也面向全球网罗顶尖科技人才。今年3月，人工智能专家、前南洋理工大学教授王刚加入阿里人工智能实验室。6月26日，亚马逊最顶级的华人科学家任小枫加盟了阿里，出任iDST副院长。<br>　　9月11日，量子技术领域的重量级人物施尧耘加入阿里巴巴，担任阿里云量子技术首席科学家，负责组建并领导阿里云量子计算实验室，同时，施尧耘也在之江实验室担任副主任，该实验室是由浙江省政府、浙江大学、阿里巴巴集团出资成立的混合所有制新型研发机构，9月6日正式挂牌成立。<br>　　按照“NASA”计划，如果2万多人才全涌到阿里巴巴所在地杭州，似乎也并不现实，在人才聚集地建立海外实验室成为实现“NASA”计划的更好方式。就在云栖大会当天，阿里巴巴首席技术官张建锋透露，“达摩院”已经开始在全球各地组建前沿科技研究中心，包括亚洲达摩院、美洲达摩院、欧洲达摩院，并在北京、杭州、新加坡、以色列、圣马特奥、贝尔维尤、莫斯科等地设立不同研究方向的实验室，初期计划引入100名顶尖科学家和研究人员。<br>　　张建锋表示，选择在何地建实验室主要有两个原则，一是根据当地的人才状况，比如以色列的安全做得很好，美国的一些大数据算法人才比较好等；二是跟业务有一些关系，比如新加坡本身是有产业基础的，更有利于科技成果在当地转化。<br>　　据刘湘雯介绍，现在杭州、北京两地的实验室已经在建设中，美洲、欧洲等实验室的人员陆续到位，已经开始做一些事情。新加坡在加快团队建设的速度，可能很短的时间就能到位。俄罗斯和以色列的实验室还处于筹备阶段。<br>　　“NASA”计划已见雏形，但究竟研究哪些领域并没有确定。10月10日，就在云栖大会前一天，13位顶级科学家造访阿里巴巴，并与马云举办了一场座谈。<br>　　在这13位科学家中，包括中国唯一的图灵奖获得者姚期智院士、中国量子力学第一人潘建伟院士、定义了“计算思维”的哥伦比亚大学教授周以真、全球人脸识别技术“开拓者”和“探路者”汤晓鸥教授等。这些科学家研究领域不同，但都参与了“达摩院”的出谋划策。<br>　　数年前，潘建伟曾向阿里巴巴提出，成立一个中科院跟阿里巴巴联合量子计算的实验室。今年7月30日，中国科学院－阿里巴巴量子计算实验室正式成立，实验室将结合阿里云在经典计算算法、架构和云计算方面的技术优势，以及中科院在量子计算和模拟、量子人工智能等方面的优势，颠覆摩尔定律，探索超越经典计算机的下一代超快计算技术。<br>　　“当时我说可能15年之内都不会有产出，也不会有回报。没想到阿里巴巴很快参与进来合作。”潘建伟感慨地说。<br>　　这也是“达摩院”三大组成部分之一，即自主研究中心、与高校和研究机构建立的联合实验室（研究中心）和全球开放研究项目。<br>　　与具有科研优势、地缘优势的著名高校联合建立科研基地是阿里学术合作的主要方式之一。继去年10月成立清华大学－蚂蚁金服金融科技联合实验室，今年1月成立UC Berkeley RISE 实验室之后，“NASA”计划启动以来，5月成立了阿里巴巴－浙江大学前沿技术联合研究中心，阿里巴巴不断探索新的合作模式，汇集诸多技术领域内全球最优秀的学术人才，共同打造高效率的科技创新链条和一体化的创新体系。<br>　　学术合作的另一种方式是发布全球开放研究项目，将阿里巴巴遇到的工程和技术挑战和各个实验室里最强的学术大脑进行碰撞，进而实现工业界与学术界科技能力的融合。在此次云栖大会上，公布了“阿里巴巴创新研究计划（AIR）”2017全球课题评选结果，在13个国家和地区的99个高校与科研机构（国内54个，海外45个）提交申请的234份科研项目提案中，有40余个优秀项目最终入选。<br>　　AIR 是阿里巴巴集团探索科技创新设立的首个全球性科研项目，聚焦技术驱动未来，致力于推进计算机科学领域基础性、前瞻性、突破性的研究，以校企深度合作的方式引领重大科技创新的实践应用，构建技术生态。以此搭建学术界、工业界的合作平台，联合双方优势共同促进前沿技术的发展。<br>　　“一家公司要做长远的科研非常不容易。世界上很少有公司能够做到。阿里巴巴能够有此决心，不只是做跟阿里巴巴商业相关的东西，非常高瞻远瞩。”姚期智对达摩院的雄心表示赞赏。</p><h2 id="来势汹汹"><a href="#来势汹汹" class="headerlink" title="来势汹汹"></a>来势汹汹</h2><p>　　“达摩院”在成立之初，便显出凶猛的势头。在马云的演讲中，已经提出“必须要超越英特尔，必须超越微软，必须超越IBM”，而首批公布的学术委员会更是“星光熠熠”，十人中有三位中国两院院士、五位美国科学院院士，包括世界人工智能泰斗Michael I. Jordan、分布式计算大家李凯、人类基因组计划负责人George M. Church等。<br>　　这样的登场，使得达摩院从一开始便赚足了眼球。<br>　　“科学研究是有其自身规律的，需要大量的资源、资金和人才，而研究的周期和结果更是无法预测，‘达摩院’才刚起步，现在谈发展如何还为时尚早。”一位某知名企业研究机构的工作人员表示。<br>　　“达摩院”首批公布的13个研究领域，包括量子计算、机器学习、基础算法、网络安全、视觉计算、自然语言处理、下一代人机交互、芯片技术、传感器技术、嵌入式系统等，涵盖机器智能、智联网、金融科技等多个产业领域。<br>　　“这是一个综合决策的过程！”刘湘雯表示，从今3月开始，就在确定研究领域，不光有科研人员，还有从事产业研究的人员，以及公司管理层。<br>　　刘湘雯表示，这些领域基本上会基于整个科技发展的规律，一方面是阿里巴巴自身的业务诉求，另外一方面，虽然没有看清楚它对业务有怎样的影响，但从大趋势来看，有可能是颠覆性的，比如量子计算机。<br>　　然而，一些基础性或颠覆性的学科可能投入大，而回报慢，作为一家企业所属的研究院，必须考虑不同类别学科的合理组合。因此要放回产业成熟度的链条上，有一些可能三五年能见到成果，有一些可能需要十年以上。“但究竟是怎样一个比例，目前没法给出一个确切的数字。”刘湘雯说。<br>　　在中国产学研合作促进会秘书长王建华看来，“达摩院”的建立值得鼓励，要创新一种模式，总需要有人先去探索、实践，“达摩院”正是这样一种探索。<br>　　另一个冲击眼球的是阿里巴巴的人才战略，10月16日，“达摩院”宣布，微软亚洲研究院首席研究员聂再清博士、谷歌Tango和DayDream项目技术主管李名杨博士，入职阿里人工智能实验室。<br>　　不难发现，“NASA”计划实施以来，加入阿里和“达摩院”的顶尖人才，除了来自高校和科研院所，有相当一部分来自于知名企业研究院，加上马云对几家研究机构的公开“宣战”，很难不让人联想到“挖墙脚”一词。<br>　　“达摩院”的成立起到了一种“鲶鱼效应”，相当于整个科研生态里出了一个新物种，一定会打破暂时的平衡，也一定会有人才的流动。但即使达摩院从某处吸引了一个人才，造成该处暂时的空缺，肯定会从另一处补进一个人才，使整个系统领域在某个阶段会快速地进行重新定位，重新达成一种平衡，并且这种平衡往往会比原来更健康。<br>　　按照马云对“达摩院”的定位，即“Research for solving the problem with profit and fun（为解决问题研究并带来利润和快乐）”，刘湘雯认为，“达摩院”招揽的人才除了在专业上彼此认可，在时间地点上恰好也适合这些客观条件之外，从软性条件上来说，双方对于愿景的驱动这件事情要有高度的契合。</p><h2 id="经营之道"><a href="#经营之道" class="headerlink" title="经营之道"></a>经营之道</h2><p>　　近年来，阿里巴巴不断加大技术上的投入。财报显示，阿里巴巴2017财年技术投入为170亿元，居中国互联网公司之首。<br>　　此次“达摩院”的成立，阿里巴巴宣布将在3年内投入1000亿元，相当于每年330多亿元，几乎是2017财年技术投入的一倍。但在马云眼里，这笔钱只是给“达摩院”的创业基金，实验室绝不能等资金，要有挣钱意识，才能活下去。“我希望不仅仅靠论文活下来，90％以上研究的东西，不能只在实验室里面，必须在市场上。只有这样，这个实验室才能走得长。”马云说。<br>　　如何挣钱？作为“达摩院”首任院长，张建锋对此回应道，达摩院作为一个依托大数据而建立的新型的研究机构，需要一个产业的支撑。而阿里巴巴拥有诸多业务，有金融科技，有电子商务，有物流等等，都是对研究非常重要的支持。同时，依托于阿里云平台，达摩院可以连接更多的应用场景给客户，使他们通过研究院和阿里云这个平台，能够去做智慧城市，做工业大脑，做医疗大脑，连接更多的行业。“我认为这是现在达摩院最大的价值。”<br>　　刘湘雯认为，阿里巴巴企业的本质决定了“达摩院”在做科技成果转化上是有天然优势的。<br>　　在她看来，一方面，阿里巴巴有丰富的业务场景，都会来到“达摩院”里找他们能用的东西，而“达摩院”通过设立技术开放日，也可以向业务团队去介绍他们的东西。<br>　　另一方面，更大的优势就是阿里云。“阿里云从‘达摩院’这头看，是一个放大器，从客户那头看是一个漏斗。”刘湘雯说。<br>　　在旷视研究院院长孙剑看来，企业研究院分为两种，一种是研究的内容和企业没有太大关系，主要只是起到“保险”的作用，确保公司将来在大的方向上不要走错；另一种是研究和企业，和当前产品能够有效结合，为公司赚钱。<br>　　“其实如果看过去的这些研究院，当一个公司快速发展的时候，或者公司的赚钱是非常没有问题的时候，这个研究院是会蓬勃发展的。但是公司的经济有问题的话，研究院是第一个会被考虑裁减的，因此在企业快速发展，在形势大好的时候，最需要拿出资源投入对未来的投资。”孙剑表示。<br>　　从这一角度，阿里巴巴三年1000亿元的投入，显然能给“达摩院”一个相对宽松的科研环境，但如何运用这笔资金，也是大家关注的焦点。<br>　　刘湘雯表示，达摩院实行的是院长负责制，资金大部分可能会花在人才上，因为对于一个研究院来说，最主要的就是人才，此外，还将用于购买必要的科研设施。<br>　　接下来，“达摩院”既会建自己的研究院，也会建联合的实验室，还会向学术界开放，资金也会朝这三个方向分配。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/2017/12/alibaba_mayun_01.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《2017阿里技术》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《2017阿里技术》" scheme="http://yoursite.com/tags/%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>25岁Java工程师如何转型学习人工智能？</title>
    <link href="http://yoursite.com/2017/12/20/25%E5%B2%81Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%A6%82%E4%BD%95%E8%BD%AC%E5%9E%8B%E5%AD%A6%E4%B9%A0%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%9F%E2%80%94%E2%80%94%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    <id>http://yoursite.com/2017/12/20/25岁Java工程师如何转型学习人工智能？——《2017阿里技术》/</id>
    <published>2017-12-20T07:25:12.000Z</published>
    <updated>2017-12-26T09:42:14.553Z</updated>
    
    <content type="html"><![CDATA[<p>　　“大牛我要问”栏目推出一段时间后，阿里妹收到不少童鞋的来信，其中以职业发展、技术成长的困惑居多。<br>　　今天阿里妹选择了一个颇具有代表性的问题：关于目前大热的AI入门学习，希望能帮助有同样问题的童鞋解惑指路。<br>　　来信问题：25岁Java工程师如何转型学习AI？<br>　　我是一名25岁的Java开发工程师。本科学习的专业是信息与计算科学（数学专业），因为对计算机方面感兴趣，之后培训学习了Java，所以现在从事Java开发。目前就是在电商公司开发一些系统。<br>　　我对人工智能非常感兴趣，对数学的兴趣也从未减弱。人工智能设计的学习材料很多，像我这样的状况，如果想要转型以后从事这方面的工作，具体应该学习些什么？<br><a id="more"></a><br>　　阿里技术童鞋“以均”回信：<br>　　首先，我想聊聊为何深度学习最近这么火。<br>　　外行所见的是2016年AlphaGo 4比1 战胜李世石，掀起了一波AI热潮，DeepMind背后所用的深度学习一时间火得不得了。其实在内行看来，AlphaGo对阵李世石的结果是毫无悬念的，真正的突破在几年前就发生了。<br>　　2012年，Gefferey Hinton的学生Alex使用一个特别构造的深度神经网络（后来就叫AlexNet），在图像识别的专业比赛ImageNet中，得到了远超之前最好成绩的结果，那个时候，整个人工智能领域就已经明白，深度学习的革命已经到来了。<br>　　果然，之后深度学习在包括语音识别，图像理解，机器翻译等传统的人工智能领域都超越了原先各自领域效果最好的方法。从2015年起，工业界内一些嗅觉灵敏的人士也意识到，一场革命或已到来。</p><h1 id="关于基本概念的学习"><a href="#关于基本概念的学习" class="headerlink" title="关于基本概念的学习"></a>关于基本概念的学习</h1><h3 id="机器学习与深度学习"><a href="#机器学习与深度学习" class="headerlink" title="机器学习与深度学习"></a>机器学习与深度学习</h3><p>　　深度学习是机器学习中的一种技术，机器学习包含深度学习。机器学习还包含其他非深度学习的技术，比如支持向量机，决策树，随机森林，以及关于“学习”的一些基本理论，比如，同样都能描述已知数据的两个不同模型，参数更少的那个对未知数据的预测能力更好（奥卡姆剃刀原理）。<br>　　深度学习是一类特定的机器学习技术，主要是深度神经网络学习，在之前经典的多层神经网络的基础上，将网络的层数加深，并辅以更复杂的结构，在有极大量的数据用于训练的情况下，在很多领域得到了比其他方法更好的结果。</p><h3 id="机器学习与大数据"><a href="#机器学习与大数据" class="headerlink" title="机器学习与大数据"></a>机器学习与大数据</h3><p>　　大数据：机器学习的基础，但在多数语境下，更侧重于统计学习方法。<br>　　机器学习，深度学习，数据挖掘，大数据的关系可以用下图表示<br><img src="/uploads/2017/12/DataMining-BigData-MachineLearning-DeepLearning.png" alt=""></p><h2 id="系统学习资料"><a href="#系统学习资料" class="headerlink" title="系统学习资料"></a>系统学习资料</h2><p>　　深度学习火起来之后，网上关于深度学习的资料很多。但是其质量参差不齐。我从2013年开始就关注深度学习，见证了它从一个小圈子的领先技术到一个大众所追捧的热门技术的过程，也看了很多资料。我认为一个高质量的学习资料可以帮助你真正的理解深度学习的本质，并且更好地掌握这项技术，用于实践。<br>　　以下是我所推荐的学习资料：<br>　　首先是视频课程。</p><h3 id="Yaser-Abu-Mostafa"><a href="#Yaser-Abu-Mostafa" class="headerlink" title="Yaser Abu-Mostafa"></a>Yaser Abu-Mostafa</h3><p>　　加州理工的Yaser Abu-Mostafa教授出品的机器学习网络课程，非常系统地讲解了机器学习背后的原理，以及主要的技术。讲解非常深入浅出，让你不光理解机器学习有哪些技术，还能理解它们背后的思想，为什么要提出这项技术，机器学习的一些通用性问题的解决方法（比如用正则化方法解决过拟合）。强烈推荐。<br>　　课程名称：Machine Learning Course - CS 156<br>　　视频地址：<br>　　<a href="https://www.youtube.com/watch?v=mbyG85GZ0PI&amp;list=PLD63A284B7615313A" target="_blank" rel="noopener">https://www.youtube.com/watch?v=mbyG85GZ0PI&amp;list=PLD63A284B7615313A</a></p><h3 id="Geoffrey-Hinton"><a href="#Geoffrey-Hinton" class="headerlink" title="Geoffrey Hinton"></a>Geoffrey Hinton</h3><p>　　深度学习最重要的研究者。也是他和另外几个人（Yann LeCun，Yoshua Bengio等）在神经网络被人工智能业界打入冷宫，进入低谷期的时候仍然不放弃研究，最终取得突破，才有了现在的深度学习热潮。<br>　　他在Coursera上有一门深度学习的课程，其权威性自不待言，但是课程制作的质量以及易于理解的程度，实际上比不上前面Yaser Mostafa的。当然，因为其实力，课程的干货还是非常多的。<br>　　课程名称：Neural Networks for Machine Learning<br>　　课程地址：<a href="https://www.coursera.org/learn/neural-networks" target="_blank" rel="noopener">https://www.coursera.org/learn/neural-networks</a></p><h3 id="UdaCity"><a href="#UdaCity" class="headerlink" title="UdaCity"></a>UdaCity</h3><p>　　Google工程师出品的一个偏重实践的深度学习课程。讲解非常简明扼要，并且注重和实践相结合。推荐。<br>　　课程名称：深度学习<br>　　课程地址：<a href="https://cn.udacity.com/course/deep-learning--ud730" target="_blank" rel="noopener">https://cn.udacity.com/course/deep-learning--ud730</a></p><h3 id="小象学院"><a href="#小象学院" class="headerlink" title="小象学院"></a>小象学院</h3><p>　　国内小象学院出品的一个深度学习课程，理论与实践并重。由纽约城市大学的博士李伟主讲，优点是包含了很多业内最新的主流技术的讲解。值得一看。<br>　　课程名称：深度学习（第四期）<br>　　课程地址： <a href="http://www.chinahadoop.cn/classroom/45/courses" target="_blank" rel="noopener">http://www.chinahadoop.cn/classroom/45/courses</a></p><h3 id="推荐阅读书目"><a href="#推荐阅读书目" class="headerlink" title="推荐阅读书目"></a>推荐阅读书目</h3><p>　　《Deep Learning the Book》 —— 这本书是前面提到的大牛Yoshua Begio的博士生Goodfellow写的。Goodfellow是生成式对抗网络的提出者，生成式对抗网络被Yann LeCun认为是近年最激动人心的深度学习技术想法。这本书比较系统，专业，偏重理论，兼顾实践，是系统学习深度学习不可多得的好教材。<br>　　英文版：<a href="http://deeplearningthebook.com" target="_blank" rel="noopener">http://deeplearningthebook.com</a><br>　　目前Github上已经有人翻译出了中文版：<br>　　<a href="https://github.com/exacity/deeplearningbook-chinese" target="_blank" rel="noopener">https://github.com/exacity/deeplearningbook-chinese</a></p><h2 id="推荐学习路径"><a href="#推荐学习路径" class="headerlink" title="推荐学习路径"></a>推荐学习路径</h2><p>　　不同的人有不同的需求，有些人希望掌握好理论基础，然后进行实践，有些人希望能够快速上手，马上做点东西，有些人希望理论与实践兼顾。下面推荐几条学习路径，照顾到不同的需求。大家可以根据自己的特点进行选择。<br>　　<strong>Hard way</strong><br>　　Yaser -&gt; Geoffrey Hinton -&gt; UdaCity -&gt; Good Fellow<br>　　特点：理论扎实，步步为营。最完整的学习路径，也是最“难”的。<br>　　推荐指数： 4星<br>　　<strong>Good way</strong><br>　　Yaser -&gt; UdaCity -&gt; 小象学院-&gt; Good Fellow<br>　　特点：理论扎实，紧跟潮流，兼顾实战，最后系统梳理。比较平衡的学习路径。<br>　　推荐指数： 5星<br>　　<strong>“Fast” way</strong><br>　　UdaCity -&gt; Good Fellow<br>　　特点：快速上手，然后完善理论。<br>　　推荐指数： 4星<br>　　<strong>“码农” way</strong><br>　　UdaCity<br>　　特点：快速上手，注重实践。<br>　　推荐指数： 3星</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　“大牛我要问”栏目推出一段时间后，阿里妹收到不少童鞋的来信，其中以职业发展、技术成长的困惑居多。&lt;br&gt;　　今天阿里妹选择了一个颇具有代表性的问题：关于目前大热的AI入门学习，希望能帮助有同样问题的童鞋解惑指路。&lt;br&gt;　　来信问题：25岁Java工程师如何转型学习AI？&lt;br&gt;　　我是一名25岁的Java开发工程师。本科学习的专业是信息与计算科学（数学专业），因为对计算机方面感兴趣，之后培训学习了Java，所以现在从事Java开发。目前就是在电商公司开发一些系统。&lt;br&gt;　　我对人工智能非常感兴趣，对数学的兴趣也从未减弱。人工智能设计的学习材料很多，像我这样的状况，如果想要转型以后从事这方面的工作，具体应该学习些什么？&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《2017阿里技术》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《2017阿里技术》" scheme="http://yoursite.com/tags/%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>技术变化那么快，程序员如何做到不被淘汰？</title>
    <link href="http://yoursite.com/2017/12/20/%E6%8A%80%E6%9C%AF%E5%8F%98%E5%8C%96%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E4%B8%8D%E8%A2%AB%E6%B7%98%E6%B1%B0%EF%BC%9F%E2%80%94%E2%80%94%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    <id>http://yoursite.com/2017/12/20/技术变化那么快，程序员如何做到不被淘汰？——《2017阿里技术》/</id>
    <published>2017-12-20T03:34:28.000Z</published>
    <updated>2017-12-26T09:42:55.628Z</updated>
    
    <content type="html"><![CDATA[<p>作者：空融<br>　　阿里妹导读：写了这么多年的代码，你是否曾经有过这样的迷茫和困惑——技术发展日新月异，奋力追赶的我们，究竟是技术的主人还是技术的奴隶？今天，我们邀请到了蚂蚁金服的技术专家空融，一起来聊聊技术人的软件世界观。<br>　　在浩大的软件世界里，作为一名普通程序员，显得十分渺小，甚至会感到迷茫。我们内心崇拜技术，却也对日新月异的技术抱有深深的恐惧。有时候我会思考难道在技术领域内不断紧跟新潮，不断提升技能就是我的价值所在？那么我是技术的主人还是技术的奴隶？<br>人之所以迷茫往往是找不到工作生活的重心，感受不到工作或生活的价值。那么什么是价值呢？说的大一点就是我改变了世界，说的小一点就是我的所作所为改善了某些问题。如果不清楚自己的行为、目标、价值三者的关系，那么又何来重心？又如何能分得清重要性与优先级呢？<br><a id="more"></a><br>　　程序员的迷茫不仅仅是面对技术繁杂的无力感，更重要的是因为长期埋没于软件世界的浩大的分工体系中，无法看清从业务到软件架构的价值链条，无法清楚定位自己在分工体系的位置，处理不好自身与技术、业务的关系所致。<br>　　很多程序员打心底不喜欢业务，这一点我曾经也经历过，我更宁愿从事框架工具、技术组件研究的相关事情。我有个朋友经常吐槽我说：”你们天天加班加点写了那么多代码，然后呢？有改变什么吗？还不是写出了一堆垃圾。”仔细想想很多时候业务在我们脑海中存留的只是逻辑和流程，我们丢失的是对业务场景的感受，对用户痛点的体会，对业务发展的思考。这些都是与价值紧密相关的部分。我们很自然的用战术的勤快掩盖战略的懒惰！那么这样的后果就是我们把自己限死在流水线的工位上，阉割了自己能够发现业务价值的能力，而过多关注新技术对职场竞争力的价值。这也就是我们面对繁杂技术，而产生技术学习焦虑症的根本原因。</p><h3 id="业务、技术与软件系统的价值链"><a href="#业务、技术与软件系统的价值链" class="headerlink" title="业务、技术与软件系统的价值链"></a>业务、技术与软件系统的价值链</h3><p>　　那么什么是业务呢？就是指某种有目的的工作或工作项目，业务的目的就是解决人类社会与吃喝住行息息相关的领域问题，包括物质的需求和精神的需求，使开展业务活动的主体和受众都能得到利益。通俗的讲业务就是用户的痛点，是业务提供方（比如公司）的盈利点。而技术则是解决问题的工具和手段。比如为了解决用户随时随地购物的业务问题时，程序员利用web技术构建电子商务App，而当需求升级为帮助用户快速选购商品时，程序员会利用数据算法等技术手段构建推荐引擎。 技术如果脱离了业务，那么技术应用就无法很好的落地，技术的研究也将失去场景和方向。而业务脱离了技术，那么业务的开展就变得极其昂贵和低效。<br>　　所以回过头来我们想想自己没日没夜写了那么多的代码从而构建起来的软件系统，它的价值何在呢？说白了就是为了解决业务问题，所以当你所从事的工作内容并不能为解决业务问题带来多大帮助的时候，你应该要及时做出调整。那么软件系统又是如何体现它自身的价值呢？在我看来有如下几个方面的体现：<br>　　<strong>业务领域与功能：</strong>比如支付宝立足支付领域而推出的转账、收款功能等，比如人工智能自动驾驶系统等。<br>　　<strong>服务能力：</strong>这就好比火车站购票窗口，评判它的服务能力的标准就是它能够同时处理多少用户的购票业务，能不能在指定时间内完成购票业务，能不能7*8小时持续工作。对应到软件系统领域，则表现为以下三个方面：</p><pre><code>* 系统正确性(程序能够正确表述业务流程，没有Bug)* 可用性（可以7＊24小时＊365不间歇工作）* 大规模（高并发，高吞吐量）</code></pre><p>　　互联网公司正是借助大规模的软件系统承载着繁多的业务功能，使其拥有巨大的服务能力并借助互联网技术突破了空间限制，高效低廉解决了业务问题，创造了丰厚的利润，这是人肉所不可比拟的。<br>　　理解了这一层面的概念，你就可以清楚这个价值链条：<font color="red">公司依靠软件系统提供业务服务而创造价值，程序员则是通过构建并持续演进软件系统服务能力以及业务功能以支撑公司业务发展从而创造价值。</font><br>　　有了这个价值链条，我们就可以反思自己的工作学习对软件系统的服务能力提升起到了多大的推动作用？可以反思自己的工作学习是否切实在解决领域的业务问题，还是只是做一些意义不大的重复性工作。<br>　　前两天面试了一个候选人，他的工作是从事票务系统开发，他说自己在研究linux内核与汇编语言，我就问他linux内核和汇编语言的学习对你的工作产生了哪些帮助？能否举一个例子？他哑口无言，我内心就觉得这样一个热爱学习的好苗子正迷茫找不到重心，正在做一件浪费精力的事情。<font color="red">正确的学习方式应该是将学习与具体业务场景结合起来，和公司通过软件系统开展业务服务而创造价值，程序员通过提升软件系统服务能力创造价值这一链条串接起来，从对这些价值产生帮助的程度去思考优先级。学习本身没有错，错的往往就是那颗初心。</font><br>　　现在你再来看高并发分布式相关的知识，你会发现并不是因为这些知识比较高深、比较时髦，很多公司有需求才值得学习，而是他们对价值链条有着实实在在的贡献。</p><h3 id="价值驱动的架构"><a href="#价值驱动的架构" class="headerlink" title="价值驱动的架构"></a>价值驱动的架构</h3><p>　　一谈到软件系统，人们免不了想起架构这件事来。之所以此处去谈及架构是因为每一个程序员本质都是软件架构体系中的一分子，我们可能深埋于体系流水线之中，感受不到位置和价值。但如果站在架构这一高度去看这些问题则将会非常透彻。那么架构究竟是什么？和上述的价值链又有什么关系呢？</p><h3 id="什么是架构？"><a href="#什么是架构？" class="headerlink" title="什么是架构？"></a><font color="red">什么是架构？</font></h3><p>　　在我看来软件架构就是将人员、技术等资源组织起来以解决业务问题，支撑业务增长的一种活动。可能比较抽象，我想我们可以从架构师的一些具体工作任务来理解这句话含义：<br>　　<strong>组织业务：</strong>架构师通过探索和研究业务领域的知识，构建自身看待业务的”世界观”。他会基于这种认识拆分业务生命周期，确立业务边界，构建出了一套解决特定业务问题的领域模型，并且确认模型之间、领域之间的关系与协作方式，完成了对业务领域内的要素的组织工作。<br>　　<strong>组织技术：</strong>为了能在计算机世界中运作人类社会的业务模型，架构师需要选用计算机世界中合适的框架、中间件、编程语言、网络协议等技术工具依据之前设计方案组织起来形成一套软件系统方案，在我看来软件系统就像是一种技术组织，即技术组件、技术手段依据某种逻辑被组织起来了，这些技术工具被确定了职责，有了明确分工，并以实现业务功能为目标集合在了一起。比如RPC框架或消息队列被用于内部系统之间的通信服务就如同信使一般，而数据库则负责记录结果，它更像是一名书记员。<br>　　<strong>组织人员：</strong>为了能够实现利用软件系统解决业务问题的目标，架构师还需要关注软件系统的构建过程，他以实现软件系统为号召，从公司组织中聚集一批软件工程师，并将这些人员按不同工种、不同职责、不同系统进行组织，确定这些人员之间的协作方式，并关注这个组织系统是否运作良好比如沟通是否顺畅、产出是否达到要求、能否按时间完成等。<br>　　<strong>组织全局，对外输出：</strong>架构师的首要目标是解决业务问题，推动业务增长。所以他非常关心软件的运行状况。因为只有在软件系统运行起来后，才能对外提供服务，才能在用户访问的过程中，解决业务问题。架构师需要关注运行过程中产生的数据比如业务成功率，系统运行资源占用数据、用户反馈信息、业务增长情况等，这些信息将会帮助架构师制定下一步架构目标和方向。<br>　　所以软件架构不仅仅只是选用什么框架、选用什么技术组件这么简单。它贯穿了对人的组织、对技术的组织、对业务的组织，并将这三种组织以解决业务问题这一目标有机的结合在了一起。<br>　　很多面试的候选人在被问及他所开发的系统采用什么架构的问题时，只会罗列出一些技术组件、技术框架等技术要素，这样看来其根本没有理清架构的深层含义。也有一些架构师只专注对底层技术的研究，以为打造一个卓越的系统是非常牛逼的事情，可是他忽略了软件系统的价值是以解决业务问题的能力、支撑业务增长的能力为衡量标准，所以最后生产出了很多对组织，对业务没有帮助的系统。</p><h3 id="成本与收益"><a href="#成本与收益" class="headerlink" title="成本与收益"></a>成本与收益</h3><p>　　正如之前所说软件系统只有在运行的时候才能创造价值，也就是说软件系统能否7*24小时＊365天稳定的工作关系到公司的收益水平。所以开发团队对生产环境的发布总是小心翼翼，对解决生产环境的问题总是加班加点。而<font color="red">软件系统的成本则体现在软件构建过程，这时候我们就能理解那些工程技术如项目管理、敏捷开发、 单元测试、持续集成、持续构建，版本管理等的价值了，他们有的是保证软件系统正确性，有的是为了降低沟通成本，有的是为了提升开发效率等但总的来说就是为了降低软件的构建成本。</font>所以在提升系统服务能力，创造更多业务收益的同时，降低构建成本也是一种提升收益的有效手段。<br>　　作为一名软件工程师而言，我们往往处在软件构建过程体系中的某个环节，我们可以基于成本与收益的关系去思考自己每一项技能的价值，学习新的有价值的技能，甚至在工作中基于成本与收益的考量选择合适的技术。比如在逻辑不大发生变化的地方，没有必要去做过多的设计，应用各种花俏的设计模式等浪费时间。这样我们才能成为技术的主人。</p><h3 id="架构目标需要适应业务的发展"><a href="#架构目标需要适应业务的发展" class="headerlink" title="架构目标需要适应业务的发展"></a>架构目标需要适应业务的发展</h3><p>　　架构的目标就是为了支撑业务增长，就是提升软件系统的服务能力。可是话虽说如此，但真实却要做很多取舍。比如对初创团队而言，其产品是否解决业务问题这一设想还没得到确认，就立即去构造一个高性能、高可用的分布式系统，这样的架构目标远超出业务发展的需求，最后的结果就是浪费大量人力物力，却得不到任何起色。架构师需要审时度势，仔细衡量正确性、大规模、可用性三者的关系，比如今年业务蓬勃发展日均订单300万，基于对未来的可能预测，明年可能有3000 万的订单，那么架构师应该要着重考虑大规模和可用性。而且每一点提升的程度，也需要架构师衡量把握，比如可用性要达到2个9还是3个9。<br>　　回顾自己以往的工作很多时候就是因为没有确立架构目标导致浪费了组织很多资源，比如在之前的创业团队中，由于本人有一定的代码洁癖，经常会花费很多时间和同事计较代码质量，这样本可以更快上线的功能却需要被延迟，当时过度追求正确性的行为是与创业团队快速验证想法的业务需求不匹配的。<br>　　另外一点比较深刻的案例则是在本人担任一个技术团队负责人的时候，在一次述职报告的时候，leader问我对接下来团队工作有什么计划？我当时说了一堆什么改进代码质量，每天晨会，任务透明化，建立迭代机制等等，然后就被各种批驳一通。当时团队基本以外包人员为主，人员水平较差，开发出来的金融系统也是千疮百孔而这条业务线最重要的业务价值则是按计划实现潜在投资方的需求，争取拉到投资。所以不久leader就召集测试架构的相关人员与我这边一同梳理对核心功能的测试工作，将研发、测试、上线的流程自动化。<br>　　当时并不理解这样做核心价值是什么。但回过头来看这样的工作方式恰好符合了业务发展的需求，即确保系统是符合设计需求的，保证系统达到可接受的正确性，为后续能过快速前进打下基础，最重要的是为企业降低了构建成本。所以程序员想要工作出业绩，必须认清楚系统背后的业务价值，按价值去梳理工作优先级，而不是像我一般过度纠结细节，追求技术理想化。</p><h3 id="成也分工，败也分工"><a href="#成也分工，败也分工" class="headerlink" title="成也分工，败也分工"></a>成也分工，败也分工</h3><p>　　正如在程序员的迷茫那一章节提到的：<font color="red">程序员的迷茫因为长期埋没于软件世界的浩大的分工体系中，无法看清从业务到软件架构的价值链条，无法清楚定位自己在分工体系的位置，处理不好自身与技术、业务的关系所致，</font>所以在这里我想谈谈分工。架构师为了使软件系统更好的服务业务，必然将软件系统生命周期进行拆分，比如分出开发生命周期、测试生命周期、用户访问生命周期、软件运维生命周期，并根据不同的生命周期划分出不同的职责与角色。<br>　　比如开发人员负责开发周期负责完成软件研发，测试人员负责对开发人员交付的成果进行测试等，于是就形成了分工。一旦分工形成，每一个分工组织都会有自己的价值追求，架构师关注的顶层的价值即软件系统能否支撑业务增长被分工的形式打碎到各个组织中。分工是有其价值的，他使得复杂昂贵的任务可以被简单、并行、可替换的流水线方式解决。但久而久之，价值碎片化的问题就出现了，比如测试人员只关注找出更多问题，开发人员只关注快速开发更多的系统，运维人员只关注保障系统稳定。<br>　　三者之间常常都只站在自己的立场去要求对方怎么做，没有人再关注整体价值，产生诸多矛盾增加软件实施成本。而身处流水线中的一员，又因为困扰于重复性工作， 迷茫于工作的意义，甚至感觉自己做为了人的创意与灵感都被扼杀了。所以我的朋友吐槽我说你写了那么多代码然后并没有怎么样是非常有道理的，那是因为我只关注着做为流水工人的价值要求，看不到生态链最顶端的价值。<br>　　我们仔细想想那些团队领导，精英领袖哪一个不是为着更广大的价值所负责，比如项目经理只需要关心自身项目的商业价值，而公司CEO则关心公司范畴内所有业务的总体商业价值。所以关注的价值越大且职位也就越高。这些高层领导者们把控着整体的价值链条，及时纠正底层分工组织的价值目标与整体价值目标出现偏差的问题。</p><h3 id="从价值出发－找寻学习与工作的新思路"><a href="#从价值出发－找寻学习与工作的新思路" class="headerlink" title="从价值出发－找寻学习与工作的新思路"></a>从价值出发－找寻学习与工作的新思路</h3><p>　　迷茫能引发思考，架构则塑造了视野，而价值则是我们之所以存活，之所以工作的逻辑起点。基于这样一种价值思维，对我们的学习和工作又可以有哪些改启示呢？<br>　　<strong>明确自身的业务相关主体：</strong>找出你工作的协作关系网内的业务方和客户方，这样你就可以从客户方中找到离你最近的业务价值点，从你的业务方中挖掘更多的资源。甚至你可以按这个思路顺着网络向上或向下挖掘价值链条，整合更多的上下游资源以实现更大的价值。<br>　　<strong>向前一步，为更大的价值负责：</strong><font color="red">不要因为自己是开发人员就不去关注软件运维，不要因为只是测试就不关注软件开发，因为你关注的越多你越能看清全局的价值目标。如果只关注一亩三分地，那么注定这辈子只能困守在这一亩三分地里，成为一名流水线上焦虑至死的码农。试着转变思维，从架构师的角度思考价值问题，看看能否将技术贯穿到业务、到用户、到最终的价值去。</font>之前我的朋友说过要把产品经理踢到运营位置去，把程序员踢到产品经理位置去，这样才是正确做事方式。这句话也是类似的意思，向前一步才能懂得怎么做的更好。<br>　　<strong>像架构师一样思考，用价值找寻重心：</strong><font color="red">人的迷茫是因为找不到重心，而价值的意义在于引导我们思考做哪些事情才能实现价值，先做哪些事情会比后做哪些事情更能创造收益。像架构师那样全局性思考，把遇到问题进行拆分，把学习到的事物串联起来，努力构成完整的价值链条。</font><br>　　<strong>学会连接，构建体系：</strong>前几天看到一篇文章对今日头条的产品形态极尽批判之词，指责它的智能算法将人类封死在自己的喜好之中，将人类社会进一步碎片化。这似乎很有道理，有趣的是互联网将我们连接至广袤的世界，却也把我们封闭在独属于自己的小世界里。依旧是我的那位朋友，他说他的最大价值在于连接，将不同的人连接在一起，有趣的事情可能就会即将发生。<br>　　或许算法的天性就是顺从与迎合，但人最终想理解这个世界还是需要依靠自身的行动与不同人之间建立联系，这也是一种摆脱流水线限制的有效方式。另外，我们自身也是某种事物连接的产物，比如架构师，他是业务、技术、管理连接在一起的一种产物。所以我们应当树立自身的知识体系以吸收融合新知识，将孤立的概念连接起来，形成自身的价值链条。比如这篇文章将我从事技术开发经验、与对架构的理解以及自身过往经历结合起来，这也是一种内在的体系梳理。<br>　　作者简介：空融，网名“D调的暖冬”。现就职蚂蚁金服，从事支付宝身份认证相关领域的技术开发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：空融&lt;br&gt;　　阿里妹导读：写了这么多年的代码，你是否曾经有过这样的迷茫和困惑——技术发展日新月异，奋力追赶的我们，究竟是技术的主人还是技术的奴隶？今天，我们邀请到了蚂蚁金服的技术专家空融，一起来聊聊技术人的软件世界观。&lt;br&gt;　　在浩大的软件世界里，作为一名普通程序员，显得十分渺小，甚至会感到迷茫。我们内心崇拜技术，却也对日新月异的技术抱有深深的恐惧。有时候我会思考难道在技术领域内不断紧跟新潮，不断提升技能就是我的价值所在？那么我是技术的主人还是技术的奴隶？&lt;br&gt;人之所以迷茫往往是找不到工作生活的重心，感受不到工作或生活的价值。那么什么是价值呢？说的大一点就是我改变了世界，说的小一点就是我的所作所为改善了某些问题。如果不清楚自己的行为、目标、价值三者的关系，那么又何来重心？又如何能分得清重要性与优先级呢？&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《2017阿里技术》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《2017阿里技术》" scheme="http://yoursite.com/tags/%E3%80%8A2017%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>谈谈MySQL隐式类型转换【转】</title>
    <link href="http://yoursite.com/2017/12/18/%E8%B0%88%E8%B0%88MySQL%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>http://yoursite.com/2017/12/18/谈谈MySQL隐式类型转换【转】/</id>
    <published>2017-12-18T03:52:21.000Z</published>
    <updated>2017-12-18T05:24:38.946Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　今天我们继续回到MySQL系列文章中,谈一谈MySQL中隐式类型转换。(其实我最早知道是在慢SQL优化中知道的隐式类型转换概念的),在说隐式类型转换之前,首先我们通过一个实例来看看是怎么回事。<br><a id="more"></a></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>本文中所有的操作,都是基于该数据结构(有兴趣的童鞋,可以实验):</p><pre><code>create table t_base_user(   oid bigint(20) not null primary key auto_increment,  name varchar(30) null comment &quot;name&quot;,  email varchar(30) null comment &quot;email&quot;,  age int null comment &quot;age&quot;,  telephone varchar(30) null comment &quot;telephone&quot;,  status tinyint(4) null comment &quot;0 无效 1 有效&quot;,  created_at datetime null default now() comment &quot;创建时间&quot;,  updated_at datetime null default now() comment &quot;修改时间&quot;  )### 新建索引alter table t_base_user add index idx_email(email);alter table t_base_user add index idx_name(name);alter table t_base_user add index idx_telephone(telephone);### 新增记录: INSERT INTO `test`.`t_base_user` (`name`, `email`, `age`, `telephone`, `status`, `created_at`, `updated_at`) VALUES (&apos;111111&apos;, &apos;andytohome@gmail.com&apos;, &apos;111&apos;, &apos;12345678901&apos;, &apos;1&apos;, now(),now());</code></pre><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>  首先我们基于上述数据结构中,我们来看看下面这个执行计划:</p><blockquote><p>explain select * from t_base_user where telephone=12345678901;</p></blockquote><p>执行计划结果:</p><pre><code>id | select_type |    table    | type | possible_keys | key  | key_len | ref  | rows | Extra-- | ----------- | ----------- | ---- | ------------- | ---- | ------- | ---- | ---- | ------------1  | SIMPLE      | t_base_user | ALL  | idx_telephone | NULL | NULL    | NULL | 1    | Using where</code></pre><p>细心的童鞋应该已经看出来了,为什么数据结构中已经在telephone字段上新建了idx_telephone，而上述语句并没有走索引,而是全表扫描。这是为什么呢？带着这疑问,我们来看看今天的主角–MySQL隐式类型转换</p><h3 id="什么隐式类型转换？"><a href="#什么隐式类型转换？" class="headerlink" title="什么隐式类型转换？"></a>什么隐式类型转换？</h3><p>  在MySQL中:</p><blockquote><p>当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。则会发生转换隐式</p></blockquote><p>也就是说,MySQL会根据需要自动将数字转换为字符串，将字符串转换数字。看到这个概念之后,是不是有一种茅塞顿开的感觉。哦… 原来在数据结构中telephone字段为字符串(varchar)类型,而我们传的手机号是数字类型。现在我们将SQL修改下:</p><blockquote><p>select * from t_base_user where telephone=”1234567890”;</p></blockquote><p>再看看执行计划上述语句的执行计划:</p><blockquote><p>explain select * from t_base_user where telephone=”1234567890”;</p></blockquote><p>结果:</p><pre><code>id | select_type |    table    | type | possible_keys |      key      | key_len | ref  | rows | Extra-- | ----------- | ----------- | ---- | ------------- | ------------- | ------- | ---- | ---- | ------------1  | SIMPLE      | t_base_user | ref  | idx_telephone | idx_telephone |   63    | const|   1  | Using index condition</code></pre><p>从这里看,现在语句已经走索引了。为了加深我们对隐式类型转换的印象,我们再多看看几个隐式类型转换案例:<br>案例一: 字符串转换为数字</p><blockquote><p>mysql &gt; SELECT 1+’1’;</p></blockquote><p>结果:</p><blockquote><p>mysql &gt; 2</p></blockquote><p>案例二: 数字转换为字符串</p><blockquote><p>mysql -&gt; SELECT CONCAT(1024,’ andyqian’);</p></blockquote><p>结果:<br>‘1,’ test’;</p><p>此时CONCAT(字符拼接)函数就进行了隐式类型转换。</p><h3 id="如何避免隐式类型转换"><a href="#如何避免隐式类型转换" class="headerlink" title="如何避免隐式类型转换?"></a>如何避免隐式类型转换?</h3><p>　　只有当清楚的知道隐式类型转换的规则，才能从根本上避免产生隐式类型转换。MySQL也在官网描述了进行隐式类型转换的一些规则如下:</p><p><strong>1. 隐式类型转换规则:</strong></p><ul><li>如果一个或两个参数都是NULL，比较的结果是NULL，除了NULL安全的&lt;=&gt;相等比较运算符。对于NULL &lt;=&gt; NULL，结果为true。不需要转换</li><li>如果比较操作中的两个参数都是字符串，则将它们作为字符串进行比较。</li><li>如果两个参数都是整数，则将它们作为整数进行比较。</li><li>如果不与数字进行比较，则将十六进制值视为二进制字符串</li><li>如果其中一个参数是十进制值，则比较取决于另一个参数。 如果另一个参数是十进制或整数值，则将参数与十进制值进行比较，如果另一个参数是浮点值，则将参数与浮点值进行比较</li><li>如果其中一个参数是TIMESTAMP或DATETIME列，另一个参数是常量，则在执行比较之前将常量转换为时间戳。</li><li>在所有其他情况下，参数都是作为浮点数（实数）比较的。</li></ul><p><strong>2. 使用CAST函数显示转换</strong><br>我们可以使用CAST显示的将类型进行转换,如下所示:</p><blockquote><p>mysql&gt; SELECT 38.8, CAST(38.8 AS CHAR);</p></blockquote><p>结果:</p><blockquote><p>mysql &gt; 38.8, ‘38.8’</p></blockquote><p>如上述中:</p><blockquote><p>select * from t_base_user where telephone=cast(15608464487 as char);</p></blockquote><p>查看执行计划,我们也可以看出,这个时候也走索引了。</p><p><strong>3. 类型一致</strong><br>  这里说的类型一致,指的是在写SQL时,参数类型一定要与数据库中的类型一致,避免产生隐式类型转换,就如刚才在文首时,如果多检查,写的SQL的参数类型与数据库中字段类型一致，也就不会不走索引了，你说是不是？</p><h3 id="小心隐式类型转换"><a href="#小心隐式类型转换" class="headerlink" title="小心隐式类型转换"></a>小心隐式类型转换</h3><p>　　这里再重申一次,写SQL时一定要检查参数类型与数据库字段类型一致,(如果参数不一致,也要使用CAST函数显示转换成一致)否则造成隐式类型转换,不走索引,后果简直不堪设想, 在前面《写会MySQL索引》这篇文章中提到过,不走索引,轻则造成慢查询，重则造成数据库服务器CPU100%。唉,说到这里,不瞒你说，我就吃过不少MySQL隐式类型转换的亏,导致了慢查询。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>　　看到这里,是不是有一种，数据表设计还真不是件容易的事情。需要考虑的因素太多太多了,需要考虑字段类型,索引设计,还有各种约束条件等等。也一定要谨慎谨慎再谨慎！其实换个角度就更容易理解了,大家都知道高楼大厦都是需要一个好的地基的,在数据库表设计中,前期的表结构设计就是这个地基，其重要性可想而知。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　今天我们继续回到MySQL系列文章中,谈一谈MySQL中隐式类型转换。(其实我最早知道是在慢SQL优化中知道的隐式类型转换概念的),在说隐式类型转换之前,首先我们通过一个实例来看看是怎么回事。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
