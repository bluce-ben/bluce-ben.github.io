<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-29T06:30:14.405Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 入职必备</title>
    <link href="http://yoursite.com/2019/08/29/Git-%E5%85%A5%E8%81%8C%E5%BF%85%E5%A4%87/"/>
    <id>http://yoursite.com/2019/08/29/Git-入职必备/</id>
    <published>2019-08-29T06:13:38.000Z</published>
    <updated>2019-08-29T06:30:14.405Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、配置操作"><a href="#一、配置操作" class="headerlink" title="一、配置操作"></a>一、配置操作</h4><h5 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h5><p>Git自带一个 git config 的工具来帮助设置控制 Git外观和行为的配置变量。这些变量存储在三个不同的位置：</p><ol><li><strong>/etc/gitconfig 文件</strong>：包含系统上每一个用户及他们仓库的通用配置。如果使用带有 --system 选项的 git config时，它会从此文件读写配置变量。</li><li><strong>~/.gitconfig 或 ~/.config/git/config 文件</strong>：只针对当前用户。可以传递 --global 选项让 Git读写此文件。</li><li>当前使用仓库的Git目录中的config文件（就是 <strong>.git/config</strong>)：针对该仓库。</li></ol><p>每一个级别覆盖上一个级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。<br><a id="more"></a></p><h5 id="2、用户信息"><a href="#2、用户信息" class="headerlink" title="2、用户信息"></a>2、用户信息</h5><p>当安装完 Git应该做的第一件事就是设置用户名称与邮件地址。这样做很重要，因为每一个Git 的提交都会使用这些信息，并且它会写入到每一次提交中，不可更改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;zhengbenwu&quot;</span><br><span class="line">git config --global user.email &quot;zhengbenwu@soyoung.com&quot;</span><br></pre></td></tr></table></figure></p><p>再次强调，如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，Git都会使用这些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在哪个项目目录下运行不使用 --global选项的命令来设置。<br>Git提交示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit 2a82ac5a1bfcd8e052e9053e512e14a8880c02ce (HEAD -&gt; dev-sms)</span><br><span class="line">Merge: 8e4c451 3b03b5e</span><br><span class="line">Author: zhengbenwu &lt;zhengbenwu@soyoung.com&gt;</span><br><span class="line">Date:   Thu Aug 29 10:17:11 2019 +0800</span><br></pre></td></tr></table></figure></p><h5 id="3、常用配置命令"><a href="#3、常用配置命令" class="headerlink" title="3、常用配置命令"></a>3、常用配置命令</h5><ol><li>git config <key> 查看某个配置项</key></li><li>git config –list 列出所有Git当时能找到的配置</li><li>git help config  查看config命令的手册<blockquote><p>扩展：可使用 <code>git help &lt;verb&gt;</code> 命令来查看对应某个命令的手册信息。</p></blockquote></li></ol><h4 id="二、Git基本介绍"><a href="#二、Git基本介绍" class="headerlink" title="二、Git基本介绍"></a>二、Git基本介绍</h4><h5 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h5><p>Git是一个版本控制工具，<strong>版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。</strong>版本控制可以有如下分类：</p><ul><li><strong>集中化的版本控制系统</strong>，例如SVN，更久远的CVS。这类系统，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或提交更新。优点是集中管理，可以轻松掌控每个开发者的权限等等。缺点就是中央服务器的单点故障，如果宕机，那么谁都无法提交更新，也无法协同工作。如果数据没有备份，出现磁盘损坏，数据也会丢失等等。</li><li><strong>分布式版本控制系统</strong>，例如Git。 客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。那么，如果出现服务器故障，事后都可以用任何一个镜像出来的本地仓库恢复。</li></ul><h5 id="2、Git开发流程"><a href="#2、Git开发流程" class="headerlink" title="2、Git开发流程"></a>2、Git开发流程</h5><ol><li>开通或注册账号，获取项目仓库权限</li><li>克隆仓库到本地开发环境</li><li>新建分支并进行开发，此处不建议在master上开发</li><li>开发完成后，需要更新分支，同步远程分支协同工作的开发修改</li><li>将更新提交到分支上，合并到master，推到远程仓库中<br>（注：此处可直接将分支推到远程仓库中，有Git的开源项目管理工具，通过该工具进行合并master）</li></ol><h5 id="3、本地开发需要了解"><a href="#3、本地开发需要了解" class="headerlink" title="3、本地开发需要了解"></a>3、本地开发需要了解</h5><p>首先，需要了解什么是工作区、暂存区和版本库的概念。</p><ul><li>工作区：就是你在电脑里能看到的目录</li><li>暂存区：英文叫stage，或index。一般存放在”.git”目录下的index文件中，所以我们也把暂存区叫做索引(index)。</li><li>版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是Git的版本库。</li></ul><p>我们开发的时候，是在工作区写代码。然后通过”git add”命令，将工作区的修改或新增文件添加到暂存区，此时，暂存区的目录树被更新，同时工作区修改或新增的文件被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。<br>当执行提交操作（git commit）时，暂存区的目录树写到版本库中，此时，相应的分支会做相应的更新。即对应分支指向的目录树就是提交时暂存区的目录树。<br>当执行”git reset HEAD”命令时，暂存区的目录树会被重写，被分支指向的目录树所替换，但是工作区不受影响。<br>当执行”git rm --cached <file>“命令时，会直接从暂存区删除文件，工作区则不做出改变。<br>当执行”git checkout .” 或 “git checkout -- <file>“命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。<br>当执行”git checkout HEAD .” 或 “git checkout HEAD <file>“命令时，会用HEAD指向的分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也非常危险，因为不但会清楚工作区中未提交的改动，也会清楚暂存区中未提交的改动。</file></file></file></p><blockquote><p>暂存区详情：<a href="https://blog.csdn.net/s646575997/article/details/52143586" target="_blank" rel="noopener">Git暂存区原理</a></p></blockquote><h5 id="4、与远程仓库的操作"><a href="#4、与远程仓库的操作" class="headerlink" title="4、与远程仓库的操作"></a>4、与远程仓库的操作</h5><p>上面说的版本库，仅仅只是对本地的仓库来说的。并没有涉及到远程仓库，因此，还需要将本地的仓库修改推到远程仓库中。一般的操作流程如下：</p><ol><li><code>git pull</code> 更新远程仓库到本地</li><li><code>git push origin dev-sms</code> 将本地修改推动到远程仓库中</li></ol><p>注意，一定要在推送前，先更新下远程仓库，因为在协同开发中有可能会出现冲突，遇到冲突的话，需要先解决冲突之后，才能推送。 </p><h4 id="三、Git常用命令"><a href="#三、Git常用命令" class="headerlink" title="三、Git常用命令"></a>三、Git常用命令</h4><h5 id="1、基本操作"><a href="#1、基本操作" class="headerlink" title="1、基本操作"></a>1、基本操作</h5><p> 可参考我以前的文章：<a href="https://blog.zhengbenwu.com/2018/03/14/Git%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%EF%BC%88%E5%9B%9B%EF%BC%89/" target="_blank" rel="noopener">常用命令汇总</a></p><h5 id="2、实际工作中记录"><a href="#2、实际工作中记录" class="headerlink" title="2、实际工作中记录"></a>2、实际工作中记录</h5><ol><li>git stash用法<br>保存工作区到暂存区： git stash save “save message”<br>查看暂存区：git stash list<br>查看暂存区中某一个做了哪些改动：git stash show [stash@{$num}]<br>应用某个存储单不会删除：git stash apply [stash@{$num}]<br>应用某个存储并删除：git stash pop [stash@{$num}]<br>删除某个存储：git stash drop stash@{$num}<br>删除所有存储：git stash clear</li><li>git commit用法<br>1）修改commit注释，前提是commit后未push<br><code>git commit --amend</code>进入vi编辑界面，修改注释后保存退出即可。<br>2）还有一种用法是，当需要将本地的修改推到未push的commit中时使用，先add添加进去，在commit。<br>（注：还有一种是将两个commit糅合在一起，通过 rebase -i）</li><li><p>git 强制提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br><span class="line">-f/--force</span><br></pre></td></tr></table></figure></li><li><p>查看日志<br>1）git log 查看以前日志<br>2）git reflog 查看未来日志<br>配合 git reset HEAD@{index}来回滚代码 或 git reset --hard commitId</p></li><li>比较版本内容<br>git diff <file> 比较当前文件和暂存区文件差异<br>git diff <id1><id2> 比较两次提交之间的差异<br>git diff <branch1> <branch2> 在两个分支之间比较<br>git diff --staged  比较暂存区和版本库差异<br>git diff --cached  比较暂存区和版本库差异<br>git diff --stat 仅仅比较统计信息</branch2></branch1></id2></id1></file></li><li>合并线上分支报文件冲突，询问是否覆盖本地。<br>合并分支：<code>git merge origin/dev-new-swoole</code><br>解决单个文件冲突:<br><code>git checkout --patch dev-new-swoole SDK/Services/ShopService/ShopService_Shop.php</code></li></ol><h4 id="四、Git常见问题记录"><a href="#四、Git常见问题记录" class="headerlink" title="四、Git常见问题记录"></a>四、Git常见问题记录</h4><h5 id="1、由于本地版本与Git上版本相差太多导致的"><a href="#1、由于本地版本与Git上版本相差太多导致的" class="headerlink" title="1、由于本地版本与Git上版本相差太多导致的"></a>1、由于本地版本与Git上版本相差太多导致的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">To git.culiu.org:dwxk/dwxk-api.git</span><br><span class="line"> ! [rejected]            dev-turnplate -&gt; dev-turnplate (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &apos;git@git.culiu.org:dwxk/dwxk-api.git&apos;</span><br><span class="line">hint: Updates were rejected because a pushed branch tip is behind its remote</span><br><span class="line">hint: counterpart. Check out this branch and integrate the remote changes</span><br><span class="line">hint: (e.g. &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure><blockquote><p>注意点：<br>不要把自己修改的代码给合并没了，当发现自己代码没了，只能再从日志中拉取了（或log,或relog）。</p></blockquote><blockquote><p>解决方案：<br>把远程库同步到本地就可以了，然后解决冲突，提交即可。<br><code>git pull --rebase origin dev-turnplate</code></p></blockquote><blockquote><p>依据提示操作即可。 注意点，有可能版本相差有点多，导致需要每一个版本都要合并，所以，要仔细合并。完事再确认代码是否正确。</p></blockquote><p><strong>参考网站：</strong><br>1、<a href="http://www.hechaku.com/git/Gitkuaisurumen.html" target="_blank" rel="noopener">Git语言快速入门</a><br>2、<a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">Git教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、配置操作&quot;&gt;&lt;a href=&quot;#一、配置操作&quot; class=&quot;headerlink&quot; title=&quot;一、配置操作&quot;&gt;&lt;/a&gt;一、配置操作&lt;/h4&gt;&lt;h5 id=&quot;1、配置文件&quot;&gt;&lt;a href=&quot;#1、配置文件&quot; class=&quot;headerlink&quot; title=&quot;1、配置文件&quot;&gt;&lt;/a&gt;1、配置文件&lt;/h5&gt;&lt;p&gt;Git自带一个 git config 的工具来帮助设置控制 Git外观和行为的配置变量。这些变量存储在三个不同的位置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;/etc/gitconfig 文件&lt;/strong&gt;：包含系统上每一个用户及他们仓库的通用配置。如果使用带有 --system 选项的 git config时，它会从此文件读写配置变量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;~/.gitconfig 或 ~/.config/git/config 文件&lt;/strong&gt;：只针对当前用户。可以传递 --global 选项让 Git读写此文件。&lt;/li&gt;
&lt;li&gt;当前使用仓库的Git目录中的config文件（就是 &lt;strong&gt;.git/config&lt;/strong&gt;)：针对该仓库。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每一个级别覆盖上一个级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MySQL日志系统之常见日志详解</title>
    <link href="http://yoursite.com/2019/08/11/MySQL%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%B8%B8%E8%A7%81%E6%97%A5%E5%BF%97%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/08/11/MySQL日志系统之常见日志详解/</id>
    <published>2019-08-11T10:34:57.000Z</published>
    <updated>2019-08-11T10:47:46.078Z</updated>
    
    <content type="html"><![CDATA[<p>innoDB事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作，这两个日志都是innoDB特有的。而binlog（二进制日志）是MySQL数据库Server层实现的，所有引擎都可以使用。<br>下面会对 redo log、undo log及binlog进行说明基本概念、相关作用及之间区别。</p><a id="more"></a><p>首先，我们先来看看一次查询/更新语句流程图：<br><img src="/uploads/2019/08/mysql_select_or_update_process.png" alt=""><br><strong>本文主要说明 执行器 <-> 存储引擎之间的交互。</-></strong></p><blockquote><p>mysql不是每次数据更改都立刻写到磁盘，而是会先将修改后的结果暂存在内存中，当一段时间后，再一次性将多个修改写到磁盘上，减少磁盘io成本，同时提高操作速度。</p></blockquote><h3 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>重做日志用来实现事务的持久性，即事务ACID中的D。其由两部分组成：</p><ol><li>一是内存中的重做日志缓存（redo log buffer）,其是易失的；</li><li>二是重做日志文件（redo log file)，其是持久的。</li></ol><p>InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交（COMMIT）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的COMMIT操作完成才算完成。</p><blockquote><p>扩展：主从复制的原理：<br>mysql中是基于binlog，来进行主从复置的。<br>oracle中就没有binlog，只用redo log，复制是基于redo log来做。</p></blockquote><h4 id="redo-log与二进制日志的区别"><a href="#redo-log与二进制日志的区别" class="headerlink" title="redo log与二进制日志的区别"></a>redo log与二进制日志的区别</h4><p>redo log不是二进制日志。虽然二进制日志中也记录了innodb表的很多操作，也能实现重做的功能，但是它们之间有很大的区别。</p><ol><li>二进制日志是在<strong>存储引擎的上层（即Server层）</strong>产生的，不管是什么存储引擎，对数据库进行了修改都会产生二进制日志。而redo log是innodb层产生的，只记录该存储引擎中表的修改。<strong>并且二进制日志先于redo log被记录</strong>。</li><li>二进制日志记录操作的方法是逻辑性的语句。即便它是基于行格式的记录方式，其本质也还是逻辑的SQL设置，如该行记录的每列的值是多少。而redo log是在物理格式上的日志，它记录的是数据库中每个页的修改。</li><li>二进制日志只在每次事务提交的时候一次性写入缓存中的日志“文件”。而redo log在数据准备修改前写入缓存中的redo log中，然后才对缓存中的数据执行修改操作；而且保证在发出事务提交指令时，先向缓存中的redo log写入日志，写入完成后才执行提交动作。</li><li>因为二进制日志只在提交的时候一次性写入，所以二进制日志中的记录方式和提交顺序有关，且一次提交对应一次记录。而redo log中是记录的物理页的修改，redo log文件中同一个事务可能多次记录，最后一个提交的事务记录会覆盖所有未提交的事务记录。<br>例如：在binlog日志中记录方式如下：T1,T4,T3,T2，每个事务都会在提交之后被写入到二进制日志中。而redo log是并发写入的，不同事务之间的不同版本的记录会穿插写入到redo log 文件中，例如可能redo log的记录方式如下：T1-1,T1-2,T2-1,T2-2,T2*,T1-3,T1*，其中T1<em> 表示最后提交时的日志记录，所以对应的数据页最终状态是 T1\</em>对应的操作结果。</li><li>事务日志记录的是物理页的情况，它具有幂等性，因此记录日志的方式极其简练。幂等性的意思是多次操作前后状态是一样的，例如新插入一行后又删除该行，前后状态没有变化。而二进制日志记录的是所有影响数据的操作，记录的内容较多。例如插入一行记录一次，删除该行又记录一次。</li></ol><h4 id="innodb的恢复行为"><a href="#innodb的恢复行为" class="headerlink" title="innodb的恢复行为"></a>innodb的恢复行为</h4><p>在启动innoDB的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。且InnoDB可以保证数据库在异常重启后后的状态和使用binlog文件恢复出来的数据库状态保持一致。<br>我们可以假设没有redo log，只有binlog，那么数据文件更新和写入binlog的顺序由两种可能：</p><ul><li>第一种，更新数据文件； 写入binlog</li><li>第二种，写入binlog；更新数据文件</li></ul><p>第一种情况如果在完成步骤1后服务器异常关闭，则导致binlog中缺少最后更新的数据；第二种情况如果在完成步骤1后服务器异常关闭，则数据库中比binlog中少了最后的数据变更记录。此时如果使用binlog文件进行恢复数据库（比如备库），则会导致数据库不一致的情况。<br><strong>redo log是怎么做的？</strong><br>先看下面的图片，是InnoDB更新数据时update语句的执行流程，橙色的流程在InnoDB内部执行，蓝色的部分在MySQL Server层执行器中执行。图片以下条SQL语句为例。<br><code>update T set c=c+1 where ID=2;</code><br><img src="/uploads/2019/08/mysql_update_process.png" alt=""><br>如上图所示，redo log的写入分为两个阶段（prepare 和 commit），这个称作两阶段提交，保证了数据的正确性。下面我们从上图4个可能发生异常关闭的时间点来分析InnoDB如何在MySQL启动时做崩溃恢复。</p><ol><li>Point A<br>如果服务器异常关闭发生在Point A 以及之前的时间点，这个时候redo log和binlog 都没有任何记录，事务还未提交，不会造成任何影响。</li><li>Point B<br>当服务器启动的时候发现redo log里处于prepare状态的记录，这个时候需要检查binlog是否完整包含此条redo log的更新内容（通过全局事务ID对应），发现binlog中还未包含此事务变更，则丢弃此次变更。</li><li>Point C<br>和Point B基本相同，只不过此时发现binlog中包含redo log的更新内容，此时事务会进行提交。</li><li>Point D<br>binlog中和数据库中均含有此事务的变更，没有任何影响。</li></ol><p><strong>组提交</strong><br>上面关于崩溃恢复部分只是讲了写redo log和binlog 的步骤，那么一定很疑惑数据是何时被写入到磁盘文件中的呢，这里就要说下InnoDB通过redo log实现的组提交的策略了。<br>因为更新数据时写磁盘的操作是随机写，这部分的IO消耗很大，而通过组提交（多个事务的变更统一写磁盘）的方式可以提升系统的吞吐量。</p><p><strong>组提交实现</strong><br>下图是一组redo log文件的工作示意图，如图所示，一组redo log文件是一个类似环形的状态，循环利用。<br><img src="/uploads/2019/08/mysql_redo_log.png" alt=""><br>write pos表示日志当前记录的位置，当ib_logfile_4写满后，会从ib_logfile_1从头开始记录； checkpoint表示将日志记录的修改写进磁盘，完成数据落盘，数据落盘后checkpoint会将日志上的相关记录擦除掉，即write pos -&gt; checkpoint之间的部分是redo log空着的部分，用于记录新的记录，checkpoint -&gt; write pos之间是redo log待落盘的数据修改记录。当write pos追上checkpoint时，得先停下记录，先推动checkpoint向前移动，空出位置记录新的日志。<br>（注：有了redo log，当数据库发生宕机重启后，可通过redo log将未落盘的数据恢复，即保证已经提交的事务记录不会丢失。）</p><h4 id="日志刷盘的规则"><a href="#日志刷盘的规则" class="headerlink" title="日志刷盘的规则"></a>日志刷盘的规则</h4><p>内存中（buffer pool，即log buffer）未刷到磁盘的数据称为脏数据（dirty data）。由于数据和日志都以页的形式存在，所以脏页表示脏数据和脏日志。<br>在innoDB中，数据刷盘的规则只有一个：checkpoint。 但是触发checkpoint的情况却有集中。不管怎样，checkpoint触发后，会将buffer中脏数据页和脏日志页都刷到磁盘。<br>innoDB存储引擎中checkpoint分为两种：</p><ol><li>sharp checkpoint：在重用redo log文件（例如切换日志文件）的时候，将所有已记录到redo log中对应的脏数据刷到磁盘。</li><li>fuzzy checkpoint：一次只刷一小部分的日志到磁盘，而非将所有脏日志刷盘。有以下几种情况会触发该检查点：<ul><li>master thread checkpoint： 由master线程控制，每秒或每10秒刷入一定比例的脏页到磁盘。</li><li><code>flush_lru_list</code> checkpoint： 从MySQL5.6开始可通过 <code>innodb_page_cleaners</code> 变量指定专门负责脏页刷盘的page cleaner线程的个数，该线程的目的是为了保证lru列表有可用的空闲页。</li><li>async/sync flush checkpoint： 同步刷盘还是异步刷盘。 例如还有非常多的脏页没刷到磁盘（非常多是多少，有比例控制），这时候会选择同步刷到磁盘，但这很少出现；如果脏页不是很多，可以选择异步刷到磁盘，如果脏页很少，可以暂时不刷脏页到磁盘。</li><li>dirty page too much checkpoint： 脏页太多时强制出发检查点，目的是为了保证缓存有足够的空闲空间。too much的比例由变量<code>innodb_max_dirty_pages_pct</code>控制，MySQL5.6默认的值为75，即当脏页占缓冲池的百分之75后，就强制刷一部分脏页到磁盘。</li></ul></li></ol><p>（注：由于刷脏页需要一定的时间来完成，所以记录检查点的位置是在每次刷盘结束之后才在redo log中标记的。）</p><h4 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h4><p>redo log的大小是固定的，在mysql中可以通过修改配置参数 innodb_log_files_in_group和innodb_log_file_size 配置日志文件数量和每个日志文件大小，redolog采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。</p><blockquote><p>注：binlog文件是通过追加的方式写入的。</p></blockquote><ol><li><code>innodb_flush_log_at_trx_commit={0|1|2}</code> #指定何时将事务日志刷到磁盘，默认为1.<ul><li>0 表示每秒将“log buffer”同步到“os buffer”且从”os buffer”刷到磁盘日志文件中。</li><li>1 表示每事务提交都将“log buffer”同步到“os buffer“且从”os buffer“刷到磁盘日志文件中。</li><li>2 表示每事务提交都将“log buffer”同步到“os buffer“但每秒才从”os buffer“刷到磁盘日志文件中。</li></ul></li><li><code>innodb_log_buffer_size:</code> #log buffer的大小，默认8M</li><li><code>innodb_log_file_size:</code> #事务日志的大小，默认5M</li><li><code>innodb_log_fiel_group=2</code> #事务日志组中的事务日志文件个数，默认2个</li><li><code>innodb_log_group_home_dir=./</code> #事务日志组路径，当前目录表示数据目录</li><li><code>innodb_mirrored_log_groups=1</code> #指定事务日志组的镜像组个数，但镜像功能好像是强制关闭的，所以只有一个log group。在MySQL5.7中该变量已经移除。</li></ol><h3 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>undo log有两个作用：提供回滚和多个行版本控制（MVCC）。<br>在数据修改的时候，不仅记录了redo，还记录了相对应的undo，如果因为某些原因导致事务失败或回滚了，可以借助该undo进行回滚。<br>undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：</p><ol><li>redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，他用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）。</li><li>undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。</li></ol><h3 id="binlog（binary-log，二进制日志）"><a href="#binlog（binary-log，二进制日志）" class="headerlink" title="binlog（binary log，二进制日志）"></a>binlog（binary log，二进制日志）</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>MySQL的二进制日志binlog可以说是MySQL最重要的日志，它记录了所有的DDL和DML语句（除了数据查询语句select），以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。</p><p>binlog日志有两个最重要的使用场景：</p><ol><li>mysql主从复制： mysql replication在master端开启binlog，master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。</li><li>数据恢复： 通过mysqlbinlog 工具来恢复数据。</li></ol><blockquote><p>binlog 日志包括两类文件：</p><ol><li>二进制日志索引文件（文件名后缀为 .index）用于记录所有的二进制文件。</li><li>二进制日志文件（文件名后缀为 .00000*）记录数据库所有的DDL和DML（除了数据查询语句select）语句事件。<blockquote><p>DDL（Data Definition Language 数据库定义语言），主要命令有create、alter、drop等，ddl主要是用在定义或改变表（table）的结构，数据类型，表之间的连接和约束等初始工作上，他们大多在建表时候使用。<br>DML（Data Manipulation Language 数据操纵语言），主要命令是select、update、insert、delete，就像他的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。</p></blockquote></li></ol></blockquote><h4 id="相关配置-1"><a href="#相关配置-1" class="headerlink" title="相关配置"></a>相关配置</h4><p>binlog文件是通过追加的方式写入的，可通过配置参数<code>max_binlog_size</code>设置每个binlog文件的大小，当文件大小大于给定值后，日志会发生滚动，之后的日志记录到新的文件上。<br>binlog有两种记录模式，statement格式的话是记sql语句，row格式会记录行的内容，记两条，更新前和更新后都有。</p><p>注：binlog文件配置主从复制可查看我的另一篇文章。</p><p>博客：<br><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_11" target="_blank" rel="noopener">详细分析MySQL事务日志（redo log和undo log）</a><br><a href="https://cloud.tencent.com/developer/article/1417482" target="_blank" rel="noopener">MySQL崩溃恢复功臣——Redo Log</a><br><a href="https://www.jianshu.com/p/4bcfffb27ed5" target="_blank" rel="noopener">MySQL日志系统之redo log和bin log</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;innoDB事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作，这两个日志都是innoDB特有的。而binlog（二进制日志）是MySQL数据库Server层实现的，所有引擎都可以使用。&lt;br&gt;下面会对 redo log、undo log及binlog进行说明基本概念、相关作用及之间区别。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>常设计模式</title>
    <link href="http://yoursite.com/2019/08/06/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/06/常用设计模式/</id>
    <published>2019-08-06T09:29:30.000Z</published>
    <updated>2019-08-06T10:03:32.109Z</updated>
    
    <content type="html"><![CDATA[<p>参考博客：<br><a href="https://www.awaimai.com/patterns" target="_blank" rel="noopener">https://www.awaimai.com/patterns</a><br><a href="https://learnku.com/docs/php-design-patterns/2018/about/1524" target="_blank" rel="noopener">https://learnku.com/docs/php-design-patterns/2018/about/1524</a><br><a href="http://c.biancheng.net/view/1395.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1395.html</a></p><a id="more"></a><h4 id="一、创建型模式（-）"><a href="#一、创建型模式（-）" class="headerlink" title="一、创建型模式（*）"></a>一、创建型模式（*）</h4><h5 id="1、简单工厂模式"><a href="#1、简单工厂模式" class="headerlink" title="1、简单工厂模式"></a>1、简单工厂模式</h5><p>概述：通过传入参数，工厂就实例化出合适的对象，通过多态，返回对应的实例。<br>简单代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Factory</span><br><span class="line">&#123;</span><br><span class="line">    public static function getObject($type) &#123;</span><br><span class="line">        $object = null;</span><br><span class="line">        switch ($type) &#123;</span><br><span class="line">            case “A”:</span><br><span class="line">                $object = new Object();</span><br><span class="line">                break;</span><br><span class="line">            case “B”:</span><br><span class="line">                $object = new Object();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return $object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有类似这种的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class SimpleFactory</span><br><span class="line">&#123;</span><br><span class="line">    public function createBicycle() &#123;</span><br><span class="line">        return new Bicycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$factory = new SimpleFactory();</span><br><span class="line">$bicycle = $factory-&gt;createBicycle();</span><br></pre></td></tr></table></figure></p><p>（注：简单工厂模式，可以理解为生产类的工厂。）</p><h5 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h5><p>概述：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。<br>简单代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface IFactory</span><br><span class="line">&#123;</span><br><span class="line">    function getObject();</span><br><span class="line">&#125;</span><br><span class="line">class ObjectA implements IFactory</span><br><span class="line">&#123;</span><br><span class="line">    public function getObject() &#123;</span><br><span class="line">        return new self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h5><p>概述：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>其实就是简单工厂模式与抽象工厂模式的结合。<br>简单代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Product    //抽象接口</span><br><span class="line">&#123;</span><br><span class="line">    public function calculatePrice();</span><br><span class="line">&#125;</span><br><span class="line">class ShippableProduct implements Product    //实现接口的具体类</span><br><span class="line">&#123;</span><br><span class="line">    public function calculatePrice() &#123;</span><br><span class="line">        return 66;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ProductFactory    //工厂类</span><br><span class="line">&#123;</span><br><span class="line">    public function createShippableProduct($price) &#123;</span><br><span class="line">        return new ShippableProduct($price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="4、单例模式"><a href="#4、单例模式" class="headerlink" title="4、单例模式"></a>4、单例模式</h5><p>概述：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>简单代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private static $instance = null;</span><br><span class="line">    private function __construct() &#123;&#125;</span><br><span class="line">    public static function getInstance() &#123;</span><br><span class="line">        if (self::$instance === null) &#123;</span><br><span class="line">            self::$instance = new self();</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    private function __clone() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线上示例：连接数据库的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Database</span><br><span class="line">&#123;</span><br><span class="line">    private static $instance = null;</span><br><span class="line">    private $db = null;</span><br><span class="line">    private function __construct($config = array()) &#123;</span><br><span class="line">        $dsn = sprintf(‘mysql:host=%s,dbname=%s’, $config[‘host’], $config[‘db_name’]);</span><br><span class="line">        $this-&gt;db = new PDO($dsn, $config[‘db_user’], $config[‘db_pass’]);</span><br><span class="line">    &#125;</span><br><span class="line">    public static function getInstance($config = array()) &#123;</span><br><span class="line">        if (self::$instance === null) &#123;</span><br><span class="line">            self::$instance = new self($config);</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public function db() &#123;</span><br><span class="line">        return $this-&gt;db;</span><br><span class="line">    &#125;</span><br><span class="line">    private function __clone() &#123;&#125;</span><br><span class="line">    private function __wakeup() &#123;&#125;    //禁止重建对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二、结构性模式"><a href="#二、结构性模式" class="headerlink" title="二、结构性模式"></a>二、结构性模式</h4><h5 id="1、适配器模式（-）"><a href="#1、适配器模式（-）" class="headerlink" title="1、适配器模式（*）"></a>1、适配器模式（*）</h5><p>即根据客户端需要，将某个类的接口转换成特定样式的接口，以解决类之间的兼容问题。</p><blockquote><p>如果我们的代码依赖一些外部的API，或者依赖一些可能会经常更改的类，那么应该考虑用适配器模式。例如，支付接口，需要接入支付宝、微信等等。可对内部项目封装成一个支付接口，统一调用。外部接口变化，客户端接口并不需要调整。</p></blockquote><p>简单代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface PayAdapter</span><br><span class="line">&#123;</span><br><span class="line">    public function pay();</span><br><span class="line">&#125;</span><br><span class="line">class AlipayAdapter implements PayAdapter</span><br><span class="line">&#123;</span><br><span class="line">    public function pay() &#123;</span><br><span class="line">        $alipay = new Alipay();</span><br><span class="line">        $alipay-&gt;sendPayment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$alipay = new AlipayAdapter();</span><br><span class="line">$alipay-&gt;pay();</span><br></pre></td></tr></table></figure></p><p>如果当Alipay的支付方式改变，只需要修改AlipayAdapter类即可。</p><h5 id="2、组合模式"><a href="#2、组合模式" class="headerlink" title="2、组合模式"></a>2、组合模式</h5><p>概述：组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。<br>在组合模式，客户端访问独立对象和组合对象（或称对象集合）一样。</p><h5 id="3、装饰器模式"><a href="#3、装饰器模式" class="headerlink" title="3、装饰器模式"></a>3、装饰器模式</h5><p>概述：又名包装（Wrapper）模式，该模式向一个已有的对象添加新的功能，而不改变其结构。</p><blockquote><p>通常给对象添加功能有3种方法：</p><ol><li>直接修改类，添加相应的功能。 直接修改类代码是一种侵入式修改，很容易对类功能造成损害。</li><li>派生对应的子类扩展新功能。 使用继承方式扩展功能，则在整个子类中添加功能，即使有的对象不需要，new出来也会有这些新功能。</li><li>使用对象组合的方式。 装饰器模式是典型的基于对象组合的方式，可以很灵活的给对象添加所需要的功能，它能动态的为一个对象增加功能，而且还能动态撤销。</li></ol></blockquote><h5 id="4、依赖注入模式"><a href="#4、依赖注入模式" class="headerlink" title="4、依赖注入模式"></a>4、依赖注入模式</h5><p>概述：用松散耦合的方式来更好的实现可测试、可维护和可扩展的代码。</p><h5 id="5、注册模式（-）"><a href="#5、注册模式（-）" class="headerlink" title="5、注册模式（*）"></a>5、注册模式（*）</h5><p>概述：目的是能够存储在应用程序中经常使用的对象实例，通常会使用只有静态方法的抽象类来实现（或使用单例模式）。需要注意的是这里可能会引入全局的状态，我们需要使用依赖注入来避免它。</p><h4 id="三、行为型模式"><a href="#三、行为型模式" class="headerlink" title="三、行为型模式"></a>三、行为型模式</h4><h5 id="1、策略模式（-）"><a href="#1、策略模式（-）" class="headerlink" title="1、策略模式（*）"></a>1、策略模式（*）</h5><p>概述：策略模式定义了一簇相同类型的算法，算法之间独立封装，并且可以互换代替。<br>这些算法是同一类型问题的多种处理方式，它们具体行为有差别。<br>每一个算法、或说每一种处理方式称为一个策略。在应用中，就可以根据环境的不同，选择不同的策略来处理问题。<br>简单代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface OutputStrategy    //策略接口</span><br><span class="line">&#123;</span><br><span class="line">    public function render($array);</span><br><span class="line">&#125;</span><br><span class="line">class SerializeStrategy implements OutputStrategy    //策略1</span><br><span class="line">&#123;</span><br><span class="line">    public function render($array) &#123;</span><br><span class="line">        return serialize($array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class JsonStrategy implements OutputStrategy    //策略2</span><br><span class="line">&#123;</span><br><span class="line">    public function render($array) &#123;</span><br><span class="line">        return json_encode($array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>环境角色用来管理策略，实现不同策略的切换功能。<br>同样，一旦写好，环境角色类以后也不需要修改了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Output    //环境角色类</span><br><span class="line">&#123;</span><br><span class="line">    private $outputStrategy;</span><br><span class="line">    public function __construct(OutputStrategy $outputStrategy) &#123;</span><br><span class="line">        $this-&gt;outputStrategy = $outputStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    public function renderOutput($array) &#123;</span><br><span class="line">        return $this-&gt;outputStrategy-&gt;render($array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$test = [‘a’, ‘b’, ‘c’];</span><br><span class="line">$output = new Output(new JsonStrategy());</span><br><span class="line">$data = $output-&gt;renderOutput($test);</span><br></pre></td></tr></table></figure></p><h5 id="2、观察者模式（-）"><a href="#2、观察者模式（-）" class="headerlink" title="2、观察者模式（*）"></a>2、观察者模式（*）</h5><p>概述：也称发布-订阅模式，定义了一个被观察者和多个观察者的、一对多的对象关系。<br>在被观察者状态发生变化的时候，它的所有观察者都会收到通知，并自动更新。<br>观察者模式常用在 实时事件处理系统、组件间解耦、数据库驱动的消息队列系统，同时也是MVC设计模式中的重要组成部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *被观察者接口</span><br><span class="line"> */</span><br><span class="line">interface Observable</span><br><span class="line">&#123;</span><br><span class="line">    public function attach(Observer $observer);    //添加/注册观察者</span><br><span class="line">    public function detach(Observer $observer);    //删除观察者</span><br><span class="line">    public function notify();    //触发通知</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被观察者至少要实现attach()、detach()、notify()三个方法，用以添加、删除和通知观察者。<br>通知的方式是，在类中的其他方法调用notify()方法。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Order implements Observable</span><br><span class="line">&#123;</span><br><span class="line">    private $observers = array();    //保存观察者</span><br><span class="line">    private $state = 0;    //订单状态</span><br><span class="line">    public function attach(Observer $observer) &#123;</span><br><span class="line">        $key = array_search($observer, $this-&gt;observers);</span><br><span class="line">        if ($key === false) &#123;</span><br><span class="line">            $this-&gt;observers[] = $observer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public function detach(Observer $observer) &#123;</span><br><span class="line">        $key = array_search($observer, $this-&gt;observers);</span><br><span class="line">        if ($key !== false) &#123;</span><br><span class="line">            unset($this-&gt;observers[$key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public function notify() &#123;    //遍历调用观察者的update()方法进行通知，不关心其具体实现方式</span><br><span class="line">        foreach($this-&gt;observers as $observer) &#123;</span><br><span class="line">            $observer-&gt;update($this);    //把本类对象传给观察者，以便观察者获取当前类对象的信息</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public function addOrder() &#123;    //订单状态有变化时发送通知</span><br><span class="line">        $this-&gt;state = 1;</span><br><span class="line">        $this-&gt;notify();</span><br><span class="line">    &#125;</span><br><span class="line">    public function getState() &#123;    //观察者可能需要被观察者的一些状态信息，对外提供接口</span><br><span class="line">        return $this-&gt;state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *观察者接口</span><br><span class="line"> */</span><br><span class="line">interface Observer</span><br><span class="line">&#123;</span><br><span class="line">    public function update(Observable $observable);    //接收到通知的处理方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察者可能有多个，但每个观察者都必须实现Observer接口规定的update()接口，这是接收被观察者通知的唯一渠道。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Email implements Observer</span><br><span class="line">&#123;</span><br><span class="line">    public function update(Observable $observable) &#123;</span><br><span class="line">        $state = $observable-&gt;getState();</span><br><span class="line">        if ($state) &#123;</span><br><span class="line">            echo &quot;发送邮件：您已经成功下单。&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            echo “发送邮件：下单失败，请重试。”;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$email = new Email();    //创建观察者对象</span><br><span class="line">$order = new Order();    //创建订单对象</span><br><span class="line">$order-&gt;attach($email);    //向订单对象中注册观察者</span><br><span class="line">$order-&gt;addOrder();    //添加订单，添加时会自动发送通知给观察者</span><br></pre></td></tr></table></figure></p><h5 id="3、迭代器模式"><a href="#3、迭代器模式" class="headerlink" title="3、迭代器模式"></a>3、迭代器模式</h5><p>概述：让对象变得可迭代并表现得像对象集合。</p><h5 id="4、代理模式"><a href="#4、代理模式" class="headerlink" title="4、代理模式"></a>4、代理模式</h5><p>概述：在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。</p><h4 id="四、设计模式遵循的七大原则"><a href="#四、设计模式遵循的七大原则" class="headerlink" title="四、设计模式遵循的七大原则"></a>四、设计模式遵循的七大原则</h4><p>开闭原则、里氏替换原则、迪米特原则、单一职责原则、接口分割原则、依赖倒置原则、组合/聚合复用原则。<br>设计目标：开闭原则、里氏替换原则、迪米特原则<br>设计方法：单一职责原则、接口分割原则、依赖倒置原则、组合/聚合复用原则</p><p>开闭原则：软件实体（模块、类、方法等）应该对扩展开放，对修改关闭。<br>里氏替换原则：子类能够替换基类。<br>迪米特原则：又叫最少知道原则。只与你直接的朋友们通信，不要跟“陌生人”说话。<br>单一职责原则：只能让一个类/接口/方法有且仅有一个职责。<br>接口分割原则：使用多个专门的接口比使用单一的总接口要好。<br>依赖倒置原则：高层模块不应该依赖底层模块，二者都应该依赖于抽象。<br>组合/聚合复用原则：尽量使用组合/聚合，不要使用类继承。</p><h4 id="五、面向对象的三个基本特征："><a href="#五、面向对象的三个基本特征：" class="headerlink" title="五、面向对象的三个基本特征："></a>五、面向对象的三个基本特征：</h4><h5 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h5><p> 就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p><h5 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h5><p> 他可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。<br> 继承的称为“子类”或“派生类”。<br> 被继承的称为“基类”、“父类”或“超类”。</p><h5 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a>3、多态</h5><p> 不同类对象对相同行为的不同反应，就叫做多态。 与继承相对应的是多态提供了对同一类对象差异性的处理方法，子类通过多态重写父类继承的方法来实现子类的差异性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考博客：&lt;br&gt;&lt;a href=&quot;https://www.awaimai.com/patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.awaimai.com/patterns&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://learnku.com/docs/php-design-patterns/2018/about/1524&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://learnku.com/docs/php-design-patterns/2018/about/1524&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://c.biancheng.net/view/1395.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://c.biancheng.net/view/1395.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP安装yaf扩展</title>
    <link href="http://yoursite.com/2019/08/02/PHP%E5%AE%89%E8%A3%85yaf%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2019/08/02/PHP安装yaf扩展/</id>
    <published>2019-08-02T09:46:46.000Z</published>
    <updated>2019-08-02T09:53:27.023Z</updated>
    
    <content type="html"><![CDATA[<p>Yaf，全称 Yet Another Framework，是一个C语言编写的PHP框架，是一个用PHP扩展形式提供的PHP开发框架, 相比于一般的PHP框架, 它更快. 它提供了Bootstrap, 路由, 分发, 视图, 插件, 是一个全功能的PHP框架。最大特点就是简单、高效、快速，已经在百度和新浪微博经过大平台验证。</p><h4 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h4><p>Git仓库：<code>https://github.com/laruence/yaf</code></p><blockquote><p>资源整理：</p><ol><li>yaf官方文档 ：<code>http://www.laruence.com/manual/</code></li><li>yaf手册：<code>http://www.laruence.com/manual/index.html</code></li></ol></blockquote><a id="more"></a><h4 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h4><p>依据git仓库中的说明，有两种方式可安装（也可使用其它方式）。</p><h5 id="1、Yaf是PECL的一个扩展，因此，可以直接使用PECL安装即可"><a href="#1、Yaf是PECL的一个扩展，因此，可以直接使用PECL安装即可" class="headerlink" title="1、Yaf是PECL的一个扩展，因此，可以直接使用PECL安装即可"></a>1、Yaf是PECL的一个扩展，因此，可以直接使用PECL安装即可</h5><p><code>pecl install yaf</code><br>（注：没有pecl命令，可先安装该命令。）</p><h5 id="2、编译安装（Linux）"><a href="#2、编译安装（Linux）" class="headerlink" title="2、编译安装（Linux）"></a>2、编译安装（Linux）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/path/to/phpize</span><br><span class="line">./configure --with-php-config=/path/to/php-config</span><br><span class="line">Make &amp; make install</span><br></pre></td></tr></table></figure><blockquote><p>成功安装提示：<br>Build process completed successfully<br>Installing ‘/usr/local/lib/php/extensions/no-debug-non-zts-20170718/yaf.so’<br>install ok: channel://pecl.php.net/yaf-3.0.8<br>configuration option “php_ini” is not set to php.ini location<br>You should add “extension=yaf.so” to php.ini</p></blockquote><h5 id="三、使用yaf框架"><a href="#三、使用yaf框架" class="headerlink" title="三、使用yaf框架"></a>三、使用yaf框架</h5><h6 id="1、启用yaf扩展"><a href="#1、启用yaf扩展" class="headerlink" title="1、启用yaf扩展"></a>1、启用yaf扩展</h6><p>由上面“成功安装提示”可知道，下面需要配置php.ini，将yaf.so添加进PHP扩展中，重新启动PHP即可。</p><blockquote><p>下面是常用yaf配置选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[yaf]</span><br><span class="line">yaf.environ = product</span><br><span class="line">yaf.library = NULL</span><br><span class="line">yaf.cache_config = 0</span><br><span class="line">yaf.name_suffix = 1</span><br><span class="line">yaf.name_separator = &quot;&quot;</span><br><span class="line">yaf.forward_limit = 5</span><br><span class="line">yaf.use_namespace = 0</span><br><span class="line">yaf.use_spl_autoload = 0</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="2、生成yaf框架代码"><a href="#2、生成yaf框架代码" class="headerlink" title="2、生成yaf框架代码"></a>2、生成yaf框架代码</h5><p>Yaf提供了代码生成工具yaf_code generator（在git项目中）, 所以也可以通过使用代码生成工具yaf_cg来完成这个简单的入门Demo（即yaf框架）。<br><code>./yaf/tools/cg/yaf_cg sample</code><br>会在 cg/output/目录下生成 sample文件夹，即yaf初版框架。将其粘贴到自己的项目中使用</p><h5 id="3、访问yaf框架"><a href="#3、访问yaf框架" class="headerlink" title="3、访问yaf框架"></a>3、访问yaf框架</h5><p>注：需要将’yaf_’ 更改为’/yaf/‘，才能识别出yaf的位置，否则会报找不到相应的类。<br>然后就可以访问成功了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World! I am Stranger</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Yaf，全称 Yet Another Framework，是一个C语言编写的PHP框架，是一个用PHP扩展形式提供的PHP开发框架, 相比于一般的PHP框架, 它更快. 它提供了Bootstrap, 路由, 分发, 视图, 插件, 是一个全功能的PHP框架。最大特点就是简单、高效、快速，已经在百度和新浪微博经过大平台验证。&lt;/p&gt;
&lt;h4 id=&quot;一、下载&quot;&gt;&lt;a href=&quot;#一、下载&quot; class=&quot;headerlink&quot; title=&quot;一、下载&quot;&gt;&lt;/a&gt;一、下载&lt;/h4&gt;&lt;p&gt;Git仓库：&lt;code&gt;https://github.com/laruence/yaf&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;资源整理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;yaf官方文档 ：&lt;code&gt;http://www.laruence.com/manual/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;yaf手册：&lt;code&gt;http://www.laruence.com/manual/index.html&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>一个URL的漫游详解</title>
    <link href="http://yoursite.com/2019/08/01/%E4%B8%80%E4%B8%AAURL%E7%9A%84%E6%BC%AB%E6%B8%B8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/08/01/一个URL的漫游详解/</id>
    <published>2019-08-01T09:28:41.000Z</published>
    <updated>2019-08-02T02:05:47.648Z</updated>
    
    <content type="html"><![CDATA[<p><strong>详细分解网络请求</strong><br>一个网络请求通过TCP/IP五层架构（此处数据链路层和物理层是分开的）进行传输，都是怎么传输的，以及都干了些什么。此文将会从网络层、传输层和应用层进行详解，各个层都做了哪些操作，以及是如何进行传输的。</p><p>下面我们将从大的方向来说明一个请求从客户端到服务端都经历了哪些过程，此处可能会遗漏，以后达到该层次，再补充。<br><a id="more"></a></p><h4 id="一、一个HTTP的URL的生命过程"><a href="#一、一个HTTP的URL的生命过程" class="headerlink" title="一、一个HTTP的URL的生命过程"></a>一、一个HTTP的URL的生命过程</h4><p>（注：此处会涉及到一个客户端缓存的问题，如果请求的是静态页面且本机上有该缓存页面，则直接读取，不会向服务器发送请求。此处忽略该请求）<br>总体来说分为以下六个步骤：</p><h5 id="1、DNS解析"><a href="#1、DNS解析" class="headerlink" title="1、DNS解析"></a>1、DNS解析</h5><p>我们都知道，正常的url是通过域名来访问的，而在服务器之间则是通过IP地址来传输的。因此，首先客户端会进行URL解析——DNS解析。DNS会先在本机查找是否有缓存，没有的话，会向DNS服务器发送请求，而DNS服务器则会递归查询，直到找到该解析，则返回，客户端则会缓存该解析。</p><blockquote><p>扩展：<br>DNS缓存：DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存，系统缓存，路由缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，<br>DNS负载均衡：DNS可以返回一个合适的机器的IP给用户，例如可以根据每台服务器的负载量，该机器离用户地理位置的距离等，这种过程就是DNS负载均衡，又可以叫做DNS重定向，大家耳熟能详的CDN就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</p></blockquote><h5 id="2、TCP连接"><a href="#2、TCP连接" class="headerlink" title="2、TCP连接"></a>2、TCP连接</h5><p>由DNS解析后，客户端就能够找到服务器，首先会通过TCP建立连接。</p><h5 id="3、发送HTTP请求"><a href="#3、发送HTTP请求" class="headerlink" title="3、发送HTTP请求"></a>3、发送HTTP请求</h5><p>建立连接后，客户端就向服务器发送请求。</p><h5 id="4、服务器处理请求并返回HTTP报文"><a href="#4、服务器处理请求并返回HTTP报文" class="headerlink" title="4、服务器处理请求并返回HTTP报文"></a>4、服务器处理请求并返回HTTP报文</h5><p>服务器接收到请求后，首先服务器会进行处理，如果是静态页面，则直接返回；否则，将该动态请求转发给后端服务处理，等待后端服务处理结束，则返回处理结果。</p><h5 id="5、浏览器解析渲染页面"><a href="#5、浏览器解析渲染页面" class="headerlink" title="5、浏览器解析渲染页面"></a>5、浏览器解析渲染页面</h5><p>客户端接收到服务端返回的结果后，进行页面渲染。展示给用户。</p><h5 id="6、连接结束"><a href="#6、连接结束" class="headerlink" title="6、连接结束"></a>6、连接结束</h5><p>客户端断开连接。到此，一个请求周期结束。<br>（注：如果是keepalive长连接模式，则该连接不会断开，在timeout时间结束后，连接才会断开。）<br><img src="/uploads/2019/04/the_whole_url.jpg" alt="" title="一个完整的URL请求过程"></p><h4 id="二、一个请求的建立及断开都经历了什么"><a href="#二、一个请求的建立及断开都经历了什么" class="headerlink" title="二、一个请求的建立及断开都经历了什么"></a>二、一个请求的建立及断开都经历了什么</h4><p>我们通过监听9000端口，来捕捉一个php-fpm的请求。仔细分析一下，该请求在服务端都进行了哪些处理，以及都进行了哪些步骤。（注：此分析相当于服务器处理请求并返回结果的过程）<br>下面是通过<code>tcpdump</code>捕获的一个php请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos conf]# tcpdump -i lo port 9000 -S -XX</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">15:07:47.787523 IP VM_0_7_centos.39980 &gt; VM_0_7_centos.cslistener: Flags [S], seq 682182615, win 43690, options [mss 65495,sackOK,TS val 3797694546 ecr 0,nop,wscale 7], length 0</span><br><span class="line">0x0000:  0000 0000 0000 0000 0000 0000 0800 4500  ..............E.</span><br><span class="line">0x0010:  003c 7f85 4000 4006 bd34 7f00 0001 7f00  .&lt;..@.@..4......</span><br><span class="line">0x0020:  0001 9c2c 2328 28a9 47d7 0000 0000 a002  ...,#((.G.......</span><br><span class="line">0x0030:  aaaa fe30 0000 0204 ffd7 0402 080a e25c  ...0...........\</span><br><span class="line">0x0040:  3852 0000 0000 0103 0307                 8R........</span><br><span class="line">00:58:18.801473 IP VM_0_7_centos.cslistener &gt; VM_0_7_centos.39980: Flags [S.], seq 1894922491, ack 682182616, win 43690, options [mss 65495,sackOK,TS val 3797694546 ecr 3797694546,nop,wscale 7], length 0</span><br><span class="line">0x0000:  0000 0000 0000 0000 0000 0000 0800 4500  ..............E.</span><br><span class="line">0x0010:  003c 0000 4000 4006 3cba 7f00 0001 7f00  .&lt;..@.@.&lt;.......</span><br><span class="line">0x0020:  0001 2328 9c2c 70f2 38fb 28a9 47d8 a012  ..#(.,p.8.(.G...</span><br><span class="line">0x0030:  aaaa fe30 0000 0204 ffd7 0402 080a e25c  ...0...........\</span><br><span class="line">0x0040:  3852 e25c 3852 0103 0307                 8R.\8R....</span><br><span class="line">15:07:47.787544 IP VM_0_7_centos.39980 &gt; VM_0_7_centos.cslistener: Flags [.], ack 1894922492, win 342, options [nop,nop,TS val 3797694546 ecr 3797694546], length 0</span><br><span class="line">0x0000:  0000 0000 0000 0000 0000 0000 0800 4500  ..............E.</span><br><span class="line">0x0010:  0034 7f86 4000 4006 bd3b 7f00 0001 7f00  .4..@.@..;......</span><br><span class="line">0x0020:  0001 9c2c 2328 28a9 47d8 70f2 38fc 8010  ...,#((.G.p.8...</span><br><span class="line">0x0030:  0156 fe28 0000 0101 080a e25c 3852 e25c  .V.(.......\8R.\</span><br><span class="line">0x0040:  3852                                     8R</span><br><span class="line">15:07:47.787571 IP VM_0_7_centos.39980 &gt; VM_0_7_centos.cslistener: Flags [P.], seq 682182616:682183504, ack 1894922492, win 342, options [nop,nop,TS val 3797694546 ecr 3797694546], length 888</span><br><span class="line">0x0000:  0000 0000 0000 0000 0000 0000 0800 4500  ..............E.</span><br><span class="line">0x0010:  03ac 7f87 4000 4006 b9c2 7f00 0001 7f00  ....@.@.........</span><br><span class="line">0x0020:  0001 9c2c 2328 28a9 47d8 70f2 38fc 8018  ...,#((.G.p.8...</span><br><span class="line">0x0030:  0156 01a1 0000 0101 080a e25c 3852 e25c  .V.........\8R.\</span><br><span class="line">0x0040:  3852 0101 0001 0008 0000 0001 0000 0000  8R..............</span><br><span class="line">0x0050:  0000 0104 0001 034f 0100 0f17 5343 5249  .......O....SCRI</span><br><span class="line">0x0060:  5054 5f46 494c 454e 414d 452f 686f 6d65  PT_FILENAME/home</span><br><span class="line">0x0070:  2f77 7777 726f 6f74 2f69 6e64 6578 2e70  /wwwroot/index.p</span><br><span class="line">0x0080:  6870 0c00 5155 4552 595f 5354 5249 4e47  hp..QUERY_STRING</span><br><span class="line">0x0090:  0e03 5245 5155 4553 545f 4d45 5448 4f44  ..REQUEST_METHOD</span><br><span class="line">0x00a0:  4745 540c 0043 4f4e 5445 4e54 5f54 5950  GET..CONTENT_TYP</span><br><span class="line">0x00b0:  450e 0043 4f4e 5445 4e54 5f4c 454e 4754  E..CONTENT_LENGT</span><br><span class="line">0x00c0:  480b 0a53 4352 4950 545f 4e41 4d45 2f69  H..SCRIPT_NAME/i</span><br><span class="line">0x00d0:  6e64 6578 2e70 6870 0b0a 5245 5155 4553  ndex.php..REQUES</span><br><span class="line">0x00e0:  545f 5552 492f 696e 6465 782e 7068 700c  T_URI/index.php.</span><br><span class="line">0x00f0:  0a44 4f43 554d 454e 545f 5552 492f 696e  .DOCUMENT_URI/in</span><br><span class="line">0x0100:  6465 782e 7068 700d 0d44 4f43 554d 454e  dex.php..DOCUMEN</span><br><span class="line">0x0110:  545f 524f 4f54 2f68 6f6d 652f 7777 7772  T_ROOT/home/wwwr</span><br><span class="line">0x0120:  6f6f 740f 0853 4552 5645 525f 5052 4f54  oot..SERVER_PROT</span><br><span class="line">0x0130:  4f43 4f4c 4854 5450 2f31 2e31 0e04 5245  OCOLHTTP/1.1..RE</span><br><span class="line">0x0140:  5155 4553 545f 5343 4845 4d45 6874 7470  QUEST_SCHEMEhttp</span><br><span class="line">0x0150:  1107 4741 5445 5741 595f 494e 5445 5246  ..GATEWAY_INTERF</span><br><span class="line">0x0160:  4143 4543 4749 2f31 2e31 0f0c 5345 5256  ACECGI/1.1..SERV</span><br><span class="line">0x0170:  4552 5f53 4f46 5457 4152 456e 6769 6e78  ER_SOFTWAREnginx</span><br><span class="line">0x0180:  2f31 2e31 342e 300b 0d52 454d 4f54 455f  /1.14.0..REMOTE_</span><br><span class="line">0x0190:  4144 4452 3232 332e 3230 2e31 3633 2e39  ADDR223.20.163.9</span><br><span class="line">0x01a0:  350b 0452 454d 4f54 455f 504f 5254 3437  5..REMOTE_PORT47</span><br><span class="line">0x01b0:  3839 0b0a 5345 5256 4552 5f41 4444 5231  89..SERVER_ADDR1</span><br><span class="line">0x01c0:  3732 2e32 372e 302e 370b 0253 4552 5645  72.27.0.7..SERVE</span><br><span class="line">0x01d0:  525f 504f 5254 3830 0b09 5345 5256 4552  R_PORT80..SERVER</span><br><span class="line">0x01e0:  5f4e 414d 456c 6f63 616c 686f 7374 0f03  _NAMElocalhost..</span><br><span class="line">0x01f0:  5245 4449 5245 4354 5f53 5441 5455 5332  REDIRECT_STATUS2</span><br><span class="line">0x0200:  3030 090c 4854 5450 5f48 4f53 5431 3138  00..HTTP_HOST118</span><br><span class="line">0x0210:  2e32 342e 382e 3232 390f 0a48 5454 505f  .24.8.229..HTTP_</span><br><span class="line">0x0220:  434f 4e4e 4543 5449 4f4e 6b65 6570 2d61  CONNECTIONkeep-a</span><br><span class="line">0x0230:  6c69 7665 1e01 4854 5450 5f55 5047 5241  live..HTTP_UPGRA</span><br><span class="line">0x0240:  4445 5f49 4e53 4543 5552 455f 5245 5155  DE_INSECURE_REQU</span><br><span class="line">0x0250:  4553 5453 310f 7948 5454 505f 5553 4552  ESTS1.yHTTP_USER</span><br><span class="line">0x0260:  5f41 4745 4e54 4d6f 7a69 6c6c 612f 352e  _AGENTMozilla/5.</span><br><span class="line">0x0270:  3020 284d 6163 696e 746f 7368 3b20 496e  0.(Macintosh;.In</span><br><span class="line">0x0280:  7465 6c20 4d61 6320 4f53 2058 2031 305f  tel.Mac.OS.X.10_</span><br><span class="line">0x0290:  3134 5f34 2920 4170 706c 6557 6562 4b69  14_4).AppleWebKi</span><br><span class="line">0x02a0:  742f 3533 372e 3336 2028 4b48 544d 4c2c  t/537.36.(KHTML,</span><br><span class="line">0x02b0:  206c 696b 6520 4765 636b 6f29 2043 6872  .like.Gecko).Chr</span><br><span class="line">0x02c0:  6f6d 652f 3733 2e30 2e33 3638 332e 3130  ome/73.0.3683.10</span><br><span class="line">0x02d0:  3320 5361 6661 7269 2f35 3337 2e33 360b  3.Safari/537.36.</span><br><span class="line">0x02e0:  7648 5454 505f 4143 4345 5054 7465 7874  vHTTP_ACCEPTtext</span><br><span class="line">0x02f0:  2f68 746d 6c2c 6170 706c 6963 6174 696f  /html,applicatio</span><br><span class="line">0x0300:  6e2f 7868 746d 6c2b 786d 6c2c 6170 706c  n/xhtml+xml,appl</span><br><span class="line">0x0310:  6963 6174 696f 6e2f 786d 6c3b 713d 302e  ication/xml;q=0.</span><br><span class="line">0x0320:  392c 696d 6167 652f 7765 6270 2c69 6d61  9,image/webp,ima</span><br><span class="line">0x0330:  6765 2f61 706e 672c 2a2f 2a3b 713d 302e  ge/apng,*/*;q=0.</span><br><span class="line">0x0340:  382c 6170 706c 6963 6174 696f 6e2f 7369  8,application/si</span><br><span class="line">0x0350:  676e 6564 2d65 7863 6861 6e67 653b 763d  gned-exchange;v=</span><br><span class="line">0x0360:  6233 140d 4854 5450 5f41 4343 4550 545f  b3..HTTP_ACCEPT_</span><br><span class="line">0x0370:  454e 434f 4449 4e47 677a 6970 2c20 6465  ENCODINGgzip,.de</span><br><span class="line">0x0380:  666c 6174 6514 0e48 5454 505f 4143 4345  flate..HTTP_ACCE</span><br><span class="line">0x0390:  5054 5f4c 414e 4755 4147 457a 682d 434e  PT_LANGUAGEzh-CN</span><br><span class="line">0x03a0:  2c7a 683b 713d 302e 3900 0104 0001 0000  ,zh;q=0.9.......</span><br><span class="line">0x03b0:  0000 0105 0001 0000 0000                 ..........</span><br><span class="line">15:07:47.787577 IP VM_0_7_centos.cslistener &gt; VM_0_7_centos.39980: Flags [.], ack 682183504, win 356, options [nop,nop,TS val 3797694546 ecr 3797694546], length 0</span><br><span class="line">0x0000:  0000 0000 0000 0000 0000 0000 0800 4500  ..............E.</span><br><span class="line">0x0010:  0034 00ae 4000 4006 3c14 7f00 0001 7f00  .4..@.@.&lt;.......</span><br><span class="line">0x0020:  0001 2328 9c2c 70f2 38fc 28a9 4b50 8010  ..#(.,p.8.(.KP..</span><br><span class="line">0x0030:  0164 fe28 0000 0101 080a e25c 3852 e25c  .d.(.......\8R.\</span><br><span class="line">0x0040:  3852                                     8R</span><br><span class="line">15:07:49.735400 IP VM_0_7_centos.cslistener &gt; VM_0_7_centos.39980: Flags [P.], seq 1894922492:1894922596, ack 682183504, win 356, options [nop,nop,TS val 3797696494 ecr 3797694546], length 104</span><br><span class="line">0x0000:  0000 0000 0000 0000 0000 0000 0800 4500  ..............E.</span><br><span class="line">0x0010:  009c 00af 4000 4006 3bab 7f00 0001 7f00  ....@.@.;.......</span><br><span class="line">0x0020:  0001 2328 9c2c 70f2 38fc 28a9 4b50 8018  ..#(.,p.8.(.KP..</span><br><span class="line">0x0030:  0164 fe90 0000 0101 080a e25c 3fee e25c  .d.........\?..\</span><br><span class="line">0x0040:  3852 0106 0001 0050 0000 582d 506f 7765  8R.....P..X-Powe</span><br><span class="line">0x0050:  7265 642d 4279 3a20 5048 502f 372e 302e  red-By:.PHP/7.0.</span><br><span class="line">0x0060:  3333 0d0a 436f 6e74 656e 742d 7479 7065  33..Content-type</span><br><span class="line">0x0070:  3a20 7465 7874 2f68 746d 6c3b 2063 6861  :.text/html;.cha</span><br><span class="line">0x0080:  7273 6574 3d55 5446 2d38 0d0a 0d0a 4865  rset=UTF-8....He</span><br><span class="line">0x0090:  6c6c 6f20 576f 726c 6421 0103 0001 0008  llo.World!......</span><br><span class="line">0x00a0:  0000 0000 0000 003a 2074                 .......:.t</span><br><span class="line">15:07:49.735419 IP VM_0_7_centos.39980 &gt; VM_0_7_centos.cslistener: Flags [.], ack 1894922596, win 342, options [nop,nop,TS val 3797696494 ecr 3797696494], length 0</span><br><span class="line">0x0000:  0000 0000 0000 0000 0000 0000 0800 4500  ..............E.</span><br><span class="line">0x0010:  0034 7f88 4000 4006 bd39 7f00 0001 7f00  .4..@.@..9......</span><br><span class="line">0x0020:  0001 9c2c 2328 28a9 4b50 70f2 3964 8010  ...,#((.KPp.9d..</span><br><span class="line">0x0030:  0156 fe28 0000 0101 080a e25c 3fee e25c  .V.(.......\?..\</span><br><span class="line">0x0040:  3fee                                     ?.</span><br><span class="line">15:07:49.735501 IP VM_0_7_centos.cslistener &gt; VM_0_7_centos.39980: Flags [F.], seq 1894922596, ack 682183504, win 356, options [nop,nop,TS val 3797696494 ecr 3797696494], length 0</span><br><span class="line">0x0000:  0000 0000 0000 0000 0000 0000 0800 4500  ..............E.</span><br><span class="line">0x0010:  0034 00b0 4000 4006 3c12 7f00 0001 7f00  .4..@.@.&lt;.......</span><br><span class="line">0x0020:  0001 2328 9c2c 70f2 3964 28a9 4b50 8011  ..#(.,p.9d(.KP..</span><br><span class="line">0x0030:  0164 fe28 0000 0101 080a e25c 3fee e25c  .d.(.......\?..\</span><br><span class="line">0x0040:  3fee                                     ?.</span><br><span class="line">15:07:49.735547 IP VM_0_7_centos.39980 &gt; VM_0_7_centos.cslistener: Flags [F.], seq 682183504, ack 1894922597, win 342, options [nop,nop,TS val 3797696494 ecr 3797696494], length 0</span><br><span class="line">0x0000:  0000 0000 0000 0000 0000 0000 0800 4500  ..............E.</span><br><span class="line">0x0010:  0034 7f89 4000 4006 bd38 7f00 0001 7f00  .4..@.@..8......</span><br><span class="line">0x0020:  0001 9c2c 2328 28a9 4b50 70f2 3965 8011  ...,#((.KPp.9e..</span><br><span class="line">0x0030:  0156 fe28 0000 0101 080a e25c 3fee e25c  .V.(.......\?..\</span><br><span class="line">0x0040:  3fee                                     ?.</span><br><span class="line">15:07:49.735554 IP VM_0_7_centos.cslistener &gt; VM_0_7_centos.39980: Flags [.], ack 682183505, win 356, options [nop,nop,TS val 3797696494 ecr 3797696494], length 0</span><br><span class="line">0x0000:  0000 0000 0000 0000 0000 0000 0800 4500  ..............E.</span><br><span class="line">0x0010:  0034 00b1 4000 4006 3c11 7f00 0001 7f00  .4..@.@.&lt;.......</span><br><span class="line">0x0020:  0001 2328 9c2c 70f2 3965 28a9 4b51 8010  ..#(.,p.9e(.KQ..</span><br><span class="line">0x0030:  0164 fe28 0000 0101 080a e25c 3fee e25c  .d.(.......\?..\</span><br><span class="line">0x0040:  3fee                                     ?.</span><br></pre></td></tr></table></figure></p><p>分析分为三个步骤，建立连接、传输数据、断开连接，及TCP的一个周期。</p><h5 id="1、三次握手建立连接"><a href="#1、三次握手建立连接" class="headerlink" title="1、三次握手建立连接"></a>1、三次握手建立连接</h5><p>一个连接包含了哪些数据，包头和包体。包头又包含了mac头、IP头、TCP头。下面扩展中分析了各头部所占用的位数。<br>需要注意区分的是，IP头的协议版本、首部长度及IP地址是什么，TCP头的端口号、数据偏移及标识位是什么。<br>对应上面二进制的表示，则为：<br>IP头的版本号为<code>4500</code>中的’4’，表示IPv4，如果为’6’，表示IPv6。<br>IP头的首部长度为<code>4500</code>中的’5’，表示4x5=20，说明IP头部有20个字节。<br>IP头的IP地址为<code>7f00 0001</code>，表示’127.0.0.1’。<br>TCP头的端口号为<code>9c2c</code>，表示nginx起的端口号为’39980’；<code>2328</code>，表示php-fpm的端口号为’9000’。<br>TCP头的长度为<code>a002</code>中的’a’，表示10x4=40，说明TCP头部有40个字节。<br>TCP头的标识位为<code>a002</code>中的’02’，表示‘SYN’；<code>a012</code>中的’12’，表示‘SYN’和‘ACK’。而断开连接的<code>8011</code>中的’11’，表示’FIN’和’ACK’。</p><p>因此，建立连接的步骤为：<br>1) 客户端向服务端发送了一个‘SYN’，seq 682182615。<br>2) 服务端回了客户端一个’ACK’，并向客户端发送了一个’SYN’，seq 1894922491, ack 682182616。<br>3) 客户端回了服务端一个’ACK’，ack 1894922492。（注：此seq是接着服务端的seq的）<br>至此，客户端与服务端建立了连接。下面就是客户端向服务端发送了请求。</p><blockquote><p>扩展：<br>Mac头包含什么？<br>mac头包含了14个字节。<br>对应上面的二进制，即为<code>0000 0000 0000 0000 0000 0000 0800</code>。<br>IP头包含什么？<br><img src="/uploads/2019/04/ip_head.jpeg" alt="" title="IP首部"><br>对应上面的二进制，即为<code>7f00 0001</code>结束。<br>TCP头包含什么？<br><img src="/uploads/2019/04/tcp_head.png" alt="" title="TCP首部"><br>对应上面的二进制，即为<code>fe30 0000</code>结束。<br>注：标识位区分<br>TCP的标识位一共有6个，分别为URG、ACK（响应）、PSH（数据传输）、RST（连接重置）、SYN（建立连接）、FIN（关闭连接）。<br>对应的位数分别表示为：10，01，1000，0100，0010，0001。转成16进制则为：2，1，8，4，2，1。<br>TCP/IP头部大小<br>通过TCP的数据偏移及IP的首部长度可说明头部的大小，因为都是4位，最大表示15，因此，TCP/IP头部最大头部位15x4=60个字节。由于最低头部有20字节，因此，可扩展的头部字节数为40字节。至于为什么要乘于4，因为4表示4字节，32位。而TCP/IP头部每一行占用32位。所以，TCP/IP的长度标识位最小数应为5。</p></blockquote><h5 id="2、传输数据"><a href="#2、传输数据" class="headerlink" title="2、传输数据"></a>2、传输数据</h5><p>在发送请求的时候，客户端给服务端回了一个’ACK‘，以及向服务端发送了数据’PSH’，seq 682182616:682183504, ack 1894922492<br>（注：此处的682182616:682183504，表示传输的数据大小。）<br>传输数据的协议都有哪些？HTTP、HTTPS、fastcgi,cgi</p><p>本次分析，以fastcgi协议来说明数据是如何传输的，以及如何保证数据的正确性。<br>博客：<a href="https://mengkang.net/668.html" target="_blank" rel="noopener">https://mengkang.net/668.html</a><br>传输数据时，nginx与PHP都会按照fastcig协议来进行通信，而最后，会通过nginx来进行组装数据，返回给客户端。</p><blockquote><p><strong>扩展：</strong><br>各协议详解？</p></blockquote><h5 id="3、四次挥手断开连接"><a href="#3、四次挥手断开连接" class="headerlink" title="3、四次挥手断开连接"></a>3、四次挥手断开连接</h5><p>首先，是服务端主动断开连接的，向服务端发送了‘FIN’，客户端回了一个‘ACK’，并发送了一个‘FIN’，服务端回了客户端一个‘ACK’。断开连接。</p><blockquote><p><strong>扩展：</strong><br>1、在浏览器与服务器通信的时候，哪端主动断开连接<br> 那端都可主动断开连接，一般是客户端会断开连接。 如果服务端配置的有CLB，一般是CLB对服务端断开连接。 服务器上的TIME_WAIT一般都是请求其它服务断开的连接。例如：mysql、redis、mq、rpc等等。<br>2、TIME_WAIT的产生，以及影响<br> 那端主动断开，TIME_WAIT产生在那端，且存留时间为2MSL（MSL：数据报在网络中存留的最大时间）。如果并发量太高的话，会导致服务器端口被用尽，其它请求会报5xx。 解决办法，就是只能增加机器，横向扩展，服务器降级，多配几台低端机器，增加并发量。<br>3、服务端连接都有几种状态，以及各个状态的含义<br>三次握手状态：LISTEN、CLOSED、SYN_SENT、SYN_RCVD、ESTABLISHED<br>四次挥手状态：FIN_WAIT_1、CLOSE_WAIT、FIN_WAIT_2、LAST_ACK、TIME_WAIT、CLOSED</p></blockquote><p><strong>扩展知识点：</strong><br>各层之间都是透明的，互不影响的，通过接口进行调用及传输。<br>网络层的作用是找到主机（通过IP+mac地址）；传输层的作用是找到那个进程，即服务（通过端口）；</p><p><strong>经典文章：</strong><br><a href="https://www.cnblogs.com/jacklikedogs/articles/3848263.html" target="_blank" rel="noopener">https://www.cnblogs.com/jacklikedogs/articles/3848263.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;详细分解网络请求&lt;/strong&gt;&lt;br&gt;一个网络请求通过TCP/IP五层架构（此处数据链路层和物理层是分开的）进行传输，都是怎么传输的，以及都干了些什么。此文将会从网络层、传输层和应用层进行详解，各个层都做了哪些操作，以及是如何进行传输的。&lt;/p&gt;
&lt;p&gt;下面我们将从大的方向来说明一个请求从客户端到服务端都经历了哪些过程，此处可能会遗漏，以后达到该层次，再补充。&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP手册学习之类</title>
    <link href="http://yoursite.com/2019/07/19/PHP%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/07/19/PHP手册学习之类/</id>
    <published>2019-07-19T09:00:56.000Z</published>
    <updated>2019-07-19T09:24:41.425Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>PHP5中的新特性包括：访问控制、抽象类、final类与方法，附加的魔术方法、接口、对象复制和类型约束。</p><h5 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h5><ol><li>一个类可以包含有属于自己的常量、变量（称为“属性”）以及函数（称为“方法”）。</li><li>一个类可以在声明中用 extends 关键字继承另一个类的方法和属性。PHP不支持多重继承。</li><li>访问控制关键字 public、protected、private、static、final</li><li>静态成员、类常量访问使用“::“</li><li>self,parent和static这是那个特殊的关键字是用于在类定义的内部对其属性或方法进行访问的。</li><li>对象比较<br><code>==</code> 比较两个对象时，如果两个对象的属性和属性值 都相等，而且两个对象是同一个类的实例，那么这两个对象变量相等。<br><code>===</code> 使用全等运算符，这两个对象变量一定要指向某个类的同一个实例（即同一个对象）。</li></ol><a id="more"></a><h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><ol><li>声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个已实例化的类对象来访问（但静态方法可以）。</li><li>由于静态方法不需要通过对象即可调用，所以伪变量 $this在静态方法中不可用。</li><li>静态属性不可以由对象通过 -&gt; 操作符来访问。</li><li>用静态方式调用一个非静态方法会导致一个 E_STRICT级别的错误</li></ol><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><ol><li>通过关键字 interface来定义，通过implements关键字来实现接口。（类可以实现多个接口）</li><li>接口定义的所有方法都必须是公有的，这是接口的特性。</li><li>类中必须实现接口定义的所有方法，否则会报一个致命错误</li></ol><h5 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h5><ol><li>Trait是为类似PHP的单继承语言而准备的一种代码复用机制。利用组合的方式来复用代码。</li><li>优先级问题：<br>从基类继承的成员会被trait插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了trait的方法，而trait则覆盖了被继承的方法。</li><li>多个trait，通过都好分隔，在use声明列出多个trait，可以都插入到一个类中。</li></ol><h5 id="重载（类魔术方法）"><a href="#重载（类魔术方法）" class="headerlink" title="重载（类魔术方法）"></a>重载（类魔术方法）</h5><h6 id="属性重载"><a href="#属性重载" class="headerlink" title="属性重载"></a>属性重载</h6><p>__set() 在给不可访问属性赋值时，会调用<br>__get() 读取不可访问属性的值时，会调用<br>__isset() 当对不可访问属性调用isset()或empty()时，会调用<br>__unset() 当对不可访问属性调用unset()时，会调用</p><h6 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h6><p>__call() 在对象中调用一个不可访问方法时，会调用<br>__callStatic() 在静态上下文中调用一个不可访问方法时，会调用</p><h5 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h5><p>__construct()、__destruct()、__call()、__callStatic()、<br>__get()、__set()、__isset()、__unset()、__sleep()、__wakeup()、<br>__toString()、__invoke()、__clone()、__set_state()、__debugInfo()<br>__toString() 用于当一个类被当成字符串时应该怎么回应。例如echo $obj;应该显示什么<br>__invoke() 当尝试以调用函数的方式调用一个对象时，该方法会自动调用。<br>__clone() 当克隆对象的时候，会调用该方法。</p><h5 id="类型约束（PHP5可以使用）"><a href="#类型约束（PHP5可以使用）" class="headerlink" title="类型约束（PHP5可以使用）"></a>类型约束（PHP5可以使用）</h5><ol><li>函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组或者callable</li><li>如果一个类或接口指定了类型约束，则其所有的子类或者实现也都如此。</li></ol><h5 id="类-对象函数"><a href="#类-对象函数" class="headerlink" title="类/对象函数"></a>类/对象函数</h5><p>__autoload    - 尝试加载为定义的类 sql_autoload_register()<br>class_exists    - 检查类是否已定义<br>method_exists    - 检查类的方法是否存在<br>trait_exists    - 检查指定的trait是否存在<br>property_exists - 检查对象或类是否具有该属性<br>get_class    - 返回对象的类名<br>is_a        - 如果对象属于该类或该类是此对象的父类则返回TRUE</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><h5 id="一、错误处理和日志记录"><a href="#一、错误处理和日志记录" class="headerlink" title="一、错误处理和日志记录"></a>一、错误处理和日志记录</h5><p>1、预定义常量<br>E_ERROR        致命的运行时错误<br>E_WARNING    运行时警告<br>E_PARSE        编译时语法解析错误<br>E_NOTICE    运行时通知<br>E_STRICT    启用PHP对代码的修改建议，以确保代码具有最佳的互操作性和向前兼容性<br>E_ALL        除E_STRICT外所有错误和警告信息</p><p>2、运行时配置项： 可通过ini_set()函数设置运行时配置<br>error_reporting        设置错误报告的级别。运行时可直接使用error_reporting()函数设置<br> PHP5.3及以上版本中，默认值为E_ALL &amp; ~E_NOTICE &amp; ~E_STRICT &amp; ~E_DEPRECATED<br>该设置不会显示E_NOTICE、E_STRICT、E_DEPRECATED级错误提示。<br>display_errors        该选项设置是否将错误信息作为输出的一部分显示到屏幕，或者对用户隐藏而不显示。<br>log_errors        设置是否将脚本运行的错误信息记录到服务器错误日志或者error_log之中。<br>error_log        设置脚本错误将被记录到文件。<br>ignore_repeated_errors    不记录重复的信息</p><p>3、错误处理函数：<br>debug_backtrace 产生一条回溯信息<br>debug_print_backtrace 打印一条回溯信息<br>error_clear_last 清楚最近一次错误<br>error_get_last    获取最后发生的错误<br>error_log    发送错误信息到某个地方<br>error_reporting    设置应该报告何种PHP错误<br>set_error_handler    设置用户自定义的错误处理函数<br>set_exception_handler    设置用户自定义的异常处理函数</p><h5 id="二、PHP选项-信息函数"><a href="#二、PHP选项-信息函数" class="headerlink" title="二、PHP选项/信息函数"></a>二、PHP选项/信息函数</h5><p>set_time_limit    - 设置脚本最大执行时间<br>ini_set        - 为一个配置选项设置值<br>getenv        - 获取一个环境变量的值<br>getlastmod    - 获取页面最后修改的时间<br>ini_get        - 获取一个配置选项的值<br>memory_get_usage     - 返回分配给PHP的内存量<br>php_ini_loaded_file    - 取得已加载的php.ini文件的路径<br>php_uname    - 返回运行PHP的系统的有关信息<br>phpinfo        - 输出关于PHP配置的信息<br>phpversion    - 获取当前的PHP版本<br>putenv        - 设置环境变量的值</p><h5 id="三、扩展："><a href="#三、扩展：" class="headerlink" title="三、扩展："></a>三、扩展：</h5><p><strong>压缩与归档扩展：</strong><br> Bzip2        对.bz2的压缩文件<br> Rar<br> Zip<br> Zlib        对gzip的编译<br><strong>加密：</strong><br> Hash        无需安装，自带<br> Mcrypt        加密扩展，需安装<br> OpenSSL        对称/非对称加解密<br><strong>数据库：</strong><br> Mysql(原始)    从PHP5.5.0起这个扩展已经被废弃，并且从PHP7.0.0开始被移除。可使用mysqli或者PDO_MySQL扩展代替。<br> Mysqli        MySQL增强版扩展<br> Mysqlnd        mysql的客户端<br> PDO_MYSQL    mysql的PDO驱动<br><strong>国际化与字符编码支持：</strong><br> iconv        包含了iconv字符集转换功能的接口<br> gettext    实现了NLS API<br><strong>图像生成和处理：</strong><br> GD        图像处理和GD<br> Gmagick、ImageMagick、Exif<br><strong>邮件相关扩展：</strong> 一般使用第三方邮件系统<br><strong>数学扩展：</strong><br> BC Math    BCMath 任意精度数学<br> Math<br><strong>其它基本扩展：</strong><br> JSON、Sessions、libxml<br> Lua、Swoole、Yaf、Yaml<br><strong>其它服务：</strong><br> cURL、Memcache、Memcached、Sockets</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h4&gt;&lt;p&gt;PHP5中的新特性包括：访问控制、抽象类、final类与方法，附加的魔术方法、接口、对象复制和类型约束。&lt;/p&gt;
&lt;h5 id=&quot;基本概念：&quot;&gt;&lt;a href=&quot;#基本概念：&quot; class=&quot;headerlink&quot; title=&quot;基本概念：&quot;&gt;&lt;/a&gt;基本概念：&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;一个类可以包含有属于自己的常量、变量（称为“属性”）以及函数（称为“方法”）。&lt;/li&gt;
&lt;li&gt;一个类可以在声明中用 extends 关键字继承另一个类的方法和属性。PHP不支持多重继承。&lt;/li&gt;
&lt;li&gt;访问控制关键字 public、protected、private、static、final&lt;/li&gt;
&lt;li&gt;静态成员、类常量访问使用“::“&lt;/li&gt;
&lt;li&gt;self,parent和static这是那个特殊的关键字是用于在类定义的内部对其属性或方法进行访问的。&lt;/li&gt;
&lt;li&gt;对象比较&lt;br&gt;&lt;code&gt;==&lt;/code&gt; 比较两个对象时，如果两个对象的属性和属性值 都相等，而且两个对象是同一个类的实例，那么这两个对象变量相等。&lt;br&gt;&lt;code&gt;===&lt;/code&gt; 使用全等运算符，这两个对象变量一定要指向某个类的同一个实例（即同一个对象）。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP手册学习之函数整理</title>
    <link href="http://yoursite.com/2019/07/19/PHP%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2019/07/19/PHP手册学习之函数整理/</id>
    <published>2019-07-19T08:59:43.000Z</published>
    <updated>2019-07-19T09:24:41.425Z</updated>
    
    <content type="html"><![CDATA[<p>下面是此段时间看手册整理之后的函数：</p><a id="more"></a><h4 id="数组函数："><a href="#数组函数：" class="headerlink" title="数组函数："></a>数组函数：</h4><p>array_chunk(array, size, bool) 对数组进行分组，每个数组包含size个元素<br>array_column(array, null, key) 获取数组中某一列数据，或以某列为键，某列为值<br>array_combine(array1, array2)  合并两个数组，以array1为键，以array2为值，如果两个数组元素个数不一样，返回false<br>array_diff(array1, array2,…) 比较数组的值，返回差集，存在array1,且不存在其它数组中的值。保持索引不变<br>array_diff_key(array1, array2, …) 比较数组的键，返回差集，存在array1,且不存在其它数组中，保持索引不变<br>array_intersect(array1, array2, …) 比较数组的值，返回交集，返回即存在array1,又存在array2种，保持索引不变<br>array_intersect_key(array1, array2, …) 比较数组的键，返回交集，返回即存在array1,又存在array2种，保持索引不变<br>array_filter(array, [callback]) 用回调函数过滤数组中的单元，如果没有回调函数，则过滤数组中false的单元<br>array_flip(array)  交换数组中的键值<br>array_keys(array)  返回数组中的键<br>array_values(array)   返回数组中的值<br>array_map(callback, array)  返回数组，对array中的每个元素都应用callback之后的数组<br>array_walk(&amp;array, callback, [userdata])  返回bool，对数组中的每个元素应用callback<br>array_merge(array1, array2, …) 合并两个数组，关联数组后面的会覆盖前面。索引数组会重置索引值，从0开始。（比较 “+” 合并数组，索引数组会保持索引值，前面的会覆盖后面。）<br>array_pop()、array_push()、array_shift()、array_unshift()<br>array_rand(array, [int]) 从数组中随机取出一个或多个单元。只取出一个，返回键名。否则返回包含键名的数组。<br>shuffle(array) 打乱数组，返回bool。<br>array_reverse(array, [bool=false]) 返回单元顺序相反的数组。如果第二个值为true，会保留数字索引。<br>array_key_exists(key, array)  检查数组中是否包含key<br>in_array(needle, array) 检查数组中是否存在某个值<br>array_search(needle, array) 在数组中搜索给定的值，成功返回键名<br>array_slice(array, offset, [length, bool=false]) 返回根据offset和length指定的数组序列。第四个值设为true，保持数字索引不变。<br>array_sum(array)  对数组中所有值求和<br>array_unique(array)  移除数组中重复的值，默认按照字符串排序<br>sort()、rsort()、asort()、arsort()、ksort()、krsort()、usort(array, callback)、uksort()、uasort()<br>compact(varname1) 建立一个数组，包含变量名和它们的值。会在当前符号表中查找该变量名并将它添加到输出的数组中，变量名成为键名而变量的内容成为该键的值。<br>extract(array)  从数组中将变量导入到当前的符号表。 与compact正好相反<br>count(array, [int = 0]) 获取数组的单元个数。 如果第二个值为1，则获取多维数组中单元个数。<br>current() 返回数组当前单元，并不移动指针<br>key() 从关联数组中取得键名，返回当前单元的键名，并不移动指针<br>end() 返回数组最后一个单元，返回值<br>next() 将数组中的内部指针向前移动一位，返回值<br>prev() 将数组的内部指针倒回一位，返回值<br>reset() 将数组的内部指针指向第一个单元，返回值<br>each() 返回数组中当前的键/值对并将数组指针向前移动一位<br>list(var1, …) 把数组中的值赋给一组变量<br>range(start, end, [step=1]) 根据范围创建数组，包含指定的元素。</p><h4 id="字符串函数："><a href="#字符串函数：" class="headerlink" title="字符串函数："></a>字符串函数：</h4><p>addslashes($str):str    - 使用反斜线引用字符串<br>stripcslashes($str):str    - 反引用一个使用addslashes转义的字符串<br>html_entity_decode    - 转化html实体<br>htmlspecialchars()    - 将特殊字符转换为HTML实体<br>htmlspecialchars_decode() - 将特殊的HTML实体转换回普通字符<br>explode($delimiter, $str):array        - 使用一个字符串分隔另一个字符串<br>implode($glue, $pieces):string        - 将一个一维数组的值转化为字符串<br>trim()、ltrim()、rtrim()    - 删除字符串两边的空白字符（或其它字符）<br>md5($str, [$raw_output]):str        - 计算字符串的MD5散列值<br>sha1($str, [$raw_output]):str        - 计算字符串的sha1散列值<br>crc32($str):int        - 计算一个字符串的crc32多项式<br>sprintf($format, [$args,…]):str     - 格式化字符串<br>printf($format, [$args, …]):int    - 输出格式化字符串<br>number_format($number, $decimals, $dec_point=’.’, $thousands_sep=’,’) - 以千位分隔符方式格式化一个数字（注：本函数接受1个、2个或者4个参数，不能是3个）<br>str_pad($input, $pad_length, [$pad_string, $pad_type=’left’]):str    - 使用另一个字符串填充字符串为指定长度<br>str_shuffle($str):str    - 随机打乱一个字符串<br>strlen($str):str    - 获取字符串长度<br>strrev($str):str    - 反转字符串<br>strpos($haystack, $needle, [$offset]):int    - 查找字符串首次出现的位置<br>stripos($haystack, $needle, [$offset]):int    - 查找字符串首次出现的位置（不区分大小写）<br>strrpos($haystack, $needle, [$offset]):int    - 计算指定字符串在目标字符串中最后一次出现的位置<br>strtolower($str):str    - 将字符串转化为小写<br>strtoupper($str):str    - 将字符串转化为大写<br>substr_replace($str, $replace, $start, [$length]):mixed    - 替换字符串的子串<br>substr($str, $start, $length):str    - 返回字符串的子串<br>ucfirst($str):str    - 将字符串的首字母转换为大写<br>ucwords($str):str    - 将字符串中每个单词的首字母转换为大写</p><h4 id="数学函数："><a href="#数学函数：" class="headerlink" title="数学函数："></a>数学函数：</h4><p>ceil()    - 进一法取整<br>floor()    - 舍去法取整<br>round()    - 对浮点数进行四舍五入<br>fmod()    - 返回除法的浮点数余数<br>max()    - 找出最大值<br>min()    - 找出最小值<br>rand()    - 产生一个随机整数（闭合区间）<br>mt_rand()    - 生成更好的随机数（闭合区间）<br>pow()    - 指数表达式<br>abs()    - 绝对值</p><h4 id="BC数学函数："><a href="#BC数学函数：" class="headerlink" title="BC数学函数："></a>BC数学函数：</h4><p>bcadd($left_operand, $right_operand, [$scale])    - 2个任意精度数字的加法计算<br>bcsub($left_operand, $right_operand, [$scale])    - 2个任意精度数学的减法<br>bcmul($left_operand, $right_operand, [$scale])    - 2个任意精度数字乘法计算<br>bcdiv($left_operand, $right_operand, [$scale])        - 2个任意精度的数字除法计算<br>bccomp($left_operand, $right_operand, [$scale])    - 比较两个任意精度的数字<br>bcmod($left_operand, $modulus)        - 对一个任意精度数字取模<br>bcpow($left_operand, $right_operand, [$scale])        - 任意精度数字的乘方<br>bcsqrt($operand, [$scale])    - 任意精度数学的二次方根<br>bcscale($scale)     - 设置所有bc数学函数的默认小数点保留位数</p><h4 id="时间函数："><a href="#时间函数：" class="headerlink" title="时间函数："></a>时间函数：</h4><p>date()        - 格式化一个本地时间/日期<br>microtime()    - 返回当前Unix时间戳和微秒数<br>mktime()    - 取得一个日期的Unix时间戳<br>strtotime()    - 将任何字符串的日期时间描述解析为Unix时间戳<br>time()        - 返回当前的Unix时间戳<br>localtime()    - 取得本地时间<br>date_default_timezone_set - 设定用于一个脚本中所有日期时间函数的默认时区<br>date_default_timezone_get - 获取</p><h4 id="文件函数："><a href="#文件函数：" class="headerlink" title="文件函数："></a>文件函数：</h4><p>opendir($path):resource    - 打开目录句柄<br>closedir($dir_handle)    - 关闭目录句柄<br>readdir($dir_handle):str    - 从目录句柄中读取条目<br>scandir($directory, [$sorting_order]):array    - 列出指定路径中的文件和目录<br>chdir($directory):bool        - 改变目录<br>chroot($directory):bool    - 改变根目录<br>getcwd():str    - 取得当前工作目录</p><h4 id="文件系统函数；"><a href="#文件系统函数；" class="headerlink" title="文件系统函数；"></a>文件系统函数；</h4><p>file_get_contents($filename):str - 将整个文件读取一个字符串<br>file_put_contents($filename, $data):int - 将一个字符串写入文件<br>basename($path, [$suffix]):str    - 返回路径中的文件名部分（如果文件名是以suffix结尾，也会被去掉）<br>dirname($path):str    - 返回路径中的目录部分<br>pathinfo($path):mixd    - 返回文件路径信息（包含：surname,basename,extension,filename）<br>fopen($filename, $mode):resource    - 打开文件或者URL<br>fread($handle, $length):str        - 读取文件<br>fgetc($handle):str        - 从文件指针中读取字符<br>fgets($handle, [$length]):str    - 从文件指针中读取一行（如果没有指定length，则默认1K，即1024字节）<br>fclose($handle):bool    - 关闭一个已打开的文件指针<br>feof($handle):bool        - 测试文件指针是否到了文件结束的位置<br>fwrite($handle, $str, [$length]):int    - 写入文件<br>mkdir($pathname, [$mode=0777, $recursive=false]):bool        - 新建目录<br>rmdir($dirname):bool        - 删除目录（目录必须是空的）<br>unlink($filename):bool    - 删除文件<br>fseek()        - 在文件指针中定位<br>move_uploaded_file($filename, $destination):bool    - 将上传的文件移动到新位置<br>filesize($filename):int    - 取得文件大小<br>filetype($filename):type    - 取得文件类型<br>fileatime($filename):int    - 文件访问时间<br>filectime($filename):int    - 文件inode修改时间<br>filemtime($filename):int    - 取得文件修改时间<br>is_dir($filename):bool    - 是否是一个目录<br>is_file($filename):bool    - 是否为一个正常的文件<br>is_executable($filename):bool    - 文件是否可执行<br>is_writable($filename):bool    - 文件是否可写<br>is_readable($filename):bool    - 文件是否可读<br>chgrp($filename, $group):bool        - 改变文件所属的组<br>chmod($filename, $mode):bool        - 改变文件模式<br>chown($filename, $user):bool        - 改变文件的所有者<br>copy($source, $dest):bool        - 拷贝文件<br>rename()    - 重命名一个文件或目录<br>realpath()    - 返回规范化的绝对路径名<br>touch()        - 设定文件的访问和修改时间</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是此段时间看手册整理之后的函数：&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP手册学习之基础知识</title>
    <link href="http://yoursite.com/2019/07/19/PHP%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/07/19/PHP手册学习之基础知识/</id>
    <published>2019-07-19T08:59:10.000Z</published>
    <updated>2019-07-19T09:24:41.425Z</updated>
    
    <content type="html"><![CDATA[<h4 id="PHP类型：支持9种原始数据类型。"><a href="#PHP类型：支持9种原始数据类型。" class="headerlink" title="PHP类型：支持9种原始数据类型。"></a>PHP类型：支持9种原始数据类型。</h4><h5 id="四种标量类型："><a href="#四种标量类型：" class="headerlink" title="四种标量类型："></a>四种标量类型：</h5><p> boolean、integer、float(double)、string</p><h5 id="三种复合类型："><a href="#三种复合类型：" class="headerlink" title="三种复合类型："></a>三种复合类型：</h5><p> array、object、callable(可调用)</p><h5 id="两种特殊类型："><a href="#两种特殊类型：" class="headerlink" title="两种特殊类型："></a>两种特殊类型：</h5><p> resource、NULL(无类型)</p><a id="more"></a><h4 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h4><ol><li><p>以下值被认为是false：<br>false、0、0.0、”0”、””、array()、NULL</p></li><li><p>永远不要比较两个浮点数是否相等</p></li><li><p>一个字符串的表达方式：单引号、双引号、heredoc语法结构、nowdoc语法结构</p></li><li><p>在下列情况下一个变量被认为是NULL：被赋值为NULL；尚未被赋值；被unset()。<br>（注：使用unset()将一个变量转换为null将不会删除该变量或unset其值。仅是返回NULL值而已）</p></li><li><p>define()、const()定义常量，一个常量一旦被定义，就不能再改变或者取消定义。</p><ul><li>1）常量只能包含标量数据</li><li>2）const()可以在类中定义常量</li></ul></li><li><p>常量和变量的不同点</p><ul><li>常量前面没有美元符号 $</li><li>常量只能用define()函数定义，而不能通过赋值语句</li><li>常量可以不用理会变量的作用域而在任何地方定义和访问</li><li>常量一旦定义就不能被重新定义或者取消</li><li>常量的值只能是标量。</li></ul></li><li><p>isset()与empty()<br>isset()检测变量是否设置并且非NULL，注意，null字符并不等同于NULL常量。当变量被unset()之后，就变为NULL了。<br>empty()检测变量是否为空。当一个变量不存在，或者它的值等同于false，那么就会被被认为不存在。<br>以下的东西被认为是空的：<br>“”、0、0.0、”0”、NULL、false、array()、$var(一个声明了，但是没有值的变量)<br>（注：不存在的变量，empty()检测也是为true。）</p></li></ol><h4 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h4><ol><li><p>允许强制转换的有：<br>(int)、(bool)、(float)、(string)、(array)、(object)、(unset)<br>对应函数：intval()、strval()</p></li><li><p>确定变量的类型：<br>gettype()、is_array()、is_bool()、is_float()、is_int()、is_object()、is_string()、is_null()、is_numeric()</p></li><li><p>变量相关函数：<br>empty()、isset()、serialize()、unserialize()、unset()、var_dump()、print_r()、var_export()</p></li></ol><ol start="4"><li>PHP预定义变量：<br>$_GLOBALS<br>$_SERVER<br>$_GET<br>$_POST<br>$_REQUEST<br>$_FILES<br>$_SESSION<br>$_COOKIE<br>$_ENV 环境变量<br>$argc 传递给脚本的参数数目<br>$argv 传递给脚本的参数数组<br>$php_errormsg 前一个错误信息<br>$HTTP_RAW_POST_DATA 原声POST数据<br>$http_response_header HTTP响应头</li></ol><ol start="5"><li><p>魔术常量：<br>__LINE__ 文件中当前行号<br>__FILE__ 文件的完整路径和文件名<br>__DIR__ 文件所在的目录<br>__FUNCTION__ 函数名称（区分大小写）<br>__CLASS__ 类的名称（区分大小写）<br>__TRAIT__ Trait的名字（区分大小写）<br>__METHOD__ 类的方法名（区分大小写）<br>__NAMESPACE__ 当前命名空间的名称（区分大小写）</p></li><li><p>常见函数：<br>get_class()、get_object_vars()、file_exists()、function_exists()<br>call_user_func - 把第一个参数作为回调函数调用<br>func_get_args - 返回一个包含函数参数列表的数组</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;PHP类型：支持9种原始数据类型。&quot;&gt;&lt;a href=&quot;#PHP类型：支持9种原始数据类型。&quot; class=&quot;headerlink&quot; title=&quot;PHP类型：支持9种原始数据类型。&quot;&gt;&lt;/a&gt;PHP类型：支持9种原始数据类型。&lt;/h4&gt;&lt;h5 id=&quot;四种标量类型：&quot;&gt;&lt;a href=&quot;#四种标量类型：&quot; class=&quot;headerlink&quot; title=&quot;四种标量类型：&quot;&gt;&lt;/a&gt;四种标量类型：&lt;/h5&gt;&lt;p&gt; boolean、integer、float(double)、string&lt;/p&gt;
&lt;h5 id=&quot;三种复合类型：&quot;&gt;&lt;a href=&quot;#三种复合类型：&quot; class=&quot;headerlink&quot; title=&quot;三种复合类型：&quot;&gt;&lt;/a&gt;三种复合类型：&lt;/h5&gt;&lt;p&gt; array、object、callable(可调用)&lt;/p&gt;
&lt;h5 id=&quot;两种特殊类型：&quot;&gt;&lt;a href=&quot;#两种特殊类型：&quot; class=&quot;headerlink&quot; title=&quot;两种特殊类型：&quot;&gt;&lt;/a&gt;两种特殊类型：&lt;/h5&gt;&lt;p&gt; resource、NULL(无类型)&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP异常处理机制</title>
    <link href="http://yoursite.com/2019/05/06/PHP%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/06/PHP异常处理机制/</id>
    <published>2019-05-06T12:55:32.000Z</published>
    <updated>2019-05-06T13:04:23.596Z</updated>
    
    <content type="html"><![CDATA[<h4 id="异常与错误的区别"><a href="#异常与错误的区别" class="headerlink" title="异常与错误的区别"></a>异常与错误的区别</h4><p>首先要明白异常跟错误是两个不一样的概念，异常是出现正常逻辑之外的情况，而错误是指运行时出错了，比如，使用了一个未定义的变量等。异常需要抛出（throw）才能被捕捉到，而错误会导致程序执行终止。</p><p>PHP默认情况下，在代码出现了错误，如notice warning等消息时，错误信息会被直接打印到浏览器上，这个时候你通过 try catch是捕获不到错误信息的。php的try catch只能捕获到你自己 throw new Exception(“ “)抛出的错误，通过throw之后，程度会直接进入到catch中继续执行。如果你想抛弃php自身的错误处理机制，这个时候可以通过set_error_handler自定义一个函数用来处理，在这个函数中你可以抛出异常，然后再通过catch捕捉到异常。<br><a id="more"></a></p><h4 id="异常介绍"><a href="#异常介绍" class="headerlink" title="异常介绍"></a>异常介绍</h4><p>  PHP异常一般是指在业务逻辑上出现的不合预期、与正常流程不同的状况，不是语法错误。</p><p>  PHP异常处理机制借鉴了java  c++等，但是PHP的异常处理机制是不健全的。异常处理机制目的是将程序正常执行的代码与出现异常如何处理的代码分离。异常主要有检测（try）、抛出（throw）和捕获（catch）等操作。</p><p>  PHP异常处理中需要注意的有，<strong>当代码中有throw出来的异常，则必须要catch到，也即是一个 try 至少要有一个与之对应的 catch。</strong>可以定义多个 catch 可以捕获不同的对象，php会按这些 catch 被定义的顺序执行，直到完成最后一个为止。而在这些 catch 内，又可以抛出新的异常。php的异常也像JAVA的异常的一样，可以在最外层catch捕捉，也可以在throw的地方捕捉。</p><p>  当一个异常被抛出时，其后的代码将不会继续执行，PHP 会尝试查找匹配的 “catch” 代码块。如果一个异常没有被捕获，而且又没用使用set_exception_handler()作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出未能捕获异常(Uncaught Exception …)的提示信息。</p><p>  PHP是无法自动捕获异常的（绝大多数），只有主动抛出异常并捕捉。也就是说，对于异常，是可预见的。目前PHP能自动抛出的异常不多，如：PDO类。</p><h4 id="异常相关函数（可自定义处理异常函数）"><a href="#异常相关函数（可自定义处理异常函数）" class="headerlink" title="异常相关函数（可自定义处理异常函数）"></a>异常相关函数（可自定义处理异常函数）</h4><ol><li><p>set_exception_handler - 设置一个用户定义的异常处理函数<br>1）callable set_exception_handler(callable $exception_handler)<br>该函数设置默认的异常处理程序，用于没有用 try/catch 块来捕获的异常。在 exception_handler调用后异常会中止。<br>2）如果把自定义的异常封装到一个类上，则可以使用数组的方式调用：<br><code>set_exception_handler(array(&#39;MyExceptionHander&#39;, &#39;deal&#39;));</code></p></li><li><p>register_shutdown_function - 设置一个当执行关闭时可以调用的一个函数<br>当脚本执行完成或意外死掉导致PHP执行即将关闭时，我们的这个函数将会被调用。<br>该函数使用场景：1）页面被强制停止；2）程序代码意外终止或超时。<br>说明：该函数接收一个回调函数作为参数（注意：如果函数里面有写路径一定要写绝对路径，因为执行回调函数时已经脱离了脚本，是从内存中调用该函数）</p></li><li><p>Exception<br>Exception 是系统自带的异常处理类，是所有异常的基类。（这个在PHP7中有变化）</p></li></ol><h4 id="PHP7中的错误和异常"><a href="#PHP7中的错误和异常" class="headerlink" title="PHP7中的错误和异常"></a>PHP7中的错误和异常</h4><p>在 PHP7 之前的 PHP 版本一个很大的痛点就是：发生了 E_ERROR 错误，无法捕获，导致数据库的事务无法回滚造成数据不一致。<br>PHP 7 改变了大多数错误的报告方式。不同于传统（PHP 5）的错误报告机制，现在大多数错误被作为 Error 异常抛出（在 PHP7 中，只有 fatal error 和 recoverable error 抛出异常，其他 error 比如 warning 和 notice 的表现不变）。PHP7 中的 Error 和 Exception 的关系如图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Throwable</span><br><span class="line">    |- Exception implements Throwable</span><br><span class="line">        |- ...</span><br><span class="line">    |- Error implements Throwable</span><br><span class="line">        |- TypeError extends Error</span><br><span class="line">        |- ParseError extends Error</span><br><span class="line">        |- ArithmeticError extends Error</span><br><span class="line">            |- DivisionByZeroError extends ArithmeticError</span><br><span class="line">        |- AssertionError extends Error</span><br></pre></td></tr></table></figure></p><p>值得注意的是，Error 类表现上和 Exception 基本一致，可以像 Exception 异常一样被第一个匹配的 try / catch 块所捕获，如果没有匹配的 catch 块，则调用异常处理函数（事先通过 set_exception_handler() 注册7）进行处理。 如果尚未注册异常处理函数，则按照传统方式处理，被报告为一个致命错误（Fatal Error）。但并非继承自 Exception 类（要考虑到和 PHP5 的兼容性），所以不能用 catch (Exception $e) { … } 来捕获，而需要使用 catch (Error $e) { … }，当然，也可以使用 set_exception_handler 来捕获。</p><p>但是，用户不能自己定义类实现 Throwable，这是为了保证只有 Exception 和 Error 才可以抛出。</p><blockquote><p>注：平常使用想要自定义处理错误的时候，可直接选择继承 Exception就可以。</p></blockquote><h4 id="对错误和异常的一种实践"><a href="#对错误和异常的一种实践" class="headerlink" title="对错误和异常的一种实践"></a>对错误和异常的一种实践</h4><p>根据以上所述，我们提炼了一个对错误和异常处理较好的实践。<br>对于业务中不应该出现错误的地方，抛出 InternalException，而不是 Error<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class InternalException extends Exception &#123; /*...*/ &#125;</span><br><span class="line"></span><br><span class="line">function find(Array $ids) &#123;</span><br><span class="line">  if (empty($ids)) &#123;</span><br><span class="line">    throw new InternalException(&apos;ids should not be empty&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>1. 只在需要清理现场的时候 catch Error</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">try &#123; /*...*/ &#125;</span><br><span class="line">catch (Throwable $t) &#123;</span><br><span class="line">  // log, transaction rollback, cleanup...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>未捕获的 Error 和Exception 通过 set_exception_handler 做后续清理和log</li><li>其他错误仍然通过 set_error_handler来处理，在处理的时候使用更加明确的 FriendlyErrorType，并抛出ErrorException 记录调用栈。</li></ol><p><strong>FriendlyErrorType:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function FriendlyErrorType($type) </span><br><span class="line">&#123; </span><br><span class="line">    switch($type) </span><br><span class="line">    &#123; </span><br><span class="line">        case E_ERROR: // 1 // </span><br><span class="line">            return &apos;E_ERROR&apos;; </span><br><span class="line">        case E_WARNING: // 2 // </span><br><span class="line">            return &apos;E_WARNING&apos;; </span><br><span class="line">        case E_PARSE: // 4 // </span><br><span class="line">            return &apos;E_PARSE&apos;; </span><br><span class="line">        case E_NOTICE: // 8 // </span><br><span class="line">            return &apos;E_NOTICE&apos;; </span><br><span class="line">        case E_CORE_ERROR: // 16 // </span><br><span class="line">            return &apos;E_CORE_ERROR&apos;; </span><br><span class="line">        case E_CORE_WARNING: // 32 // </span><br><span class="line">            return &apos;E_CORE_WARNING&apos;; </span><br><span class="line">        case E_COMPILE_ERROR: // 64 // </span><br><span class="line">            return &apos;E_COMPILE_ERROR&apos;; </span><br><span class="line">        case E_COMPILE_WARNING: // 128 // </span><br><span class="line">            return &apos;E_COMPILE_WARNING&apos;; </span><br><span class="line">        case E_USER_ERROR: // 256 // </span><br><span class="line">            return &apos;E_USER_ERROR&apos;; </span><br><span class="line">        case E_USER_WARNING: // 512 // </span><br><span class="line">            return &apos;E_USER_WARNING&apos;; </span><br><span class="line">        case E_USER_NOTICE: // 1024 // </span><br><span class="line">            return &apos;E_USER_NOTICE&apos;; </span><br><span class="line">        case E_STRICT: // 2048 // </span><br><span class="line">            return &apos;E_STRICT&apos;; </span><br><span class="line">        case E_RECOVERABLE_ERROR: // 4096 // </span><br><span class="line">            return &apos;E_RECOVERABLE_ERROR&apos;; </span><br><span class="line">        case E_DEPRECATED: // 8192 // </span><br><span class="line">            return &apos;E_DEPRECATED&apos;; </span><br><span class="line">        case E_USER_DEPRECATED: // 16384 // </span><br><span class="line">            return &apos;E_USER_DEPRECATED&apos;; </span><br><span class="line">    &#125; </span><br><span class="line">    return &quot;&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>error_handler:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function exception_error_handler($severity, $message, $file, $line) &#123;</span><br><span class="line">    if (!(error_reporting() &amp; $severity)) &#123;</span><br><span class="line">        // This error code is not included in error_reporting</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> log FriendlyErrorType($severity);</span><br><span class="line">    throw new ErrorException($message, 0, $severity, $file, $line);</span><br><span class="line">&#125;</span><br><span class="line">set_error_handler(&quot;exception_error_handler&quot;);</span><br></pre></td></tr></table></figure></p><p><strong>总结：</strong><br>要注意，PHP中异常与错误是有区别的，并且处理机制也都是不一样的。因此，要区别对待。</p><p>参考博文：</p><ol><li><a href="https://www.jianshu.com/p/fd3683407993" target="_blank" rel="noopener">PHP异常处理机制</a></li><li><a href="https://juejin.im/entry/5987d2ff6fb9a03c314fe732" target="_blank" rel="noopener">PHP的错误和异常处理机制</a></li><li><a href="http://www.laruence.com/2012/02/02/2515.html" target="_blank" rel="noopener">我们什么时候应该使用异常？</a></li><li><a href="http://www.laruence.com/2010/08/03/1697.html" target="_blank" rel="noopener">深入理解PHP原理之异常机制</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;异常与错误的区别&quot;&gt;&lt;a href=&quot;#异常与错误的区别&quot; class=&quot;headerlink&quot; title=&quot;异常与错误的区别&quot;&gt;&lt;/a&gt;异常与错误的区别&lt;/h4&gt;&lt;p&gt;首先要明白异常跟错误是两个不一样的概念，异常是出现正常逻辑之外的情况，而错误是指运行时出错了，比如，使用了一个未定义的变量等。异常需要抛出（throw）才能被捕捉到，而错误会导致程序执行终止。&lt;/p&gt;
&lt;p&gt;PHP默认情况下，在代码出现了错误，如notice warning等消息时，错误信息会被直接打印到浏览器上，这个时候你通过 try catch是捕获不到错误信息的。php的try catch只能捕获到你自己 throw new Exception(“ “)抛出的错误，通过throw之后，程度会直接进入到catch中继续执行。如果你想抛弃php自身的错误处理机制，这个时候可以通过set_error_handler自定义一个函数用来处理，在这个函数中你可以抛出异常，然后再通过catch捕捉到异常。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP错误处理机制</title>
    <link href="http://yoursite.com/2019/05/06/PHP%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/06/PHP错误处理机制/</id>
    <published>2019-05-06T12:51:44.000Z</published>
    <updated>2019-05-07T01:52:59.472Z</updated>
    
    <content type="html"><![CDATA[<h4 id="错误简介"><a href="#错误简介" class="headerlink" title="错误简介"></a>错误简介</h4><p>  PHP提供了错误处理和日志记录的功能. 这些函数允许你定义自己的错误处理规则，以及修改错误记录的方式. 这样，你就可以根据自己的需要，来更改和加强错误输出信息以满足实际需要。<br>  常见的错误类型有：语法错误、环境错误、逻辑错误。平时遇到的warning、notice都是错误，只是级别不同而已。<br>  常见的错误级别有：Deprecated（最低级别）、Notice（通知）、Warning（警告）、Fatal（致命）、Parser（语法解析），E_USER_相关错误。</p><blockquote><p>注：在 PHP 中，默认的错误处理很简单。一条错误消息会被发送到浏览器，这条消息带有文件名、行号以及描述错误的消息。</p></blockquote><a id="more"></a><h4 id="错误处理函数（可自定义处理错误函数）"><a href="#错误处理函数（可自定义处理错误函数）" class="headerlink" title="错误处理函数（可自定义处理错误函数）"></a>错误处理函数（可自定义处理错误函数）</h4><ol><li><p>error_reporting  设置PHP的报错级别<br>1）通过php.ini设置如下： error_reporting = E_ALL<br>2）通过error_reporting()函数设置，如：<br>error_reporting(0); //关闭所有PHP错误报告<br>error_reporting(-1); //报告所有PHP错误<br>error_reporting(E_ALL); //和error_reporting(-1)一样<br>3）通过ini_set()函数运行时设置<br><code>ini_set(&#39;error_reporting&#39;, E_ALL)</code>;</p></li><li><p>display_errors 设置是否将错误信息<br>1）在php.ini设置如下：display_errors = On<br>（注：不管是On还是Off都会记录到你错误日志里面，前提是配置了错误日志log_errors和error_log）<br>2）通过<code>ini_set(&#39;display_errors&#39;, 1);</code> 设置运行时状态</p></li><li><p>set_error_handler  设置一个用户定义的错误处理函数<br>1）<code>set_error_handler(&#39;my_error&#39;);</code> //my_error()函数为自定义的错误处理方法<br>2）如果把自定义的错误封装到一个类上，则使用数组的方式调用：<br><code>set_error_handler(array(&#39;MyErrorHander&#39;, &#39;deal&#39;));</code> //MyErrorHander为错误类，deal为处理方法<br>3）set_error_handler() 参数介绍如下：<br><img src="/uploads/2019/05/set_error_handler.png" alt="" title="set_error_handler"></p></li></ol><blockquote><p>注：(1)以下级别的错误不能由用户定义的函数来处理： E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、E_COMPILE_WARNING，和在调用 set_error_handler() 函数所在文件中产生的大多数 E_STRICT。 官方没有给出原因，但不难看出这些错误要么是运行时的致命错误，要么是php核心或编译时的错误，因此也不难猜想：对于运行时的致命错误，php直接中断，导致了错误处理函数没有机会执行。<br>(2)如果错误发生在脚本执行之前（比如文件上传时），将不会调用自定义的错误处理程序，因为它尚未在那时注册。</p></blockquote><ol start="4"><li><p>trigger_error()  产生一个用户级别的 error/warning/notice 信息</p></li><li><p>error_log —发送错误信息到某个地方<br>1）在配置文件中： error_log = E:\phpStudy\MyError\test_error.txt<br>2）运行时设置：<code>int_set(&#39;error_log&#39;, &#39;E:\phpStudy\MyError\test_error.txt&#39;)</code>;<br>3）使用error_log函数：<code>error_log(&quot;You messed up!&quot;, 3, &quot;./error/my-errors.log&quot;)</code>;</p></li><li><p>error_get_last()  获取最后发生的错误<br>返回一个关联数组，描述了最后错误的信息，以该错误的“type”、“message”、“file”和“line”为数组的键。 如果该错误由PHP内置函数导致的，“message”会以该函数名开头。如果还没有错误则返回NULL。</p></li></ol><h4 id="错误控制配置"><a href="#错误控制配置" class="headerlink" title="错误控制配置"></a>错误控制配置</h4><p>我们按照php+php-fpm的模型来说，会影响php错误显示的其实是有两个配置文件，一个是php本身的配置文件php.ini，另外一个是php-fpm的配置文件，php-fpm.conf。</p><h5 id="1）php-ini中的配置"><a href="#1）php-ini中的配置" class="headerlink" title="1）php.ini中的配置"></a>1）php.ini中的配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error_reporting = E_ALL  // 报告错误级别，什么级别的</span><br><span class="line">error_log = /tmp/php_errors.log // php中的错误显示的日志位置</span><br><span class="line">display_errors = On // 是否把错误展示在输出上，这个输出可能是页面，也可能是stdout</span><br><span class="line">display_startup_errors = On // 是否把启动过程的错误信息显示在页面上，记得上面说的有几个Core类型的错误是启动时候发生的，这个就是控制这些错误是否显示页面的。</span><br><span class="line">log_errors = On // 是否要记录错误日志</span><br><span class="line">log_errors_max_len = 1024 // 错误日志的最大长度</span><br><span class="line">ignore_repeated_errors = Off // 是否忽略重复的错误</span><br><span class="line">track_errors = Off // 是否使用全局变量$php_errormsg来记录最后一个错误</span><br><span class="line">xmlrpc_errors = 0 //是否使用XML-RPC的错误信息格式记录错误</span><br><span class="line">xmlrpc_error_number = 0 // 用作 XML-RPC faultCode 元素的值。</span><br><span class="line">html_errors = On  // 是否把输出中的函数等信息变为HTML链接</span><br><span class="line">docref_root = http://manual/en/ // 如果html_errors开启了，这个链接的根路径是什么</span><br><span class="line">fastcgi.logging = 0 // 是否把php错误抛出到fastcgi中</span><br></pre></td></tr></table></figure><h5 id="2）php-fpm中的配置"><a href="#2）php-fpm中的配置" class="headerlink" title="2）php-fpm中的配置"></a>2）php-fpm中的配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error_log = /var/log/php-fpm/error.log // php-fpm自身的日志</span><br><span class="line">log_level = notice // php-fpm自身的日志记录级别</span><br><span class="line">php_flag[display_errors] = off // 覆盖php.ini中的某个配置变量，可被程序中的ini_set覆盖</span><br><span class="line">php_value[display_errors] = off // 同php_flag</span><br><span class="line">php_admin_value[error_log] = /tmp/www-error.log // 覆盖php.ini中的某个配置变量，不可被程序中的ini_set覆盖</span><br><span class="line">php_admin_flag[log_errors] = on // 同php_admin_value</span><br><span class="line">catch_workers_output = yes // 是否抓取fpmworker的输出</span><br><span class="line">request_slowlog_timeout = 0 // 慢日志时长</span><br><span class="line">slowlog = /var/log/php-fpm/www-slow.log // 慢日志记录</span><br></pre></td></tr></table></figure><p>php-fpm的配置中也有一个error_log配置，这个很经常会和php.ini中的error_log配置弄混。但他们记录的东西是不一样的，php-fpm的error_log只记录php-fpm本身的日志，比如fpm启动，关闭。<br>而php.ini中的error_log是记录php程序本身的错误日志。</p><p>那么在php-fpm中要覆盖php.ini中的error_log配置，就需要使用到下面几个函数：</p><ul><li>php_flag</li><li>php_value</li><li>php_admin_flag</li><li>php_admin_value<br>这四个函数admin的两个函数说明这个变量设置完之后，不能在代码中使用ini_set把这个变量重新赋值了。而php_flag/value就仍然以php代码中的ini_set为准</li></ul><h4 id="错误处理应该遵循的规则"><a href="#错误处理应该遵循的规则" class="headerlink" title="错误处理应该遵循的规则"></a>错误处理应该遵循的规则</h4><ul><li>一定要让PHP报告错误；</li><li>在开发环境中要显示错误；</li><li>在生产环境中不能显示错误；</li><li>在开发和生产环境中都要记录错误。</li></ul><p>参考博文：</p><ol><li><a href="http://www.cnblogs.com/yjf512/p/5314345.html" target="_blank" rel="noopener">PHP错误机制总结</a></li><li><a href="https://www.jianshu.com/p/8752a7339022" target="_blank" rel="noopener">PHP错误处理机制</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;错误简介&quot;&gt;&lt;a href=&quot;#错误简介&quot; class=&quot;headerlink&quot; title=&quot;错误简介&quot;&gt;&lt;/a&gt;错误简介&lt;/h4&gt;&lt;p&gt;  PHP提供了错误处理和日志记录的功能. 这些函数允许你定义自己的错误处理规则，以及修改错误记录的方式. 这样，你就可以根据自己的需要，来更改和加强错误输出信息以满足实际需要。&lt;br&gt;  常见的错误类型有：语法错误、环境错误、逻辑错误。平时遇到的warning、notice都是错误，只是级别不同而已。&lt;br&gt;  常见的错误级别有：Deprecated（最低级别）、Notice（通知）、Warning（警告）、Fatal（致命）、Parser（语法解析），E_USER_相关错误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：在 PHP 中，默认的错误处理很简单。一条错误消息会被发送到浏览器，这条消息带有文件名、行号以及描述错误的消息。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用docker-compose.yml管理LNMP环境</title>
    <link href="http://yoursite.com/2019/01/22/Docker%E4%BD%BF%E7%94%A8docker-compose-yml%E7%AE%A1%E7%90%86LNMP%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2019/01/22/Docker使用docker-compose-yml管理LNMP环境/</id>
    <published>2019-01-22T10:47:03.000Z</published>
    <updated>2019-01-22T11:11:23.887Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、生成必备的镜像文件-php版本"><a href="#一、生成必备的镜像文件-php版本" class="headerlink" title="一、生成必备的镜像文件 - php版本"></a>一、生成必备的镜像文件 - php版本</h4><p>说明：由于官方的镜像文件不满足实际使用需求，因此需要自定义Dockerfile文件来配置PHP。<br><a id="more"></a></p><h5 id="1、基于php5-6-40镜像版本"><a href="#1、基于php5-6-40镜像版本" class="headerlink" title="1、基于php5.6.40镜像版本"></a>1、基于php5.6.40镜像版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ROM php:5.6-fpm</span><br><span class="line">ENV PHPREDIS_VERSION 3.0.0</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">        libfreetype6-dev \</span><br><span class="line">        libjpeg62-turbo-dev \</span><br><span class="line">        libmcrypt-dev \</span><br><span class="line">        libpng-dev \</span><br><span class="line">    &amp;&amp; docker-php-ext-install iconv mcrypt \</span><br><span class="line">    &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \</span><br><span class="line">    &amp;&amp; docker-php-ext-install gd pdo pdo_mysql mysqli opcache</span><br><span class="line"></span><br><span class="line"># 安装memcached</span><br><span class="line">RUN apt-get update \</span><br><span class="line">        # 手动安装依赖</span><br><span class="line">        &amp;&amp; apt-get install -y libmemcached-dev zlib1g-dev \</span><br><span class="line">    # 安装需要的扩展</span><br><span class="line">    &amp;&amp; pecl install memcached-2.2.0 \</span><br><span class="line">    # 启用扩展</span><br><span class="line">    &amp;&amp; docker-php-ext-enable memcached</span><br><span class="line"></span><br><span class="line"># 安装memcache</span><br><span class="line">RUN pecl install memcache-2.2.7 \</span><br><span class="line">    &amp;&amp; docker-php-ext-enable memcache</span><br><span class="line"></span><br><span class="line"># 安装redis</span><br><span class="line">RUN pecl install -o -f redis \</span><br><span class="line">    &amp;&amp; rm -rf /tmp/pear \</span><br><span class="line">    &amp;&amp; docker-php-ext-enable redis</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/local/</span><br><span class="line">CMD [&quot;./sbin/php-fpm&quot;, &quot;-c&quot;, &quot;/usr/local/etc/php-fpm.conf&quot;]</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ul><li>（1）安装扩展<br>由于php的pecl支持安装memcached、memcache、redis扩展，则使用pecl安装即可。<br>注：要使用docker命令 <code>docker-php-ext-enable</code> 来开启扩展。</li></ul><h5 id="2、基于php7-2-14镜像版本"><a href="#2、基于php7-2-14镜像版本" class="headerlink" title="2、基于php7.2.14镜像版本"></a>2、基于php7.2.14镜像版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">FROM php:7.2.14-fpm</span><br><span class="line">ENV PHPREDIS_VERSION 3.0.0</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">        libfreetype6-dev \</span><br><span class="line">        libjpeg62-turbo-dev \</span><br><span class="line">        libpng-dev \</span><br><span class="line">    &amp;&amp; docker-php-ext-install iconv \</span><br><span class="line">    &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \</span><br><span class="line">    &amp;&amp; docker-php-ext-install gd pdo pdo_mysql mysqli opcache</span><br><span class="line"></span><br><span class="line"># 拷贝php.ini文件</span><br><span class="line">RUN cp /usr/local/etc/php/php.ini-development /usr/local/etc/php/php.ini</span><br><span class="line"></span><br><span class="line"># 注：php7不支持pecl安装memcached memcache</span><br><span class="line"># 安装memcached</span><br><span class="line">RUN apt-get install -y libmemcached-dev</span><br><span class="line">COPY ./memcached /tmp/memcached</span><br><span class="line">RUN cd /tmp/memcached &amp;&amp; /usr/local/bin/phpize \</span><br><span class="line">    &amp;&amp; ./configure -with-php-config=/usr/local/bin/php-config \</span><br><span class="line">    &amp;&amp; make \</span><br><span class="line">    &amp;&amp; make install</span><br><span class="line">RUN docker-php-ext-enable memcached</span><br><span class="line"></span><br><span class="line"># 安装memcache</span><br><span class="line">COPY ./memcache /tmp/memcache</span><br><span class="line">RUN cd /tmp/memcache &amp;&amp; /usr/local/bin/phpize \</span><br><span class="line">    &amp;&amp; ./configure -with-php-config=/usr/local/bin/php-config \</span><br><span class="line">    &amp;&amp; make \</span><br><span class="line">    &amp;&amp; make install</span><br><span class="line">RUN docker-php-ext-enable memcache</span><br><span class="line"></span><br><span class="line"># 安装redis</span><br><span class="line">RUN pecl install -o -f redis \</span><br><span class="line">    &amp;&amp; rm -rf /tmp/pear \</span><br><span class="line">    &amp;&amp; docker-php-ext-enable redis</span><br><span class="line"></span><br><span class="line"># 清空脏数据</span><br><span class="line">RUN rm -rf /tmp/*</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/local/</span><br><span class="line">CMD [&quot;./sbin/php-fpm&quot;, &quot;-c&quot;, &quot;/usr/local/etc/php-fpm.conf&quot;]</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ul><li><p>（1）安装memcache扩展<br>php7不支持pecl安装memcached 和memcache扩展，因此只能使用源码安装，所以要下载源码，地址如下：<br>Memcached:  git clone <a href="https://github.com/php-memcached-dev/php-memcached" target="_blank" rel="noopener">https://github.com/php-memcached-dev/php-memcached</a> memcached<br>Memcache: git clone <a href="https://github.com/websupport-sk/pecl-memcache" target="_blank" rel="noopener">https://github.com/websupport-sk/pecl-memcache</a> memcache</p></li><li><p>（2）安装memcache后，开启扩展时<br>不要使用下面命令把扩展添加到php.ini文件，因为镜像中设置的<code>--with-config-file-path</code>参数找不到php.ini。<br><code>RUN echo extension=memcached.so &gt;&gt; /usr/local/etc/php/php.ini</code><br>因此，要用<code>docker-php-ext-enable</code>命令来开启扩展。</p></li><li><p>（3）清空脏数据时<br>不要使用<code>rm -rf /tmp/</code>命令，该命令会删除tmp文件。导致docker构建错误：<code>Fatal Error Unable to create lock file: Bad file descriptor (9)</code></p></li></ul><h5 id="3、构建镜像文件"><a href="#3、构建镜像文件" class="headerlink" title="3、构建镜像文件"></a>3、构建镜像文件</h5><ul><li><p>（1）PHP<br>基于上面书写的Dockerfile文件来构建镜像文件：<br><code>docker build -t lnmp/php5.6:redis-memcache-001 .</code></p></li><li><p>（2）Nginx、mysql<br>使用官方镜像即可，此处不用构建！下面会贴出对应的版本。</p></li></ul><h4 id="二、使用docker-compose-yml管理镜像"><a href="#二、使用docker-compose-yml管理镜像" class="headerlink" title="二、使用docker-compose.yml管理镜像"></a>二、使用docker-compose.yml管理镜像</h4><h5 id="1、docker-compose-yml文件"><a href="#1、docker-compose-yml文件" class="headerlink" title="1、docker-compose.yml文件"></a>1、docker-compose.yml文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">    php-fpm7:</span><br><span class="line">        container_name: php-fpm7</span><br><span class="line">        image: &quot;lnmp/php7.2:redis-memcache-001&quot;</span><br><span class="line">        expose:</span><br><span class="line">            - &quot;9000&quot;</span><br><span class="line">        volumes:</span><br><span class="line">            - /Users/zhengbenwu/Docker/wwwroot/:/usr/share/nginx/html</span><br><span class="line">        networks:</span><br><span class="line">            - lnmp</span><br><span class="line"></span><br><span class="line">    php-fpm5:</span><br><span class="line">        container_name: php-fpm5</span><br><span class="line">        image: &quot;lnmp/php5.6:redis-memcache-001&quot;</span><br><span class="line">        depends_on:</span><br><span class="line">            - mysql</span><br><span class="line">        expose:</span><br><span class="line">            - &quot;9000&quot;</span><br><span class="line">        volumes:</span><br><span class="line">            - /Users/zhengbenwu/Docker/wwwroot/:/usr/share/nginx/html</span><br><span class="line">        networks:</span><br><span class="line">            - lnmp</span><br><span class="line"></span><br><span class="line">    nginx:</span><br><span class="line">        container_name: nginx</span><br><span class="line">        image: &quot;nginx:1.14.2&quot;</span><br><span class="line">        depends_on:</span><br><span class="line">            - php-fpm5</span><br><span class="line">        links:</span><br><span class="line">            - php-fpm5:fpm5</span><br><span class="line">            - php-fpm7:fpm7</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;80:80&quot;</span><br><span class="line">        volumes:</span><br><span class="line">            - /Users/zhengbenwu/Docker/nginx/nginx.conf:/etc/nginx/nginx.conf</span><br><span class="line">            - /Users/zhengbenwu/Docker/nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">            - /Users/zhengbenwu/Docker/nginx/logs:/var/log/nginx</span><br><span class="line">            - /Users/zhengbenwu/Docker/wwwroot/:/usr/share/nginx/html</span><br><span class="line">        networks:</span><br><span class="line">            - lnmp</span><br><span class="line"></span><br><span class="line">    mysql:</span><br><span class="line">        container_name: mysql</span><br><span class="line">        image: mysql:5.7</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;3306:3306&quot;</span><br><span class="line">        environment:</span><br><span class="line">            - MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">        volumes:</span><br><span class="line">            - /Users/zhengbenwu/Docker/mysql/data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">    lnmp:</span><br><span class="line">        driver: bridge</span><br></pre></td></tr></table></figure><h4 id="附常用命令："><a href="#附常用命令：" class="headerlink" title="附常用命令："></a>附常用命令：</h4><h5 id="1、docker-compose"><a href="#1、docker-compose" class="headerlink" title="1、docker-compose"></a>1、docker-compose</h5><p>注： <code>-f docker-compose.yml</code> 参数可省略，若省略默认找docker-compose.yml文件，找不到会报错。且此参数必须紧跟docker-compse后面<br>开启/关闭：<code>docker-compose [-f docker-compose.yml] start/stop</code><br>删除镜像：<code>docker-compose rm</code><br>构建并开启：<code>docker-compose up -d</code> （注：<code>-d</code>参数表示后台执行）</p><h5 id="2、docker"><a href="#2、docker" class="headerlink" title="2、docker"></a>2、docker</h5><p>注：下面说明的<code>container_id</code>或<code>image_id</code> 可相应的使用<code>container_name</code>或<code>image_name</code><br>查看docker详细安装信息：<code>docker info</code><br>查看镜像文件：<code>docker images</code><br>查看容器：<code>docker ps [-a] （注：添加-a表示查看所有）</code><br>查看镜像或容器详细信息：<code>docker inspect container_id/image_id</code><br>进入容器：<code>docker exec -it container_id /bin/bash</code><br>容器关闭/开启：<code>docker stop/start container_id</code><br>删除容器：<code>docker rm container_id</code><br>删除镜像：<code>docker rmi image_id</code><br>构建镜像（Dockerfile）：<code>docker build -t image_name . （注：“.” 表示使用当前目录的Dockerfile）</code><br>生成容器：<code>docker run -itd - -name container_name - -v $PWD/data:/var/data -p 8888:8888 image_id</code><br>查看构建容器日志：<code>docker logs container_id</code></p><h4 id="错误记录："><a href="#错误记录：" class="headerlink" title="错误记录："></a>错误记录：</h4><p>1、Error response from daemon: configured logging driver does not support reading<br>参考文章：<a href="https://docs.docker.com/config/containers/logging/configure/" target="_blank" rel="noopener">https://docs.docker.com/config/containers/logging/configure/</a><br>解决方法：<br>在生成容器的时候多加一个参数：<br><code>docker run -itd --log-driver json-file --name container_name image_id</code><br>注： <code>--log-driver</code>参数含义是指定日志驱动。 报错显示守护进程配置日志不支持，通过<code>docker inspect container_id</code>可查看到容器的 LoggingDriver 参数为null。因此需要指定一个日志驱动即可。</p><p><strong>参考博客：</strong><br>使用docker创建集成服务-lnmp：<a href="https://www.cnblogs.com/s-b-b/p/8624491.html" target="_blank" rel="noopener">https://www.cnblogs.com/s-b-b/p/8624491.html</a><br>Dockerfile构建LNMP平台：<a href="http://blog.51cto.com/ganbing/2074640" target="_blank" rel="noopener">http://blog.51cto.com/ganbing/2074640</a><br>秒懂Docker中安装扩展PHP：<a href="https://blog.csdn.net/u014389734/article/details/79683136" target="_blank" rel="noopener">https://blog.csdn.net/u014389734/article/details/79683136</a><br>Dockerfile文件中添加redis扩展：<a href="https://blog.csdn.net/xiaobinqt/article/details/83105807" target="_blank" rel="noopener">https://blog.csdn.net/xiaobinqt/article/details/83105807</a><br>PHP7下安装memcache和memcached扩展：<a href="https://blog.csdn.net/u011547570/article/details/78325556" target="_blank" rel="noopener">https://blog.csdn.net/u011547570/article/details/78325556</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、生成必备的镜像文件-php版本&quot;&gt;&lt;a href=&quot;#一、生成必备的镜像文件-php版本&quot; class=&quot;headerlink&quot; title=&quot;一、生成必备的镜像文件 - php版本&quot;&gt;&lt;/a&gt;一、生成必备的镜像文件 - php版本&lt;/h4&gt;&lt;p&gt;说明：由于官方的镜像文件不满足实际使用需求，因此需要自定义Dockerfile文件来配置PHP。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Docker实战" scheme="http://yoursite.com/tags/Docker%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>PhpStorm中添加自定义函数注释</title>
    <link href="http://yoursite.com/2019/01/08/PhpStorm%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%B3%A8%E9%87%8A/"/>
    <id>http://yoursite.com/2019/01/08/PhpStorm中添加自定义函数注释/</id>
    <published>2019-01-08T08:29:19.000Z</published>
    <updated>2019-01-08T08:30:58.717Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看更多<br><a id="more"></a></p><h4 id="一、创建模板"><a href="#一、创建模板" class="headerlink" title="一、创建模板"></a>一、创建模板</h4><p>1、首先我们要添加自己的一套模板，点击 file-&gt;settings-&gt;editor-&gt;live Templates<br><img src="/uploads/2019/01/phpstorm_editor_01.png" alt=""></p><p>2、点击右侧加号，选择第二个选项“template group”，创建一个分组。（注：不需要分组，可跳过此步）<br><img src="/uploads/2019/01/phpstorm_editor_02.png" alt=""></p><p>3、选中刚才添加的分组，点击右侧加号，选择第一个选项“live template”添加一个具体模板。<br><img src="/uploads/2019/01/phpstorm_editor_03.png" alt=""></p><p>4、按照图中步骤：其中第四步不一定要改，可以根据个人习惯，我习惯用enter键。<br><img src="/uploads/2019/01/phpstorm_editor_04.png" alt=""></p><p>5、这是第五步点击内容，分别对DATE, TIME标签做设置。<br><img src="/uploads/2019/01/phpstorm_editor_05.png" alt=""></p><p>设置完后点击”Apply”。</p><h4 id="二、使用模板"><a href="#二、使用模板" class="headerlink" title="二、使用模板"></a>二、使用模板</h4><p>上面是设置要用的标签模板，下面是如何来使用它：<br>点击“file and code templates-&gt;includes-&gt;PHP Function Doc Comment”，在里面输入自己想要的注释内容，注意Times对应添加的模板名称。<br><img src="/uploads/2019/01/phpstorm_editor_06.png" alt=""></p><p>之后点击”apply”。</p><h4 id="三、测试使用"><a href="#三、测试使用" class="headerlink" title="三、测试使用"></a>三、测试使用</h4><p>在项目中使用<br>输入”/**”后点击enter键，会出现刚才添加的注释，再次点击enter键，会自动出现系统时间。<br>注意：如果刚才第四步没有设置”enter”，要点击tab键，默认是tab键。<br><img src="/uploads/2019/01/phpstorm_editor_07.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看更多&lt;br&gt;
    
    </summary>
    
      <category term="编辑器" scheme="http://yoursite.com/categories/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>PHP错误日志简单配置</title>
    <link href="http://yoursite.com/2019/01/08/PHP%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/01/08/PHP错误日志简单配置/</id>
    <published>2019-01-08T08:23:42.000Z</published>
    <updated>2019-01-08T08:25:13.061Z</updated>
    
    <content type="html"><![CDATA[<p>php.ini<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; 错误日志</span><br><span class="line">log_errors = On</span><br><span class="line">; 显示错误</span><br><span class="line">display_errors = Off</span><br><span class="line">; 日志路径</span><br><span class="line">error_log = &quot;/usr/local/lnmp/php/var/log/error_log&quot;</span><br><span class="line">; 错误等级</span><br><span class="line">error_reporting = E_ALL&amp;~E_NOTICE</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>php-fpm.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">; php-fpm pid文件</span><br><span class="line">pid = /usr/local/php/var/run/php-fpm.pid</span><br><span class="line">; php-fpm 错误日志路径</span><br><span class="line">error_log = /usr/local/php/var/log/php-fpm.log</span><br><span class="line">; php-fpm 记录错误日志等级</span><br><span class="line">log_level = notice</span><br><span class="line">[www]</span><br><span class="line">; 记录错误到php-fpm的日志中</span><br><span class="line">;catch_workers_output = yes</span><br><span class="line">; 慢日志</span><br><span class="line">slowlog = var/log/slow.log</span><br><span class="line">; 关闭打印日志</span><br><span class="line">php_flag[display_errors] = off</span><br><span class="line">; 错误日志</span><br><span class="line">php_admin_value[error_log] = /usr/local/php/var/log/www.log</span><br><span class="line">; 记录错误</span><br><span class="line">php_admin_flag[log_errors] = on</span><br><span class="line">; 内存使用量</span><br><span class="line">php_admin_value[memory_limit] = 32M</span><br></pre></td></tr></table></figure></p><p>注：如果错误没有写入到文件，查看网站用户对<code>php_admin_value[error_log]</code>的路径是否有写入权限。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;php.ini&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;; 错误日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log_errors = On&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;; 显示错误&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;display_errors = Off&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;; 日志路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;error_log = &amp;quot;/usr/local/lnmp/php/var/log/error_log&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;; 错误等级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;error_reporting = E_ALL&amp;amp;~E_NOTICE&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>图解TCP连接及对TIME_WAIT的理解</title>
    <link href="http://yoursite.com/2018/12/19/%E5%9B%BE%E8%A7%A3TCP%E8%BF%9E%E6%8E%A5%E5%8F%8A%E5%AF%B9TIME-WAIT%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/19/图解TCP连接及对TIME-WAIT的理解/</id>
    <published>2018-12-19T11:14:58.000Z</published>
    <updated>2019-01-08T08:05:31.231Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h4><p>访问路径：<a href="http://118.24.8.229/index.html" target="_blank" rel="noopener">http://118.24.8.229/index.html</a><br>index.html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.zhengbenwu.com</span><br><span class="line">&lt;img src=&quot;./apple.jpg&quot; /&gt;</span><br><span class="line">&lt;img src=&quot;./ceshi.webp&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>监控工具：Wireshark<br>监控筛选条件：<code>ip.addr == 118.24.8.229 &amp;&amp; tcp.port == 80</code><br><a id="more"></a></p><h4 id="监控说明："><a href="#监控说明：" class="headerlink" title="监控说明："></a>监控说明：</h4><h5 id="（1）建立连接"><a href="#（1）建立连接" class="headerlink" title="（1）建立连接"></a>（1）建立连接</h5><p><img src="/uploads/2018/12/network_tcp_wireshark_01.png" alt=""><br>客户端开启了3个连接请求，相应的客户端也会占用3个端口：59746、59747、59748。通过三次握手建立连接，图示连接建立过程很清晰。</p><p>客户端监控端口：<br><img src="/uploads/2018/12/network_tcp_client_01.png" alt=""></p><p>服务端监控端口：<br><img src="/uploads/2018/12/network_tcp_server_01.png" alt=""></p><h5 id="（2）传输数据"><a href="#（2）传输数据" class="headerlink" title="（2）传输数据"></a>（2）传输数据</h5><p>index.html 文件传输：通过59747端口传输<br><img src="/uploads/2018/12/network_tcp_file_01.png" alt=""></p><p>apple.jpg 文件传输：通过59747端口传输<br><img src="/uploads/2018/12/network_tcp_file_02.png" alt=""></p><p>ceshi.webp 文件传输：通过59748端口传输<br><img src="/uploads/2018/12/network_tcp_file_03.png" alt=""></p><h5 id="（3）断开连接"><a href="#（3）断开连接" class="headerlink" title="（3）断开连接"></a>（3）断开连接</h5><p><img src="/uploads/2018/12/network_tcp_unconnect.png" alt=""><br>① 59746端口连接<br>由图示可以看出，首先断开的是59746端口的连接，且是客户端主动断开连接。因此，客户端会产生TIME_WAIT。<br><img src="/uploads/2018/12/network_tcp_client_02.png" alt=""><br><img src="/uploads/2018/12/network_tcp_server_02.png" alt=""></p><blockquote><p>要注意的是，在此URL请求里，客户端建立的59746端口连接并没有用到；并且，很快就被断开了，并没有保持持久连接检测。</p></blockquote><p>② 59747、59748端口连接<br>由上图示可以看出来，这两个端口是服务端主动断开连接的。中间客户端发送了 Keep-Alive保持连接，之后服务端在keepalive_timeout到时间后，自动断开了连接。因此，服务端会产生TIME_WAIT。<br><img src="/uploads/2018/12/network_tcp_client_03.png" alt=""><br><img src="/uploads/2018/12/network_tcp_server_03.png" alt=""></p><blockquote><p>由此可知道，网站如果量比较大的话，尽量不要使用长连接，会产生大量的TIME_WAIT，导致网站瘫痪。<br>量大的话，服务器可采用降配横向扩展，多部署几台服务器，提高端口数量，降低TIME_WAIT。</p></blockquote><h4 id="问题思考："><a href="#问题思考：" class="headerlink" title="问题思考："></a>问题思考：</h4><h5 id="长连接中TCP是如何请求的？"><a href="#长连接中TCP是如何请求的？" class="headerlink" title="长连接中TCP是如何请求的？"></a>长连接中TCP是如何请求的？</h5><p>实验一：客户端请求连接中，有多个额外请求时，TCP使用是怎么样的？<br>服务端程序改成：<br>（1）1个html和1个图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.zhengbenwu.com</span><br><span class="line">&lt;img src=&quot;./apple.jpg&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>结论：<br>客户端仍然会产生3个TCP连接，并且由于html的数据量少，导致服务端只使用了一个TCP连接就传输了html页面和图片数据。客户端产生2个TIME_WAIT，服务端产生1个TIME_WAIT。</p><p>（2）1个html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.zhengbenwu.com</span><br></pre></td></tr></table></figure></p><p>结论：<br>客户端仍然会产生3个TCP连接，传输数据的TCP连接会保持持久连接，其余未传输数据的客户端会主动断开连接，不检测持久连接。客户端产生2个TIME_WAIT，服务端产生1个TIME_WAIT。<br><img src="/uploads/2018/12/network_tcp_wireshark_02.png" alt=""></p><p>（3）1个html和4个图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">www.zhengbenwu.com</span><br><span class="line">&lt;img src=&quot;./apple.jpg&quot; /&gt;</span><br><span class="line">&lt;img src=&quot;./ceshi.webp&quot; /&gt;</span><br><span class="line">&lt;img src=&quot;./timg.jpg&quot; /&gt;</span><br><span class="line">&lt;img src=&quot;./test001.jpg&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>结论：<br>客户端初始仍会产生3个TCP连接，首先建立连接的TCP会先传输html数据，当传输完成后，会自动的继续传输前3个图片，当发现3个TCP连接都用完后，仍有一个图片未传输，客户端会再新建一个TCP连接，用于传输第四个图片。 此时，TCP连接建立了4个，且都会检测是否保持持久连接，因此最后服务端会产生4个TIME_WAIT。<br><img src="/uploads/2018/12/network_tcp_server_04.png" alt=""></p><p>（4）1个html和7个图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">www.zhengbenwu.com</span><br><span class="line">&lt;img src=&quot;./apple.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./ceshi.webp&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./timg.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test001.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test002.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test003.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test004.jpg&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>结论：<br>客户端初始会产生6个TCP连接，并且复用连接。断开TCP连接的是服务端，因此最后服务端会产生6个TIME_WAIT。<br><img src="/uploads/2018/12/network_tcp_server_05.png" alt=""></p><p>解决方案：<br>线上环境可使用负载均衡。</p><h5 id="短连接中TCP是如何请求的？"><a href="#短连接中TCP是如何请求的？" class="headerlink" title="短连接中TCP是如何请求的？"></a>短连接中TCP是如何请求的？</h5><p>实验二：使用短连接（在服务端Nginx配置 <code>keepalive_timeout 0;</code>）<br>（1）1个html和7个图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">www.zhengbenwu.com</span><br><span class="line">&lt;img src=&quot;./apple.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./ceshi.webp&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./timg.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test001.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test002.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test003.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test004.jpg&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>结论：<br>在使用短连接的情况下，每个请求都会建立一个TCP连接，不会复用。并且，测试显示都是服务端断开的连接，因此服务端会产生TIME_WAIT。<br><img src="/uploads/2018/12/network_tcp_server_06.png" alt=""></p><h5 id="TIME-WAIT在服务端与客户端的理解"><a href="#TIME-WAIT在服务端与客户端的理解" class="headerlink" title="TIME_WAIT在服务端与客户端的理解"></a>TIME_WAIT在服务端与客户端的理解</h5><p>我理解的TIME_WAIT有两种，一种是作为客户端产生的TIME_WAIT，一种是作为服务端产生的TIME_WAIT。<br>这里，我们先说一下请求的过程。首先，客户端会新建一个进程，并随机分配一个端口号，来与服务端的固定端口号进行连接建立。因此，这一条请求就有两个端口，一个是客户端的随机端口，一个是服务端的固定端口。那么，下面来说结论：<br>① 对于客户端来说<br>客户端主动断开连接，TIME_WAIT产生在客户端。那么，服务端的这条TCP连接会被迅速回收；而客户端会耗时2MSL才被回收，端口才会被释放。</p><p>② 对于服务端来说<br>服务端主动断开连接，TIME_WAIT产生在服务端。客户端的TCP连接会被迅速回收，端口释放，重复使用；而服务端会耗时2MSL才会释放该条连接。</p><p>请注意，这里服务端与TCP建立连接并没有占用端口号，服务端的固定端口号一直在监听服务，并不会被请求占用，而是复用端口。这里与客户端建立连接的是服务端的线程或子进程，会复制主进程的资源，进行处理请求，然后，返回给客户端。<br>因此，服务端产生的TIME_WAIT并不会消耗端口号，只会消耗线程或子进程资源。当请求量达到服务器承载的极限值时，服务端会返回错误。</p><font color="red">（注：由上可知，一般说的TIME_WAIT，是指服务端作为客户端发起的请求产生的TIME_WAIT。过多会导致端口号不够，造成错误。）</font><h5 id="那端会产生TIME-WAIT"><a href="#那端会产生TIME-WAIT" class="headerlink" title="那端会产生TIME_WAIT"></a>那端会产生TIME_WAIT</h5><p>主动断开连接的那端会产生TIME_WAIT。 那又有个问题，那端会先断开连接呢？什么情况下客户端先断，什么情况下服务端先断？</p><ol><li>对于http1.0协议来说，如果响应头中有content-length头，则以content-length的长度就可以知道body的长度了，客户端在接收body时，就可以依照这个长度来接收数据，接收完后，就表示这个请求完成了。而如果没有content-length头，则客户端会一直接收数据，直到服务端主动断开连接，才表示body接收完了。</li><li>而对于http1.1协议来说，如果响应头中的Transfer-encoding为chunked传输，则表示body是流式输出，body会被分成多个块，每块的开始会标识出当前块的长度，此时，body不需要通过长度来指定。如果是非chunked传输，而且有content-length，则按照content-length来接收数据。否则，如果是非chunked，并且没有content-length，则客户端接收数据，直到服务端主动断开连接。</li></ol><p><strong>总结：</strong></p><ul><li>http1.0<br>带content-length，body长度可知，客户端在接收body时，就可以依据这个长度来接受数据。接受完毕后，就表示这个请求完毕了。客户端主动调用close进入四次挥手。<br>不带content-length ，body长度不可知，客户端一直接受数据，直到服务端主动断开</li><li>http1.1<br>带content-length，body长度可知，客户端主动断开<br>带Transfer-encoding：chunked，body会被分成多个块，每块的开始会标识出当前块的长度，body就不需要通过content-length来指定了。但依然可以知道body的长度 客户端主动断开<br>不带Transfer-encoding：chunked且不带content-length，客户端接收数据，直到服务端主动断开连接。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;环境说明：&quot;&gt;&lt;a href=&quot;#环境说明：&quot; class=&quot;headerlink&quot; title=&quot;环境说明：&quot;&gt;&lt;/a&gt;环境说明：&lt;/h4&gt;&lt;p&gt;访问路径：&lt;a href=&quot;http://118.24.8.229/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://118.24.8.229/index.html&lt;/a&gt;&lt;br&gt;index.html代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;www.zhengbenwu.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;img src=&amp;quot;./apple.jpg&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;img src=&amp;quot;./ceshi.webp&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;监控工具：Wireshark&lt;br&gt;监控筛选条件：&lt;code&gt;ip.addr == 118.24.8.229 &amp;amp;&amp;amp; tcp.port == 80&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之URL基础知识</title>
    <link href="http://yoursite.com/2018/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BURL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/12/17/计算机网络之URL基础知识/</id>
    <published>2018-12-17T08:27:14.000Z</published>
    <updated>2018-12-17T08:40:39.525Z</updated>
    
    <content type="html"><![CDATA[<p>URI：服务器资源名被称为<strong>统一资源标识符（Uniform Resource Identifier,URI）</strong>。<br>URL：<strong>统一资源定位符（URL）</strong>是资源标识符最常见的形式。URL描述了一台特定服务器上某资源的特定位置。他们可以明确说明如何从一个精确、固定的位置获取资源。<br>URN：URI的第二种形式就是<strong>统一资源名（URN）</strong>。URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与位置无关的URN，就可以将资源四处搬移。通过URN，还可以用同一个名字通过多种网络访问协议来访问资源。（注：仍然处于实验阶段，还未大范围使用。）<br><a id="more"></a><br>URL趣谈</p><blockquote><p>黑暗岁月：<br>想要访问一个资源，需要使用FTP，连接到对应的域名上，匿名登录，切换到对应的目录，然后下载到本地。进行浏览这个文件。<br>现在，只需要将URL输入到浏览器，直接回车进行浏览即可。</p></blockquote><p>URL<br>大多数URL方案的URL语法都建立在这个由9部分构成的通用格式上：<br>    <code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code><br>几乎没有哪个URL中包含所有这些组件。URL最重要的3个部分是方案（scheme）、主机（host）和路径（path）。下表对各种组件进行了总结：</p><p><strong>通用URL组件</strong></p><table><thead><tr><th>组件</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>方案</td><td>访问服务器以获取资源时要使用那种协议</td><td>无</td></tr><tr><td>用户</td><td>某些方案访问资源时需要的用户名</td><td>匿名</td></tr><tr><td>密码</td><td>用户名后面可能要包含的密码，中间由冒号（:）分隔</td><td>&lt;E-mail地址&gt;</td></tr><tr><td>主机</td><td>资源宿主服务器的主机名或点分IP地址</td><td>无</td></tr><tr><td>端口</td><td>资源宿主服务器正在监听的端口号。很多方案都默认端口号（HTTP的默认端口号为80）</td><td>每个方案特有</td></tr><tr><td>路径</td><td>服务器上资源的本地名，有一个斜杠（/）将其与前面的URL组件分隔开来。路径组件的语法是与服务器和方案有关的（本章稍后会讲到URL路径可以分为若干个段，每段都可以有其特有的组件）</td><td>无</td></tr><tr><td>参数</td><td>某些方案会用这个组件来指定输入参数。参数为名/值对。URL中可以包含多个参数字段，他们相互之间以及与路径的其余部分之间用分号（;）分隔</td><td>无</td></tr><tr><td>查询</td><td>某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引擎以及其它因特网网关）。查询组件的内容没有通用格式。用字符“?”将其与URL的其余部分分割开来</td><td>无</td></tr><tr><td>片段</td><td>一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器，这个字段是在客户端内部使用的。通过字符“#”将其与URL的其余部分分隔开来</td><td>无</td></tr></tbody></table><p><strong>常见的方案格式</strong></p><table><thead><tr><th>方案</th><th>描述</th></tr></thead><tbody><tr><td>http</td><td>超文本传输协议方案，除了没有用户名和密码之外，与通用的URL格式相符。如果省略了端口，就默认为80。<br>基本格式：<br><code>http://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</code></td></tr><tr><td>https</td><td>方案https与方案http是一对。唯一的区别在于方案https使用了网景的SSL，SSL为HTTP连接提供了端到端的加密机制。其语法与HTTP的语法相同，默认端口为443。<br>基本格式：<br><code>http://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</code></td></tr><tr><td>mailto</td><td>Mailto URL指向的是E-mail地址。由于E-mail的行为与其他方案都有所不同（他并不指向任何可以直接访问的对象），所以mailto URL的格式与标准URL的格式也有所不同。因特网E-mail地址的语法记录在RFC 822中。<br>基本格式：<br><code>mailto:&lt;RFC-822-addr-spec&gt;</code><br>示例：<br>mailto:<a href="mailto:joe@joes-hardware.com" target="_blank" rel="noopener">joe@joes-hardware.com</a></td></tr><tr><td>ftp</td><td>文件传输协议URL可以用来从FTP服务器上下载或向其上载文件，并获取FTP服务器上的目录结构内容的列表。<br>在Web和URL出现之前FTP就已经存在了。Web应用程序将FTP作为一种数据访问方案使用。URL语法遵循下列通用格式。<br>基本格式：<br><code>ftp://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;</code><br><a href="ftp://anonymous:joe%40joes-hardware.com@prep.ai.mit.edu:21/pub/gnu/" target="_blank" rel="noopener">ftp://anonymous:joe%40joes-hardware.com@prep.ai.mit.edu:21/pub/gnu/</a></td></tr><tr><td>file</td><td>方案file表示一台指定主机（通过本地磁盘、网络文件系统或其他一些文件共享系统）上可直接访问的文件。各字段都遵循通用格式。如果省略了主机名，就默认为正在使用URL的本地主机。<br>基本格式：<br><code>file://&lt;host&gt;/&lt;path&gt;</code></td></tr><tr><td>telnet</td><td>方案telnet用于访问交互式业务。他表示的并不是对象自身，而是可通过telnet协议访问的交互式应用程序（资源）。<br>基本格式：<br><code>telnet://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/</code></td></tr><tr><td>rtsp,rtspu</td><td>RTSP URL是可以通过实时流传输协议（Real Time Streaming Protocol）解析的音/视屏媒体资源的标识符。<br>方案rtspu中的u表示它是使用UDP协议来获取资源的。<br>基本格式：<br><code>rtsp://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code><br><code>rtspu://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></td></tr><tr><td>news</td><td>省略…</td></tr></tbody></table><blockquote><p>URL是一种强有力的工具，但是并不完美。他们表示的是实际的地址，而不是准确的名字。这就意味着如果资源被移走了，URL就不再有效了。就无法对对象进行定位了。<br>为了应对这个问题，因特网工程任务组（Internet Engineering Task Force，IETF）已经对一种名为统一资源名（uniform resource name,URN）的新标准做了一段时间的研究了。无论对象搬移到什么地方（在一个Web服务器内或是在不同的Web服务器间），URN都能为对象提供一个稳定的名称。<br><strong>永久统一资源定位符（persistent uniform resource locators,PURL）</strong>是用URL来实现URN功能的一个例子。其基本思想是在搜索资源的过程中引入另一个中间层，通过一个中间<strong>资源定位符（resource locator）</strong>服务器对资源的实际URL进行登记和跟踪。客户端可以向定位符请求一个永久URL，定位符可以以一个资源作为响应，将客户端重定向到资源当前实际的URL上去。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;URI：服务器资源名被称为&lt;strong&gt;统一资源标识符（Uniform Resource Identifier,URI）&lt;/strong&gt;。&lt;br&gt;URL：&lt;strong&gt;统一资源定位符（URL）&lt;/strong&gt;是资源标识符最常见的形式。URL描述了一台特定服务器上某资源的特定位置。他们可以明确说明如何从一个精确、固定的位置获取资源。&lt;br&gt;URN：URI的第二种形式就是&lt;strong&gt;统一资源名（URN）&lt;/strong&gt;。URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与位置无关的URN，就可以将资源四处搬移。通过URN，还可以用同一个名字通过多种网络访问协议来访问资源。（注：仍然处于实验阶段，还未大范围使用。）&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>[转]计算机网络之端口问题</title>
    <link href="http://yoursite.com/2018/12/17/%E8%BD%AC-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/12/17/转-计算机网络之端口问题/</id>
    <published>2018-12-17T08:26:51.000Z</published>
    <updated>2018-12-17T08:41:51.946Z</updated>
    
    <content type="html"><![CDATA[<p>博文出处：<a href="https://blog.csdn.net/weixin_42204641/article/details/83585277" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42204641/article/details/83585277</a></p><p>搞清楚一些问题，端口就彻底了解了！</p><a id="more"></a><p>1、 端口到底是什么？<br>端口就是一个数字而已；<br>这里的一个常识是：TCP/IP协议中的端口，端口号的范围从0到65535。</p><p>2、 端口到底是用来干嘛的？<br>当系统调用一个应用程序的时候，会将该进程与一个端口绑定，这样一来，传输层传给该端口的数据都被相应的进程接收，与此同时，相应进程发给传输层的数据也都通过该端口输出。所以，<strong>端口就是用来识别系统中运行的应用程序的</strong>。</p><p>3、 一般80端口是用来www服务（网页服务）的，为什么有些网站不是80端口呢？而是别的什么端口呢？<br>我们在IE的地址栏里输入一个网址的时候（比如<a href="http://www.baidu.com.cn）是不必指定端口号的，因为在默认情况下WWW服务的端口号是“80”。" target="_blank" rel="noopener">www.baidu.com.cn）是不必指定端口号的，因为在默认情况下WWW服务的端口号是“80”。</a></p><p>网络服务是可以改的，使用其他端口号完全是可以的，要注意的是，如果不是默认端口号则应该在地址栏上指定端口号。</p><p>4、 主机和端口的关系是什么？<br>大哥比方，就好比你要去银行存钱，这家银行就可以看成是一台主机，然后，银行不可能只有一种业务，对应每种业务就有很多的窗口，那么你一进银行大门的时候，在门口的服务人员就会问你说：你好！你要办什么业务？<br>你跟他说：存钱！！<br>服务员接着就会告诉你：请到三号窗口办理！<br>这个时候你总该不会往其他的窗口跑吧？！<br>这些窗口就可以看成是port。</p><p>5、 端口映射到底是怎么回事呢？<br>就是建立内网主机IP地址和外网IP地址之间的一个映射；<br>那么当我们向这个外网的IP地址发送请求时，该请求会被转发给内网的那台IP主机上去；从而实现了外网对内网的访问，端口映射的过程如果做个类比那就是：<br>你的一个朋友来找你（网络请求），但是来找你但是不知道你住哪里（内网IP），但是他知道你的名字，（外网IP）于是你的朋友向物业告知你的名字后，物业查到了你的具体地址，几栋几单元几零几（内网IP），然后物业联系你，和你确认（端口映射），然后你的朋友就去对应的地址敲了你的门，然后你开门见到了你的朋友（外网访问到内网）<br>这里的端口，是一种逻辑端口，是TCP/IP协议中定义的端口概念而已，通常就是一些装逼文章里的虚拟端口，那些看得见的端口，就叫做接口。</p><blockquote><p>进程是个什么鬼呢？<br>应用程序调入内存运行之后，就不能叫应用程序了，得叫进程；所以进程就是跑起来的应用程序。</p></blockquote><p>6、 TCP和端口有什么关系呢？<br>TCP和联机有关，所谓的联机就是指客户端Client机和服务端Server机的联系和通信；要想实现Client和Server的通信，必须先通过TCP来实现两端的联机！！<br>TCP联机的过程是：<br>第一步：客户端向服务端发送一个TCP封包（客户端发送的时候的端口是随机的）<br>　　这等同于，客户端打电话问服务端：服务端，听得到我说话么？<br>第二步：服务端按端口的服务性质接受到请求后，向客户端发送第二个TCP封包，也就是第一个响应封包<br>　　这等同于，服务端回客户端说：我听得到！<br>第三步：客户端获得这个响应封包之后，再向服务端发送一个确认封包；<br>　　这等同于，客户端向服务端说：好的！<br>第四步：服务端接收到这个确认封包之后，客户端和服务端的联机就算真正建立了；<br>在建立了tcp联机之后，才能进行服务资源的请求-响应。</p><p>了解到这里就可以完全用几句话把TCP协议和UDP协议的区别讲清楚了<br>TCP协议是：不仅发送信息，然后还要确认信息是否送达<br>UDP协议是：只发送信息，不确认信息是否送达</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博文出处：&lt;a href=&quot;https://blog.csdn.net/weixin_42204641/article/details/83585277&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/weixin_42204641/article/details/83585277&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搞清楚一些问题，端口就彻底了解了！&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之端口解析</title>
    <link href="http://yoursite.com/2018/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/17/计算机网络之端口解析/</id>
    <published>2018-12-17T08:26:03.000Z</published>
    <updated>2018-12-17T08:30:15.267Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、端口概述"><a href="#1、端口概述" class="headerlink" title="1、端口概述"></a>1、端口概述</h4><p>在Internet上，各主机间通过TCP/TP协议发送和接收数据报，各个数据报根据其目的主机的ip地址来进行互联网络中的路由选择。可见，把数据报顺利的传送到目的主机是没有问题的。问题出在哪里呢?我们知道大多数操作系统都支持多程序（进程）同时运行，那么目的主机应该把接收到的数据报传送给众多同时运行的进程中的哪一个呢？显然这个问题有待解决，端口机制便由此被引入进来。</p><blockquote><p>请注意，端口号只具有本地意义（即只对本地机器来说才有意义），它只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口。</p></blockquote><a id="more"></a><p>本地操作系统会给那些有需求的进程分配协议端口 （protocal port，即我们常说的端口），每个协议端口由一个正整数标识，如：80，139，445，等等。当目的主机接收到数据报后，将根据报文首部的目的端口号，把数据发送到相应端口，而与此端口相对应的那个进程将会领取数据并等待下一组数据的到来。</p><p>端口其实就是队，操作系统为各个进程分配了不同的队，数据报按照目的端口被推入相应的队中，等待被进程取用，在极特殊的情况下，这个队也是有可能溢出的，不过操作系统允许各进程指定和调整自己的队的大小。</p><p>不光接受数据报的进程需要开启它自己的端口，发送数据报的进程也需要开启端口，这样，数据报中将会标识有源端口，以便接受方能顺利的回传数据报到这个端口。</p><blockquote><p>传输层标识的端口号用16位来表示，说明只能允许有65535（2^16-1）个不同的端口号。</p></blockquote><h4 id="2、端口分类"><a href="#2、端口分类" class="headerlink" title="2、端口分类"></a>2、端口分类</h4><h5 id="（1）服务器端使用的端口号"><a href="#（1）服务器端使用的端口号" class="headerlink" title="（1）服务器端使用的端口号"></a>（1）服务器端使用的端口号</h5><p>这里又分为两类，最重要的一类叫做熟知端口号（well-known port number）或系统端口号，数值为0~1023。可在网址 <a href="http://www.iana.org查到。" target="_blank" rel="noopener">www.iana.org查到。</a><br>IANA把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道。下面给出一些常用的熟知端口号：</p><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>SNMP</th><th>SNMP(trap)</th></tr></thead><tbody><tr><td>熟知端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>161</td><td>162</td></tr></tbody></table><p>另一类叫做登记端口号，数值为 1024~49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。</p><h5 id="（2）客户端使用的端口号数值为-49152-65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。"><a href="#（2）客户端使用的端口号数值为-49152-65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。" class="headerlink" title="（2）客户端使用的端口号数值为 49152~65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。"></a>（2）客户端使用的端口号数值为 49152~65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。</h5><blockquote><p>短暂端口（ephemeral port）表示这种端口的存在时间是短期的。客户进程并不在意操作系统给它分配的是哪一个端口号，因为客户进程之所以必须有一个端口号（在本地主机中必须是唯一的），是为了让传输层的实体能够找到自己。这和熟知端口不同。服务器机器一接通电源，服务器程序就运行起来。为了让因特网上所有的客户程序都能够找到服务器程序，服务器程序所使用的端口（即熟知端口）就必须是固定的，并且是众所周知的。</p></blockquote><h4 id="端口在入侵中的作用"><a href="#端口在入侵中的作用" class="headerlink" title="端口在入侵中的作用"></a>端口在入侵中的作用</h4><p>有人曾经把服务器比作房子，而把端口比作通向不同房间（服务）的门，如果不考虑细节的话，这是一个不错的比喻。入侵者要占领这间房子，势必要破门而入（物理入侵另说），那么对于入侵者来说，了解房子开了几扇门，都是什么样的门，门后面有什么东西就显得至关重要。<br>　 入侵者通常会用扫描器对目标主机的端口进行扫描，以确定哪些端口是开放的，从开放的端口，入侵者可以知道目标主机大致提供了哪些服务，进而猜测可能存在的漏洞，因此对端口的扫描可以帮助我们更好的了解目标主机，而对于管理员，扫描本机的开放端口也是做好安全防范的第一步。</p><h4 id="端口大小设置"><a href="#端口大小设置" class="headerlink" title="端口大小设置"></a>端口大小设置</h4><blockquote><p>端口大小需要先了解MTU是什么？<br>MTU是Maximum Transmission Unit的缩写，意思是网络上传送的最大数据包，它的的单位是字节。</p></blockquote><blockquote><p>大部分网络设备都是1500。如果本机的MTU比网关的MTU大，大的数据包就会被拆开来传送，这样会产生很多数据包碎片，增加丢包率，降低网络速度。把本机的MTU设成比网关的MTU小或相同，就可以减少丢包 。通俗的说也就是，如果你上传一个大的文件，速度非常慢，可能就是这种原因，当你把MTU值改小时，就可以解决。</p></blockquote><p><strong>查看本机的mtu ：</strong> <code>netstat -i</code></p><p><strong>设置本机的mtu ：</strong> <code>echo &quot;1450&quot; &gt; /sys/class/net/eth0/mtu</code> 或直接编辑eth1网卡配置文件。</p><blockquote><p>扩展：不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p></blockquote><p>在应用程序中我们用到的Data的长度最大是多少，直接取决于底层的限制。<br>我们从下到上分析一下：</p><ol><li>在链路层，由以太网的物理特性决定了数据帧的长度为(46＋18)－(1500＋18)，其中的18是数据帧的头和尾，也就是说数据帧的内容最大为1500(不包括帧头和帧尾)，即MTU(Maximum Transmission Unit)为1500；</li><li>在网络层，因为IP包的首部要占用20字节，所以这的MTU为1500－20＝1480；</li><li>在传输层，对于UDP包的首部要占用8字节，所以这的MTU为1480－8＝1472；（注：TCP的首部要占用20字节）　　</li></ol><p>所以，在应用层，你的Data最大长度为1472。当我们的UDP包中的数据多于MTU(1472)时，发送方的IP层需要分片fragmentation进行传输，而在接收方IP层则需要进行数据报重组，由于UDP是不可靠的传输协议，如果分片丢失导致重组失败，将导致UDP数据包被丢弃。</p><blockquote><p><img src="/uploads/2018/12/network_mtu_001.jpg" alt=""><br>由于以太网EthernetII最大的数据帧是1518Bytes这样，刨去以太网帧的帧头（DMAC目的MAC地址48bits=6Bytes+SMAC源MAC地址48bits=6Bytes+Type域2Bytes）14Bytes和帧尾CRC校验部分4Bytes那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值我们就把它称之为MTU。</p></blockquote><blockquote><p>如果我们定义的TCP和UDP包没有超过范围，那么我们的包在IP层就不用分包了，这样传输过程中就避免了在IP层组包发生的错误；如果超过范围，既IP数据报大于1500字节，发送方IP层就需要将数据包分成若干片，而接收方IP层就需要进行数据报的重组。更严重的是，如果使用UDP协议，当IP层组包发生错误，那么包就会被丢弃。接收方无法重组数据报，将导致丢弃整个IP数据报。UDP不保证可靠传输；但是TCP发生组包错误时，该包会被重传，保证可靠传输。</p></blockquote><p>UDP数据报的长度是指包括报头和数据部分在内的总字节数，其中报头长度固定，数据部分可变。数据报的最大长度根据操作环境的不同而各异。从理论上说，包含报头在内的数据报的最大长度为65535字节(64K)。</p><blockquote><p>注：此处的最大字节数，为系统内核缓存区大小。现在默认值已经不是65535字节，可依据机器查询。<br><code>cat /proc/sys/net/core/rmem_max</code>    //读缓存区，单位字节<br>16777216<br><code>cat /proc/sys/net/core/wmem_max</code>    //写缓存区，单位字节<br>16777216<br><code>cat /proc/sys/net/core/rmem_default</code>    //默认读缓存区<br>8388608<br><code>cat /proc/sys/net/core/wmem_default</code>    //默认写缓存区<br>8388608</p></blockquote><p>我们在用Socket编程时，UDP协议要求包小于64K（需要减去IP头(20)+UDP头(8)=65507，否则用sendto函数发送数据会返回错误）。TCP没有限定，TCP包头中就没有“包长度”字段，而完全依靠IP层去处理分帧。这就是为什么TCP常常被称作一种“流协议”的原因，开发者在使用TCP服务的时候，不必去关心数据包的大小，只需讲SOCKET看作一条数据流的入口，往里面放数据就是了，TCP协议本身会进行拥塞/流量控制。</p><h4 id="端口阻塞问题？（自我理解，不一定正确。待后期确认）"><a href="#端口阻塞问题？（自我理解，不一定正确。待后期确认）" class="headerlink" title="端口阻塞问题？（自我理解，不一定正确。待后期确认）"></a>端口阻塞问题？（自我理解，不一定正确。待后期确认）</h4><p>端口号仅仅是为了区别本地机器的进程用的，并不会出现阻塞问题。出现阻塞问题，也都是一些TCP方面的，或者是IP层面的。</p><p>传输层或网络层的发送与接收缓存打满，导致阻塞丢失数据问题，出现阻塞。（这就是为什么TCP有拥塞控制。需要检测拥塞和减少包的发送率，降低拥塞，避免网络瘫痪。）</p><p>（注：一般不会说UDP会阻塞网络，因为UDP是不可靠的传输，因此如果有阻塞发生，UDP就会丢包，没有重传机制。造成阻塞的情况，可能就是源主机一直发送数据，导致拥塞，造成网络不能正常收发数据。）</p><p>还有就是进程阻塞问题。 一般不会说端口阻塞。端口只会被禁止，通过防火墙一类的限制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、端口概述&quot;&gt;&lt;a href=&quot;#1、端口概述&quot; class=&quot;headerlink&quot; title=&quot;1、端口概述&quot;&gt;&lt;/a&gt;1、端口概述&lt;/h4&gt;&lt;p&gt;在Internet上，各主机间通过TCP/TP协议发送和接收数据报，各个数据报根据其目的主机的ip地址来进行互联网络中的路由选择。可见，把数据报顺利的传送到目的主机是没有问题的。问题出在哪里呢?我们知道大多数操作系统都支持多程序（进程）同时运行，那么目的主机应该把接收到的数据报传送给众多同时运行的进程中的哪一个呢？显然这个问题有待解决，端口机制便由此被引入进来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意，端口号只具有本地意义（即只对本地机器来说才有意义），它只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之TCP、UDP解析</title>
    <link href="http://yoursite.com/2018/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BTCP%E3%80%81UDP%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/17/计算机网络之TCP、UDP解析/</id>
    <published>2018-12-17T08:25:45.000Z</published>
    <updated>2018-12-17T08:29:16.114Z</updated>
    
    <content type="html"><![CDATA[<h4 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h4><p>OSI模型最初是用来作为开发网络通信协议族的一个工业参考标准。通过严格遵守OSI模型，不同的网络技术之间可以轻易地实现互操作。<br><img src="/uploads/2018/12/network_osi.png" alt=""><br><a id="more"></a></p><p>OSI模型包含许多被分割成层的组件。在网络数据通信的过程中，每一层完成一个特定的任务。当传输数据的时候，每一层接收到上面层格式化后的数据，对数据进行操作，然后把它传给下面的层。当接收数据的时候，每一层接收到下面层传过来的数据，对数据进行解包，然后把它传给上一层。</p><p>OSI模型的一个关键概念是虚电路。兼容OSI模型的网络栈的每一部分都不知道其上面层和下面层的行为和细节；它只是向上和向下传输数据。就模型的层次而言，每一层都有一虚电路直接连接目的主机上的对应层。就每一层而言，它的数据在目的层被解包的方式和被打包的方式是完全一样的。层不知道传输数据的实际细节；它们只知道数据是从周围层中传过来的。</p><h4 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h4><p>OSI模型是一种通用的、标准的、理论模型，今天市场上没有一个流行的网络协议完全遵守OSI模型，TCP/IP也不例外，TCP/IP协议族有自己的模型，被称为TCP/IP协议栈，又称DOD模型（Department of defense）<br><img src="/uploads/2018/12/network_tcp_ip_01.png" alt=""></p><blockquote><p>问：TCP/IP是什么？<br>答：TCP/IP是协议栈，并不是单指TCP协议、IP协议或者HTTP协议。仅仅是一个协议族，是一个统称。</p></blockquote><h4 id="TCP、UDP概述"><a href="#TCP、UDP概述" class="headerlink" title="TCP、UDP概述"></a>TCP、UDP概述</h4><h5 id="（1）用户数据报协议UDP（User-Datagram-Protocol）：UDP用户数据报"><a href="#（1）用户数据报协议UDP（User-Datagram-Protocol）：UDP用户数据报" class="headerlink" title="（1）用户数据报协议UDP（User Datagram Protocol）：UDP用户数据报"></a>（1）用户数据报协议UDP（User Datagram Protocol）：UDP用户数据报</h5><p>UDP在传送数据之前不需要先建立连接。远地主机的传输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。</p><h5 id="（2）传输控制协议TCP（Transmission-Control-Protocol）：TCP报文段"><a href="#（2）传输控制协议TCP（Transmission-Control-Protocol）：TCP报文段" class="headerlink" title="（2）传输控制协议TCP（Transmission Control Protocol）：TCP报文段"></a>（2）传输控制协议TCP（Transmission Control Protocol）：TCP报文段</h5><p>TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的传输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。</p><p><strong>使用UDP和TCP协议的各种应用和应用层协议</strong></p><table><thead><tr><th>应用</th><th>应用层协议</th><th>运输层协议</th></tr></thead><tbody><tr><td>域名解析</td><td>DNS</td><td>UDP</td></tr><tr><td>文件传送</td><td>TFTP</td><td>UDP</td></tr><tr><td>路由选择协议</td><td>RIP</td><td>UDP</td></tr><tr><td>IP地址配置</td><td>BOOTP，DHCP</td><td>UDP</td></tr><tr><td>网络管理</td><td>SNMP</td><td>UDP</td></tr><tr><td>远程文件服务器</td><td>NFS</td><td>UDP</td></tr><tr><td>多播</td><td>IGMP</td><td>UDP</td></tr><tr><td>万维网</td><td>HTTP</td><td>TCP</td></tr><tr><td>文件传送</td><td>FTP</td><td>TCP</td></tr><tr><td>远程终端接入</td><td>TELNET</td><td>TCP</td></tr></tbody></table><blockquote><p>题外话：如何将一个进程通过网络送到对应服务器的进程中？<br>解决这个问题的方法就是在传输层使用协议端口号（protocol port number），或通常简称为端口（port）。这就是说，虽然通信的终点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的目的端口（通过IP来完成），剩下的工作（即最后交付给目的进程）就由TCP来完成。</p><blockquote><p>请注意，这种在协议栈层间的抽象的协议端口是软件端口，和路由器或交换机上的硬件端口（应该称为接口）是完全不同的概念。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。</p></blockquote></blockquote><blockquote><p>扩展：TCP/IP的传输层用一个16位端口号来标志一个端口。但请注意，端口号只具有本地意义（即本机机器来说才有意义），它只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口。16位的端口号可允许有65535个不同的端口号，这个数目对一个计算机来说是足够用的。</p></blockquote><h4 id="UDP解析"><a href="#UDP解析" class="headerlink" title="UDP解析"></a>UDP解析</h4><h5 id="1、主要特点："><a href="#1、主要特点：" class="headerlink" title="1、主要特点："></a>1、主要特点：</h5><p>（1）UDP是<strong>无连接</strong>的，即发送数据之前不需要建立连接（当然发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延。<br>（2）UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有许多参数）。<br>（3）UDP是<strong>面向报文</strong>的。发送方的UDP对应程序交下来的报文，在添加首部后就向下交付给IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是<strong>保留这些报文的边界</strong>。这就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。如下图，在接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付给上层的应用进程。<br>因此，<font color="red">应用程序必须选择合适大小的报文。</font>若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这回降低IP层的效率。反之，若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。<br><img src="/uploads/2018/12/network_udp_01.png" alt=""><br>（4）UDP<strong>没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。（这对某些实时应用是很重要的。）<br>（5）UDP<strong>支持一对一、一对多、多对一和多对多的交互通信</strong>。<br>（6）UDP的<strong>首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</p><blockquote><p>虽然某些实时应用需要使用没有拥塞控制的UDP，但当很多的源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，结果大家都无法正常接收。因此，不适用拥塞控制功能的UDP有可能会引起网络产生严重的拥塞问题。</p></blockquote><h5 id="2、UDP的首部格式"><a href="#2、UDP的首部格式" class="headerlink" title="2、UDP的首部格式"></a>2、UDP的首部格式</h5><p>用户数据报UDP有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节，由四个字段组成，每个字段的长度都是两个字节。各字段意义如下：</p><table><thead><tr><th>报头字段名</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td>源端口号</td><td>16</td><td>发送主机的UDP端口</td></tr><tr><td>目的端口号</td><td>16</td><td>目标主机的UDP端口</td></tr><tr><td>消息长度</td><td>16</td><td>UDP用户数据报的长度，其最小值是8（仅有首部）</td></tr><tr><td>校验和</td><td>16</td><td>检测UDP用户数据报在传输中是否有错。有错就丢弃</td></tr></tbody></table><p><img src="/uploads/2018/12/network_udp_02.png" alt=""><br>当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交最后的终点——应用进程。</p><h4 id="TCP解析"><a href="#TCP解析" class="headerlink" title="TCP解析"></a>TCP解析</h4><h5 id="1、主要特点：-1"><a href="#1、主要特点：-1" class="headerlink" title="1、主要特点："></a>1、主要特点：</h5><p>（1）TCP是<strong>面向连接的传输层协议</strong>。这就是说，应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。<br>（2）每一条TCP连接只能有<strong>两个端点（endpoint）</strong>，每一条TCP连接只能是点对点的（一对一）。<br>（3）TCP提供<strong>可靠交付</strong>的服务。也就是说，通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。<br>（4）TCP提供<strong>全双工通信</strong>。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。<br>（5）面向字节流。TCP中的<strong>“流”（stream）指的是流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和TCP的交互时一次一个数据块（大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的<strong>无结构的字节流。</strong>TCP并不知道所传送的字节流的含义。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块就把收到的字节流交付给了上层的应用程序）。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。当然，接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。</p><h5 id="2、TCP的连接"><a href="#2、TCP的连接" class="headerlink" title="2、TCP的连接"></a>2、TCP的连接</h5><p>TCP把连接作为最基本的抽象。TCP的许多特性都与TCP是面向连接的这个基本特性有关。<br>前面已经说过，每一条TCP连接有两个端点。那么，TCP连接的端点是什么呢？ 不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口。 TCP连接的端点叫做<strong>套接字（socket）或插口</strong>。根据RFC 793的定义：端口号<strong>拼接到（contatenated with）IP</strong>地址即构成了套接字。</p><p><font color="red">每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。</font>即：<br>    TCP连接 ::= {socket1, socket2} = {(IP1:port1), (IP2:port2)}</p><blockquote><p>应用编程接口API（Application Programming Interface），即传输层与应用程序之间的一种接口，称为socket API，并简称为socket。</p></blockquote><h5 id="3、TCP报文段的首部格式"><a href="#3、TCP报文段的首部格式" class="headerlink" title="3、TCP报文段的首部格式"></a>3、TCP报文段的首部格式</h5><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP的全部功能都提现在它首部中各字段的作用。只有弄清楚TCP首部各字段的作用才能掌握TCP的工作原理。</p><p>TCP报文段首部的前20个字节是固定的，如下图，后面有4N字节是根据需要而增加的选项（N是整数）。因此TCP首部的最小长度是20字节。<br><img src="/uploads/2018/12/network_tcp_01.png" alt=""></p><table><thead><tr><th>报头字段名</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td>源端口号</td><td>16</td><td>本地通信端口，支持TCP的多路复用机制</td></tr><tr><td>目的端口号</td><td>16</td><td>远地通信端口，支持TCP的多路复用机制</td></tr><tr><td>序号（SEQ）</td><td>32</td><td>数据段第一个数据字节的序号（除含有SYN的段外）；SYN段的SYN序号（建立本次连接的初始序号）</td></tr><tr><td>确认号（ACK）</td><td>32</td><td>表示本地希望接收的下一个数据字节的序号</td></tr><tr><td>数据偏移</td><td>4</td><td>指出该段中数据的初始位置（以32位为单位）</td></tr><tr><td>保留</td><td>6</td><td>保留为今后使用，但目前应置为0</td></tr><tr><td>控制字段（CTL）</td><td></td><td></td></tr><tr><td>    URG</td><td>1</td><td>紧急指针字段有效标志，即该段中携带紧急数据</td></tr><tr><td>    ACK</td><td>1</td><td>确认号字段有效标志</td></tr><tr><td>    PSH</td><td>1</td><td>PUSH操作的标志</td></tr><tr><td>    RST</td><td>1</td><td>要求异常终止通信连接的标志</td></tr><tr><td>    SYN</td><td>1</td><td>建立同步连接的标志</td></tr><tr><td>    FIN</td><td>1</td><td>本地数据发送已结束，终止连接的标志</td></tr><tr><td>窗口</td><td>16</td><td>本地接收窗口尺寸，即本地接收缓冲区大小</td></tr><tr><td>校验和</td><td>16</td><td>包括TCP报头和数据在内的校验和</td></tr><tr><td>紧急指针</td><td>16</td><td>从段序号开始的正向位移，指向紧急数据的最后一个字节</td></tr><tr><td>选项</td><td>可变</td><td>提供任选的服务</td></tr><tr><td>填充</td><td>可变</td><td>保证TCP报头以32位为边界对齐</td></tr></tbody></table><h5 id="4、TCP的连接与释放"><a href="#4、TCP的连接与释放" class="headerlink" title="4、TCP的连接与释放"></a>4、TCP的连接与释放</h5><p>用三次握手建立TCP连接：<br><img src="/uploads/2018/12/network_tcp_02.png" alt=""></p><p>TCP连接释放的过程：<br><img src="/uploads/2018/12/network_tcp_03.png" alt=""></p><p>为什么A在TIME-WAIT状态必须等待2MSL的时间呢？这有两个理由。</p><ul><li>第一，为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。</li><li>第二，防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。<br>B只要收到了A发出的确认，就进入CLOSED状态。同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接。我们注意到，B结束TCP连接的时间要比A早一些。</li></ul><blockquote><p>除时间等待计时器外，TCP还设有一个<strong>保活计时器（keepalive timer）</strong>。设想有这样的情况：客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75秒发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p></blockquote><h5 id="5、TCP高级知识点概述"><a href="#5、TCP高级知识点概述" class="headerlink" title="5、TCP高级知识点概述"></a>5、TCP高级知识点概述</h5><p>（1）TCP是怎么保证可靠传输的？<br>通过超时重传、选择确认、滑动窗口机制来保证可靠传输。</p><p>（2）TCP的keepalive保活机制？<br>通过保活计时器来确保TCP的keepalive的连接。</p><p>（3）TCP的时延、瓶颈及存在的障碍？<br>最常见的TCP相关时延，其中包括：</p><ul><li>TCP连接建立握手；</li><li>TCP慢启动拥塞控制；</li><li>数据聚集的Nagle算法；</li><li>用于捎带确认的TCP延迟确认算法；</li><li>TIME_WAIT时延和端口耗尽。</li></ul><p>（4）拥塞控制<br>所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。<br>TCP的流量控制：利用滑动窗口实现流量控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;OSI模型&quot;&gt;&lt;a href=&quot;#OSI模型&quot; class=&quot;headerlink&quot; title=&quot;OSI模型&quot;&gt;&lt;/a&gt;OSI模型&lt;/h4&gt;&lt;p&gt;OSI模型最初是用来作为开发网络通信协议族的一个工业参考标准。通过严格遵守OSI模型，不同的网络技术之间可以轻易地实现互操作。&lt;br&gt;&lt;img src=&quot;/uploads/2018/12/network_osi.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>线上TIME_WAIT日志记录总结</title>
    <link href="http://yoursite.com/2018/12/13/%E7%BA%BF%E4%B8%8ATIME-WAIT%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/13/线上TIME-WAIT日志记录总结/</id>
    <published>2018-12-13T07:55:57.000Z</published>
    <updated>2018-12-13T07:58:55.856Z</updated>
    
    <content type="html"><![CDATA[<p>首先发现的是平响太高了，之后又降下来了。然后，开始查询原因。下面是过程记录</p><p>刚开始是追寻的问题是： CLB的“心跳”突然没了？（注：CLB是负载均衡，心跳应该是CLB那边用来检测的。是一个文件。）<br><a id="more"></a><br>查看php-fpm数量，发现有434个；最后群里有人说是他调的<br><img src="/uploads/2018/12/network_timewait_001.jpg" alt=""><br><img src="/uploads/2018/12/network_timewait_002.png" alt=""></p><p>然后就开始查询为啥“心跳”没了。<br>回答：CLB改心跳检查接口的话，如果改动比较大，应该是大面积报。最后问题回归到我们这边。</p><p>回答为啥将PHP-FPM数量调高？<br>我理解是这样的，后端有请求时间过长的接口，然后PHP-FPM都用于处理了这些请求长的接口，然后堵住了，然后导致后边的请求都在等待，包括心跳的。<br>心跳5s超时，前端CLB自己断的连接，报的499.<br><img src="/uploads/2018/12/network_timewait_003.png" alt=""><br>所以，增加了fpm的进程数。</p><p>查看PHP的error。 只报进程数不够。突然频繁启动PHP进程，结果达到最大值了。<br><img src="/uploads/2018/12/network_timewait_004.jpg" alt=""></p><p><em>说明：在这个时间点，服务器内存和CPU也都没有问题。</em></p><p>在监控记录中发现，5xx的记录有一个高峰。如下图：<br><img src="/uploads/2018/12/network_timewait_005.jpg" alt=""><br>并且，报这么多错误，项目日志中并没有记录。（说明不是项目导致的问题）</p><p>然后有人在监控记录中有了新发现，如下图：<br><img src="/uploads/2018/12/network_timewait_006.jpg" alt=""><br><img src="/uploads/2018/12/network_timewait_007.jpg" alt=""></p><p><em>注：在双十一期间，机器是10台。双十一前是2台（并且量不高）。双十一之后恢复到2台（量比以前高了点）。</em></p><p>现在确定原因了，由于双十一之后量比以前增多了，导致 timewait 增多，2台机器的端口不能够满足那么大的连接。导致频频报5xx。</p><p><strong>解决方案：</strong><br>服务器降级，多开几台低配，降低 timewait。（注：timewait不可避免，只能通过增加机器，或者是调整服务端配置，提高timewait的回收速度。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先发现的是平响太高了，之后又降下来了。然后，开始查询原因。下面是过程记录&lt;/p&gt;
&lt;p&gt;刚开始是追寻的问题是： CLB的“心跳”突然没了？（注：CLB是负载均衡，心跳应该是CLB那边用来检测的。是一个文件。）&lt;br&gt;
    
    </summary>
    
      <category term="问题" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/"/>
    
      <category term="线上业务" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1/"/>
    
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HTTP之长连接、短连接</title>
    <link href="http://yoursite.com/2018/12/11/HTTP%E4%B9%8B%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/12/11/HTTP之长连接、短连接/</id>
    <published>2018-12-11T03:58:29.000Z</published>
    <updated>2018-12-11T04:33:36.561Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、什么是长连接、短连接？"><a href="#1、什么是长连接、短连接？" class="headerlink" title="1、什么是长连接、短连接？"></a>1、什么是长连接、短连接？</h4><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<code>Connection:keep-alive</code>。<br><a id="more"></a><br>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h4 id="2、TCP连接"><a href="#2、TCP连接" class="headerlink" title="2、TCP连接"></a>2、TCP连接</h4><p>当网络通信时采用TCP协议时，在真正的读写操作之前，客户端与服务器端之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时可以释放这个连接。连接的建立依靠“三次握手”，而释放则需要“四次握手”，所以每个连接的建立都是需要资源消耗和时间消耗的。<br>经典的三次握手建立连接示意图：<br><img src="/uploads/2018/12/network_tcp_01.jpg" alt=""><br><img src="/uploads/2018/12/network_tcp_02.png" alt=""><br>经典的四次握手关闭连接示意图：<br><img src="/uploads/2018/12/network_tcp_03.jpg" alt=""><br><img src="/uploads/2018/12/network_tcp_04.jpg" alt=""></p><h5 id="（1）TCP短连接"><a href="#（1）TCP短连接" class="headerlink" title="（1）TCP短连接"></a>（1）TCP短连接</h5><p>模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。</p><p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。</p><h5 id="（2）TCP长连接"><a href="#（2）TCP长连接" class="headerlink" title="（2）TCP长连接"></a>（2）TCP长连接</h5><p>我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p>TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。</p><p>如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：</p><ul><li>客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。</li><li>客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。</li><li>客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li><li>客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。</li></ul><blockquote><p>易混淆概念：TCP的keep alive和HTTP的Keep-alive<br>TCP的keep  alive是检查当前TCP连接是否活着；HTTP的Keep-alive是要让一个TCP连接活久点。它们是不同层次的概念。</p><blockquote><p>TCP keep alive的表现：<br>当一个连接“一段时间”没有数据通讯时，一方会发出一个心跳包（Keep Alive包），如果对方有回包则表明当前连接有效，继续监控。</p></blockquote></blockquote><blockquote><p>HTTP的Keep-alive<br>（1）HTTP Keep-Alive<br>在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。<br>使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。<br>但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。<br>（2）keepalvie timeout<br>Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住keepalive_timeout秒后，才开始关闭这个连接。<br>当httpd守护进程发送完一个响应后，理应马上主动关闭相应的tcp连接，设置 keepalive_timeout后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览发过来http请求，则关闭这个http连接。</p></blockquote><h4 id="3、长短连接的优缺点："><a href="#3、长短连接的优缺点：" class="headerlink" title="3、长短连接的优缺点："></a>3、长短连接的优缺点：</h4><p>长连接和短连接的产生在于client和server采取的关闭策略。不同的应用场景适合采用不同的策略。</p><p>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p><p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽</p><h4 id="4、长短连接操作过程："><a href="#4、长短连接操作过程：" class="headerlink" title="4、长短连接操作过程："></a>4、长短连接操作过程：</h4><ul><li>短连接：<br>操作步骤：连接-&gt;传输数据-&gt;关闭连接</li><li>长连接：<br>操作步骤：连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; 。。。 -&gt;关闭连接。</li></ul><h4 id="5、什么时候用长连接，短连接？"><a href="#5、什么时候用长连接，短连接？" class="headerlink" title="5、什么时候用长连接，短连接？  　　"></a>5、什么时候用长连接，短连接？  　　</h4><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 </p><p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p><p>参考文章：<br>HTTP长连接、短连接究竟是什么？：<a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">https://www.cnblogs.com/gotodsp/p/6366163.html</a><br>HTTP 的长连接和短连接：<a href="http://blog.jobbole.com/104108/" target="_blank" rel="noopener">http://blog.jobbole.com/104108/</a><br>http keep_alive 和 tcp keep_alive：<a href="https://blog.csdn.net/lys86_1205/article/details/21234867" target="_blank" rel="noopener">https://blog.csdn.net/lys86_1205/article/details/21234867</a><br>HTTP Keep-Alive模式：<a href="http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、什么是长连接、短连接？&quot;&gt;&lt;a href=&quot;#1、什么是长连接、短连接？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是长连接、短连接？&quot;&gt;&lt;/a&gt;1、什么是长连接、短连接？&lt;/h4&gt;&lt;p&gt;在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。&lt;/p&gt;
&lt;p&gt;而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：&lt;code&gt;Connection:keep-alive&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
</feed>
