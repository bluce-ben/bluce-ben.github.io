<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-09T10:16:49.607Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx 配置文件详解</title>
    <link href="http://yoursite.com/2018/04/09/Nginx-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/09/Nginx-配置文件详解/</id>
    <published>2018-04-09T10:09:58.000Z</published>
    <updated>2018-04-09T10:16:49.607Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、结构分析"><a href="#1、结构分析" class="headerlink" title="1、结构分析"></a>1、结构分析</h4><p>nginx配置文件中主要包括六块：main，events，http，server，location，upstream<br>结构如下图：</p><ul><li><strong>main块：</strong>主要控制nginx子进程的所属用户/用户组、派生子进程数、错误日志位置/级别、pid位置、子进程优先级、进程对应cpu、进程能够打开的文件描述符数目等</li><li><strong>events块：</strong>控制nginx处理连接的方式</li><li><strong>http块：</strong>是nginx处理http请求的主要配置模块，大多数配置都在这里面进行</li><li><strong>server块：</strong>是nginx中主机的配置块，可以配置多个虚拟主机</li><li><strong>location块：</strong>是server中对应的目录级别的控制块，可以有多个</li><li><strong>upstream块：</strong>是nginx做反向代理和负载均衡的配置块，可以有多个</li></ul><a id="more"></a><h4 id="2、配置命令解释"><a href="#2、配置命令解释" class="headerlink" title="2、配置命令解释"></a>2、配置命令解释</h4><p>nginx中每条配置命令都必须要以分号“;”结束！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">#定义Nginx运行的用户和用户组</span><br><span class="line">user www www;</span><br><span class="line"></span><br><span class="line">#nginx进程数，建议设置为等于CPU总核心数。</span><br><span class="line">worker_processes 8;</span><br><span class="line"></span><br><span class="line">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">error_log /var/log/nginx/error.log info;</span><br><span class="line"></span><br><span class="line">#指定nginx  pid的存放路径</span><br><span class="line">pid /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）</span><br><span class="line">#与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">#工作模式与连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; </span><br><span class="line">    #epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。</span><br><span class="line">    use epoll;</span><br><span class="line">    #单个进程最大连接数（最大连接数=连接数*进程数）</span><br><span class="line">    worker_connections 65535;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#设定http服务器</span><br><span class="line">http &#123;</span><br><span class="line">    include mime.types; #文件扩展名与文件类型映射表</span><br><span class="line">    default_type application/octet-stream; #默认文件类型</span><br><span class="line">    #charset utf-8; #默认编码</span><br><span class="line">    server_names_hash_bucket_size 128; #服务器名字的hash表大小</span><br><span class="line">    client_header_buffer_size 32k; #设定请求缓</span><br><span class="line">    large_client_header_buffers 4 64k; #设定请求缓</span><br><span class="line">    client_max_body_size 8m; #配置客户端能够上传的文件大小</span><br><span class="line">    sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，</span><br><span class="line">    #对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，</span><br><span class="line">    #以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br><span class="line">    autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line">    tcp_nopush on; #防止网络阻塞</span><br><span class="line">    tcp_nodelay on; #防止网络阻塞</span><br><span class="line">    keepalive_timeout 120; #长连接超时时间，单位是秒</span><br><span class="line">    </span><br><span class="line">    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问    速度。下面参数看字面意思都能理解。</span><br><span class="line">    fastcgi_connect_timeout 300;</span><br><span class="line">    fastcgi_send_timeout 300;</span><br><span class="line">    fastcgi_read_timeout 300;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">    #gzip模块设置</span><br><span class="line">    gzip on; #开启gzip压缩输出</span><br><span class="line">    gzip_min_length 1k; #最小压缩文件大小</span><br><span class="line">    gzip_buffers 4 16k; #压缩缓冲区</span><br><span class="line">    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br><span class="line">    gzip_comp_level 2; #压缩等级</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class="line">    #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用</span><br><span class="line"></span><br><span class="line">    #日志格式设定</span><br><span class="line">    log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;</span><br><span class="line">    #启用访问日志，并且指定日志采用的格式</span><br><span class="line">    access_log /var/log/nginx/ha97access.log main;</span><br><span class="line">    #自定义日志格式</span><br><span class="line">    #log_format access &apos;$http_x_forwarded_for $remote_addr [$time_local] &quot;http://$host&quot; &quot;$request&quot; &apos;</span><br><span class="line">    #&apos;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$remote_user&quot; &apos;;</span><br><span class="line">    #（x_forwarded_for表示用户的真实IP。）</span><br><span class="line"></span><br><span class="line">    upstream blog.ha97.com &#123;</span><br><span class="line">        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。</span><br><span class="line">        #weigth参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">        server 192.168.80.121:80 weight=3;</span><br><span class="line">        server 192.168.80.122:80 weight=2;</span><br><span class="line">        server 192.168.80.123:80 weight=3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #虚拟主机的配置</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">        #监听端口</span><br><span class="line">        listen 80;</span><br><span class="line">        #域名可以有多个，用空格隔开</span><br><span class="line">        server_name www.ha97.com ha97.com;</span><br><span class="line">        #默认索引文件</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">        #主机站点根目录地址</span><br><span class="line">        root /data/www/ha97;</span><br><span class="line">        #error_page   404    /404.html;  //404页面地址（可以配置其它错误页面地址如500等，格式一样）</span><br><span class="line"></span><br><span class="line">        #转发PHP文件到指定服务</span><br><span class="line">        location ~ .*\.(php|php5)?$&#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            include fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        #图片缓存时间设置</span><br><span class="line">        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$&#123;</span><br><span class="line">            expires 10d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #JS和CSS缓存时间设置</span><br><span class="line">        location ~ .*\.(js|css)?$&#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #对 &quot;/&quot; 启用反向代理</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:88;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            #以下是一些反向代理的配置，可选。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            client_max_body_size 10m; #允许客户端请求的最大单文件字节数</span><br><span class="line">            client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">            proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">            proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)</span><br><span class="line">            proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">            proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">            proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置</span><br><span class="line">            proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">            proxy_temp_file_write_size 64k;</span><br><span class="line">            #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #设定查看Nginx状态的地址</span><br><span class="line">        location /NginxStatus &#123;</span><br><span class="line">            stub_status on;</span><br><span class="line">            access_log on;</span><br><span class="line">            auth_basic &quot;NginxStatus&quot;;</span><br><span class="line">            auth_basic_user_file conf/htpasswd;</span><br><span class="line">            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #本地动静分离反向代理配置</span><br><span class="line">        #所有jsp的页面均交由tomcat或resin处理</span><br><span class="line">        location ~ .(jsp|jspx|do)?$ &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">        #所有静态文件由nginx直接读取不经过tomcat或resin</span><br><span class="line">        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip</span><br><span class="line">        |txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$&#123; </span><br><span class="line">            expires 15d; </span><br><span class="line">        &#125;</span><br><span class="line">        location ~ .*.(js|css)?$&#123; </span><br><span class="line">            expires 1h; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、结构分析&quot;&gt;&lt;a href=&quot;#1、结构分析&quot; class=&quot;headerlink&quot; title=&quot;1、结构分析&quot;&gt;&lt;/a&gt;1、结构分析&lt;/h4&gt;&lt;p&gt;nginx配置文件中主要包括六块：main，events，http，server，location，upstream&lt;br&gt;结构如下图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;main块：&lt;/strong&gt;主要控制nginx子进程的所属用户/用户组、派生子进程数、错误日志位置/级别、pid位置、子进程优先级、进程对应cpu、进程能够打开的文件描述符数目等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;events块：&lt;/strong&gt;控制nginx处理连接的方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;http块：&lt;/strong&gt;是nginx处理http请求的主要配置模块，大多数配置都在这里面进行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;server块：&lt;/strong&gt;是nginx中主机的配置块，可以配置多个虚拟主机&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;location块：&lt;/strong&gt;是server中对应的目录级别的控制块，可以有多个&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;upstream块：&lt;/strong&gt;是nginx做反向代理和负载均衡的配置块，可以有多个&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 中的事件驱动模型</title>
    <link href="http://yoursite.com/2018/04/09/Nginx-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/04/09/Nginx-中的事件驱动模型/</id>
    <published>2018-04-09T09:19:16.000Z</published>
    <updated>2018-04-09T09:40:21.110Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是事件驱动模型？"><a href="#什么是事件驱动模型？" class="headerlink" title="什么是事件驱动模型？"></a>什么是事件驱动模型？</h4><p>在计算机编程领域，事件驱动模型对应一种程序设计方式，Event-driven programming，即事件驱动程序设计。事件驱动模型一般是由事件收集器，事件发送器，事件处理器三部分基本单元组成。</p><ul><li>事件收集器专门负责收集所有的事件，包括来自用户的（如鼠标单击事件、键盘输入事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。</li><li>事件发送器负责将收集器收集到的事件分发到目标对象中。目标对象就是事件处理器所处的位置。</li><li>事件处理器主要负责具体事件的响应工作，它往往要到实现阶段才完全确定。</li></ul><p>事件驱动程序可以由任何编程语言来实现，只是难易程度有别。如果一个系统是以事件驱动程序模型作为编程基础的，那么，它的架构基本上是这样的：预先设计一个事件循环所形成的程序，这个事件循环程序构成了“事件收集器”，它不断地检查目前要处理的事件信息，然后使用“事件发送器”传递给“事件处理器”。“事件处理器”一般运用虚函数机制来实现。<br><a id="more"></a></p><h4 id="Nginx中的事件驱动模型"><a href="#Nginx中的事件驱动模型" class="headerlink" title="Nginx中的事件驱动模型"></a>Nginx中的事件驱动模型</h4><p>Nginx服务器响应和处理Web请求的过程，就是基于事件驱动模型的，它也包含事件收集器、事件发送器和事件处理器等三部分基本单元。Nginx的“事件收集器”和“事件发送器”的实现没有太大的特点，重点介绍一下它的“事件处理器”。<br>通常，我们在编写服务器处理模型的程序时，基于事件驱动模型，“目标对象”中的“事件处理器”可以有以下几种实现办法：</p><ul><li>“事件发送器”每传递过来一个请求，“目标对象”就创建一个新的进程，调用“事件处理器”来处理该请求。</li><li>“事件发送器”每传递过来一个请求，“目标对象”就创建一个新的线程，调用“事件处理器”来处理该请求。</li><li>“事件发送器”每传递过来一个请求，“目标对象”就将其放入一个待处理事件的列表，使用非阻塞I/O方式调用“事件处理器”来处理该请求。</li></ul><p>以上的三种处理方式，各有特点，第一种方式，由于创建新的进程的开销比较大，会导致服务器性能比较差，但其实现相对来说比较简单。<br>第二种方式，由于要涉及到线程的同步，故可能会面临死锁、同步等一系列问题，编码比较复杂。<br>第三种方式，在编写程序代码时，逻辑比前面两种都复杂。大多数网络服务器采用了第三种方式，逐渐形成了所谓的“事件驱动处理库”。<br>事件驱动处理库又被称为多路IO复用方法，最常见的包括以下三种：select模型，poll模型和epoll模型。Nginx服务器还支持rtsig模型、kqueue模型、dev/poll模型和eventport模型等。通过Nginx配置可以使得Nginx服务器支持这几种事件驱动处理模型。这里详细介绍以下它们。</p><h4 id="select库"><a href="#select库" class="headerlink" title="select库"></a>select库</h4><p>select库，是各个版本的Linux和Windows平台都支持的基本事件驱动模型库，并且在接口的定义上也基本相同，只是部分参数的含义略有差异。使用select库的步骤一般是：<br>首先，创建所关注事件的描述符集合。对于一个描述符，可以关注其上面的（Read)事件、写（Write)事件以及异常发送（Exception）事件，所以要创建三类事件描述符集合，分别用来收集读事件的描述符、写事件的描述符和异常事件的描述符。<br>其次，调用底层提供的select()函数，等待事件发生。这里需要注意的一点是，select的阻塞与是否设置非阻塞I/O是没有关系的。<br>然后，轮询所有事件描述符集合中的每一个事件描述符，检查是否有相应的事件发生，如果有，就进行处理。<br>Nginx服务器在编译过程中如果没有为其指定其他高性能事件驱动模型库，它将自动编译该库。我们可以使用–with-select_module和–without-select_module两个参数强制Nginx是否编译该库。</p><blockquote><p><strong>缺点：</strong><br>1、单个进程可监视的fd（描述符）数量被限制，即能监听端口的大小有限。<br>    一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.<br>2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：<br>    当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。<br>3、需要维护一个用来存放大量fd（描述符）的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p></blockquote><h4 id="poll库"><a href="#poll库" class="headerlink" title="poll库"></a>poll库</h4><p>poll库，作为Linux平台上的基本事件驱动模型，实在Linux2.1.23中引入的。Windows平台不支持poll库。<br>poll与select的基本工作方式是相同的，都是现创建一个关注事件的描述符集合，再去等待这些事件发生，然后在轮询描述符集合，检查有没有事件发生，如果有，就进行处理。<br>poll库与select库的主要区别在于，select库需要为读事件、写事件和异常事件分别创建一个描述符集合，因此在最后轮询的时候，需要分别轮询这三个集合。而poll库只需要创建一个集合，在每个描述符对应的结构上分别设置读事件、写事件或者异常事件，最后轮询的时候，可以同时检查这三种事件是否发生。可以说，poll库是select库的优化实现。<br>Nginx服务器在编译过程中如果没有为其制定其他高性能事件驱动模型库，它将自动编译该库。我们可以使用–with-poll_module和–without-poll_module两个参数强制Nginx是否编译该库。</p><blockquote><p><strong>缺点：</strong><br>1、大量的fd（描述符）的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。<br>2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p></blockquote><h4 id="epoll库"><a href="#epoll库" class="headerlink" title="epoll库"></a>epoll库</h4><p>epoll库是Nginx服务器支持的高性能事件驱动库之一，它是公认的非常优秀的事件驱动模型，和poll库及select库有很大的不同。epoll属于poll库的一个变种，是在Linux 2.5.44中引入的，在Linux 2.6以上的版本都可以使用它。poll库和select库在实际工作中，最大的区别在于效率。<br>从前面的介绍我们知道，它们的处理方式都是创建一个待处理事件列表，然后把这个列表发给内核，返回的时候，再去轮询检查这个列表，以判断事件是否发生。这样在描述符比较多的应用中，效率就显得比较低下了。一种比较好的做法是，把描述符列表的管理交给内核负责，一旦有某种事件发生，内核把发生事件的描述符列表通知给进程，这样就避免了轮询整个描述符列表。epoll库就是这样一种模型。<br>首先，epoll库通过相关调用通知内核创建一个由N个描述符的事件列表。然后，给这些描述符设置所关注的事件，并把它添加到内核的事件列表中去，在具体的编码过程中也可以通过相关调用对事件列表中的描述符进行修改和删除。<br>完成设置之后，epoll库就开始等待内核通知事件发生了。某一事件发生后，内核将发生事件的描述符列表上报给epoll库。得到事件列表的epoll库，就可以进行事件处理了。<br>epoll库在Linux平台上是最高效的。它支持一个进程打开大数目的事件描述符，上限是系统可以打开文件的最大数目。同时，epoll库的IO效率不随描述符数目增加而线性下降，因为它只会对内核上报的“活跃”的描述符进行操作。</p><blockquote><p><strong>优点：</strong><br>1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；<br>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；<br>    即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。<br>3、内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p></blockquote><h4 id="rtsig模型"><a href="#rtsig模型" class="headerlink" title="rtsig模型"></a>rtsig模型</h4><p>rtsig是Real-Time Signal的缩写，是实时信号的意思。从严格意义上说，rtsig模型并不是常用的事件驱动模型，但Nginx服务器使用了使用实时信号对事件进行响应的支持，官方文档中将rtsig模型与其他的事件驱动模型并列。<br>使用rtsig模型时，工作进程会通过系统内核建立一个rtsig队列用于存放标记事件发生（在Nginx服务器应用中特指客户端请求发生）的信号。每个事件发生时，系统内核就会产生一个信号存放到rtsig队列中等待工作进程的处理。<br>需要指出的是，rtsig队列有长度限制，超过该长度后就会发生溢出。默认情况下，Linux系统事件信号队列的最大长度设置为1024，也就是同时最多可以存放1024个发生事件的信号。在Linux 2.6.6-mm2之前的版本中，系统各个进程的事件信号队列是由内核统一管理的，用户可以通过修改内核参数/proc/sys/kernel/rtsig-max/来自定义该长度设置。在Linux 2.6.6-mm2之后的版本中，该内核参数被取消，系统各个进程分别拥有各自的事件信号队列，这个队列的大小由Linux系统的RLIMT_SIGPENGIND参数定义，在执行setrlimit()系统调用时确定该大小。Nginx提供了worker_rlimit_sigpending参数用于调节这种情况下的事件信号队列长度。<br>当rtsig队列发生溢出时，Nginx将暂时停止使用rtsig模型，而调用poll库处理未处理的事件，直到rgsit信号队列全部清空，然后再次启动rtsig模型，以防止新的溢出发生。<br>Nginx在配置文件中提供了相关参数对rtsig模型的使用配置。编译Nginx服务器时，使用–with-rtsig_module配置选项来启用rtsig模型的编译。</p><h4 id="其他事件驱动模型"><a href="#其他事件驱动模型" class="headerlink" title="其他事件驱动模型"></a>其他事件驱动模型</h4><p>除了以上四种主要的事件驱动模型，Nginx服务器针对特定的Linux平台提供了响应的事件驱动模型支持。目前实现的主要有kqueue模型、/dev/poll模型和eventport模型等。</p><ul><li><strong>kqueue模型</strong>，是用于支持BSD系列平台的高效事件驱动模型，主要用在FreeBSD 4.1及以上版本、OpenBSD 2.9及以上版本、NetBSD 2.0及以上版本以及Mac OS X平台上。该模型也是poll库的一个变种，其和epoll库的处理方式没有本质上的区别，都是通过避免轮询操作提供效率。该模型同时支持条件触发（level-triggered,也叫水平触发，只要满足条件就触发一个事件）和边缘触发（edge-triggered，每当状态变化时，触发一个事件）。如果大家在这些平台下使用Nginx服务器，建议选在该模型用于请求处理，以提高Nginx服务器的处理性能。</li><li><strong>/dev/poll模型</strong>，适用于支持Unix衍生平台的高效事件驱动模型，其主要在Solaris711/99及以上版本、HP/UX 11.22及以上版本、IRIX 6.5.15及以上版本和Tru64 UNIX 5.1A及以上版本的平台中使用。该模型是Sun公司在开发Solaris系列平台时提出的用于完成事件驱动机制的方案，它使用了虚拟的/dev/poll设备，开发人员可以将要监视的文件描述符加入这个设备，然后通过ioctl()调用来获取事件通知。在以上提到的平台中，建议使用该模型处理请求。</li><li><strong>eventport模型</strong>，适用于支持Solaris 10及以上版本平台的高效事件驱动模型。该模型也是Sun公司在开发Solaris系列平台时提出的用于完成事件驱动机制的方案，它可以有效防止内核崩溃情况的发生。Nginx服务器为此提供了支持。</li></ul><p>以上就是Nginx服务器支持的事件驱动库。可以看到，Nginx服务器针对不同的Linux或Unix衍生平台提供了多种事件驱动模型的处理，尽量发挥系统平台本身的优势，最大程度地提高处理客户端请求事件的能力。在实际工作中，我们需要根据具体情况和应用情景选择使用不同的事件驱动模型，以保证Nginx服务器的高效运行。</p><h4 id="select、poll、epoll-区别总结："><a href="#select、poll、epoll-区别总结：" class="headerlink" title="select、poll、epoll 区别总结："></a>select、poll、epoll 区别总结：</h4><p><strong>1、支持一个进程所能打开的最大连接数</strong></p><style type="text/css">    table th:first-of-type{        width: 10%;    }</style><table><thead><tr><th>select</th><th>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</th></tr></thead><tbody><tr><td>poll</td><td>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td></tr><tr><td>epoll</td><td>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</td></tr></tbody></table><p><strong>2、FD剧增后带来的IO效率问题</strong></p><table><thead><tr><th>select</th><th>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</th></tr></thead><tbody><tr><td>poll</td><td>同上</td></tr><tr><td>epoll</td><td>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</td></tr></tbody></table><p><strong>3、 消息传递方式</strong></p><table><thead><tr><th>select</th><th>内核需要将消息传递到用户空间，都需要内核拷贝动作</th></tr></thead><tbody><tr><td>poll</td><td>同上</td></tr><tr><td>epoll</td><td>epoll通过内核和用户空间共享一块内存来实现的。</td></tr></tbody></table><p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。<br>1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。<br>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是事件驱动模型？&quot;&gt;&lt;a href=&quot;#什么是事件驱动模型？&quot; class=&quot;headerlink&quot; title=&quot;什么是事件驱动模型？&quot;&gt;&lt;/a&gt;什么是事件驱动模型？&lt;/h4&gt;&lt;p&gt;在计算机编程领域，事件驱动模型对应一种程序设计方式，Event-driven programming，即事件驱动程序设计。事件驱动模型一般是由事件收集器，事件发送器，事件处理器三部分基本单元组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件收集器专门负责收集所有的事件，包括来自用户的（如鼠标单击事件、键盘输入事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。&lt;/li&gt;
&lt;li&gt;事件发送器负责将收集器收集到的事件分发到目标对象中。目标对象就是事件处理器所处的位置。&lt;/li&gt;
&lt;li&gt;事件处理器主要负责具体事件的响应工作，它往往要到实现阶段才完全确定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件驱动程序可以由任何编程语言来实现，只是难易程度有别。如果一个系统是以事件驱动程序模型作为编程基础的，那么，它的架构基本上是这样的：预先设计一个事件循环所形成的程序，这个事件循环程序构成了“事件收集器”，它不断地检查目前要处理的事件信息，然后使用“事件发送器”传递给“事件处理器”。“事件处理器”一般运用虚函数机制来实现。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx + FastCGI运行原理</title>
    <link href="http://yoursite.com/2018/04/09/Nginx-FastCGI%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/09/Nginx-FastCGI运行原理/</id>
    <published>2018-04-09T07:17:41.000Z</published>
    <updated>2018-04-09T08:28:30.314Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、什么是-FastCGI"><a href="#1、什么是-FastCGI" class="headerlink" title="1、什么是 FastCGI"></a>1、什么是 FastCGI</h4><p>FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等。同时，FastCGI也被许多脚本语言支持，其中就有PHP。</p><p>FastCGI是从CGI发展改进而来的。传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后将结果返回给HTTP服务器。这在处理高并发访问时几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少使用了。<br><a id="more"></a><br>FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p><h4 id="2、Nginx-FastCGI运行原理"><a href="#2、Nginx-FastCGI运行原理" class="headerlink" title="2、Nginx+FastCGI运行原理"></a>2、Nginx+FastCGI运行原理</h4><p>Nginx不支持对外部程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket（这个socket可以是文件socket，也可以是ip socket）。</p><p>wrapper：为了调用CGI程序，还需要一个FastCGI的wrapper（wrapper可以理解为用于启动另一个程序的程序），这个wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接收到请求，然后Fork(派生）出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据（html页面或者图片）发送给客户端。这就是Nginx+FastCGI的整个运作过程，如图1-3所示。<br><img src="/uploads/2018/04/nginx_fastcgi.png" alt=""></p><p>所以，我们首先需要一个wrapper，这个wrapper需要完成的工作：</p><ol><li>通过调用fastcgi（库）的函数通过socket和ningx通信（读写socket是fastcgi内部实现的功能，对wrapper是非透明的）</li><li>调度thread，进行fork和kill</li><li>和application（php）进行通信</li></ol><h4 id="3、spawn-fcgi与PHP-FPM"><a href="#3、spawn-fcgi与PHP-FPM" class="headerlink" title="3、spawn-fcgi与PHP-FPM"></a>3、spawn-fcgi与PHP-FPM</h4><p>FastCGI接口方式在脚本解析服务器上启动一个或者多个守护进程对动态脚本进行解析，这些进程就是FastCGI进程管理器，或者称为FastCGI引擎。 spawn-fcgi与PHP-FPM就是支持PHP的两个FastCGI进程管理器。因此HTTPServer完全解放出来，可以更好地进行响应和并发处理。</p><blockquote><p>spawn-fcgi与PHP-FPM的异同：<br>1）spawn-fcgi是HTTP服务器lighttpd的一部分，目前已经独立成为一个项目，一般与lighttpd配合使用来支持PHP。但是ligttpd的spwan-fcgi在高并发访问的时候，会出现内存泄漏甚至自动重启FastCGI的问题。即：PHP脚本处理器当机，这个时候如果用户访问的话，可能就会出现白页(即PHP不能被解析或者出错)。<br>2）Nginx是个轻量级的HTTP server，必须借助第三方的FastCGI处理器才可以对PHP进行解析，因此其实这样看来nginx是非常灵活的，它可以和任何第三方提供解析的处理器实现连接从而实现对PHP的解析(在nginx.conf中很容易设置)。nginx也可以使用spwan-fcgi(需要一同安装lighttpd，但是需要为nginx避开端口，一些较早的blog有这方面安装的教程)，但是由于spawn-fcgi具有上面所述的用户逐渐发现的缺陷，现在慢慢减少用nginx+spawn-fcgi组合了。</p></blockquote><p>由于spawn-fcgi的缺陷，现在出现了第三方(目前已经加入到PHP core中)的PHP的FastCGI处理器PHP-FPM，它和spawn-fcgi比较起来有如下优点：</p><ul><li>由于它是作为PHP的patch补丁来开发的，安装的时候需要和php源码一起编译，也就是说编译到php core中了，因此在性能方面要优秀一些；</li><li>同时它在处理高并发方面也优于spawn-fcgi，至少不会自动重启fastcgi处理器。因此，推荐使用Nginx+PHP/PHP-FPM这个组合对PHP进行解析。</li><li>相对Spawn-FCGI，PHP-FPM在CPU和内存方面的控制都更胜一筹，而且前者很容易崩溃，必须用crontab进行监控，而PHP-FPM则没有这种烦恼。</li><li>FastCGI 的主要优点是把动态语言和HTTP Server分离开来，所以Nginx与PHP/PHP-FPM经常被部署在不同的服务器上，以分担前端Nginx服务器的压力，使Nginx专一处理静态请求和转发动态请求，而PHP/PHP-FPM服务器专一解析PHP动态请求。</li></ul><h4 id="4、Nginx-PHP-FPM"><a href="#4、Nginx-PHP-FPM" class="headerlink" title="4、Nginx+PHP-FPM"></a>4、Nginx+PHP-FPM</h4><p>PHP-FPM是管理FastCGI的一个管理器，它作为PHP的插件存在，在安装PHP要想使用PHP-FPM时在老php的老版本（php5.3.3之前）就需要把PHP-FPM以补丁的形式安装到PHP中，而且PHP要与PHP-FPM版本一致，这是必须的）</p><p>PHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。<br>PHP5.3.3已经集成php-fpm了，不再是第三方的包了。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多优点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。</p><p>fastcgi已经在php5.3.5的core中了，不必在configure时添加 –enable-fastcgi了。老版本如php5.2的需要加此项。</p><p><strong>当我们安装Nginx和PHP-FPM完后，配置信息：</strong></p><blockquote><p>PHP-FPM的默认配置php-fpm.conf：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listen_address  127.0.0.1:9000 #这个表示php的fastcgi进程监听的ip地址以及端口</span><br><span class="line">start_servers</span><br><span class="line">min_spare_servers</span><br><span class="line">max_spare_servers</span><br></pre></td></tr></table></figure></p><p>Nginx配置运行php： 编辑nginx.conf加入如下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root html;   </span><br><span class="line">    fastcgi_pass 127.0.0.1:9000; 指定了fastcgi进程侦听的端口,nginx就是通过这里与php交互的</span><br><span class="line">    fastcgi_index index.php;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME   /usr/local/nginx/html$fastcgi_script_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>Nginx通过location指令，将所有以php为后缀的文件都交给127.0.0.1:9000来处理，而这里的IP地址和端口就是FastCGI进程监听的IP地址和端口。</p><p><strong>其整体工作流程：</strong><br>1)  FastCGI进程管理器php-fpm自身初始化，启动主进程php-fpm和启动start_servers个CGI 子进程。<br>    主进程php-fpm主要是管理fastcgi子进程，监听9000端口。<br>    fastcgi子进程等待来自Web Server的连接。<br>2)  当客户端请求到达Web Server Nginx是时，Nginx通过location指令，将所有以php为后缀的文件都交给127.0.0.1:9000来处理，即Nginx通过location指令，将所有以php为后缀的文件都交给127.0.0.1:9000来处理。<br>3)  FastCGI进程管理器PHP-FPM选择并连接到一个子进程CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程。<br>4)  FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。<br>5)  FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在 WebServer中）的下一个连接。</p><h4 id="5、Nginx-PHP正确配置"><a href="#5、Nginx-PHP正确配置" class="headerlink" title="5、Nginx+PHP正确配置"></a>5、Nginx+PHP正确配置</h4><p>一般web都做统一入口：把PHP请求都发送到同一个文件上，然后在此文件里通过解析「REQUEST_URI」实现路由。</p><p>Nginx配置文件分为好多块，常见的从外到内依次是「http」、「server」、「location」等等，缺省的继承关系是从外到内，也就是说内层块会自动获取外层块的值作为缺省值。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 80;  </span><br><span class="line">    server_name foo.com;  </span><br><span class="line">    root /path;  </span><br><span class="line">    location / &#123;  </span><br><span class="line">        index index.html index.htm index.php;  </span><br><span class="line">        if (!-e $request_filename) &#123;  </span><br><span class="line">            rewrite . /index.php last;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    location ~ \.php$ &#123;  </span><br><span class="line">        include fastcgi_params;  </span><br><span class="line">        fastcgi_param SCRIPT_FILENAME /path$fastcgi_script_name;  </span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;  </span><br><span class="line">        fastcgi_index index.php;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>1) 不应该在location 模块定义index</strong><br>一旦未来需要加入新的「location」，必然会出现重复定义的「index」指令，这是因为多个「location」是平级的关系，不存在继承，此时应该在「server」里定义「index」，借助继承关系，「index」指令在所有的「location」中都能生效。</p><p><strong>2) 使用try_files</strong><br>接下来看看「if」指令，说它是大家误解最深的Nginx指令毫不为过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!-e $request_filename) &#123;</span><br><span class="line">    rewrite . /index.php last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很多人喜欢用「if」指令做一系列的检查，不过这实际上是「try_files」指令的职责：<br><code>try_files $uri $uri/ /index.php;</code></p><p>除此以外，初学者往往会认为「if」指令是内核级的指令，但是实际上它是rewrite模块的一部分，加上Nginx配置实际上是声明式的，而非过程式的，所以当其和非rewrite模块的指令混用时，结果可能会非你所愿。</p><p><strong>3）fastcgi_params」配置文件：</strong><br><code>include fastcgi_params;</code></p><p>Nginx有两份fastcgi配置文件，分别是「fastcgi_params」和「fastcgi.conf」，它们没有太大的差异，唯一的区别是后者比前者多了一行「SCRIPT_FILENAME」的定义：<br><code>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</code></p><p>注意：$document_root 和 $fastcgi_script_name 之间没有 /。<br>原本Nginx只有「fastcgi_params」，后来发现很多人在定义「SCRIPT_FILENAME」时使用了硬编码的方式，于是为了规范用法便引入了「fastcgi.conf」。</p><p>不过这样的话就产生一个疑问：为什么一定要引入一个新的配置文件，而不是修改旧的配置文件？这是因为「fastcgi_param」指令是数组型的，和普通指令相同的是：内层替换外层；和普通指令不同的是：当在同级多次使用的时候，是新增而不是替换。换句话说，如果在同级定义两次「SCRIPT_FILENAME」，那么它们都会被发送到后端，这可能会导致一些潜在的问题，为了避免此类情况，便引入了一个新的配置文件。</p><p>此外，我们还需要考虑一个安全问题：在PHP开启「cgi.fix_pathinfo」的情况下，PHP可能会把错误的文件类型当作PHP文件来解析。如果Nginx和PHP安装在同一台服务器上的话，那么最简单的解决方法是用「try_files」指令做一次过滤：<br><code>try_files $uri =404;</code></p><p>依照前面的分析，给出一份改良后的版本，是不是比开始的版本清爽了很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 80;  </span><br><span class="line">    server_name foo.com;  </span><br><span class="line">    root /path;  </span><br><span class="line">    index index.html index.htm index.php;  </span><br><span class="line">    location / &#123;  </span><br><span class="line">        try_files $uri $uri/ /index.php;  </span><br><span class="line">    &#125;  </span><br><span class="line">    location ~ \.php$ &#123;  </span><br><span class="line">       try_files $uri =404;  </span><br><span class="line">       include fastcgi.conf;  </span><br><span class="line">       fastcgi_pass 127.0.0.1:9000;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、什么是-FastCGI&quot;&gt;&lt;a href=&quot;#1、什么是-FastCGI&quot; class=&quot;headerlink&quot; title=&quot;1、什么是 FastCGI&quot;&gt;&lt;/a&gt;1、什么是 FastCGI&lt;/h4&gt;&lt;p&gt;FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等。同时，FastCGI也被许多脚本语言支持，其中就有PHP。&lt;/p&gt;
&lt;p&gt;FastCGI是从CGI发展改进而来的。传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后将结果返回给HTTP服务器。这在处理高并发访问时几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少使用了。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 概述及工作原理</title>
    <link href="http://yoursite.com/2018/04/09/Nginx-%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/09/Nginx-概述及工作原理/</id>
    <published>2018-04-09T07:17:01.000Z</published>
    <updated>2018-04-09T09:17:03.708Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、nginx概述"><a href="#一、nginx概述" class="headerlink" title="一、nginx概述"></a>一、nginx概述</h4><p>Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强。</p><h5 id="1、什么是nginx？"><a href="#1、什么是nginx？" class="headerlink" title="1、什么是nginx？"></a>1、什么是nginx？</h5><p>Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。Nginx 是由俄罗斯人 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，它已经在该站点运行超过两年半了。Igor Sysoev 在建立的项目时,使用基于 BSD 许可。<br><a id="more"></a></p><p>Nginx 以<font color="red">事件驱动</font>的方式编写，所以有非常好的性能，同时也是<font color="red">一个非常高效的反向代理、负载平衡</font>。其拥有匹配 Lighttpd 的性能，同时还没有 Lighttpd 的内存泄漏问题，而且 Lighttpd 的 mod_proxy 也有一些问题并且很久没有更新。</p><p>现在，Igor 将源代码以类 BSD 许可证的形式发布。Nginx 因为它的稳定性、丰富的模块库、灵活的配置和低系统资源的消耗而闻名．业界一致认为它是 Apache2.2＋mod_proxy_balancer 的轻量级代替者，不仅是因为响应静态页面的速度非常快，而且它的模块数量达到 Apache 的近 2/3。对 proxy 和 rewrite 模块的支持很彻底，还支持 mod_fcgi、ssl、vhosts ，适合用来做 mongrel clusters 的前端 HTTP 响应。</p><h5 id="2、nginx的特点"><a href="#2、nginx的特点" class="headerlink" title="2、nginx的特点"></a>2、nginx的特点</h5><p>Nginx 做为 HTTP 服务器，有以下几项基本特性：</p><ul><li>处理静态文件，索引文件以及自动索引；打开文件描述符缓冲．</li><li>无缓存的反向代理加速，简单的负载均衡和容错．</li><li>FastCGI，简单的负载均衡和容错．</li><li>模块化的结构。包括 gzipping, byte ranges, chunked responses,以及 SSI-filter 等 filter。如果由 FastCGI 或其它代理服务器处理单页中存在的多个 SSI，则这项处理可以并行运行，而不需要相互等待。</li><li>支持 SSL 和 TLSSNI．</li></ul><p>Nginx 专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率 。它支持内核 Poll 模型，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。</p><p>Nginx 具有很高的稳定性。其它 HTTP 服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前 apache 一旦上到 200 个以上进程，web响应速度就明显非常缓慢了。而 Nginx 采取了分阶段资源分配技术，使得它的 CPU 与内存占用率非常低。Nginx 官方表示保持 10,000 个没有活动的连接，它只占 2.5M 内存，所以类似 DOS 这样的攻击对 Nginx 来说基本上是毫无用处的。就稳定性而言,Nginx 比 lighthttpd 更胜一筹。</p><p>Nginx 支持热部署。它的启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。</p><h4 id="二、nginx的架构"><a href="#二、nginx的架构" class="headerlink" title="二、nginx的架构"></a>二、nginx的架构</h4><p>众所周知，Nginx 性能高，而 Nginx 的高性能与其架构是分不开的。那么 Nginx 究竟是怎么样的呢？</p><p>Nginx 在启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程。我们也可以手动地关掉后台模式，让 Nginx 在前台运行，并且通过配置让 Nginx 取消 master 进程，从而可以使 Nginx 以单进程方式运行。很显然，生产环境下我们肯定不会这么做，所以关闭后台模式，一般是用来调试用的。所以，我们可以看到，Nginx 是以多进程的方式来工作的，当然 Nginx 也是支持多线程的方式的，只是我们主流的方式还是多进程的方式，也是 Nginx 的默认方式。Nginx 采用多进程的方式有诸多好处，所以我就主要讲解 Nginx 的多进程模式吧。</p><h5 id="1、Nginx-的进程模型"><a href="#1、Nginx-的进程模型" class="headerlink" title="1、Nginx 的进程模型"></a>1、Nginx 的进程模型</h5><p>刚才讲到，Nginx 在启动后，会有一个 master 进程和多个 worker 进程。<strong>master 进程主要用来管理 worker 进程，包含：接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动新的 worker 进程。而基本的网络事件，则是放在 worker 进程中来处理了。多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。</strong><font color="red">一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求。</font> worker 进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的<em>原因与 Nginx 的进程模型以及事件处理模型是分不开的</em>。Nginx 的进程模型，可以由下图来表示：<br><img src="/uploads/2018/04/nginx-chapter-01.png" alt=""></p><p>在 Nginx 启动后，如果我们要操作 Nginx，要怎么做呢？从上文中我们可以看到，master 来管理 worker 进程，所以我们只需要与 master 进程通信就行了。master 进程会接收来自外界发来的信号，再根据信号做不同的事情。所以我们要控制 Nginx，只需要通过 kill 向 master 进程发送信号就行了。比如kill -HUP pid，则是告诉 Nginx，从容地重启 Nginx，我们一般用这个信号来重启 Nginx，或重新加载配置，因为是从容地重启，因此服务是不中断的。master 进程在接收到 HUP 信号后是怎么做的呢？<font color="red">首先 master 进程在接到信号后，会先重新加载配置文件，然后再启动新的 worker 进程，并向所有老的 worker 进程发送信号，告诉他们可以光荣退休了。新的 worker 在启动后，就开始接收新的请求，而老的 worker 在收到来自 master 的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。</font>当然，直接给 master 进程发送信号，这是比较老的操作方式，Nginx 在 0.8 版本之后，引入了一系列命令行参数，来方便我们管理。比如，./nginx -s reload，就是来重启 Nginx，./nginx -s stop，就是来停止 Nginx 的运行。如何做到的呢？我们还是拿 reload 来说，我们看到，<font color="red">执行命令时，我们是启动一个新的 Nginx 进程，而新的 Nginx 进程在解析到 reload 参数后，就知道我们的目的是控制 Nginx 来重新加载配置文件了，它会向 master 进程发送信号，然后接下来的动作，就和我们直接向 master 进程发送信号一样了。</font></p><p>现在，我们知道了当我们在操作 Nginx 的时候，Nginx 内部做了些什么事情，那么，worker 进程又是如何处理请求的呢？我们前面有提到，<font color="red">worker 进程之间是平等的，每个进程，处理请求的机会也是一样的。</font>当我们提供 80 端口的 http 服务时，一个连接请求过来，每个进程都有可能处理这个连接，怎么做到的呢？首先，每个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面，先建立好需要 listen 的 socket（listenfd）<font color="red">（socket不知道是啥的，可点击查询）</font>之后，然后再 fork 出多个 worker 进程。所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当一个 worker 进程在 accept 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，<font color="red">一个请求，完全由 worker 进程来处理，而且只在一个 worker 进程中处理。</font></p><p>那么，Nginx 采用这种进程模型有什么好处呢？当然，好处肯定会很多了。首先，对于每个 worker 进程来说，独立的进程，不需要加锁<strong>（因为需要争抢处理请求，不使用accept_mutex接受互斥量，会导致多个worker进程处理一个请求的混乱结果）</strong>，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的 worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。当然，好处还有很多，大家可以慢慢体会。</p><h5 id="2、Nginx-事件模型"><a href="#2、Nginx-事件模型" class="headerlink" title="2、Nginx 事件模型"></a>2、Nginx 事件模型</h5><p>上面讲了很多关于 Nginx 的进程模型，接下来，我们来看看 Nginx 是如何处理事件的。</p><p>有人可能要问了，Nginx 采用多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限啊，多少个 worker 就能处理多少个并发，何来高并发呢？非也，这就是 Nginx 的高明之处，<font color="red">Nginx 采用了异步非阻塞的方式来处理请求，也就是说，Nginx 是可以同时处理成千上万个请求的。</font>想想 apache 的常用工作方式（apache 也有异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），每个请求会独占一个工作线程，当并发数上到几千时，就同时有几千的线程在处理请求了。这对操作系统来说，是个不小的挑战，线程带来的内存占用非常大，线程的上下文切换带来的 cpu 开销很大，自然性能就上不去了，而这些开销完全是没有意义的。</p><p>为什么 Nginx 可以采用异步非阻塞的方式来处理呢，或者异步非阻塞到底是怎么回事呢？我们先回到原点，看看一个请求的完整过程。<strong>首先，请求过来，要建立连接，然后再接收数据，接收数据后，再发送数据。具体到系统底层，就是读写事件，而当读写事件没有准备好时，必然不可操作，如果不用非阻塞的方式来调用，那就得阻塞调用了，事件没有准备好，那就只能等了，等事件准备好了，你再继续吧。阻塞调用会进入内核等待，cpu 就会让出去给别人用了，<font color="red">对单线程的 worker 来说</font>，显然不合适，当网络事件越多时，大家都在等待呢，cpu 空闲下来没人用，cpu利用率自然上不去了，更别谈高并发了。</strong>好吧，你说加进程数，这跟apache的线程模型有什么区别，注意，别增加无谓的上下文切换。所以，<font color="red">在 Nginx 里面，最忌讳阻塞的系统调用了。</font>不要阻塞，那就非阻塞喽。非阻塞就是，事件没有准备好，马上返回 EAGAIN，告诉你，事件还没准备好呢，你慌什么，过会再来吧。好吧，你过一会，再来检查一下事件，直到事件准备好了为止，在这期间，你就可以先去做其它事情，然后再来看看事件好了没。虽然不阻塞了，但你得不时地过来检查一下事件的状态，你可以做更多的事情了，但带来的开销也是不小的。所以，才会有了<font color="red">异步非阻塞的事件处理机制</font>，<strong>具体到系统调用就是像 select/poll/epoll/kqueue 这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。</strong><font color="red">这种机制正好解决了我们上面的两个问题，拿 epoll 为例(在后面的例子中，我们多以 epoll 为例子，以代表这一类函数)，当事件没准备好时，放到 epoll 里面，事件准备好了，我们就去读写，当读写返回 EAGAIN 时，我们将它再次加入到 epoll 里面。这样，只要有事件准备好了，我们就去处理它，只有当所有事件都没准备好时，才在 epoll 里面等着。这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。</font><strong>与多线程相比，这种事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常的轻量级。</strong>并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。 我之前有对连接数进行过测试，在 24G 内存的机器上，处理的并发请求数达到过 200 万。现在的网络服务器基本都采用这种方式，这也是nginx性能高效的主要原因。</p><p>我们之前说过，<font color="red">推荐设置 worker 的个数为 cpu 的核数，在这里就很容易理解了，更多的 worker 数，只会导致进程来竞争 cpu 资源了，从而带来不必要的上下文切换。</font>而且，nginx为了更好的利用多核特性，提供了 cpu 亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来 cache 的失效。像这种小的优化在 Nginx 中非常常见，同时也说明了 Nginx 作者的苦心孤诣。比如，Nginx 在做 4 个字节的字符串比较时，会将 4 个字符转换成一个 int 型，再作比较，以减少 cpu 的指令数等等。</p><p>现在，知道了 Nginx 为什么会选择这样的进程模型与事件模型了。对于一个基本的 Web 服务器来说，事件通常有三种类型，网络事件、信号、定时器。从上面的讲解中知道，网络事件通过异步非阻塞可以很好的解决掉。如何处理信号与定时器？</p><p>首先，<font color="red">信号的处理</font>。对 Nginx 来说，有一些特定的信号，代表着特定的意义。信号会中断掉程序当前的运行，在改变状态后，继续执行。如果是系统调用，则可能会导致系统调用的失败，需要重入。关于信号的处理，大家可以学习一些专业书籍，这里不多说。对于 Nginx 来说，如果nginx正在等待事件（epoll_wait 时），如果程序收到信号，在信号处理函数处理完后，epoll_wait 会返回错误，然后程序可再次进入 epoll_wait 调用。</p><p>另外，再来看看<font color="red">定时器</font>。由于 epoll_wait 等函数在调用的时候是可以设置一个超时时间的，所以 Nginx 借助这个超时时间来实现定时器。nginx里面的定时器事件是放在一颗维护定时器的红黑树里面，每次在进入 epoll_wait前，先从该红黑树里面拿到所有定时器事件的最小时间，在计算出 epoll_wait 的超时时间后进入 epoll_wait。所以，当没有事件产生，也没有中断信号时，epoll_wait 会超时，也就是说，定时器事件到了。这时，nginx会检查所有的超时事件，将他们的状态设置为超时，然后再去处理网络事件。由此可以看出，当我们写 Nginx 代码时，在处理网络事件的回调函数时，通常做的第一个事情就是判断超时，然后再去处理网络事件。</p><p>我们可以用一段伪代码来总结一下 Nginx 的事件处理模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    for t in run_tasks:</span><br><span class="line">        t.handler();</span><br><span class="line">    update_time(&amp;now);</span><br><span class="line">    timeout = ETERNITY;</span><br><span class="line">    for t in wait_tasks: /* sorted already */</span><br><span class="line">        if (t.time &lt;= now) &#123;</span><br><span class="line">            t.timeout_handler();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timeout = t.time - now;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    nevents = poll_function(events, timeout);</span><br><span class="line">    for i in nevents:</span><br><span class="line">        task t;</span><br><span class="line">        if (events[i].type == READ) &#123;</span><br><span class="line">            t.handler = read_handler;</span><br><span class="line">        &#125; else &#123; /* events[i].type == WRITE */</span><br><span class="line">            t.handler = write_handler;</span><br><span class="line">        &#125;</span><br><span class="line">        run_tasks_add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好，本节我们讲了进程模型，事件模型，包括网络事件，信号，定时器事件。</p><h4 id="三、Nginx的工作原理"><a href="#三、Nginx的工作原理" class="headerlink" title="三、Nginx的工作原理"></a>三、Nginx的工作原理</h4><p>nginx 主要用于Web和代理服务器，接收请求，对请求进行解析，静态资源直接返回，动态请求转发到后端做处理。由上面对nginx的架构进行解析知道，nginx常采用多进程的工作方式，nginx启动后，会有一个master进程和多个worker进程生成。master进程主要用来管理worker进程，而worker进程主要就是用来处理请求的，多个worker进程之间是对等的，他们同等竞争客户端的请求，相互之间是独立的。</p><p>每个worker进程中只有一个主线程，且采用异步非阻塞的事件处理机制来处理请求。假设机制处理采用的是epoll，主线程就会循环epoll，如果发现事件已经准备好了，就进行处理，否则再次放入epoll，继续循环。epoll中的请求数就是worker进程的连接数。因此就可处理大量的并发了。要注意，worker同一时间只能处理一个请求（因为只有一个主线程），会来回进行请求切换处理。但是，请求间的切换是没有代价的，切换也是因为异步事件未准备好，而主动让出的。</p><blockquote><font color="red"><strong>工作原理要点：</strong><br>1. nginx采用多进程的工作方式，进程模型是master-worker形式。（注：常采用多进程方式，也有多线程，单进程方式）<br>2. worker处理请求时采用异步非阻塞的处理方式。因此可支持高并发。<br>3. 进程间、线程间是没有上下文切换，仅仅只是请求切换，是没有任何代价的。（注：进程与进程间是相互独立的；每个请求仅且只可在一个worker进程中完成；worker进程中只包含一个主线程；请求间的切换是通过循环事件来实现的。）</font></blockquote><h4 id="四、Nginx相关问题"><a href="#四、Nginx相关问题" class="headerlink" title="四、Nginx相关问题"></a>四、Nginx相关问题</h4><h5 id="1、nginx为啥性能高？"><a href="#1、nginx为啥性能高？" class="headerlink" title="1、nginx为啥性能高？"></a>1、nginx为啥性能高？</h5><p>（1）nginx采用的是多进程模型<br>首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。<br>其次，采用独立的进程，可以让相互之间不会影响，一个进程退出之后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。当然，worker进程的异常退出，肯定是程序出BUG了，异常退出，会导致当前的worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险。<br>（2）nginx采用多进程事件模型：异步非阻塞<br>虽然nginx采用多worker的方式来处理请求，每个worker里面只有一个主线程，那能够处理的并发数很有限啊，多少个worker就能处理多少个并发，何来高并发呢？非也，这就是nginx的高明之处，nginx采用了异步非阻塞的方式来处理请求，也就是说，nginx是可以同时处理成千上万个请求的。一个worker进程可以同时处理的请求数只受限于内存大小，而且在架构设计上，不同的worker进程之间处理并发请求时几乎没有同步锁的限制，worker进程通常不会进入睡眠状态，因此，当Nginx上的进程数与CPU核心数相等时（最好每一个worker进程都绑定特定的CPU核心），进程间切换的代价是最小的。</p><p>而apache的常用工作方式（apache也有异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），每个进程在一个时刻只处理一个请求，因此，当并发数上到几千时，就同时有几千的进程在处理请求了。这对操作系统来说，是个不小的挑战，进程带来的内存占用非常大，进程的上下文切换带来的cpu开销很大，自然性能就上不去了，而这些开销完全是没有意义的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、nginx概述&quot;&gt;&lt;a href=&quot;#一、nginx概述&quot; class=&quot;headerlink&quot; title=&quot;一、nginx概述&quot;&gt;&lt;/a&gt;一、nginx概述&lt;/h4&gt;&lt;p&gt;Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强。&lt;/p&gt;
&lt;h5 id=&quot;1、什么是nginx？&quot;&gt;&lt;a href=&quot;#1、什么是nginx？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是nginx？&quot;&gt;&lt;/a&gt;1、什么是nginx？&lt;/h5&gt;&lt;p&gt;Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。Nginx 是由俄罗斯人 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，它已经在该站点运行超过两年半了。Igor Sysoev 在建立的项目时,使用基于 BSD 许可。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>面试 - 常见算法试题总结（PHP）</title>
    <link href="http://yoursite.com/2018/04/08/%E9%9D%A2%E8%AF%95-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/08/面试-常见算法试题总结/</id>
    <published>2018-04-08T09:52:05.000Z</published>
    <updated>2018-04-08T10:35:28.367Z</updated>
    
    <content type="html"><![CDATA[<p>试题目录：<br>1、斐波那契数列实现<br>2、楼梯有s阶台阶,上楼时可以一步上1阶,也可以一步上2阶，编程计算共有多少种不同的走法。<br>3、输入两个整数n和m，从数列1，2…….n中随意取几个数，使其和等于m，要求将其中所有的可能组合列出来。<br>4、求一个数组的最长递减子序列 比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，4，3，2}。<br>5、一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。<br>6、输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。例如输入“I am a student.”，则输出“student. a am I”。</p><a id="more"></a><hr><blockquote><p><strong>递归算法思想：</strong><br>1.递归过程一般通过函数或子过程实现；<br>2.递归算法在函数或子过程的内部，直接或间接调用自己的算法<br>3.递归算法实际上是把问题转化为规模缩小了的同类问题的子问题，然后再递归调用函数或过程来表示问题的解</p><font color="red">注意：必须有一个明确的递归结束条件；如果递归次数过多，容易造成栈溢出。</font></blockquote><hr><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><p>问题描述：<br>斐波那契数列： 1 1 2 3 5 8 13 21 34 55 …<br>概念：<br>前两个值都为1，该数列从第三位开始，每一位都是当前位前两位的和<br>规律公式为： <code>Fn = F(n-1) + F(n+1)</code></p><ul><li>F：指当前这个数列 </li><li>n：指数列的下标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* 非递归实现 */</span><br><span class="line">function fbnq($n)&#123;</span><br><span class="line">if($n&lt;=0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">$arr[1] = $arr[2] = 1;</span><br><span class="line">for($i=3; $i&lt;=$n; $i++)&#123;</span><br><span class="line">$arr[$i] = $arr[$i-1] + $arr[$i-2];</span><br><span class="line">&#125;</span><br><span class="line">return $arr;</span><br><span class="line">&#125;</span><br><span class="line">// echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">// var_dump(fbnq(10));</span><br><span class="line">/* 递归实现 */</span><br><span class="line">function fbnq_2($n)&#123;</span><br><span class="line">if($n &lt;= 0) return 0;</span><br><span class="line">static $arr;</span><br><span class="line">$arr[1] = $arr[2] = 1;</span><br><span class="line">    if($n &gt; 3)&#123;</span><br><span class="line">    fbnq_2($n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    $arr[$n] = $arr[$n-1] + $arr[$n-2];</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line">// var_dump(fbnq_2(10));</span><br></pre></td></tr></table></figure><h4 id="上台阶问题"><a href="#上台阶问题" class="headerlink" title="上台阶问题"></a>上台阶问题</h4><p>问题描述：楼梯有s阶台阶,上楼时可以一步上1阶,也可以一步上2阶，编程计算共有多少种不同的走法。</p><blockquote><p><strong>解题思路：</strong><br>此问题可分解为 f(n-1) + f(n-2) 种不同的走法。且结束条件为 小于等于 2（最多一步上2阶）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getStepSum($s)&#123;</span><br><span class="line">if($s &lt;= 0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;else if($s &lt;= 2)&#123;</span><br><span class="line">return $s;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return getStepSum($s-1)+getStepSum($s-2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// var_dump(getStepSum(3));</span><br></pre></td></tr></table></figure><h4 id="求数和问题"><a href="#求数和问题" class="headerlink" title="求数和问题"></a>求数和问题</h4><p>问题描述：输入两个整数n和m，从数列1，2…….n中随意取几个数，使其和等于m，要求将其中所有的可能组合列出来。</p><blockquote><p><strong>解题思路：</strong><br>输入sum和n，要求输出1,2…n里所有和为sum的组合<br>这是一个可划分子问题问题<br>若用f(sum, n)表示问题的界，则元素组合共有两种情况</p><ol><li>和为sum的组合里包括n，则f(sum, n) = f(sum - n, n - 1)</li><li>和为sum的组合里不包括n,则 f(sum, n) = f(sum, n - 1)<br>所以 f(sum, n) = f(sum - n, n - 1) U f(sum, n - 1)</li></ol><p>注：需要传入一个空数组来接收数，用于输出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function combination($sum, $n, $comb) &#123;</span><br><span class="line">if ($n &lt; 0 || $sum &lt; 0) &#123;</span><br><span class="line"> #当n &lt; 0或者sum &lt; 0都是不符合条件的结果</span><br><span class="line"> // print_r($comb);</span><br><span class="line"> // echo &quot;sum: &#123;$sum&#125; n: &#123;$n&#125;&lt;br&gt;&quot;;</span><br><span class="line"> return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($sum &lt; $n) &#123;</span><br><span class="line"> combination($sum, $sum, $comb); #sum &lt; n，则不可能需要比sum大的数来构成组合</span><br><span class="line"> return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#结果求得</span><br><span class="line">if ($sum == 0) &#123;</span><br><span class="line"> #输出元素组合</span><br><span class="line"> echo &quot;Combination: &quot;;</span><br><span class="line"> foreach ($comb as $val) &#123;</span><br><span class="line">     echo $val . &quot; &quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> echo &quot;&lt;br&gt;&quot;;</span><br><span class="line"> return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#组合里包含n的情况</span><br><span class="line">$comb[] = $n;</span><br><span class="line">combination($sum - $n, $n - 1, $comb);</span><br><span class="line"></span><br><span class="line">#组合里不包含n的情况</span><br><span class="line">array_pop($comb);</span><br><span class="line">combination($sum, $n - 1, $comb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最长递减子序列问题"><a href="#最长递减子序列问题" class="headerlink" title="最长递减子序列问题"></a>最长递减子序列问题</h4><p>问题描述：求一个数组的最长递减子序列 比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，4，3，2}。</p><blockquote><p><strong>解题思路：</strong><br>此问题就是比较大小的问题，把列表看成栈比较容易些（且是有序的栈）。与栈头比较大小，满足条件入栈，否则出栈。<br>注：需要判空数组的问题。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// $arr = [9, 4, 3, 2, 5, 4, 3, 1];</span><br><span class="line">$arr = [9, 4, 3, 2, 5, 4, 3, 1, 10, 8, 5, 3, 2, 1];</span><br><span class="line">function maxDescList($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$list[] = $arr[0];</span><br><span class="line">for($i=1; $i&lt;$len; $i++)&#123;</span><br><span class="line">$llen = count($list);</span><br><span class="line">for($j=$llen-1; $j&gt;=0; $j--)&#123;</span><br><span class="line">if($arr[$i] &gt; $list[$j])&#123;</span><br><span class="line">array_pop($list);</span><br><span class="line">if(empty($list))&#123;</span><br><span class="line">$list[] = $arr[$i];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">array_push($list, $arr[$i]);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $list;</span><br><span class="line">&#125;</span><br><span class="line">// echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">// var_dump(maxDescList($arr));</span><br></pre></td></tr></table></figure><h4 id="找重复出现的数字"><a href="#找重复出现的数字" class="headerlink" title="找重复出现的数字"></a>找重复出现的数字</h4><p>问题描述：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><blockquote><p><strong>解题思路：</strong><br>将整型数组看成栈比较容易理解。每次出栈一个元素，然后查询该值是否存在数组中。如果存在，说明数组该值有两个，然后删除该值（原因是如果不删除，出栈元素会再次重复一次，再出现就会出现错误。因为该值已经查询过）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$arr = [8, 5, 3, 4, 2, 4, 3, 5, 9, 8];</span><br><span class="line">function searchNum($arr)&#123;</span><br><span class="line">$list = array();</span><br><span class="line">while(!empty($arr))&#123;</span><br><span class="line">$val = array_pop($arr);</span><br><span class="line">if(!in_array($val, $arr))&#123;</span><br><span class="line">$list[] = $val;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$key = array_search($val, $arr);</span><br><span class="line">unset($arr[$key]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $list;</span><br><span class="line">&#125;</span><br><span class="line">// var_dump(searchNum($arr));</span><br></pre></td></tr></table></figure><h4 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h4><p>问题描述：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。例如输入<code>“I am a student.”</code>，则输出<code>“student. a am I”</code>。</p><blockquote><p><strong>解题思路：</strong><br>此题利用PHP函数很容易实现。<br>注：要注意使用 <code>array_reverse()</code> 数组翻转函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function strrevStr($str)&#123;</span><br><span class="line">$str_arr = explode(&quot; &quot;, $str);</span><br><span class="line">$reverse_arr = array_reverse($str_arr);</span><br><span class="line">return implode(&quot; &quot;, $reverse_arr);</span><br><span class="line">&#125;</span><br><span class="line">// $str = &quot;I am a student.&quot;;</span><br><span class="line">// echo strrevStr($str);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;试题目录：&lt;br&gt;1、斐波那契数列实现&lt;br&gt;2、楼梯有s阶台阶,上楼时可以一步上1阶,也可以一步上2阶，编程计算共有多少种不同的走法。&lt;br&gt;3、输入两个整数n和m，从数列1，2…….n中随意取几个数，使其和等于m，要求将其中所有的可能组合列出来。&lt;br&gt;4、求一个数组的最长递减子序列 比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，4，3，2}。&lt;br&gt;5、一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。&lt;br&gt;6、输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。例如输入“I am a student.”，则输出“student. a am I”。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试 - 常见函数试题总结（PHP）</title>
    <link href="http://yoursite.com/2018/04/03/%E9%9D%A2%E8%AF%95-%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/03/面试-常见函数试题总结/</id>
    <published>2018-04-03T07:14:51.000Z</published>
    <updated>2018-04-08T10:37:41.027Z</updated>
    
    <content type="html"><![CDATA[<p>试题目录：<br>1、写一个能创建多级目录的PHP函数<br>2、请写一段代码，确保多个进程同时写入一个文件成功<br>3、写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名<br>4、写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。<br>5、无限级分类<br><a id="more"></a></p><h4 id="1、写一个能创建多级目录的PHP函数"><a href="#1、写一个能创建多级目录的PHP函数" class="headerlink" title="1、写一个能创建多级目录的PHP函数"></a>1、写一个能创建多级目录的PHP函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function create_multidir($path, $mode=0777)&#123;</span><br><span class="line">if(is_dir($path))&#123;</span><br><span class="line">return &quot;目录已经存在！&quot;;</span><br><span class="line">&#125;else if(mkdir($path, $mode, true))&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、请写一段代码，确保多个进程同时写入一个文件成功"><a href="#2、请写一段代码，确保多个进程同时写入一个文件成功" class="headerlink" title="2、请写一段代码，确保多个进程同时写入一个文件成功"></a>2、请写一段代码，确保多个进程同时写入一个文件成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$fp = fopen($file, &apos;w+&apos;);</span><br><span class="line">if(flock($fp, LOCK_EX))&#123;</span><br><span class="line">//执行逻辑</span><br><span class="line">fwrite($fp, &quot;content&quot;);</span><br><span class="line">flock($fp, LOCK_UN);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo &quot;服务器繁忙...&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fclose($fp);</span><br></pre></td></tr></table></figure><h4 id="3、写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名"><a href="#3、写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名" class="headerlink" title="3、写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名"></a>3、写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名</h4><p>例如:<a href="http://www.sina.com.cn/abc/de/fg.php?id=1需要取出php或.php" target="_blank" rel="noopener">http://www.sina.com.cn/abc/de/fg.php?id=1需要取出php或.php</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getFileExtension($url)&#123;</span><br><span class="line">$url_arr = parse_url($url);</span><br><span class="line">$filename = basename($url_arr[&apos;path&apos;]);</span><br><span class="line">$file_arr = explode(&apos;.&apos;, $filename);</span><br><span class="line">return $file_arr[1];</span><br><span class="line">&#125;</span><br><span class="line">其中，最后获取扩展名，还可使用字符串截取函数。</span><br><span class="line">return strstr($filename, &apos;.&apos;);</span><br></pre></td></tr></table></figure></p><h4 id="4、写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。"><a href="#4、写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。" class="headerlink" title="4、写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。"></a>4、写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function getAllDirAndFile($path)&#123;</span><br><span class="line">$files = array();</span><br><span class="line">if(is_dir($path))&#123;</span><br><span class="line">$handle = opendir($path);</span><br><span class="line">while(($file=readdir($handle)) !== false)&#123;</span><br><span class="line">if($file != &apos;.&apos; &amp;&amp; $file != &apos;..&apos;)&#123;</span><br><span class="line">if(is_dir($path.&apos;/&apos;.$file))&#123;</span><br><span class="line">$files[$file] = getAllDirAndFile($path.&apos;/&apos;.$file);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$files[] = $file;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">closedir($handle);</span><br><span class="line">&#125;</span><br><span class="line">return $files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、无限级分类"><a href="#5、无限级分类" class="headerlink" title="5、无限级分类"></a>5、无限级分类</h4><p>创建类别表如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE category(</span><br><span class="line">cat_id smallint unsigned not null auto_increment primary key comment&apos;类别ID&apos;,</span><br><span class="line">cat_name VARCHAR(30)NOT NULL DEFAULT&apos;&apos;COMMENT&apos;类别名称&apos;,</span><br><span class="line">parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0 COMMENT&apos;类别父ID&apos;</span><br><span class="line">)engine=MyISAM charset=utf8;</span><br></pre></td></tr></table></figure></p><p>编写一个函数，递归遍历，实现无限分类。</p><p>代码实现：（结果显示层级分明）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getAllCategory($arr, $pid=0)&#123;</span><br><span class="line">$categories = array();</span><br><span class="line">foreach($arr as $val)&#123;</span><br><span class="line">if($val[&apos;parent_id&apos;] == $pid)&#123;</span><br><span class="line">$categories[$val[&apos;cat_id&apos;]] = $val;</span><br><span class="line">$categories[$val[&apos;cat_id&apos;]][&apos;childs&apos;] = getAllCategory($arr, $val[&apos;cat_id&apos;]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $categories;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码实现：（结果显示在一个层级，通过level标明层级）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getAllCategory($arr, $pid=0, $level)&#123;</span><br><span class="line">static $categories = array();</span><br><span class="line">foreach($arr as $val)&#123;</span><br><span class="line">if($val[&apos;parent_id&apos;] == $pid)&#123;</span><br><span class="line">$categories[] = $val;</span><br><span class="line">$categories[&apos;level&apos;] = $level;</span><br><span class="line">getAllCategory($arr, $val[&apos;cat_id&apos;], $level++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $categories;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;试题目录：&lt;br&gt;1、写一个能创建多级目录的PHP函数&lt;br&gt;2、请写一段代码，确保多个进程同时写入一个文件成功&lt;br&gt;3、写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名&lt;br&gt;4、写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。&lt;br&gt;5、无限级分类&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法问题 - 排序算法与二分查找法（PHP实现）</title>
    <link href="http://yoursite.com/2018/04/03/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/03/经典算法问题-排序算法与二分查找法/</id>
    <published>2018-04-03T05:53:33.000Z</published>
    <updated>2018-04-03T07:01:44.165Z</updated>
    
    <content type="html"><![CDATA[<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>测试数组：<br><code>$arr = [3,5,7,1,8,4,9,6,2];</code></p><h5 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h5><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。<br><a id="more"></a><br><strong>算法描述</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><strong>代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort($arr)&#123;</span><br><span class="line">if(!is_array($arr)) return false;</span><br><span class="line">$len = count($arr);</span><br><span class="line">if($len &lt;= 1) return $arr;</span><br><span class="line">for($i=0; $i&lt;$len; $i++)&#123;</span><br><span class="line">for($j=1; $j&lt;$len-$i; $j++)&#123;</span><br><span class="line">if($arr[$j-1] &gt; $arr[$j])&#123;</span><br><span class="line">$tmp = $arr[$j-1];</span><br><span class="line">$arr[$j-1] = $arr[$j];</span><br><span class="line">$arr[j] = $tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h5><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><p><strong>算法描述</strong><br>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><p><strong>代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function selectSort($arr)&#123;</span><br><span class="line">if(!is_array($arr)) return false;</span><br><span class="line">$len = count($arr);</span><br><span class="line">if($len &lt;= 1) return $arr;</span><br><span class="line">for($i=0; $i&lt;$len; $i++)&#123;</span><br><span class="line">$k = $i;</span><br><span class="line">for($j=$i+1; $j&lt;$len; $j++)&#123;</span><br><span class="line">if($arr[$k] &gt; $arr[$j])&#123;</span><br><span class="line">$k = $j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if($k != $i)&#123;</span><br><span class="line">$tmp = $arr[$k];</span><br><span class="line">$arr[$k] = $arr[$i];</span><br><span class="line">$arr[$i] = $tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h5><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong>算法描述</strong><br>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><p><strong>代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function insertSort($arr)&#123;</span><br><span class="line">if(!is_array($arr)) return false;</span><br><span class="line">$len = count($arr);</span><br><span class="line">if($len &lt;= 1) return $arr;</span><br><span class="line">for($i=1; $i&lt;$len; $i++)&#123;</span><br><span class="line">$tmp = $arr[$i];</span><br><span class="line">for($j=$i-1; $j&gt;=0; $j--)&#123;</span><br><span class="line">if($tmp &lt; $arr[$j])&#123;</span><br><span class="line">$arr[$j+1] = $arr[$j];</span><br><span class="line">$arr[$j] = $tmp;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h5><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p> <strong>算法描述</strong><br>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p><strong>代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function quickSort($arr)&#123;</span><br><span class="line">if(!is_array($arr)) return false;</span><br><span class="line">$len = count($arr);</span><br><span class="line">if($len &lt;= 1) return $arr;</span><br><span class="line">$left = $right = array();</span><br><span class="line">for($i=1; $i&lt;$len; $i++)&#123;</span><br><span class="line">if($arr[$i] &gt; $arr[0])&#123;</span><br><span class="line">$right[] = $arr[$i];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$left[] = $arr[$i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$left = quickSort($left);</span><br><span class="line">$right = quickSort($right);</span><br><span class="line">return array_merge($left, array($arr[0]), $right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><font color="red">排序参考文章：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></font><h4 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h4><p><strong>算法描述</strong></p><ol><li>二分查找又称折半查找，它是一种效率较高的查找方法。</li><li>二分查找要求：<br>（1）必须采用顺序存储结构<br>（2）.必须按关键字大小有序排列</li><li>原理：将数组分为三部分，依次是中值（所谓的中值就是数组中间位置的那个值）前，中值，中值后；将要查找的值和数组的中值进行比较，若小于中值则在中值前 面找，若大于中值则在中值后面找，等于中值时直接返回。然后依次是一个递归过程，将前半部分或者后半部分继续分解为三部分。</li><li>实现：二分查找的实现用递归和循环两种方式</li></ol><p><strong>（1）代码实现：（非递归实现）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function binarySearch1($arr, $searchV)&#123;</span><br><span class="line">$high = count($arr);</span><br><span class="line">$low = 0;</span><br><span class="line">while($low &lt;= $high)&#123;</span><br><span class="line">$middle = floor(($high+$low)/2);</span><br><span class="line">if($arr[$middle] &gt; $searchV)&#123;</span><br><span class="line">$high = $middle - 1;</span><br><span class="line">&#125;else if($arr[$middle] &lt; $searchV)&#123;</span><br><span class="line">$low = $middle +1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return $middle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>（2）代码实现：（递归实现）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function binarySearch2($arr, $searchV, $low, $high)&#123;</span><br><span class="line">if($low &lt;= $high)&#123;</span><br><span class="line">$middle = floor(($low+$high)/2);</span><br><span class="line">if($arr[$middle] &gt; $searchV)&#123;</span><br><span class="line">return binarySearch2($arr, $searchV, $low, $middle-1);</span><br><span class="line">&#125;else if($arr[$middle] &lt; $searchV)&#123;</span><br><span class="line">return binarySearch2($arr, $searchV, $middle+1, $high);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return $middle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h4&gt;&lt;p&gt;测试数组：&lt;br&gt;&lt;code&gt;$arr = [3,5,7,1,8,4,9,6,2];&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;1、冒泡排序&quot;&gt;&lt;a href=&quot;#1、冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1、冒泡排序&quot;&gt;&lt;/a&gt;1、冒泡排序&lt;/h5&gt;&lt;p&gt;冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法问题 - 最大连续子数列和与最大连续子数列乘积（PHP实现）</title>
    <link href="http://yoursite.com/2018/04/03/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E5%88%97%E5%92%8C%E4%B8%8E%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E5%88%97%E4%B9%98%E7%A7%AF/"/>
    <id>http://yoursite.com/2018/04/03/经典算法问题-最大连续子数列和与最大连续子数列乘积/</id>
    <published>2018-04-03T05:30:25.000Z</published>
    <updated>2018-04-03T05:50:17.119Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、最大连续子数列和问题"><a href="#一、最大连续子数列和问题" class="headerlink" title="一、最大连续子数列和问题"></a>一、最大连续子数列和问题</h4><p>给出测试数列：<br><code>$arr = [-2, 6, -1, 5, 4, -7, 2, 3];</code></p><h5 id="1、穷举法"><a href="#1、穷举法" class="headerlink" title="1、穷举法"></a>1、穷举法</h5><blockquote><p><strong>暴力求解法（穷举法）：</strong><br>暴力求解也是容易理解的做法，简单来说，我们只要用两层循环枚举起点和终点，这样就尝试了所有的子序列，然后计算每个子序列的和，然后找到其中最大的即可<br>我们可以采用一个两重的循环，假设两个循环的循环变量分别为i, j。第一层循环从第一个元素遍历到后面，第二个元素从&gt;=第一个元素的位置开始到最后。这样就可以遍历到所有的点。然后，我们取所有从i到j的连续数组部分和再比较。这样最终就可以得到最大的连续和以及最大子序列的起始与结束点。</p></blockquote><a id="more"></a><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function maxSubSum1($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$maxSum = 0;</span><br><span class="line">for($i=0; $i&lt;$len; $i++)&#123;</span><br><span class="line">for($j=$i; $j&lt;$len; $j++)&#123;</span><br><span class="line">$thisSum = 0;</span><br><span class="line">for($k=$i; $k&lt;=$j; $k++)&#123;</span><br><span class="line">$thisSum += $arr[$k];</span><br><span class="line">&#125;</span><br><span class="line">if($thisSum &gt; $maxSum)&#123;</span><br><span class="line">$maxSum = $thisSum;</span><br><span class="line">$seqStart = $i;</span><br><span class="line">$seqEnd = $j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$length = $seqEnd-$seqStart+1;</span><br><span class="line">return array_slice($arr, $seqStart, $length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2、优化穷举法"><a href="#2、优化穷举法" class="headerlink" title="2、优化穷举法"></a>2、优化穷举法</h5><blockquote><p><strong>一个简单的优化：</strong><br>前面那个最简单暴力的方法虽然看起来能解决问题，但是循环遍历的次数太多了。里面还是有不少可以改进的空间。比如说，每次我们用变量k遍历i到j的时候，都要计算求和。实际上当每次j增加1时，k把前面计算的结果在循环里又计算了一遍。这是完全没必要的，完全可以重复利用前面的计算结果。</p></blockquote><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function maxSubSum2($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$maxSum = 0;</span><br><span class="line">for($i=1; $i&lt;$len; $i++)&#123;</span><br><span class="line">$thisSum = 0;</span><br><span class="line">for($j=$i; $j&lt;$len; $j++)&#123;</span><br><span class="line">$thisSum += $arr[$j];</span><br><span class="line">if($thisSum &gt; $maxSum)&#123;</span><br><span class="line">$maxSum = $thisSum;</span><br><span class="line">$seqStart = $i;</span><br><span class="line">$seqEnd = $j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$length = $seqEnd-$seqStart+1;</span><br><span class="line">return array_slice($arr, $seqStart, $length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="3、线性算法"><a href="#3、线性算法" class="headerlink" title="3、线性算法"></a>3、线性算法</h5><blockquote><p>这个问题还是存在着一个线性时间复杂度的解法。需要我们对数组的序列进行进一步的分析。我们在数组中间找到的连续子序列，可能存在和为负的序列。如果需要找到一个最大的子数组的话，肯定该序列不是在最大子序列当中的。我们可以通过反证的方式来证明。<br>假设数组A[i…j]，里面的元素和为负。如果A[i….j]在一个最大子序列的数组中间，假定为A[i…k]，k &gt; j。那么既然从i到j这一段是负的，我把这一段去掉剩下的部分完全比我们假定的这个最大子序列还要大。这就和我的假设矛盾了。<br>这个假设还有一个限制，就是该数组就是从i开头的。否则有人可能会这么问，如果我A[i…j]这一部分确实是一个负数，但是在A[i]前面是一个很大的正数，使得他们的和为正数。那不就使得我们的结果不成立了么？如果我们是从某个数组的开头i开始的话，就不存在这个情况。<br>结合前面的讨论，我们就可以发现一个有意思的事情，就是假设我们从数组的开头A[0]开始，不断的往后面走，每一步判断是否当前和最大，并保存结果。当发现当前字串和为负数的时候，我们可以直接跳过。假设当前的索引为i的话，从0到i这一段的和是负数，可以排除。然后再从当前元素的后面开始找。这样可以得到最终最大子串和以及串的起点和终点。</p></blockquote><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function maxSubSum3($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$maxSum = 0;</span><br><span class="line">$thisSum = 0;</span><br><span class="line">for($i=0, $j=0; $j&lt;$len; $j++)&#123;</span><br><span class="line">$thisSum += $arr[$j];</span><br><span class="line">if($thisSum &gt; $maxSum)&#123;</span><br><span class="line">$maxSum = $thisSum;</span><br><span class="line">$seqStart = $i;</span><br><span class="line">$seqEnd = $j;</span><br><span class="line">&#125;else if($thisSum &lt; 0)&#123;</span><br><span class="line">$i = $j+1;</span><br><span class="line">$thisSum = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$length = $seqEnd-$seqStart+1;</span><br><span class="line">return array_slice($arr, $seqStart, $length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二、最大连续子数列乘积问题"><a href="#二、最大连续子数列乘积问题" class="headerlink" title="二、最大连续子数列乘积问题"></a>二、最大连续子数列乘积问题</h4><p>给出测试数列：<br><code>$arr = [2, 3, 0, -3, 3, -1, 0, 9];</code></p><h5 id="1、穷举法-1"><a href="#1、穷举法-1" class="headerlink" title="1、穷举法"></a>1、穷举法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function maxSubProduct1($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$maxPro = 0;</span><br><span class="line">for($i=0; $i&lt;$len; $i++)&#123;</span><br><span class="line">$thisPro = 1;</span><br><span class="line">for($j=$i; $j&lt;$len; $j++)&#123;</span><br><span class="line">$thisPro *= $arr[$j];</span><br><span class="line">if($thisPro &gt; $maxPro)&#123;</span><br><span class="line">$maxPro = $thisPro;</span><br><span class="line">$seqStart = $i;</span><br><span class="line">$seqEnd = $j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$length = $seqEnd-$seqStart+1;</span><br><span class="line">return array_slice($arr, $seqStart, $length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、线性算法"><a href="#2、线性算法" class="headerlink" title="2、线性算法"></a>2、线性算法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function maxSubProduct2($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$maxPro = 0;</span><br><span class="line">$thisPro = 1;</span><br><span class="line">for($i=0, $j=0; $j&lt;$len; $j++)&#123;</span><br><span class="line">$thisPro *= $arr[$j];</span><br><span class="line">if($thisPro &gt; $maxPro)&#123;</span><br><span class="line">$maxPro = $thisPro;</span><br><span class="line">$seqStart = $i;</span><br><span class="line">$seqEnd = $j;</span><br><span class="line">&#125;else if($thisPro == 0)&#123;</span><br><span class="line">$thisPro = 1;</span><br><span class="line">$i = $j+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$length = $seqEnd-$seqStart+1;</span><br><span class="line">return array_slice($arr, $seqStart, $length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong><br>通过对“最大连续子数列和与最大连续子数列乘积”的算法实现，可发现共通之处，即<font color="red">算法原理都是一样的</font>。最简单、最暴力的解决方法就是穷举法，同时，算法时间复杂度也是最差的。现实中使用必须要优化，否则特别影响性能。<br>因此，就出现了线性算法，此算法时间复杂度只有 O(n)，极大的提高了性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、最大连续子数列和问题&quot;&gt;&lt;a href=&quot;#一、最大连续子数列和问题&quot; class=&quot;headerlink&quot; title=&quot;一、最大连续子数列和问题&quot;&gt;&lt;/a&gt;一、最大连续子数列和问题&lt;/h4&gt;&lt;p&gt;给出测试数列：&lt;br&gt;&lt;code&gt;$arr = [-2, 6, -1, 5, 4, -7, 2, 3];&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;1、穷举法&quot;&gt;&lt;a href=&quot;#1、穷举法&quot; class=&quot;headerlink&quot; title=&quot;1、穷举法&quot;&gt;&lt;/a&gt;1、穷举法&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;暴力求解法（穷举法）：&lt;/strong&gt;&lt;br&gt;暴力求解也是容易理解的做法，简单来说，我们只要用两层循环枚举起点和终点，这样就尝试了所有的子序列，然后计算每个子序列的和，然后找到其中最大的即可&lt;br&gt;我们可以采用一个两重的循环，假设两个循环的循环变量分别为i, j。第一层循环从第一个元素遍历到后面，第二个元素从&amp;gt;=第一个元素的位置开始到最后。这样就可以遍历到所有的点。然后，我们取所有从i到j的连续数组部分和再比较。这样最终就可以得到最大的连续和以及最大子序列的起始与结束点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试总结（一）</title>
    <link href="http://yoursite.com/2018/04/02/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/02/面试总结（一）/</id>
    <published>2018-04-02T02:58:13.000Z</published>
    <updated>2018-04-03T05:51:23.803Z</updated>
    
    <content type="html"><![CDATA[<p>上周面试了一个公司，下面做一下总结。</p><h4 id="一、算法"><a href="#一、算法" class="headerlink" title="一、算法"></a>一、算法</h4><p>1、斐波那契数列实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">斐波那契数列： </span><br><span class="line">1 1 2 3 5 8 13 21 34 55 …</span><br><span class="line">概念： </span><br><span class="line">前两个值都为1，该数列从第三位开始，每一位都是当前位前两位的和 </span><br><span class="line">规律公式为： </span><br><span class="line">Fn = F(n-1) + F(n-2) </span><br><span class="line">F：指当前这个数列 </span><br><span class="line">n：指数列的下标</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><strong>PHP代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//非递归</span><br><span class="line">function fbnq($n)&#123;</span><br><span class="line">if($n&lt;=0)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">$arr[1] = $arr[2] = 1;</span><br><span class="line">for($i=3; $i&lt;=$n; $i++)&#123;</span><br><span class="line">$arr[$i] = $arr[$i-1] + $arr[$i-2];</span><br><span class="line">&#125;</span><br><span class="line">return $arr;</span><br><span class="line">&#125;</span><br><span class="line">//递归实现</span><br><span class="line">function fbnq($n)&#123;</span><br><span class="line">if($n &lt;= 0) return 0;</span><br><span class="line">static $arr;</span><br><span class="line">$arr[1] = $arr[2] = 1;</span><br><span class="line">    if($n &gt; 3)&#123;</span><br><span class="line">    fbnq($n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    $arr[$n] = $arr[$n-1] + $arr[$n-2];</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、最大连续子数列乘积问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给出一个数列为：$arr = [2, 3, 0, -3, 3, -1, 0, 9];</span><br><span class="line">求出最大连续子数列乘积。</span><br><span class="line">结果为：[-3, 3, -1]</span><br></pre></td></tr></table></figure></p><p><strong>PHP代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function maxSubProduct($arr)&#123;</span><br><span class="line">$len = count($arr);</span><br><span class="line">$maxPro = 0;</span><br><span class="line">$thisPro = 1;</span><br><span class="line">for($i=0, $j=0; $j&lt;$len; $j++)&#123;</span><br><span class="line">$thisPro *= $arr[$j];</span><br><span class="line">if($thisPro &gt; $maxPro)&#123;</span><br><span class="line">$maxPro = $thisPro;</span><br><span class="line">$seqStart = $i;</span><br><span class="line">$seqEnd = $j;</span><br><span class="line">&#125;else if($thisPro == 0)&#123;</span><br><span class="line">$thisPro = 1;</span><br><span class="line">$i = $j+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$length = $seqEnd-$seqStart+1;</span><br><span class="line">return array_slice($arr, $seqStart, $length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二、PHP基础"><a href="#二、PHP基础" class="headerlink" title="二、PHP基础"></a>二、PHP基础</h4><h5 id="1、比较empty-、isset-两个函数的区别，对应给出如下示例："><a href="#1、比较empty-、isset-两个函数的区别，对应给出如下示例：" class="headerlink" title="1、比较empty()、isset()两个函数的区别，对应给出如下示例："></a>1、比较empty()、isset()两个函数的区别，对应给出如下示例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$a = 0;</span><br><span class="line">$b = &apos;0&apos;;</span><br><span class="line">$c = null;</span><br><span class="line">$d = &apos; &apos;;</span><br><span class="line">var_dump(empty($a)); //1</span><br><span class="line">var_dump(empty($b)); //1</span><br><span class="line">var_dump(empty($c)); //1</span><br><span class="line">var_dump(isset($c)); //0</span><br><span class="line">var_dump(isset($d)); //1</span><br><span class="line">var_dump($a == $b); //1</span><br><span class="line">var_dump($a == $c); //1</span><br></pre></td></tr></table></figure><p><strong>相关知识点介绍：</strong></p><blockquote><p><code>bool isset ( mixed $var [, mixed $... ] ) — 检测变量是否已设置并且不是 NULL。</code><br>返回值：如果 var 存在并且值不是 NULL 则返回 TRUE，否则返回 FALSE。<br>（注：isset() 只能用于变量，因为传递任何其它参数都将造成解析错误。若想检测常量是否已设置，可使用 defined() 函数。<br>因为是一个语言构造器而不是一个函数，不能被 可变函数 调用。）<br><code>bool empty ( mixed $var ) — 检查一个变量是否为空</code><br>判断一个变量是否被认为是空的。当一个变量并不存在，或者它的值等同于FALSE，那么它会被认为不存在。如果变量不存在的话，empty()并不会产生警告。<br>返回值：<br>当var存在，并且是一个非空非零的值时返回 FALSE 否则返回 TRUE.</p><blockquote><p><strong>以下的东西被认为是空的：</strong><br>“” (空字符串)<br>0 (作为整数的0)<br>0.0 (作为浮点数的0)<br>“0” (作为字符串的0)<br>NULL<br>FALSE<br>array() (一个空数组)<br>$var; (一个声明了，但是没有值的变量)<br>（注：因为是一个语言构造器而不是一个函数，不能被 可变函数 调用。）</p></blockquote></blockquote><h5 id="2、数组方面，给出如下："><a href="#2、数组方面，给出如下：" class="headerlink" title="2、数组方面，给出如下："></a>2、数组方面，给出如下：</h5><p>写出对应输出的结果，包括key=&gt;value值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$a = array( 2, 1, &apos;3&apos;=&gt;2 );</span><br><span class="line">$b = array( 2=&gt;1, 4=&gt;2, 5=&gt;4 );</span><br><span class="line">foreach( $a as &amp;$k )&#123;</span><br><span class="line">    $k++;</span><br><span class="line">&#125;</span><br><span class="line">foreach( $b as $k )&#123;</span><br><span class="line">    $k++;</span><br><span class="line">&#125;</span><br><span class="line">var_dump($a); //0=&gt;3, 1=&gt;2, 3=&gt;5</span><br><span class="line">var_dump($b); //2=&gt;1, 4=&gt;2, 5=&gt;3</span><br><span class="line">var_dump($k); //5</span><br></pre></td></tr></table></figure></p><p><strong>答案解析：</strong></p><blockquote><p>根据程序自上到下的执行顺序，可知道首先遍历$a数组，且要注意<font color="red">遍历只有值，没有key，仅仅只是名字而已。</font>此处，我就看错了。然后遍历$b数组，最后输出。<br>首先要知道的一点是：$a数组将值传引用了，因此后面对$k的值更改则会更改对应的值。<br>所以，$a的值相对应的都会+1，则其值为 0=&gt;3,1=&gt;2,3=&gt;3。<br>下面，又再次对$b数组进行遍历，仅仅只是值传递。所以，对于$b数组未做改变，原样输出：2=&gt;1,4=&gt;2,5=&gt;4。<br>虽然$b数组遍历未对数值的值进行改变，但是，对$k的值进行更改了。因此，$k的值再经过$b数组的遍历后为5，要注意，$k是传引用的，与$a数组中的最后一个值是引用关系。因此，$a数组中最后一个值现在变为5。且$k的值也是5。</p></blockquote><p><strong>相关知识点介绍：</strong><br>此处，考的知识点比较多一些，比较容易混淆且不被发现。<br>首先是遍历的时候，命名问题容易让人产生是$key，没有值的幻觉，因此要注意看（面试官提醒了我好几次，最后还是看错了）。<br>再次，就是传值与传引用的知识点运用。其中涉及到变量作用域的问题，此处我也考虑错了，理解成局部变量了。下面是变量作用域的总结：</p><blockquote><p>PHP中变量的作用域可以分为:<br><strong>超全局变量：</strong>在一个脚本的任何作用域里都可以被访问,可直接在局部范围里使用,不需要用global声明。比如$GLOBALS,$_ENV,$_SERVER,$_GET,$_POST,$_FILES,$_SESSION,$_COOKIE等.<br><strong>全局变量：</strong>声明的变量不在class,function等语言结构内部.如果要在class,function等内部使用全局变量,需要用关键词global或者超全局变量$GLOBALS.<br><strong>局部变量：</strong>在class,function等结构语句内部声明的变量.<br><strong>静态变量：</strong>在function中使用关键词static声明的变量,静态变量的值保留直至当前请求的脚本运行结束,比如可以用来保存数据库连接对象.</p></blockquote><h4 id="三、Linux命令"><a href="#三、Linux命令" class="headerlink" title="三、Linux命令"></a>三、Linux命令</h4><p>给你一段文本文件，例如：file.txt<br>102 baidu 100 5000<br>101 google 110 5000<br>104 sohu 100 4500<br>103 guge 50 3000<br>下面是需要执行的命令需求：<br>1、输出前两行<br>2、输出第3行<br>3、输出第1列<br>4、输出全部并且以第一列从小到大排序<br>5、回到家目录，再回到上次目录<br>下面是对上面命令的解答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、head -2 file.txt</span><br><span class="line">2、sed -n &apos;3p&apos; file.txt 或 cat file.txt | head -3 | tail -1</span><br><span class="line">3、awk &apos;&#123;print $1&#125;&apos; file.txt</span><br><span class="line">4、sort -n -t &apos; &apos; -k 1 file.txt</span><br><span class="line">5、cd ~ ; cd -</span><br></pre></td></tr></table></figure></p><h4 id="四、操作系统方面"><a href="#四、操作系统方面" class="headerlink" title="四、操作系统方面"></a>四、操作系统方面</h4><h5 id="1、进程间通信方式以及相对应的原理"><a href="#1、进程间通信方式以及相对应的原理" class="headerlink" title="1、进程间通信方式以及相对应的原理"></a>1、进程间通信方式以及相对应的原理</h5><p>通信方式有：管道、信号、共享内存<br>原理：<br>管道：<br>信号：<br>共享内存：</p><h5 id="2、操作系统中有个重复函数加载什么的"><a href="#2、操作系统中有个重复函数加载什么的" class="headerlink" title="2、操作系统中有个重复函数加载什么的"></a>2、操作系统中有个重复函数加载什么的</h5><h5 id="3、I-O多路复用技术"><a href="#3、I-O多路复用技术" class="headerlink" title="3、I/O多路复用技术"></a>3、I/O多路复用技术</h5><h4 id="五、计算机网络"><a href="#五、计算机网络" class="headerlink" title="五、计算机网络"></a>五、计算机网络</h4><h5 id="1、计算机网络OSI七层协议模型、TCP-IP五层协议模型"><a href="#1、计算机网络OSI七层协议模型、TCP-IP五层协议模型" class="headerlink" title="1、计算机网络OSI七层协议模型、TCP/IP五层协议模型"></a>1、计算机网络OSI七层协议模型、TCP/IP五层协议模型</h5><p>OSI七层协议模型包括：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。<br>TCP/IP五层协议模型包括：应用层、传输层、网络层、数据链路层、物理层。<br>以TCP/IP五层协议模型来说明每层作用及相关协议：<br>应用层：对编程人员开发的接口，用于软件开发。主要协议包括：HTTP、SMTP、DNS等<br>传输层：接受应用层的数据包，进行处理，并选择相应的协议进行转发到下层。主要协议包括：TCP、UDP等<br>网络层：逻辑寻址，用于在网络中通过路由协议用IP:Port来进行子网定位。主要协议包括：路由协议、IP协议等<br>数据链路层：物理寻址，用于在子网中通过交换机根据Mac地址来进行定位主机；同时，将数据进行处理，转换为位流。<br>物理层：通过物理媒介，传输数据流。</p><h5 id="2、TCP-UDP的区别及特点"><a href="#2、TCP-UDP的区别及特点" class="headerlink" title="2、TCP/UDP的区别及特点"></a>2、TCP/UDP的区别及特点</h5><p>TCP：面向连接的、安全的协议。<br>UDP：无连接的、不安全的协议。</p><h5 id="3、HTTP相关知识点"><a href="#3、HTTP相关知识点" class="headerlink" title="3、HTTP相关知识点"></a>3、HTTP相关知识点</h5><p>HTTP：超文本传输协议。是一个面向连接的（底层采用的是TCP协议）、无状态的协议。</p><h4 id="六、原理方面"><a href="#六、原理方面" class="headerlink" title="六、原理方面"></a>六、原理方面</h4><h5 id="1、web服务的工作原理"><a href="#1、web服务的工作原理" class="headerlink" title="1、web服务的工作原理"></a>1、web服务的工作原理</h5><p>WEB服务器也称为WWW(WORLD WIDE WEB)服务器，主要功能是提供网上信息浏览服务。通俗的说，Web服务器是可以向发出请求的浏览器提供文档的程序。<br>1、服务器是一种被动程序：只有当Internet上运行在其他计算机中的浏览器发出请求时，服务器才会响应。<br>2、最常用的Web服务器是Apache和Microsoft的Internet信息服务器（Internet Information Services，IIS）。<br>3、Internet上的服务器也称为Web服务器，是一台在Internet上具有独立IP地址的计算机，可以向Internet上的客户机提供WWW、Email和FTP等各种Internet服务。<br>4、Web服务器是指驻留于因特网上某种类型计算机的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。服务器使用HTTP（超文本传输协议）与客户机浏览器进行信息交流，这就是人们常把它们称为HTTP服务器的原因。<br>Web服务器不仅能够存储信息，还能在用户通过Web浏览器提供的信息的基础上运行脚本和程序。</p><p><strong>采用的协议：</strong><br>1、应用层使用HTTP协议。<br>2、HTML（标准通用标记语言下的一个应用）文档格式。<br>3、浏览器统一资源定位器（URL）。<br>4、为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><p><strong>Web服务的工作原理：</strong><br>Web服务器的工作原理并不复杂，一般可分成如下4个步骤：连接过程、请求过程、应答过程以及关闭连接。<br><strong>连接过程</strong>：通过三次握手建立连接。（客户端向服务器发送请求报文SYN；服务器接受请求连接，并向客户端发送ACK确认；客户端接受ACK确认并返回给服务器，服务器接受到客户端返回的ACK确认后建立起连接。）<br><strong>请求过程</strong>客户端与服务端建立连接后，客户端即可向服务端发送请求。（如果是持久连接，一次连接可多次请求。非持久连接，则一次连接只可请求一次。）<br><strong>应答过程</strong>客户端将请求发送到服务端，服务端接受链接，并进行处理。然后把处理结果再返回给客户端。<br><strong>关闭连接</strong>最后，通过四次挥手断开连接。（客户端向服务器发送断开连接请求报文FIN；服务器接受断开连接，并向客户端发送ACK确认报文，同时，待服务器端数据处理完后返回FIN关闭连接；客户端接受到服务端的确认报文ACK，待接收到服务端的关闭连接报文FIN后，返回ACK到服务端确认关闭连接。）</p><p>使用最多的Web Server服务器软件有：IIS、Apache、nginx。</p><blockquote><p>为何使用三次握手机制：<br>假设如下异常情况：<br>客户端向服务器发送了第一条请求报文，但是该报文并未在网络中被丢弃，而是长时间阻滞在某处，而客户端收不到服务器确认，以为该报文丢失，于是重新发送该报文，这次的报文成功到达服务器，如果不使用三次握手，则服务器只需对该报文发出确认，就建立了一个连接。而在这个连接建立，并释放后，第一次发送的，阻滞在网络中的报文到达了服务器，服务器以为是客户端又重新发送了一个连接请求（实际上在客户端那里，该连接早已失效），就又向客户端发送一个确认，但客户端认为他没有发送该请求报文，因此不理睬服务器发送的确认，而服务器以为又建立了一个新的连接，于是一直等待A发来数据，造成了服务器资源的浪费，并且会产生安全隐患。因此，若使用三次握手机制，服务器发送了该确认后，收不到客户端的确认，也就知道并没有建立连接，因此不会将资源浪费在这种没有意义的等待上。</p></blockquote><h5 id="2、nginx的工作原理"><a href="#2、nginx的工作原理" class="headerlink" title="2、nginx的工作原理"></a>2、nginx的工作原理</h5><p>nginx类似是一个代理服务器，当浏览器请求的是一些静态资源，则直接返回；若接收的是动态请求，则通过配置文件直接将请求映射到对应的location block，而此location中所配置的各个指令则会启动不同的模块去完成工作，最后返回给浏览器。<br>此处，处理动态请求的PHP文件，一般是PHP-FPM。</p><h4 id="七、其它知识点"><a href="#七、其它知识点" class="headerlink" title="七、其它知识点"></a>七、其它知识点</h4><h5 id="1、session和cookie的区别"><a href="#1、session和cookie的区别" class="headerlink" title="1、session和cookie的区别"></a>1、session和cookie的区别</h5><p>首先，要知道session和cookie是怎么产生的。当客户端访问服务端的时候，服务器会对应生成一个唯一的SESSIONID，同数据一起返回给客户端，当客户端再次访问的时候，即可带着这个SESSIONID，服务端就可根据SESSIONID识别用户。HTTP是一个无状态的协议（即同一个会话的连续两次请求是互相不了解的，如果需要前面的信息，必须重传），session和cookie是会话层保持会话的一个措施。<br>（1）因此，首先一个区别就是session保存在服务端，cookie保存在客户端。<br>cookie保存在浏览器中，如果没有设置过期时间，则关闭浏览器的时候，cookie就消失了，相对应的SESSIONID也消失了。当设置过期时间的时候，cookie就保存在客户端硬盘上，当下次再访问网站的时候，可自动携带此cookie。<br>（2）由于cookie保存在客户端，因此cookie是不安全的，容易被人给copy，伪造cookie登录。session保存在服务端，相对来说安全一些。<br>假如浏览器禁止cookie，那应该怎么保持会话？<br>① 可通过重写URL，即通过GET方法附带SESSIONID的方式传送到服务端。<br>② 如果是表单，可通过隐藏表单传送SESSIONID。<br>（3）由于session是保存在服务端，因此session的增加会导致服务器数据量增加，应定时清理无效数据。<br>（4）cookie保存在客户端，但是也不能随意大批量使用，因为cookie的增加会增加数据传输量，导致带宽的增加。</p><h5 id="2、堆区与栈区介绍"><a href="#2、堆区与栈区介绍" class="headerlink" title="2、堆区与栈区介绍"></a>2、堆区与栈区介绍</h5><p>内存分配有三种：静态存储区、堆区和栈区。他们的功能不同，对他们使用方式也就不同。<br><strong>静态存储区：</strong>内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。<br><strong>栈区：</strong>在执行函数时，函数（包括main函数）内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。（任何变量都处于站区，例如int a[] = {1, 2},变量a处于栈区。数组的内容也存在于栈区。）<br><strong>堆区：</strong>亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，并立即将指针置位NULL，防止产生野指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周面试了一个公司，下面做一下总结。&lt;/p&gt;
&lt;h4 id=&quot;一、算法&quot;&gt;&lt;a href=&quot;#一、算法&quot; class=&quot;headerlink&quot; title=&quot;一、算法&quot;&gt;&lt;/a&gt;一、算法&lt;/h4&gt;&lt;p&gt;1、斐波那契数列实现&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;斐波那契数列： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 1 2 3 5 8 13 21 34 55 …&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;概念： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前两个值都为1，该数列从第三位开始，每一位都是当前位前两位的和 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;规律公式为： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Fn = F(n-1) + F(n-2) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F：指当前这个数列 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n：指数列的下标&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之sort</title>
    <link href="http://yoursite.com/2018/03/30/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bsort/"/>
    <id>http://yoursite.com/2018/03/30/Linux命令之sort/</id>
    <published>2018-03-30T07:50:27.000Z</published>
    <updated>2018-03-30T10:37:02.455Z</updated>
    
    <content type="html"><![CDATA[<p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sort [选项] [参数]</span><br><span class="line">选项：</span><br><span class="line">-n：依照数值的大小排序；</span><br><span class="line">-r：以相反的顺序来排序；</span><br><span class="line">-k：是指定需要爱排序的栏位；</span><br><span class="line">-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符；</span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入制定的文件；（注：直接使用重定向会覆盖原文件，将其清空。）</span><br><span class="line">参数：</span><br><span class="line">文件：指定待排序的文件列表。</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="用法解析"><a href="#用法解析" class="headerlink" title="用法解析"></a>用法解析</h4><h5 id="sort的工作原理"><a href="#sort的工作原理" class="headerlink" title="sort的工作原理"></a>sort的工作原理</h5><p>sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ cat seq.txt</span><br><span class="line">banana</span><br><span class="line">apple</span><br><span class="line">pear</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">[root@www ~]$ sort seq.txt</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">pear</span><br></pre></td></tr></table></figure></p><h5 id="sort的-u选项"><a href="#sort的-u选项" class="headerlink" title="sort的-u选项"></a>sort的-u选项</h5><p>它的作用很简单，就是在输出行中去除重复行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ sort -u seq.txt</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure></p><h5 id="sort的-r选项"><a href="#sort的-r选项" class="headerlink" title="sort的-r选项"></a>sort的-r选项</h5><p>sort默认的排序方式是升序，如果想改成降序，就加个-r就搞定了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ sort -r seq.txt</span><br><span class="line">pear</span><br><span class="line">pear</span><br><span class="line">orange</span><br><span class="line">banana</span><br><span class="line">apple</span><br></pre></td></tr></table></figure></p><h5 id="sort的-n选项"><a href="#sort的-n选项" class="headerlink" title="sort的-n选项"></a>sort的-n选项</h5><p>sort排序默认是采用ASCII码值进行比较来排序的，因此对比10与2的大小时，10就会比2小了，因为比较10与2的时候，真实比较的是1与2的大小，显然1小，所以就将10放在2的前面了。<br>对于此类情况，我们只要使用-n选项，就限制sort使用数值来进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ cat number.txt</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">19</span><br><span class="line">11</span><br><span class="line">2</span><br><span class="line">[root@www ~]$ sort number.txt</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">19</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">[root@www ~]$ sort -n number.txt</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">19</span><br></pre></td></tr></table></figure></p><h5 id="sort的-o选项"><a href="#sort的-o选项" class="headerlink" title="sort的-o选项"></a>sort的-o选项</h5><p>由于sort默认是把结果输出到标准输出，所以需要用重定向才能将结果写入文件，形如sort filename &gt; newfile。<br>但是，如果你想把排序结果输出到原文件中，用重定向可就不行了。会将原文件覆盖，情况数据。<br>对于这种情况，sort提供了-o选项解决了这个问题，可将结果写入原文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ sort -r number.txt &gt; number.txt</span><br><span class="line">[root@www ~]$ cat number.txt</span><br><span class="line">[root@www ~]$</span><br><span class="line">[root@www ~]$ cat number.txt</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">19</span><br><span class="line">11</span><br><span class="line">2</span><br><span class="line">[root@www ~]$ sort -nr number.txt -o number.txt</span><br><span class="line">[root@www ~]$ cat number.txt</span><br><span class="line">19</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><h5 id="sort的-t选项和-k选项"><a href="#sort的-t选项和-k选项" class="headerlink" title="sort的-t选项和-k选项"></a>sort的-t选项和-k选项</h5><blockquote><p>如果有一个文件的内容是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ cat seq.txt</span><br><span class="line">banana:30:5.5</span><br><span class="line">apple:10:2.5</span><br><span class="line">pear:90:2.3</span><br><span class="line">orange:20:3.4</span><br></pre></td></tr></table></figure></p></blockquote><p>这个文件有三列，列与列之间用冒号隔开了，第一列表示水果类型，第二列表示水果数量，第三列表示水果价格。<br>那么我想以水果数量来排序，也就是以第二列来排序，如何利用sort实现？</p><p>此处就可使用sort提供的-t选项，指定以什么间隔符进行分割。然后，再使用-k选项指定对那一列或几列进行排序即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ sort -n -k 2 -t : seq.txt</span><br><span class="line">apple:10:2.5</span><br><span class="line">orange:20:3.4</span><br><span class="line">banana:30:5.5</span><br><span class="line">pear:90:2.3</span><br></pre></td></tr></table></figure></p><h5 id="sort的-k选项进阶版"><a href="#sort的-k选项进阶版" class="headerlink" title="sort的-k选项进阶版"></a>sort的-k选项进阶版</h5><blockquote><p>例如有一个文件内容是这样的：<br>第一个域是公司名称，第二个域是公司人数，第三个域是员工平均工资。（仅作演示）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ cat facebook.txt</span><br><span class="line">google 110 5000</span><br><span class="line">baidu 100 5000</span><br><span class="line">guge 50 3000</span><br><span class="line">sohu 100 4500</span><br></pre></td></tr></table></figure></p></blockquote><p>（1）首先，按照公司人数排序，人数相同的按照员工平均工资的升序排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ sort -n -t &apos; &apos; -k 2 facebook.txt</span><br><span class="line">guge 50 3000</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br><span class="line">[root@www ~]$ sort -n -t &apos; &apos; -k 2 -k 3 facebook.txt</span><br><span class="line">guge 50 3000</span><br><span class="line">sohu 100 4500</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br></pre></td></tr></table></figure></p><p>（2）下面，按照员工平均工资的降序排序，如果员工工资相同，则按照工资人数升序排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ sort -t &apos; &apos; -n -k 3r -k 3 facebook.txt</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。&lt;/p&gt;
&lt;h4 id=&quot;语法格式&quot;&gt;&lt;a href=&quot;#语法格式&quot; class=&quot;headerlink&quot; title=&quot;语法格式&quot;&gt;&lt;/a&gt;语法格式&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@www ~]# sort [选项] [参数]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;选项：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-n：依照数值的大小排序；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-r：以相反的顺序来排序；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-k：是指定需要爱排序的栏位；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-t&amp;lt;分隔字符&amp;gt;：指定排序时所用的栏位分隔字符；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-o&amp;lt;输出文件&amp;gt;：将排序后的结果存入制定的文件；（注：直接使用重定向会覆盖原文件，将其清空。）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;文件：指定待排序的文件列表。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Redis 相关知识点整理</title>
    <link href="http://yoursite.com/2018/03/28/Redis-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/03/28/Redis-相关知识点整理/</id>
    <published>2018-03-28T10:48:18.000Z</published>
    <updated>2018-03-28T11:15:19.573Z</updated>
    
    <content type="html"><![CDATA[<p>首先，要知道redis是一个key-value内存存储系统，且是单线程模型。<br>与其他key-value缓存相比有以下特点：</p><ol><li>支持数据持久化，可以将内存中的数据保存到磁盘，重启机器后可再次加载进来</li><li>不仅仅支持key-value类型数据，还有哈希、列表、集合数据结构类型</li><li>支持数据的备份，master-slave模式的数据备份</li></ol><p>并且，redis的所有操作都具有原子性。<br><a id="more"></a></p><h4 id="1、redis-的数据类型介绍"><a href="#1、redis-的数据类型介绍" class="headerlink" title="1、redis 的数据类型介绍"></a>1、redis 的数据类型介绍</h4><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p><strong>常用命令：</strong><br>set,get,decr,incr,mget 等。<br><strong>应用场景：</strong><br>String是最常用的一种数据类型，普通的key/value存储都可以归为此类，这里就不所做解释了。<br><strong>实现方式：</strong><br>String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</p><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p><strong>常用命令：</strong><br>hget,hset,hgetall 等。<br><strong>应用场景：</strong><br>我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：<br>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：</p><ul><li>第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。</li><li>第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。</li></ul><p>那么Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口。</p><p>也就是说，Key仍然是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的 Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。</p><p>这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部Map的成员很多，那么涉及到遍历整 个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。</p><p>上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。</p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p><strong>常用命令：</strong><br>lpush,rpush,lpop,rpop,lrange等。<br><strong>应用场景：</strong><br>Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现，比较好理解，这里不再重复。<br><strong>实现方式：</strong><br>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p><strong>常用命令：</strong><br>sadd,spop,smembers,sunion 等。<br><strong>应用场景：</strong><br>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。<br><strong>实现方式：</strong><br>set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p><h5 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h5><p><strong>常用命令：</strong><br>zadd,zrange,zrem,zcard等<br><strong>使用场景：</strong><br>Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么 可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。<br><strong>实现方式：</strong><br>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的 是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p><h4 id="redis支持持久化的原理"><a href="#redis支持持久化的原理" class="headerlink" title="redis支持持久化的原理"></a>redis支持持久化的原理</h4><p>Redis由于支持非常丰富的内存数据结构类型，如何把这些复杂的内存组织方式持久化到磁盘上是一个难题，所以Redis的持久化方式与传统数据库的方式有比较多的差别，Redis一共支持四种持久化方式，分别是：</p><blockquote><p>定时快照方式(snapshot)<br>基于语句追加文件的方式(aof)<br>虚拟内存(vm)<br>Diskstore方式</p></blockquote><p>redis支持小量数据落地功能，后两种种方式并不成熟，下面分别介绍下这几种持久化方式：</p><p><strong>定时快照方式(snapshot)：</strong><br>该持久化方式实际是在Redis内部一个定时器事件，每隔固定时间去检查当前数据发生的改变次数与时间是否满足配置的持久化触发的条件<font color="red">（注：需要配置）</font>，如果满足则 通过操作系统fork调用来创建出一个子进程，这个子进程默认会与父进程共享相同的地址空间，这时就可以通过子进程来遍历整个内存来进行存储操作，而主进 程则仍然可以提供服务，当有写入时由操作系统按照内存页(page)为单位来进行copy-on-write保证父子进程之间不会互相影响。<br>该持久化的主要缺点是定时快照只是代表一段时间内的内存映像，所以系统重启会丢失上次快照与重启之间所有的数据。</p><p><strong>基于语句追加方式(aof)：</strong><br>aof方式实际类似mysql的基于语句的binlog方式，即每条会使Redis内存数据发生改变的命令都会追加到一个log文件中，也就是说这个log文件就是Redis的持久化数据。<br>aof的方式的主要缺点是追加log文件可能导致体积过大，当系统重启恢复数据时如果是aof的方式则加载数据会非常慢，几十G的数据可能需要几小时才能加载完，当然这个耗时并不是因为磁盘文件读取速度慢，而是由于读取的所有命令都要在内存中执行一遍。另外由于每条命令都要写log,所以使用aof 的方式，Redis的读写性能也会有所下降。</p><p><strong>虚拟内存方式：</strong><br>虚拟内存方式是Redis来进行用户空间的数据换入换出的一个策略，此种方式在实现的效果上比较差，主要问题是代码复杂，重启慢，复制慢等等，目前已经被作者放弃。</p><p><strong>diskstore方式：</strong><br>diskstore方式是作者放弃了虚拟内存方式后选择的一种新的实现方式，也就是传统的B-tree的方式，目前仍在实验阶段，后续是否可用我们可以拭目以待。</p><p><strong>Redis持久化磁盘IO方式及其带来的问题</strong><br>有Redis线上运维经验的人会发现Redis在物理内存使用比较多，但还没有超过实际物理内存总容量时就会发生不稳定甚至崩溃的问题，有人认为是 基于快照方式持久化的fork系统调用造成内存占用加倍而导致的，这种观点是不准确的，因为fork 调用的copy-on-write机制是基于操作系统页这个单位的，也就是只有有写入的脏页会被复制，但是一般你的系统不会在短时间内所有的页都发生了写 入而导致复制，那么是什么原因导致Redis崩溃的呢？</p><p>答案是Redis的持久化使用了Buffer IO造成的，所谓Buffer IO是指Redis对持久化文件的写入和读取操作都会使用物理内存的Page Cache,而大多数数据库系统会使用Direct IO来绕过这层Page Cache并自行维护一个数据的Cache，而当Redis的持久化文件过大(尤其是快照文件)，并对其进行读写时，磁盘文件中的数据都会被加载到物理内 存中作为操作系统对该文件的一层Cache,而这层Cache的数据与Redis内存中管理的数据实际是重复存储的，虽然内核在物理内存紧张时会做 Page Cache的剔除工作，但内核很可能认为某块Page Cache更重要，而让你的进程开始Swap ,这时你的系统就会开始出现不稳定或者崩溃了。我们的经验是当你的Redis物理内存使用超过内存总容量的3/5时就会开始比较危险了。<br><em>（注：Redis的复制功能是完全建立在基于内存快照的持久化策略基础上的，也就是说无论你的持久化策略选择的是什么，只要用到了 Redis的复制功能，就一定会有内存快照发生。）</em></p><h4 id="3、redis备份原理"><a href="#3、redis备份原理" class="headerlink" title="3、redis备份原理"></a>3、redis备份原理</h4><p>由上面持久化的原理可知道，目前使用的是RDB和AOF。<br>默认情况下60秒刷新到disk一次[save 60 10000 当有1w条keys数据被改变时]，Redis的数据集保存在叫dump.rdb一个二进制文件，这种策略被称为快照。</p><p>快照易恢复，文件也小，但是如果遇到宕机等情况的时候快照的数据可能会不完整。此时可能需要启用另一种持久化方式AOF，在配置文件中打开[appendonly yes]。</p><blockquote><p>AOF刷新日志到disk的规则：<br>appendfsync always #always 表示每次有写操作都进行同步，非常慢，非常安全。<br>appendfsync everysec #everysec表示对写操作进行累积，每秒同步一次<br>官方的建议的everysec，安全，就是速度不够快，如果是机器出现问题可能会丢失1秒的数据。</p></blockquote><p>我们现在的做法是一主(Master)多从(Slave)，主库不开启AOF持久化，只是每天备份一下RDB[官方给的建议是每小时备份RDB文件，看你的策略了]，而在从库上开启AOF备份，并且会用脚本将相应的备份文件推送到备份服务器。<br>当redis服务器挂掉时，重启时将按照以下优先级恢复数据到内存：</p><ul><li>如果只配置AOF,重启时加载AOF文件恢复数据；</li><li>如果同时 配置了RBD和AOF,启动是只加载AOF文件恢复数据;</li><li>如果只配置RBD,启动是讲加载dump文件恢复数据。</li></ul><font color="red">恢复时需要注意，要是主库挂了不能直接重启主库，否则会直接覆盖掉从库的AOF文件，一定要确保要恢复的文件都正确才能启动，否则会冲掉原来的文件。</font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，要知道redis是一个key-value内存存储系统，且是单线程模型。&lt;br&gt;与其他key-value缓存相比有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持数据持久化，可以将内存中的数据保存到磁盘，重启机器后可再次加载进来&lt;/li&gt;
&lt;li&gt;不仅仅支持key-value类型数据，还有哈希、列表、集合数据结构类型&lt;/li&gt;
&lt;li&gt;支持数据的备份，master-slave模式的数据备份&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;并且，redis的所有操作都具有原子性。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 底层索引原理【摘】</title>
    <link href="http://yoursite.com/2018/03/28/MySQL-%E5%BA%95%E5%B1%82%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E3%80%90%E6%91%98%E3%80%91/"/>
    <id>http://yoursite.com/2018/03/28/MySQL-底层索引原理【摘】/</id>
    <published>2018-03-28T10:47:37.000Z</published>
    <updated>2018-04-03T10:44:03.705Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><p>本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。本文将只关注于BTree索引。</p><p>文章主要内容分为三个部分。<br>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。<br>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。<br>第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。<br><a id="more"></a></p><h3 id="数据结构及算法基础"><a href="#数据结构及算法基础" class="headerlink" title="数据结构及算法基础"></a>数据结构及算法基础</h3><h4 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h4><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是一种数据结构。</p><p>数据库查询是数据库的主要功能之一，最基本的查询算法是顺序查找（linear search）时间复杂度为O(n)，显然在数据量很大时效率很低。优化的查找算法如二分查找（binary search）、二叉树查找（binary tree search）等，虽然查找效率提高了。但是各自对检索的数据都有要求：二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织）。所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构。这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。</p><p>看一个例子：<br><img src="/uploads/2018/04/mysql_index_01.png" alt="" title="图1"><br>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p><p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p><h4 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h4><p>关于B树和B+树请参考关于<a href="http://www.cnblogs.com/tgycoder/p/5077017.html" target="_blank" rel="noopener">B树的一些总结</a>，这篇文章介绍的比较详细，同时容易理解。</p><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p><h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p><ol><li>d&gt;=2，即B-Tree的度；</li><li>h为B-Tree的高；</li><li>每个非叶子结点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d；</li><li>每个叶子结点至少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶结点的指针均为NULL；</li><li>所有叶结点都在同一层，深度等于树高h；</li><li>key和指针相互间隔，结点两端是指针；</li><li>一个结点中的key从左至右非递减排列；</li><li>如果某个指针在结点node最左边且不为null，则其指向结点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。</li><li>如果某个指针在结点node最右边且不为null，则其指向结点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</li><li>如果某个指针在结点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向结点的所有key小于v(keyi+1)且大于v(keyi)。</li></ol><p><img src="/uploads/2018/04/mysql_index_02.png" alt="" title="图2是一个d=2的B-Tree示意图"></p><p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BTree_Search(node, key) &#123;</span><br><span class="line">    if(node == null) return null;</span><br><span class="line">    foreach(node.key)</span><br><span class="line">    &#123;</span><br><span class="line">        if(node.key[i] == key) return node.data[i];</span><br><span class="line">            if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    return BTree_Search(point[i+1]-&gt;node);</span><br><span class="line">&#125;</span><br><span class="line">data = BTree_Search(root, my_key);</span><br></pre></td></tr></table></figure></p><p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找结点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。<br>与B-Tree相比，B+Tree有以下不同点：</p><ol><li>每个结点的指针上限为2d而不是2d+1。</li><li>内结点不存储data，只存储key；叶子结点不存储指针。</li></ol><p><img src="/uploads/2018/04/mysql_index_03.png" alt="" title="图3是一个简单的B+Tree示意"></p><p>由于并不是所有节点都具有相同的域，因此B+Tree中叶结点和内结点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个结点的域和上限是一致的，所以在实现中B-Tree往往对每个结点申请同等大小的空间。</p><p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p><h5 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h5><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。<br><img src="/uploads/2018/04/mysql_index_04.png" alt="" title="图4"></p><p>如图4所示，在B+Tree的每个叶子结点增加一个指向相邻叶子结点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着结点和指针顺序遍历就可以一次性访问到所有数据结点，极大提到了区间查询效率。</p><p>这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p><h4 id="为什么使用B-Tree（B-Tree）"><a href="#为什么使用B-Tree（B-Tree）" class="headerlink" title="为什么使用B-Tree（B+Tree）"></a>为什么使用B-Tree（B+Tree）</h4><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><h5 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h5><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。<br><img src="/uploads/2018/04/mysql_index_05.png" alt="" title="图5"><br>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p><p>主存的存取过程如下：<br>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。<br>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。<br>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p><h4 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h4><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。<br><img src="/uploads/2018/04/mysql_index_06.png" alt="" title="图6是磁盘的整体结构示意图"></p><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。<br><img src="/uploads/2018/04/mysql_index_07.png" alt="" title="图7是磁盘结构的示意图"></p><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p><h5 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h5><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><font color="red">当一个数据被用到时，其附近的数据也通常会马上被使用。<br>程序运行期间所需要的数据通常比较集中。</font><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h4 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h4><p>从使用磁盘I/O次数评价索引结构的优劣性：根据B-Tree的定义，可知检索一次最多需要访问h个结点。数据库系统的设计者巧妙的利用了磁盘预读原理，将一个结点的大小设为等于一个页面，这样每个结点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p>每次新建结点时，直接申请一个页面的空间，这样可以保证一个结点的大小等于一个页面，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>B-Tree中一次检索最多需要h-1次I/O（根结点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出读d是非常大的数字，通常超过100，因此h非常小。</p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p>而红黑树结构，h明显要深得多。由于逻辑上很近的结点（父子结点）物理上可能离得很远，无法利用局部性原理。所以即使红黑树的I/O渐进复杂度也为O(h)，但是查找效率明显比B-Tree差得多。</p><p>B+Tree更适合外存索引，是和内结点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于结点内key和data的大小：dmax=floor(pagesize/(keysize+datasize+pointsize))。</p><p>floor表示向下取整。由于B+Tree内结点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p><p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p><h3 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h3><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎(MySQL数据库MyISAM和InnoDB存储引擎的比较)的索引实现方式。</p><h4 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h4><p>MyISAM引擎使用B+Tree作为索引结构，叶结点的data域存放的是数据记录的地址。下面是MyISAM索引的原理图：<br><img src="/uploads/2018/04/mysql_index_08.png" alt="" title="图8"><br>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：<br><img src="/uploads/2018/04/mysql_index_09.png" alt="" title="图9"><br>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h4 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h4><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶结点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。<br><img src="/uploads/2018/04/mysql_index_10.png" alt="" title="图10"><br>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶结点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：<br><img src="/uploads/2018/04/mysql_index_11.png" alt="" title="图11"><br>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><p>下一章将具体讨论这些与索引有关的优化策略。</p><h3 id="索引使用策略及优化"><a href="#索引使用策略及优化" class="headerlink" title="索引使用策略及优化"></a>索引使用策略及优化</h3><p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。</p><h4 id="示例数据库"><a href="#示例数据库" class="headerlink" title="示例数据库"></a>示例数据库</h4><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：<br><img src="/uploads/2018/04/mysql_index_12.png" alt="" title="图12"></p><h5 id="最左前缀原理与相关优化"><a href="#最左前缀原理与相关优化" class="headerlink" title="最左前缀原理与相关优化"></a>最左前缀原理与相关优化</h5><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p><p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组<a1, a2,="" …,="" an="">，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。</a1,></p><p>以employees.titles表为例，下面先查看其上都有哪些索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM employees.titles;</span><br><span class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span><br><span class="line">| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |</span><br><span class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span><br><span class="line">| titles |          0 | PRIMARY  |            1 | emp_no      | A         |        NULL |      | BTREE      |</span><br><span class="line">| titles |          0 | PRIMARY  |            2 | title       | A         |        NULL |      | BTREE      |</span><br><span class="line">| titles |          0 | PRIMARY  |            3 | from_date   | A         |      443308 |      | BTREE      |</span><br><span class="line">| titles |          1 | emp_no   |            1 | emp_no      | A         |      443308 |      | BTREE      |</span><br><span class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span><br></pre></td></tr></table></figure></p><p>从结果中可以到titles表的主索引为<code>&lt;emp_no, title, from_date&gt;</code>，还有一个辅助索引<code>&lt;emp_no&gt;</code>。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：<br><code>ALTER TABLE employees.titles DROP INDEX emp_no;</code><br>这样就可以专心分析索引PRIMARY的行为了。</p><h6 id="全列匹配"><a href="#全列匹配" class="headerlink" title="全列匹配"></a>全列匹配</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND title=&apos;Senior Engineer&apos; AND from_date=&apos;1986-06-26&apos;;</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br></pre></td></tr></table></figure><p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE from_date=&apos;1986-06-26&apos; AND emp_no=&apos;10001&apos; AND title=&apos;Senior Engineer&apos;;</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br></pre></td></tr></table></figure></p><p>效果是一样的。</p><h6 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos;;</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |       |</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</span><br></pre></td></tr></table></figure><p>当查询条件精确匹配索引的左边连续一个或几个列时，如<emp_no>或<emp_no, title="">，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</emp_no,></emp_no></p><h6 id="查询条件用到了索引中列的精确匹配，但是中间某个条件未提供"><a href="#查询条件用到了索引中列的精确匹配，但是中间某个条件未提供" class="headerlink" title="查询条件用到了索引中列的精确匹配，但是中间某个条件未提供"></a>查询条件用到了索引中列的精确匹配，但是中间某个条件未提供</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND from_date=&apos;1986-06-26&apos;;</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br></pre></td></tr></table></figure><p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引<emp_no, from_date="">，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</emp_no,></p><p>首先我们看下title一共有几种不同的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(title) FROM employees.titles;</span><br><span class="line">+--------------------+</span><br><span class="line">| title              |</span><br><span class="line">+--------------------+</span><br><span class="line">| Senior Engineer    |</span><br><span class="line">| Staff              |</span><br><span class="line">| Engineer           |</span><br><span class="line">| Senior Staff       |</span><br><span class="line">| Assistant Engineer |</span><br><span class="line">| Technique Leader   |</span><br><span class="line">| Manager            |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure></p><p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles</span><br><span class="line">WHERE emp_no=&apos;10001&apos;</span><br><span class="line">AND title IN (&apos;Senior Engineer&apos;, &apos;Staff&apos;, &apos;Engineer&apos;, &apos;Senior Staff&apos;, &apos;Assistant Engineer&apos;, &apos;Technique Leader&apos;, &apos;Manager&apos;)</span><br><span class="line">AND from_date=&apos;1986-06-26&apos;;</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |    7 | Using where |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure></p><p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILES;</span><br><span class="line">+----------+------------+-------------------------------------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                                                         |</span><br><span class="line">+----------+------------+-------------------------------------------------------------------------------+</span><br><span class="line">|       10 | 0.00058000 | SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND from_date=&apos;1986-06-26&apos;|</span><br><span class="line">|       11 | 0.00052500 | SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND title IN ...          |</span><br><span class="line">+----------+------------+-------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure></p><p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p><h6 id="查询条件没有指定索引第一列"><a href="#查询条件没有指定索引第一列" class="headerlink" title="查询条件没有指定索引第一列"></a>查询条件没有指定索引第一列</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE from_date=&apos;1986-06-26&apos;;</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure><p>由于不是最左前缀，索引这样的查询显然用不到索引。</p><h6 id="匹配某列前缀字符串"><a href="#匹配某列前缀字符串" class="headerlink" title="匹配某列前缀字符串"></a>匹配某列前缀字符串</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND title LIKE &apos;Senior%&apos;;</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 56      | NULL |    1 | Using where |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure><p>此时可以用到索引，<em>但是如果通配符不是只出现在末尾，则无法使用索引。</em>（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）</p><h6 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; &apos;10010&apos; and title=&apos;Senior Engineer&apos;;</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure><p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles</span><br><span class="line">WHERE emp_no &lt; &apos;10010&apos;</span><br><span class="line">AND title=&apos;Senior Engineer&apos;</span><br><span class="line">AND from_date BETWEEN &apos;1986-01-01&apos; AND &apos;1986-12-31&apos;;</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure></p><p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles</span><br><span class="line">WHERE emp_no BETWEEN &apos;10001&apos; AND &apos;10010&apos;</span><br><span class="line">AND title=&apos;Senior Engineer&apos;</span><br><span class="line">AND from_date BETWEEN &apos;1986-01-01&apos; AND &apos;1986-12-31&apos;;</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |   16 | Using where |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure></p><p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p><h6 id="查询条件中含有函数或表达式"><a href="#查询条件中含有函数或表达式" class="headerlink" title="查询条件中含有函数或表达式"></a>查询条件中含有函数或表达式</h6><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND left(title, 6)=&apos;Senior&apos;;</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br></pre></td></tr></table></figure></p><p>虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1=&apos;10000&apos;;</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure></p><p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p><h5 id="索引选择性与前缀索引"><a href="#索引选择性与前缀索引" class="headerlink" title="索引选择性与前缀索引"></a>索引选择性与前缀索引</h5><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p><p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p><p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：<br><code>Index Selectivity = Cardinality / #T</code></p><p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。</p><p><font color="red">这个问题就像是面试时提问我的一个问题：性别列适不适合建立索引？</font><br>例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.0000 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure></p><p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p><p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p><p>从图12可以看到employees表只有一个索引<code>&lt;emp_no&gt;</code>，那么如果我们想按名字搜索一个人，就只能全表扫描了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.employees WHERE first_name=&apos;Eric&apos; AND last_name=&apos;Anido&apos;;</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure></p><p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<code>&lt;first_name&gt;</code>或<code>&lt;first_name, last_name&gt;</code>，看下两个索引的选择性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.0042 |</span><br><span class="line">+-------------+</span><br><span class="line">SELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9313 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure></p><p><code>&lt;first_name&gt;</code>显然选择性太低，&lt;<code>first_name, last_name&gt;</code>选择性很好，但是<code>first_name</code>和<code>last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name</code>, <code>left(last_name, 3)&gt;</code>，看看其选择性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.7879 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure></p><p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9007 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure></p><p>这时选择性已经很理想了，而这个索引的长度只有18，比<first_name, last_name="">短了接近一半，我们把这个前缀索引 建上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employees.employees</span><br><span class="line">ADD INDEX first_name_last_name4 (first_name, last_name(4));</span><br></pre></td></tr></table></figure></first_name,></p><p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILES;</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                                                           |</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">|       87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name=&apos;Eric&apos; AND last_name=&apos;Anido&apos; |</span><br><span class="line">|       90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name=&apos;Eric&apos; AND last_name=&apos;Anido&apos; |</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure></p><p>性能的提升是显著的，查询速度提高了120多倍。</p><p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p><h4 id="InnoDB的主键选择与优化"><a href="#InnoDB的主键选择与优化" class="headerlink" title="InnoDB的主键选择与优化"></a>InnoDB的主键选择与优化</h4><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p><p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p><p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：<br><img src="/uploads/2018/04/mysql_index_13.png" alt="" title="图13"></p><p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：<br><img src="/uploads/2018/04/mysql_index_14.png" alt="" title="图14"></p><p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL索引背后的数据结构及算法原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。本文将只关注于BTree索引。&lt;/p&gt;
&lt;p&gt;文章主要内容分为三个部分。&lt;br&gt;第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。&lt;br&gt;第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。&lt;br&gt;第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 存储引擎详解</title>
    <link href="http://yoursite.com/2018/03/28/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/28/MySQL-存储引擎详解/</id>
    <published>2018-03-28T10:47:23.000Z</published>
    <updated>2018-03-28T10:58:26.417Z</updated>
    
    <content type="html"><![CDATA[<p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySql的核心就是存储引擎。</p><h4 id="存储引擎查看"><a href="#存储引擎查看" class="headerlink" title="存储引擎查看"></a>存储引擎查看</h4><p>MySQL给开发者提供了查询存储引擎的功能，我这里使用的是 10.1.28-MariaDB，可以使用：<br><code>show engines;</code><br><a id="more"></a></p><table><thead><tr><th>Engine</th><th>Suppert</th><th>Comment</th><th>Transactions</th><th>XA</th><th>Savepoints</th></tr></thead><tbody><tr><td>CSV</td><td>YES</td><td>CSV storage engine</td><td>No</td><td>No</td><td>No</td></tr><tr><td>InnoDB</td><td>DEFAULT</td><td>Comment: Percona-XtraDB, Supports transactions, row-level locking, foreignkeys and encryption for tables</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>MEMORY</td><td>YES</td><td>Hash based, stored in memory, useful for temporary tables</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>MyISAM</td><td>YES</td><td>MyISAM storage engine</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>MRG_MyISAM</td><td>YES</td><td>Collection of identical MyISAM tables</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>Aria</td><td>YES</td><td>Crash-safe tables with MyISAM heritage</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>PERFORMANCE_SCHEMA</td><td>YES</td><td>Performance Schema</td><td>NO</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>SEQUENCE</td><td>YES</td><td>Generated tables filled with sequential values</td><td>YES</td><td>NO</td><td>YES</td></tr></tbody></table><p>看到MySQL给用户提供了这么多存储引擎，包括处理事务安全表的引擎和出来了非事物安全表的引擎。</p><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，上图也看到了，InnoDB是默认的MySQL引擎。<br>InnoDB存储表和索引有一下两种方式：</p><ol><li>使用共享表空间存储，这种方式创建的表的表结构保存在.frm文件中，数据和索引保存在innodb_data_home_dir和innodb_data_file_path定义的表空间中，可以是多个文件。</li><li>使用多表空间存储，这种方式创建的表的表结构仍然保存在.frm文件中，但是每个表的数据和索引单独保存在.ibd中，如果是个分区表，则每个分区对应单独的.ibd文件，文件名是”表名+分区名”，可以在创建分区的时候指定每个分区的数据文件位置，以此来将表的IO均匀分布在多个磁盘上。</li></ol><p><strong>选择理由：</strong><br>用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据一致性，数据操作除了插入和查询意外，还包括很多的更新删除操作，那么InnoDB比较合适。InnoDB存储引擎除了有效的降低由于删除和更新操作导致的锁定，还可以确保事务的完整提交和回滚。</p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事物。<br>每个MyISAM在磁盘上存储成3个文件，文件名都和表名相同，但是扩展名不同，扩展名分别是：</p><ol><li>.frm（存储表定义）；</li><li>.MYD（MYData，存储数据）；</li><li>.MYI（MYIndex，存储索引）；</li></ol><p>MyISAM的表还支持3种不同的存储格式，分别是：</p><ol><li>静态（固定长度）表；</li><li>动态表；</li><li>压缩表；</li></ol><p><strong>选择理由：</strong><br>如果应用是以读写操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高可选用此种存储引擎。</p><h4 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h4><p>MEMORY存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。<br>MEMORY存储引擎使用存在于内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件，格式.frm。MEMORY类型的表访问非常快，因为它的数据是存放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失。</p><p><strong>选择理由：</strong><br>将所有的数据保存在RAM中，在需要快速定位记录和其他类似数据的环境下，可提供极快的访问。MEMORY的缺陷是对表的大小有限制，太大的表无法缓存在内存中，其次要确保表数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。</p><h4 id="下面对一些常用的引擎的特点进行汇总"><a href="#下面对一些常用的引擎的特点进行汇总" class="headerlink" title="下面对一些常用的引擎的特点进行汇总"></a>下面对一些常用的引擎的特点进行汇总</h4><table><thead><tr><th>功  能</th><th>MYISAM</th><th>Memory</th><th>InnoDB</th><th>Archive</th></tr></thead><tbody><tr><td>存储限制</td><td>256TB</td><td>RAM</td><td>64TB</td><td>None</td></tr><tr><td>支持事物</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>支持全文索引</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>支持数索引</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>支持哈希索引</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>支持数据缓存</td><td>No</td><td>N/A</td><td>Yes</td><td>No</td></tr><tr><td>支持外键</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr></tbody></table><p><strong>存储引擎的选择：</strong><br>如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个好的选择</p><p>如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率</p><p>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果</p><p>如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archive</p><p>使用哪一种引擎需要灵活选择，一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求，使用合适的存储引擎，将会提高整个数据库的性能</p><h4 id="MyISAM与InnoDB的区别"><a href="#MyISAM与InnoDB的区别" class="headerlink" title="MyISAM与InnoDB的区别"></a>MyISAM与InnoDB的区别</h4><p>1、InnoDB支持事务处理，而MyISAM不支持<br>2、InnoDB支持外键，而MyISAM不支持<br>3、InnoDB是行锁，而MyISAM是表锁（行锁开销大，高并发；表锁开销小，并发低）<br>4、MyISAM支持全文索引，而InnoDB不支持</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySql的核心就是存储引擎。&lt;/p&gt;
&lt;h4 id=&quot;存储引擎查看&quot;&gt;&lt;a href=&quot;#存储引擎查看&quot; class=&quot;headerlink&quot; title=&quot;存储引擎查看&quot;&gt;&lt;/a&gt;存储引擎查看&lt;/h4&gt;&lt;p&gt;MySQL给开发者提供了查询存储引擎的功能，我这里使用的是 10.1.28-MariaDB，可以使用：&lt;br&gt;&lt;code&gt;show engines;&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 的事务处理以及隔离级别</title>
    <link href="http://yoursite.com/2018/03/28/MySQL-%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/28/MySQL-的事务处理以及隔离级别/</id>
    <published>2018-03-28T10:47:09.000Z</published>
    <updated>2018-03-28T11:10:04.627Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容出自《高性能MySQL》第三版，了解事务的ACID及四种隔离级有助于我们更好的理解事务运作。<br>下面举一个银行应用是解释事务必要性的一个经典例子。假如一个银行的数据库有两张表：支票表（checking）和储蓄表（savings）。现在要从用户Jane的支票账户转移200美元到她的储蓄账户，那么至少需要三个步骤：</p><blockquote><p>1、检查支票账户的余额高于或者等于200美元。<br>2、从支票账户余额中减去200美元。<br>3、在储蓄帐户余额中增加200美元。</p></blockquote><p>上述三个步骤的操作必须打包在一个事务中，任何一个步骤失败，则必须回滚所有的步骤。<br><a id="more"></a></p><h4 id="1、事务处理的基本语法"><a href="#1、事务处理的基本语法" class="headerlink" title="1、事务处理的基本语法"></a>1、事务处理的基本语法</h4><p>可以用START TRANSACTION语句开始一个事务，然后要么使用COMMIT提交将修改的数据持久保存，要么使用ROLLBACK撤销所有的修改。事务SQL的样本如下：</p><blockquote><p>1.start transaction;<br>2.select balance from checking where customer_id = 10233276;<br>3.update checking set balance = balance - 200.00 where customer_id = 10233276;<br>4.update savings set balance = balance + 200.00 where customer_id = 10233276;<br>5.commit;</p></blockquote><h4 id="2、事务处理的特性"><a href="#2、事务处理的特性" class="headerlink" title="2、事务处理的特性"></a>2、事务处理的特性</h4><p>ACID表示原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。一个很好的事务处理系统，必须具备这些标准特性：</p><h5 id="原子性（atomicity）"><a href="#原子性（atomicity）" class="headerlink" title="原子性（atomicity）"></a>原子性（atomicity）</h5><p>　　一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性</p><h5 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h5><p>　　数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）</p><h5 id="隔离性（isolation）"><a href="#隔离性（isolation）" class="headerlink" title="隔离性（isolation）"></a>隔离性（isolation）</h5><p>　　通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）</p><h5 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h5><p>　　一旦事务提交，则其所做的修改不会永久保存到数据库。（此时即使系统崩溃，修改的数据也不会丢失。持久性是个有占模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必，而且不可能有能做到100%的持久性保证的策略。）</p><h4 id="3、事务处理的隔离级别"><a href="#3、事务处理的隔离级别" class="headerlink" title="3、事务处理的隔离级别"></a>3、事务处理的隔离级别</h4><h5 id="READ-UNCOMMITTED（未提交读）"><a href="#READ-UNCOMMITTED（未提交读）" class="headerlink" title="READ UNCOMMITTED（未提交读）"></a>READ UNCOMMITTED（未提交读）</h5><p>　　在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。</p><h5 id="READ-COMMITTED（提交读）"><a href="#READ-COMMITTED（提交读）" class="headerlink" title="READ COMMITTED（提交读）"></a>READ COMMITTED（提交读）</h5><p>　　大多数数据库系统的默认隔离级别都是READ COMMTTED（但MySQL不是）。READ COMMITTED满足前面提到的隔离性的简单定义：一个事务开始时，只能”看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候叫做不可重复读（nonrepeatble read），因为两次执行同样的查询，可能会得到不一样的结果</p><h5 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE READ(可重复读)"></a>REPEATABLE READ(可重复读)</h5><p>　　REPEATABLE READ解决了脏读的问题。该隔离级别保证了在同一个事务中多次读取同样记录结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。</p><h5 id="SERIALIZABLE（可串行化）"><a href="#SERIALIZABLE（可串行化）" class="headerlink" title="SERIALIZABLE（可串行化）"></a>SERIALIZABLE（可串行化）</h5><p>　　SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE会在读取每一行数据都加锁，所以可能导致大量的超时和锁争用问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。</p><p>下面对隔离级别进行汇总，如下表：<br><img src="/uploads/2018/03/mysql_transaction_character.png" alt=""></p><h4 id="4、事务处理的相关语法总结"><a href="#4、事务处理的相关语法总结" class="headerlink" title="4、事务处理的相关语法总结"></a>4、事务处理的相关语法总结</h4><h5 id="1、查询当前这个点的下一个事务隔离级别："><a href="#1、查询当前这个点的下一个事务隔离级别：" class="headerlink" title="1、查询当前这个点的下一个事务隔离级别："></a>1、查询当前这个点的下一个事务隔离级别：</h5><p><code>select @@tx_isolation;</code><br><img src="/uploads/2018/03/mysql_transaction_level_01.png" alt=""></p><h5 id="2、查询全局事务隔离级别，也就是从这个点开始的下一个事务起所有的事务都采用设置的该隔离级别："><a href="#2、查询全局事务隔离级别，也就是从这个点开始的下一个事务起所有的事务都采用设置的该隔离级别：" class="headerlink" title="2、查询全局事务隔离级别，也就是从这个点开始的下一个事务起所有的事务都采用设置的该隔离级别："></a>2、查询全局事务隔离级别，也就是从这个点开始的下一个事务起所有的事务都采用设置的该隔离级别：</h5><p><code>select @@global.tx_isolation;</code><br><img src="/uploads/2018/03/mysql_transaction_level_02.png" alt=""></p><h5 id="3、查询当前所在的事务的隔离级别："><a href="#3、查询当前所在的事务的隔离级别：" class="headerlink" title="3、查询当前所在的事务的隔离级别："></a>3、查询当前所在的事务的隔离级别：</h5><p><code>select @@session.tx_isolation;</code><br><img src="/uploads/2018/03/mysql_transaction_level_03.png" alt=""></p><h5 id="4、设置事务隔离级别"><a href="#4、设置事务隔离级别" class="headerlink" title="4、设置事务隔离级别"></a>4、设置事务隔离级别</h5><p>1.在my.cnf文件中的mysqld中进行更改。可供更改的leve 【READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE】<br>如：<code>transaction_isolation = SERIALIZABLE</code></p><p>2.用mysql语句进行更改，语法 <code>set tx_isolation= level</code>   level级别【READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE】</p><p>注：可通过上述语法查询是否更改。</p><h4 id="5、事务隔离级别示例详解"><a href="#5、事务隔离级别示例详解" class="headerlink" title="5、事务隔离级别示例详解"></a>5、事务隔离级别示例详解</h4><h5 id="1、脏读："><a href="#1、脏读：" class="headerlink" title="1、脏读："></a>1、<strong>脏读：</strong></h5><p>脏读指的是一个事务修改本事务的数据，但没有提交的情况下，本事务可以查看到更改了却没有提交的数据。这种情况只可能发生在未提交读readuncommitted的隔离级别里。</p><blockquote><p>首先设置事务隔离级别为read-uncommited<br>事务一：给t表添加数据a=1但并不提交！查询t表的结果里本事务是可以看到未提交的操作结果的。<br><img src="/uploads/2018/03/mysql_transaction_example_01.png" alt=""><br>事务二：查询t表的数据，这个时候事务一是没有提交的!要确保事务二的隔离级别是read-uncommited。<br><img src="/uploads/2018/03/mysql_transaction_example_02.png" alt=""></p></blockquote><p>这个情况就是所谓的脏读！只可能出现在read-uncommit隔离级别里！自己可尝试其他级别试试</p><h5 id="2、不重复读："><a href="#2、不重复读：" class="headerlink" title="2、不重复读："></a>2、<strong>不重复读：</strong></h5><p>指的是一个事务多次读取同一个数据，但此过程中第二个事务对第一个事务进行了修改，这就造成了第一个事务的多次读取过程中的结果出现了前后不一致的情况，这就是不可重复读！这个情况可以出现在read-uncommited和read-committed两个隔离级别里！</p><blockquote><p>先看反例repeatable-read隔离级别下的情况，这种级别下只会读取首次select的点的数据结果，以避免出现不重复读的情况：<br>事务一：查询t表a=5，然后update进行修改a=22，查看修改后的结果最后提交<br><img src="/uploads/2018/03/mysql_transaction_example_03.png" alt=""><br>事务二：在事务一开始后select操作时同时也进行两次查询，查询结果和事务一的结果一致，都是5，等到事务一update操作后事务二进行第三次查询，查询结果依旧为5，事务一提交后，事务二进行第四次查询，结果依旧是5，没有任何改变，所以repeatable-read的隔离级别解决了重复读的问题。<br><img src="/uploads/2018/03/mysql_transaction_example_04.png" alt=""></p></blockquote><p><strong>下面我们再来看read-commit隔离级别下的情况：</strong><br>事务一：<br><img src="/uploads/2018/03/mysql_transaction_example_05.png" alt=""><br>事务二：<br><img src="/uploads/2018/03/mysql_transaction_example_06.png" alt=""></p><h5 id="3、幻读："><a href="#3、幻读：" class="headerlink" title="3、幻读："></a>3、<strong>幻读：</strong></h5><p>在repeatable-read级别下解决了不可重复读的问题，但是还有没有解决的地方，那就是幻读，幻读是指在一个事务中，事务一对数据进行了更改并提交了，而事务二也对该数据进行了更改，但是更改的情况可能会受到事务一更改的影响，从而引起更改仿佛不存在，这就是幻读！这是由于repeatable-read的隔离措施只读取初次select的点导致的。</p><blockquote><p>t表的有一行数据，a=5<br>事务一：首先读取t表，发现有一个a=5的数据，然后更改该数据为25并提交<br><img src="/uploads/2018/03/mysql_transaction_example_07.png" alt=""><br>事务二：首先读取t表，发现有一个a=5的数据，这个时候事务一已经删除数据并期间了，但是由于隔离级别是repeatable-read导致读取的结果是a=5的数据还在，这个时候如果事务二对该数据进行更改，改为26，提交后发现之前的更改无效，该行数据a=25，这是因为事务一已经对a=5的数据进行了更改，改为了25，这个时候a=5的数据已经不存在了，因此这次更改无效，等同于幻影，这就是幻读！<br><img src="/uploads/2018/03/mysql_transaction_example_08.png" alt=""></p></blockquote><p>可以从这里看出，提交读解决了脏读问题，而重复读解决了不重复读的问题，串行化解决幻读的问题，但是也会造成锁竞争，可能造成大量的超时问题，因为串行化是给每个读的数据行加上共享锁，通过强制事务进行排序，以此防止相互冲突，具体原理以后再做说明。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容出自《高性能MySQL》第三版，了解事务的ACID及四种隔离级有助于我们更好的理解事务运作。&lt;br&gt;下面举一个银行应用是解释事务必要性的一个经典例子。假如一个银行的数据库有两张表：支票表（checking）和储蓄表（savings）。现在要从用户Jane的支票账户转移200美元到她的储蓄账户，那么至少需要三个步骤：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、检查支票账户的余额高于或者等于200美元。&lt;br&gt;2、从支票账户余额中减去200美元。&lt;br&gt;3、在储蓄帐户余额中增加200美元。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述三个步骤的操作必须打包在一个事务中，任何一个步骤失败，则必须回滚所有的步骤。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>windows 7设置WiFi热点</title>
    <link href="http://yoursite.com/2018/03/27/windows-7%E8%AE%BE%E7%BD%AEWiFi%E7%83%AD%E7%82%B9/"/>
    <id>http://yoursite.com/2018/03/27/windows-7设置WiFi热点/</id>
    <published>2018-03-27T08:04:35.000Z</published>
    <updated>2018-03-27T08:09:47.827Z</updated>
    
    <content type="html"><![CDATA[<p>点击可查看…<br><a id="more"></a></p><h4 id="1、查看是否支持并开启"><a href="#1、查看是否支持并开启" class="headerlink" title="1、查看是否支持并开启"></a>1、查看是否支持并开启</h4><p>首先打开自己的网络连接，看一下有没有上述网卡图标，若有则进行下一步，若没有则打开设备管理器，找到网卡选项，右击选择更新网卡驱动，若此时出现说明你的电脑支持此功能，若没有出现，则说明电脑不支持。<br><img src="/uploads/2018/03/network_wifi_01.jpg" alt=""></p><h4 id="2、设置WiFi热点"><a href="#2、设置WiFi热点" class="headerlink" title="2、设置WiFi热点"></a>2、设置WiFi热点</h4><p>点击 开始， 选择 附件，找到命令提示符，右击选择以管理员方式运行<br>输入：<code>netsh wlan set hostednetwork mode=allow ssid=&quot;无线热点的名字&quot; key=“w ifi的密码”</code>，然后回车，如果出现如下的信息，则表示设置成功：<br><img src="/uploads/2018/03/network_wifi_02.jpg" alt=""><br><img src="/uploads/2018/03/network_wifi_03.jpg" alt=""></p><h4 id="3、开启WiFi"><a href="#3、开启WiFi" class="headerlink" title="3、开启WiFi"></a>3、开启WiFi</h4><p>至此wifi已经设置完成，现在就是开始运行问题，输入：netsh wlan start hostednetwork 然后回车，则启动wifi<br>以后，每次重启电脑后都需要运行netsh wlan start hostednetwork命令来启动<br><img src="/uploads/2018/03/network_wifi_04.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击可查看…&lt;br&gt;
    
    </summary>
    
      <category term="Windows" scheme="http://yoursite.com/categories/Windows/"/>
    
    
      <category term="Windows" scheme="http://yoursite.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>算法概述及效率的度量</title>
    <link href="http://yoursite.com/2018/03/26/%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F/"/>
    <id>http://yoursite.com/2018/03/26/算法概述及效率的度量/</id>
    <published>2018-03-26T02:39:43.000Z</published>
    <updated>2018-03-26T02:45:14.977Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、算法的定义"><a href="#1、算法的定义" class="headerlink" title="1、算法的定义"></a>1、算法的定义</h4><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><h4 id="2、算法具有的武哥基本特性"><a href="#2、算法具有的武哥基本特性" class="headerlink" title="2、算法具有的武哥基本特性"></a>2、算法具有的武哥基本特性</h4><ul><li><strong>有穷性：</strong> 指算法在执行有限的步骤之后，自动结束而不会出现无线循环，并且每一个步骤在可接受的时间内完成。</li><li><strong>确定性：</strong> 算法的每一步骤都具有确定的含义，不会出现二义性。</li><li><strong>可行性：</strong> 算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</li><li><strong>输入：</strong> 一个算法有零个或多个的输入，这些输入取自于某个特定的对象的集合。</li><li><strong>输出：</strong> 一个算法有一个或多个的输出，这些输出是同输入有着某些特定关系的量。</li></ul><a id="more"></a><h4 id="3、算法设计的要求"><a href="#3、算法设计的要求" class="headerlink" title="3、算法设计的要求"></a>3、算法设计的要求</h4><p>设计算法时，通常应考虑达到以下目标：</p><ul><li><strong>正确性：</strong> 算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。</li><li><strong>可读性：</strong> 算法设计的另一个目的是为了便于阅读、理解和交流。另一方面，晦涩难懂的程序易于隐藏较多错误而难以调试。</li><li><strong>健壮性：</strong> 当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</li><li><strong>高效率与低存储量：</strong> 通常，效率指的是算法执行时间；存储量指的是算法执行过程中所需的最大存储空间，两者都与问题的规模相关。</li></ul><h4 id="4、算法效率的度量方法："><a href="#4、算法效率的度量方法：" class="headerlink" title="4、算法效率的度量方法："></a>4、算法效率的度量方法：</h4><ul><li><strong>事后统计方法：</strong> 这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</li><li><strong>事前分析估算法：</strong> 在计算机程序编制前，依据统计方法对算法进行估算。一个程序的运行时间，依赖于算法的好坏和问题的输入规模。（所谓问题输入规模是指输入量的多少。）</li></ul><h4 id="5、算法的时间复杂度"><a href="#5、算法的时间复杂度" class="headerlink" title="5、算法的时间复杂度"></a>5、算法的时间复杂度</h4><p>算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。他表示岁问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为<strong>时间复杂度</strong>。</p><blockquote><p>推导大O阶：<br>1.用常数1取代运行时间中的所有加法常数。<br>2.在修改后的运行次数函数中，只保留最高阶项。<br>3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。<br>得到的结果就是大O阶。</p></blockquote><table><thead><tr><th>执行次数函数</th><th>阶</th><th>非正式术语</th></tr></thead><tbody><tr><td>12</td><td>O(1)</td><td>常数阶</td></tr><tr><td>2n+3</td><td>O(n)</td><td>线性阶</td></tr><tr><td>3n^2+2n+1</td><td>O(n^2)</td><td>平方阶</td></tr><tr><td>5log2n+20</td><td>O(logn)</td><td>对数阶</td></tr><tr><td>2n+3nlog2n+19</td><td>O(nlogn)</td><td>nlogn阶</td></tr><tr><td>6n^3+2n^2+3n+4</td><td>O(n^3)</td><td>立方阶</td></tr><tr><td>2^n</td><td>O(2^n)</td><td>指数阶</td></tr></tbody></table><p><strong>常用的时间复杂度所耗费的时间从小到大依次是：</strong><br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</p><h4 id="6、算法空间复杂度"><a href="#6、算法空间复杂度" class="headerlink" title="6、算法空间复杂度"></a>6、算法空间复杂度</h4><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p><p><strong>（注：一般在没有特殊说明的情况下，都是指最坏时间复杂度。）</strong></p><h4 id="7、算法的时间复杂度推导公式"><a href="#7、算法的时间复杂度推导公式" class="headerlink" title="7、算法的时间复杂度推导公式"></a>7、算法的时间复杂度推导公式</h4><p>待补充…</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、算法的定义&quot;&gt;&lt;a href=&quot;#1、算法的定义&quot; class=&quot;headerlink&quot; title=&quot;1、算法的定义&quot;&gt;&lt;/a&gt;1、算法的定义&lt;/h4&gt;&lt;p&gt;算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。&lt;/p&gt;
&lt;h4 id=&quot;2、算法具有的武哥基本特性&quot;&gt;&lt;a href=&quot;#2、算法具有的武哥基本特性&quot; class=&quot;headerlink&quot; title=&quot;2、算法具有的武哥基本特性&quot;&gt;&lt;/a&gt;2、算法具有的武哥基本特性&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有穷性：&lt;/strong&gt; 指算法在执行有限的步骤之后，自动结束而不会出现无线循环，并且每一个步骤在可接受的时间内完成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确定性：&lt;/strong&gt; 算法的每一步骤都具有确定的含义，不会出现二义性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可行性：&lt;/strong&gt; 算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输入：&lt;/strong&gt; 一个算法有零个或多个的输入，这些输入取自于某个特定的对象的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出：&lt;/strong&gt; 一个算法有一个或多个的输出，这些输出是同输入有着某些特定关系的量。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下二进制文件命令存放目录区别</title>
    <link href="http://yoursite.com/2018/03/20/Linux-%E4%B8%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E5%AD%98%E6%94%BE%E7%9B%AE%E5%BD%95%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/20/Linux-下二进制文件命令存放目录区别/</id>
    <published>2018-03-20T10:48:21.000Z</published>
    <updated>2018-03-20T10:50:35.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二进制文件命令：</p><ul><li>/bin　　# 系统的一些指令</li><li>/sbin　　# 一般是指超级用户指令</li><li>/usr/bin　　# 后期安装的一些软件的运行脚本</li><li>/usr/sbin　　# 一些用户安装的系统管理的必备程序</li><li>/usr/local/bin　　# 通常是源码编译的软件</li><li>/usr/local/sbin　　# 通常是源码编译的软件，用来管理系统的程序</li></ul></blockquote><a id="more"></a><p><strong>首先看下PATH变量在不同用户下的值：</strong><br><strong>root用户：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos /]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure></p><p><strong>普通用户：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ben@VM_0_7_centos ~]$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/ben/.local/bin:/home/ben/bin</span><br></pre></td></tr></table></figure></p><p>（注：bin是binary的缩写，二进制。sbin意义为system binary。）</p><blockquote><p>由上面可知道 root权限都没有 /bin、/sbin 的目录使用权。为什么呢？<br>原因就是，/bin以及/sbin是和/在同一文件系统，在挂载其他文件系统之前就可以使用/bin以及/sbin下的命令。<br>/usr/bin，/usr/sbin，/usr/local/bin，/usr/local/sbin可能与根文件系统不在同一文件系统之中，可能是在其他文件系统中后挂载上去的。<br>而我的服务器是 腾讯云，因此也是挂载上去的。</p></blockquote><p>从命令功能来看，/sbin 下的命令属于基本的系统命令，如shutdown，reboot，用于启动系统，修复系统，/bin下存放一些普通的基本命令，如ls,chmod等，这些命令在Linux系统里的配置文件脚本里经常用到。</p><p>从用户权限的角度看，/sbin目录下的命令通常只有管理员才可以运行，/bin下的命令管理员和一般的用户都可以使用。</p><p>从可运行时间角度看，/sbin,/bin能够在挂载其他文件系统前就可以使用。</p><p><strong>下面来说一下常用的目录：</strong></p><blockquote><p><strong>/bin 是系统的一些指令。</strong><br>bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。<br><strong>/sbin 一般是指超级用户指令。</strong><br>主要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。<br><strong>/usr/bin 是你在后期安装的一些软件的运行脚本。</strong><br>主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome<em>、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb</em>、wget等。<br><strong>/usr/sbin 放置一些用户安装的系统管理的必备程式</strong><br>例如:dhcpd、httpd、imap、in.<em>d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。<br><strong>/usr/local/bin </strong><br>很多时候我们自己安装的软件，可能在此处建立一个软连接（符号链接），指向实际的可执行文件。<br><em>*/usr/local/sbin</em></em><br>也是我们自己安装的软件，一般用来管理系统的程序</p></blockquote><p>（注：以上所说的并不是绝对的，例如ifconfig在/sbin下，但是普通用户一般具有可执行权限。）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;二进制文件命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/bin　　# 系统的一些指令&lt;/li&gt;
&lt;li&gt;/sbin　　# 一般是指超级用户指令&lt;/li&gt;
&lt;li&gt;/usr/bin　　# 后期安装的一些软件的运行脚本&lt;/li&gt;
&lt;li&gt;/usr/sbin　　# 一些用户安装的系统管理的必备程序&lt;/li&gt;
&lt;li&gt;/usr/local/bin　　# 通常是源码编译的软件&lt;/li&gt;
&lt;li&gt;/usr/local/sbin　　# 通常是源码编译的软件，用来管理系统的程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7修改yum源</title>
    <link href="http://yoursite.com/2018/03/20/CentOS-7%E4%BF%AE%E6%94%B9yum%E6%BA%90/"/>
    <id>http://yoursite.com/2018/03/20/CentOS-7修改yum源/</id>
    <published>2018-03-20T10:48:03.000Z</published>
    <updated>2018-03-20T10:49:09.568Z</updated>
    
    <content type="html"><![CDATA[<p>官方的yum源在国内访问效果不佳。<br>需要改为国内比较好的阿里云或者网易的yum源。</p><p>1、配置 yum源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 备份当前的yum源</span><br><span class="line">cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS.Base.repo.bak</span><br><span class="line"></span><br><span class="line"># 下载阿里云的yum配置源</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure></p><p>2、然后更新缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官方的yum源在国内访问效果不佳。&lt;br&gt;需要改为国内比较好的阿里云或者网易的yum源。&lt;/p&gt;
&lt;p&gt;1、配置 yum源&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git 源码安装升级CentOS 7中版本</title>
    <link href="http://yoursite.com/2018/03/19/Git-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E5%8D%87%E7%BA%A7CentOS-7%E4%B8%AD%E7%89%88%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/03/19/Git-源码安装升级CentOS-7中版本/</id>
    <published>2018-03-19T05:49:30.000Z</published>
    <updated>2018-03-19T06:07:19.817Z</updated>
    
    <content type="html"><![CDATA[<p>服务器上报个漏洞警告：</p><blockquote><p><strong>漏洞名称：</strong>Git 远程代码执行漏洞 (CVE-2016-2315)<br><strong>漏洞描述：</strong>Git小于2.7.1的全版本中存在一个由于整数溢出导致的缓冲区边界溢出的远程代码执行漏洞，可使攻击者远程执行任意代码</p></blockquote><p>因此，才有了这篇升级安装Git，使用源码编译安装指定版本。</p><h4 id="1、下载-Git最新版的源码包"><a href="#1、下载-Git最新版的源码包" class="headerlink" title="1、下载 Git最新版的源码包"></a>1、下载 Git最新版的源码包</h4><p>登录<a href="https://github.com/git/git/releases查看git的最新版。不要下载带有-rc的，因为它代表了一个候选发布版本。" target="_blank" rel="noopener">https://github.com/git/git/releases查看git的最新版。不要下载带有-rc的，因为它代表了一个候选发布版本。</a><br>安装指令：<br><code>wget https://www.kernel.org/pub/software/scm/git/git-2.16.2.tar.gz</code><br><a id="more"></a><br><img src="/uploads/2018/03/git_releases_download.png" alt=""></p><h4 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h4><p><code>tar -xvf git-2.16.2</code></p><h4 id="3、进行目录配置"><a href="#3、进行目录配置" class="headerlink" title="3、进行目录配置"></a>3、进行目录配置</h4><p><code>cd git-2.16.2</code><br><code>./configure --prefix=/usr/local/git</code><br>结果显示没有 configure 文件，尴尬了！<br>根据网上搜索才了解到查找解压包中没有对应的 configure 文件，因此应该找README 或者 INSTALL 之类的文档。</p><p>通过 INSTALL安装文档可知，执行如下命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make configure ;# as yourself</span><br><span class="line">$ ./configure --prefix=/usr ;# as yourself</span><br><span class="line">$ make all doc ;# as yourself</span><br><span class="line"># make install install-doc install-html;# as root</span><br></pre></td></tr></table></figure></p><p>① 执行 <code>make configure</code>：报错</p><blockquote><p>[root@VM_0_7_centos git-2.16.2]# make configure<br>GIT_VERSION = 2.16.2<br>    GEN configure<br>/bin/sh: autoconf: command not found<br>make: <strong>* [configure] Error 127</strong>解决方法：**<br><code>[root@VM_0_7_centos git-2.16.2]# yum install -y autoconf</code></p></blockquote><p>② <code>./configure --prefix=/usr/local/git</code> 成功执行</p><p>③ <code>make</code>：报错</p><blockquote><p>Can’t locate ExtUtils/MakeMaker.pm in @INC (@INC contains: /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .) at Makefile.PL line 3.<br>BEGIN failed–compilation aborted at Makefile.PL line 3.<br>make[1]: <strong><em> [perl.mak] Error 2<br>make: </em></strong> [perl/perl.mak] Error 2<br><strong>解决方法：</strong><br><code>[root@VM_0_7_centos git-2.16.2]# yum install -y perl-ExtUtils-MakeMaker</code></p></blockquote><p>④ <code>make install</code> 成功执行，安装完成。<br>（注：如何确认是否安装完成，只要看 <code>make</code> 执行后的结果没有报错，基本都是ok的。）</p><h4 id="4、配置全局路径"><a href="#4、配置全局路径" class="headerlink" title="4、配置全局路径"></a>4、配置全局路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/usr/local/git/bin:$PATH&quot; </span><br><span class="line">source /etc/profile# 使/etc/profile 文件中的环境变量立即生效</span><br></pre></td></tr></table></figure><p>（注：此配置全局路径只是对当前生效，重启后就会失效。）<br>可使用软连接的形式，来使命令长久生效：<br><code>ln -s /usr/local/git/bin/git /usr/local/bin/git</code></p><h4 id="5、查看Git版本"><a href="#5、查看Git版本" class="headerlink" title="5、查看Git版本"></a>5、查看Git版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos git-2.16.2]# git --version</span><br><span class="line">git version 2.16.2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务器上报个漏洞警告：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;漏洞名称：&lt;/strong&gt;Git 远程代码执行漏洞 (CVE-2016-2315)&lt;br&gt;&lt;strong&gt;漏洞描述：&lt;/strong&gt;Git小于2.7.1的全版本中存在一个由于整数溢出导致的缓冲区边界溢出的远程代码执行漏洞，可使攻击者远程执行任意代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，才有了这篇升级安装Git，使用源码编译安装指定版本。&lt;/p&gt;
&lt;h4 id=&quot;1、下载-Git最新版的源码包&quot;&gt;&lt;a href=&quot;#1、下载-Git最新版的源码包&quot; class=&quot;headerlink&quot; title=&quot;1、下载 Git最新版的源码包&quot;&gt;&lt;/a&gt;1、下载 Git最新版的源码包&lt;/h4&gt;&lt;p&gt;登录&lt;a href=&quot;https://github.com/git/git/releases查看git的最新版。不要下载带有-rc的，因为它代表了一个候选发布版本。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/git/git/releases查看git的最新版。不要下载带有-rc的，因为它代表了一个候选发布版本。&lt;/a&gt;&lt;br&gt;安装指令：&lt;br&gt;&lt;code&gt;wget https://www.kernel.org/pub/software/scm/git/git-2.16.2.tar.gz&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>FTP 客户端报错集锦</title>
    <link href="http://yoursite.com/2018/03/19/FTP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8A%A5%E9%94%99%E9%9B%86%E9%94%A6/"/>
    <id>http://yoursite.com/2018/03/19/FTP-客户端报错集锦/</id>
    <published>2018-03-19T03:19:53.000Z</published>
    <updated>2018-03-19T03:24:34.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、ftp-客户端连接报错，如下："><a href="#1、ftp-客户端连接报错，如下：" class="headerlink" title="1、ftp 客户端连接报错，如下："></a>1、ftp 客户端连接报错，如下：</h4><blockquote><p><img src="/uploads/2018/03/ftp_connect_error.png" alt="" title="ftp连接超时"></p></blockquote><p>经查看是因为 服务器端对应的 21号端口未开启，开启即可，命令如下：<br><code>iptables -I INPUT 4 -p tcp -m tcp --dport 21 -j ACCEPT</code><br><a id="more"></a></p><h4 id="2、ftp-客户端连接成功，而读取目录失败，如下："><a href="#2、ftp-客户端连接成功，而读取目录失败，如下：" class="headerlink" title="2、ftp 客户端连接成功，而读取目录失败，如下："></a>2、ftp 客户端连接成功，而读取目录失败，如下：</h4><blockquote><p><img src="/uploads/2018/03/ftp_writedir_error.png" alt="" title="ftp读取目录失败"></p></blockquote><p>经过查找，发现是因为ftp数据连接模式的问题，ftp连接模式有两种：PORT（主动模式）和PASV（被动模式）。两者的前面文章中已经说明两者的区别，在这里我选择“主动模式”，只开放ftp服务端20端口传输数据，客户端随机产生大于1024端口号。<br>然后，开启服务端20端口权限即可，命令如下：<br><code>iptables -I INPUT 4 -p tcp -m tcp --dport 20 -j ACCEPT</code></p><h4 id="3、ftp-客户端能够下载数据，却不能上传数据，如下："><a href="#3、ftp-客户端能够下载数据，却不能上传数据，如下：" class="headerlink" title="3、ftp 客户端能够下载数据，却不能上传数据，如下："></a>3、ftp 客户端能够下载数据，却不能上传数据，如下：</h4><blockquote><p><img src="/uploads/2018/03/ftp_trans_error.png" alt="" title="ftp文件传输错误"></p></blockquote><p>经过一番查找，发现应该是我本身一堆错误导致的。包括ftp 用户组使用但未创建，ftp用户根目录权限未给予正确的ftp用户组（注：根目录创建是root用户，因此所有者及所属组都是root。所以其他用户都不能操作）。因此，我做了如下修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 首先，创建用户组</span><br><span class="line">groupadd ftpgroup</span><br><span class="line"># 将用户添加进用户组</span><br><span class="line">usermod -g ftpgroup ftp1</span><br><span class="line"># 更改用户根目录所属组</span><br><span class="line">chown -R :ftpgroup ceshi/</span><br><span class="line"># 更改用户根目录所属组权限为可写</span><br><span class="line">chmod -R g+w ceshi/</span><br></pre></td></tr></table></figure></p><h4 id="4、ftp-拒绝登陆，如下："><a href="#4、ftp-拒绝登陆，如下：" class="headerlink" title="4、ftp 拒绝登陆，如下："></a>4、ftp 拒绝登陆，如下：</h4><blockquote><p><img src="/uploads/2018/03/ftp_refuse_error.png" alt="" title="ftp拒绝登陆"></p></blockquote><p>原因是配置文件中 <code>allow_writeable_chroot=YES</code> 不存在，而<code>chroot_local_user=YES</code>已经开启。所以导致 ftp 拒绝登陆。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、ftp-客户端连接报错，如下：&quot;&gt;&lt;a href=&quot;#1、ftp-客户端连接报错，如下：&quot; class=&quot;headerlink&quot; title=&quot;1、ftp 客户端连接报错，如下：&quot;&gt;&lt;/a&gt;1、ftp 客户端连接报错，如下：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/2018/03/ftp_connect_error.png&quot; alt=&quot;&quot; title=&quot;ftp连接超时&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经查看是因为 服务器端对应的 21号端口未开启，开启即可，命令如下：&lt;br&gt;&lt;code&gt;iptables -I INPUT 4 -p tcp -m tcp --dport 21 -j ACCEPT&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="FTP" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/"/>
    
    
      <category term="FTP" scheme="http://yoursite.com/tags/FTP/"/>
    
  </entry>
  
</feed>
