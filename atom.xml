<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-15T09:44:48.880Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 源码包与RPM包详解</title>
    <link href="http://yoursite.com/2018/03/15/Linux-%E6%BA%90%E7%A0%81%E5%8C%85%E4%B8%8ERPM%E5%8C%85%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/15/Linux-源码包与RPM包详解/</id>
    <published>2018-03-15T09:11:19.000Z</published>
    <updated>2018-03-15T09:44:48.880Z</updated>
    
    <content type="html"><![CDATA[<h4 id="源码包与RPM包的区别"><a href="#源码包与RPM包的区别" class="headerlink" title="源码包与RPM包的区别"></a>源码包与RPM包的区别</h4><h5 id="1、安装之前的区别：概念上的区别"><a href="#1、安装之前的区别：概念上的区别" class="headerlink" title="1、安装之前的区别：概念上的区别"></a>1、安装之前的区别：概念上的区别</h5><p>比如说：源码包是开源的，比RPM包安装更自由，但是它安装更慢，更容易报错；RPM包是经过编译的，不能看到源代码，但是它安装更快，报错更容易解决，只有依赖性问题。</p><h5 id="2、安装之后的区别：安装位置不同"><a href="#2、安装之后的区别：安装位置不同" class="headerlink" title="2、安装之后的区别：安装位置不同"></a>2、安装之后的区别：安装位置不同</h5><p>RPM包不需要指定安装位置，它会安装到系统默认位置；而源码包是人为手工设置的，下面我们就来看看到底位置有什么区别<br><a id="more"></a></p><p>（1）RPM包安装位置<br>是按照在默认位置中<br><strong>RPM包默认安装路径</strong></p><table><thead><tr><th>安装位置</th><th>对应目录功能</th></tr></thead><tbody><tr><td>/etc/</td><td>配置文件安装目录</td></tr><tr><td>/usr/bin/</td><td>可执行的命令安装目录</td></tr><tr><td>/usr/lib/</td><td>程序所使用的函数库保存位置</td></tr><tr><td>/usr/share/doc/</td><td>基本的软件使用手册保存位置</td></tr><tr><td>/usr/share/man/</td><td>帮助文件保存位置</td></tr></tbody></table><p>（2）源码包安装位置<br>安装在指定位置当中，一般是 <code>/usr/local/软件名/</code></p><h5 id="3、安装位置不同带来的影响"><a href="#3、安装位置不同带来的影响" class="headerlink" title="3、安装位置不同带来的影响"></a>3、安装位置不同带来的影响</h5><p>RPM包安装的服务可以使用系统服务管理命令（service）来管理，例如RPM包安装的apache的启动方法是：<br><code>/etc/rc.d/init.d/httpd start</code><br><code>service httpd start</code></p><p>而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理，如：<br><code>/usr/local/apache2/bin/apachectl start</code></p><h4 id="RPM包详解"><a href="#RPM包详解" class="headerlink" title="RPM包详解"></a>RPM包详解</h4><h5 id="1、rpm包命名结构"><a href="#1、rpm包命名结构" class="headerlink" title="1、rpm包命名结构"></a>1、rpm包命名结构</h5><p>rpm包的组成：name-version-release.arch.rpm</p><blockquote><p>name：表示包的名称，包括主包名和分包名<br>version：表示包的版本信息<br>release：用于标识rpm包本身的发行号，可还包含适应的操作系统<br>arch:表示主机平台,noarch表示此包能安装到所以平台上面</p></blockquote><p>例如：gd-devel-2.0.35-11.el6.x86_64.rpm</p><blockquote><p>gd是这个包的主包名，devel是这个包的分包名，<br>2.0.35是表示版本信息，2为主版本，0为此版本，35为修订号，<br>11.el6中的11是表示发行号，el6表示是RHEL6，<br>x86_64是表示包适合的平台，如果是noarch这表示与平台无关</p></blockquote><h5 id="2、rpm包命令操作总结"><a href="#2、rpm包命令操作总结" class="headerlink" title="2、rpm包命令操作总结"></a>2、rpm包命令操作总结</h5><style type="text/css">    table th:first-of-type {        width: 15%;    }    table th:nth-of-type(2) {        width: 17%;    }    table th:nth-of-type(3) {        width: 50%;    }    table th:nth-of-type(4) {        width: 40%;    }</style><table><thead><tr><th>&#32;</th><th>option</th><th>参数解释</th><th>Example</th></tr></thead><tbody><tr><td>安装</td><td>-i</td><td>安装</td><td>&#32;</td></tr><tr><td></td><td>-v&#124;-vv&#124;-vvv</td><td>显示详细信息</td><td>&#32;</td></tr><tr><td></td><td>-h</td><td>以#显示安装进度一个#表示2%的进度</td><td>rpm -ivh zsh-4.3.10-5.el6.x86_64.rpm</td></tr><tr><td></td><td>–nodeps</td><td>忽略依赖关系</td><td>&#32;</td></tr><tr><td></td><td>–test</td><td>测试安装</td><td>&#32;</td></tr><tr><td></td><td>–replacepkgs</td><td>重新安装(安装的包已经安装了)</td><td>&#32;</td></tr><tr><td>升级</td><td>-U   -Uvh</td><td>升级+安装</td><td>&#32;</td></tr><tr><td></td><td>-F    -Fvh</td><td>升级(此包已经安装了)</td><td>&#32;</td></tr><tr><td></td><td>–force</td><td>有冲突强制升级</td><td>&#32;</td></tr><tr><td></td><td>–nodeps</td><td>忽略包依赖性关系</td><td>&#32;</td></tr><tr><td>卸载</td><td>-e</td><td>卸载</td><td>rpm  -e  包名</td></tr><tr><td></td><td>–nodeps</td><td>忽略包依赖性关系</td><td>&#32;</td></tr><tr><td>查询</td><td>-q&#124;–query</td><td>&#32;</td><td>rpm -q&#124;–query  包名</td></tr><tr><td></td><td>-qa</td><td>查看所有已经安装的包</td><td>rpm -qa  查看所有包名 <br>rpm -qa &#124; grep 包名查看某个包名</td></tr><tr><td></td><td>-qi</td><td>查看包的摘要信息</td><td>&#32;</td></tr><tr><td></td><td>-qf</td><td>查看文件是有那个包安装的</td><td>rpm  -qf  /path/to/file</td></tr><tr><td></td><td>-ql</td><td>查看包安装生成的文件清单</td><td>&#32;</td></tr><tr><td></td><td>-qc</td><td>查看包安装生成的配置文件</td><td>&#32;</td></tr><tr><td></td><td>-qd</td><td>查看包安装生成的帮助文档</td><td>&#32;</td></tr><tr><td></td><td>-q  –scripts</td><td>查看相关的脚本</td><td>rpm -q–script   包名</td></tr><tr><td></td><td>-qp[i&#124;l&#124;d&#124;c]</td><td>查看尚未安装包的详细信息</td><td>rpm -qpi /path/to/rpm_file</td></tr><tr><td>校验</td><td>-V</td><td>&#32;</td><td>rpm -V   包名</td></tr><tr><td>数据库管理</td><td>–initdb</td><td>新建</td><td>rpm  –initdb</td></tr><tr><td></td><td>–rebuilddb</td><td>重建</td><td>rpm  –rebuilddb</td></tr></tbody></table><h5 id="3、RPM包安装方法之-yum-安装"><a href="#3、RPM包安装方法之-yum-安装" class="headerlink" title="3、RPM包安装方法之 yum 安装"></a>3、RPM包安装方法之 yum 安装</h5><p>yum(Yellowdog Update  Manager),yum是RPM的前端工具，是基于RPM的一个管理工具，他能自动的解决安装rpm包产生的依赖关系。</p><blockquote><p>yum 的配置文件    /etc/yum.conf<br>yum 的repository仓库的配置文件   /etc/yum.repos.d/*.repo</p></blockquote><p>yum常用命令总结</p><style type="text/css">    table th:nth-of-type(2) {        width: 40%;    }</style><table><thead><tr><th>&#32;</th><th>操作命令</th><th>命令解释</th></tr></thead><tbody><tr><td>列表</td><td><code>yum list &lt;package_name&gt;</code></td><td>列出指定安装软件的清单</td></tr><tr><td></td><td>yum list installed</td><td>列出所有已安装的软件包</td></tr><tr><td></td><td>yum list extras</td><td>列出所有已安装但不在 Yum  仓库內的软件包</td></tr><tr><td></td><td>yum grouplist</td><td>列出所有的组</td></tr><tr><td></td><td>yum grouplist “Group1”</td><td>列出指定组的软件包列表</td></tr><tr><td>安装</td><td><code>yum -y install &lt;package_name&gt;</code></td><td>安装指定的软件</td></tr><tr><td></td><td>yum -y groupinstall “Group1” “Group2”</td><td>安装指定的组</td></tr><tr><td></td><td><code>yum -y localinstall &lt;package_name&gt;</code></td><td>用yum安装下载到本地的rpm包</td></tr><tr><td>更新</td><td>yum check-update</td><td>列出所有可更新的软件清单</td></tr><tr><td></td><td>yum update</td><td>安装所有更新软件</td></tr><tr><td></td><td><code>yum update &lt;package_name&gt;</code></td><td>更新指定的软件</td></tr><tr><td>信息</td><td>yum info</td><td>显示所有包的信息</td></tr><tr><td></td><td><code>yum info &lt;package_name&gt;</code></td><td>显示指定包的信息</td></tr><tr><td></td><td>yum groupinfo “Group1” “Group2”</td><td>显示指定组的信息</td></tr><tr><td>清除</td><td>yum clean all</td><td>清除所有yum所保存的信息</td></tr><tr><td></td><td>yum clean metadata</td><td>只清空保存的数据信息</td></tr><tr><td>其它操作</td><td>yum repolist [all&#124;enable&#124;disable]</td><td>查看yum仓库的个数，默认显示启用的</td></tr><tr><td></td><td>yum   makecache</td><td>手动生成缓存</td></tr><tr><td></td><td><code>yum search &lt;package_name&gt;</code></td><td>查询rpm包</td></tr><tr><td></td><td><code>yum reinstall &lt;package_name&gt;</code></td><td>重新安装一遍</td></tr><tr><td></td><td><code>yum provides &lt;package_name&gt;</code></td><td>列出软件包提供哪些文件</td></tr></tbody></table><h4 id="源码包详解"><a href="#源码包详解" class="headerlink" title="源码包详解"></a>源码包详解</h4><h5 id="1、tar-源码包编译安装"><a href="#1、tar-源码包编译安装" class="headerlink" title="1、tar 源码包编译安装"></a>1、tar 源码包编译安装</h5><p>编译安装的三部曲:<br>在安装三部曲之前，建议先看看解压之后目录里面的包含README, INSTALL文件，这里面的文件会告诉你详细安装步骤。</p><blockquote><p>（1）configure　　　检测编译环境<br>（2）make　　　　　进行编译<br>（3）make install　　编译安装</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;源码包与RPM包的区别&quot;&gt;&lt;a href=&quot;#源码包与RPM包的区别&quot; class=&quot;headerlink&quot; title=&quot;源码包与RPM包的区别&quot;&gt;&lt;/a&gt;源码包与RPM包的区别&lt;/h4&gt;&lt;h5 id=&quot;1、安装之前的区别：概念上的区别&quot;&gt;&lt;a href=&quot;#1、安装之前的区别：概念上的区别&quot; class=&quot;headerlink&quot; title=&quot;1、安装之前的区别：概念上的区别&quot;&gt;&lt;/a&gt;1、安装之前的区别：概念上的区别&lt;/h5&gt;&lt;p&gt;比如说：源码包是开源的，比RPM包安装更自由，但是它安装更慢，更容易报错；RPM包是经过编译的，不能看到源代码，但是它安装更快，报错更容易解决，只有依赖性问题。&lt;/p&gt;
&lt;h5 id=&quot;2、安装之后的区别：安装位置不同&quot;&gt;&lt;a href=&quot;#2、安装之后的区别：安装位置不同&quot; class=&quot;headerlink&quot; title=&quot;2、安装之后的区别：安装位置不同&quot;&gt;&lt;/a&gt;2、安装之后的区别：安装位置不同&lt;/h5&gt;&lt;p&gt;RPM包不需要指定安装位置，它会安装到系统默认位置；而源码包是人为手工设置的，下面我们就来看看到底位置有什么区别&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>解决CentOS7关闭/开启防火墙出现Unit iptables.service failed to load: No such file or directory.</title>
    <link href="http://yoursite.com/2018/03/15/%E8%A7%A3%E5%86%B3CentOS7%E5%85%B3%E9%97%AD-%E5%BC%80%E5%90%AF%E9%98%B2%E7%81%AB%E5%A2%99%E5%87%BA%E7%8E%B0Unit-iptables-service-failed-to-load-No-such-file-or-directory/"/>
    <id>http://yoursite.com/2018/03/15/解决CentOS7关闭-开启防火墙出现Unit-iptables-service-failed-to-load-No-such-file-or-directory/</id>
    <published>2018-03-15T09:11:04.000Z</published>
    <updated>2018-03-15T10:35:24.549Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS7中执行<br><code>service iptables start/stop</code></p><blockquote><p>会报错Failed to start iptables.service: Unit iptables.service failed to load: No such file or directory.</p></blockquote><p>在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，当然你可以还原传统的管理方式。或则使用新的命令进行管理。<br><a id="more"></a></p><p>1、还原传统的管理方式<br>执行一下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld  #停止 firewalld</span><br><span class="line">systemctl mask firewalld  #禁用 firewalld</span><br></pre></td></tr></table></figure></p><p>并且安装iptables-services：<br><code>yum install iptables-services</code></p><p>设置开机启动：<br><code>systemctl enable iptables</code></p><p>启动iptables：<br><code>systemctl start iptables</code></p><p>保存设置：<br>service iptables save 或者 /usr/libexec/iptables/iptables.init save</p><p>常用命令：<br>systemctl [stop|start|restart|reload] iptables（分开执行）</p><p>OK，再试一下传统管理方式应该就好使了。</p><p>2、使用新的防火墙firewalld进行管理</p><p>待补充…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS7中执行&lt;br&gt;&lt;code&gt;service iptables start/stop&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;会报错Failed to start iptables.service: Unit iptables.service failed to load: No such file or directory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，当然你可以还原传统的管理方式。或则使用新的命令进行管理。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Linux问题" scheme="http://yoursite.com/categories/Linux/Linux%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>SVN 详解之常用操作命令（三）</title>
    <link href="http://yoursite.com/2018/03/15/SVN-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/15/SVN-详解之常用操作命令（三）/</id>
    <published>2018-03-15T06:10:44.000Z</published>
    <updated>2018-03-15T06:16:45.234Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、检出"><a href="#1、检出" class="headerlink" title="1、检出"></a>1、检出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span><br><span class="line">svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名</span><br><span class="line">简写：svn co xxx</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn checkout svn://localhost/测试工具 /home/testtools –username ben<br>svn checkout <a href="http://localhost/test/testapp" target="_blank" rel="noopener">http://localhost/test/testapp</a> –username ben<br>注：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。<br>　　其中 username 与 password前是两个短线，不是一个。<br>　　不指定本地目录全路径，则检出到当前目录下。<br><a id="more"></a></p><h4 id="2、导出"><a href="#2、导出" class="headerlink" title="2、导出"></a>2、导出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn  export  [-r 版本号]  http://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">svn  export  [-r 版本号]  svn://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">svn  export  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br></pre></td></tr></table></figure><p><strong>例子：</strong><br>svn export svn://localhost/测试工具 /home/testtools –username ben<br>svn export svn://localhost/test/testapp –username ben<br>svn export /home/testapp /home/testtools<br>注：第一种从版本库导出干净工作目录树的形式是指定URL，如果指定了修订版本号，会导出相应的版本，如果没有指定修订版本，则会导出最新的，导出到指定位置。如果省略本地目录全路径，URL的最后一部分会作为本地目录的名字。<br>第二种形式是指定 本地检出的目录全路径 到 要导出的本地目录全路径，所有的本地修改将会保留，但是不在版本控制下(即没提交的新文件，因为.svn文件夹里没有与之相关的信息记录)的文件不会拷贝。</p></blockquote><h4 id="3、添加新文件"><a href="#3、添加新文件" class="headerlink" title="3、添加新文件"></a>3、添加新文件</h4><p><code>svn　add　文件名</code><br>注：告诉SVN服务器要添加文件了，还要用svn commint -m真实的上传上去！</p><blockquote><p><strong>例子：</strong><br>svn add test.php     #添加test.php<br>svn commit -m “添加我的测试用test.php“ test.php<br>svn add <em>.php         #添加当前目录下所有的php文件<br>svn commit -m “添加我的测试用全部php文件“ </em>.php</p></blockquote><h4 id="4、提交"><a href="#4、提交" class="headerlink" title="4、提交"></a>4、提交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn　commit　-m　“提交备注信息文本“　[-N]　[--no-unlock]　文件名</span><br><span class="line">简写：svn ci xxx</span><br></pre></td></tr></table></figure><p>注：必须带上-m参数，参数可以为空，但是必须写上-m</p><blockquote><p><strong>例子：</strong><br>svn commit -m “提交当前目录下的全部在版本控制下的文件“ <em>          #注意这个</em>表示全部文件<br>svn commit -m “提交我的测试用test.php“ test.php<br>svn commit -m “提交我的测试用test.php“ -N –no-unlock test.php     #保持锁就用–no-unlock开关<br>svn ci -m “提交当前目录下的全部在版本控制下的文件“ <em>             #注意这个</em>表示全部文件<br>svn ci -m “提交我的测试用test.php“ test.php<br>svn ci -m “提交我的测试用test.php“ -N –no-unlock test.php         #保持锁就用–no-unlock开关</p></blockquote><h4 id="5、更新"><a href="#5、更新" class="headerlink" title="5、更新"></a>5、更新</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn　update</span><br><span class="line">svn　update　-r　修正版本　文件名</span><br><span class="line">svn　update　文件名</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn update                         #后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本<br>svn update -r 200 test.cpp         #将版本库中的文件 test.cpp 还原到修正版本（revision）200<br>svn update test.php             #更新与版本库同步。<br>　　提交的时候提示过期冲突，需要先 update 修改文件，然后清除svn resolved，最后再提交commit。</p></blockquote><h4 id="6、删除"><a href="#6、删除" class="headerlink" title="6、删除"></a>6、删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">svn　delete　svn://路径(目录或文件的全路径) -m “删除备注信息文本”</span><br><span class="line">推荐如下操作：</span><br><span class="line">svn　delete　文件名 </span><br><span class="line">svn　ci　-m　“删除备注信息文本”</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn delete svn://localhost/testapp/test.php -m “删除测试文件test.php”<br>推荐如下操作：<br>svn delete test.php<br>svn ci -m “删除测试文件test.php”</p></blockquote><h4 id="7、比较差异"><a href="#7、比较差异" class="headerlink" title="7、比较差异"></a>7、比较差异</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn　diff　文件名 </span><br><span class="line">svn　diff　-r　修正版本号m:修正版本号n　文件名</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn diff test.php                 #将修改的文件与基础版本比较<br>svn diff -r 200:201 test.php     #对 修正版本号200 和 修正版本号201 比较差异</p></blockquote><h4 id="8、查看文件或者目录状态"><a href="#8、查看文件或者目录状态" class="headerlink" title="8、查看文件或者目录状态"></a>8、查看文件或者目录状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">svn st 目录路径/名</span><br><span class="line">svn status 目录路径/名  #目录下的文件和子目录的状态，正常状态不显示 </span><br><span class="line">　　　　　　　　　　　　　【?：不在svn的控制中；  M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 </span><br><span class="line">svn st -v 目录路径/名</span><br><span class="line">svn status -v 目录路径/名  #显示文件和子目录状态</span><br><span class="line">　　　　　　　　　　　　　　【第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人】</span><br></pre></td></tr></table></figure><p>注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。</p><h4 id="9、查看日志"><a href="#9、查看日志" class="headerlink" title="9、查看日志"></a>9、查看日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　log　文件名</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn log test.php     #显示这个文件的所有修改记录，及其版本号的变化</p></blockquote><h4 id="10、查看文件详细信息"><a href="#10、查看文件详细信息" class="headerlink" title="10、查看文件详细信息"></a>10、查看文件详细信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn info file</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn info test.php</p></blockquote><h4 id="11、帮助"><a href="#11、帮助" class="headerlink" title="11、帮助"></a>11、帮助</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn help#全部功能选项</span><br><span class="line">svn help ci #具体功能的说明</span><br></pre></td></tr></table></figure><h4 id="12、加锁-解锁"><a href="#12、加锁-解锁" class="headerlink" title="12、加锁/解锁"></a>12、加锁/解锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn　lock　-m　“加锁备注信息文本“　[--force]　文件名 </span><br><span class="line">svn　unlock　文件名</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn lock -m “锁信测试用test.php文件“ test.php<br>svn unlock test.php</p></blockquote><h4 id="13、查看版本库下的文件和目录列表"><a href="#13、查看版本库下的文件和目录列表" class="headerlink" title="13、查看版本库下的文件和目录列表"></a>13、查看版本库下的文件和目录列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn list svn://路径（目录或文件的全路径） </span><br><span class="line">简写：svn ls xx</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn list svn://localhost/test<br>svn ls svn://localhost/test      #显示svn://localhost/test目录下的所有属于版本库的文件和目录</p></blockquote><h4 id="14、创建纳入版本控制下的新目录"><a href="#14、创建纳入版本控制下的新目录" class="headerlink" title="14、创建纳入版本控制下的新目录"></a>14、创建纳入版本控制下的新目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn mkdir 目录名</span><br><span class="line">svn mkdir -m &quot;新增目录备注文本&quot; http://目录全路径</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn mkdir newdir<br>svn mkdir -m “Making a new dir.” svn://localhost/test/newdir<br>注：添加完子目录后，一定要回到根目录更新一下，不然在该目录下提交文件会提示“提交失败”</p></blockquote><p><code>svn update</code></p><blockquote><p>注：如果手工在 checkout 出来的目录中新建目录 newsubdir，再用 svn mkdir newsubdir 命令后，SVN会提示：<br>svn: 尝试用 “svn add”或 “svn add –non-recursive”代替？<br>svn: 无法创建目录“hello”: 文件已经存在<br>此时用如下命令解决：<br><code>svn add --non-recursive newsubdir</code><br>在进入这个newsubdir文件夹，用ls -a查看它下面的全部目录与文件，会发现多了：.svn目录。再用 svn mkdir -m “添hello功能模块文件” svn://localhost/test/newdir/newsubdir 命令。</p></blockquote><h4 id="15、恢复本地修改"><a href="#15、恢复本地修改" class="headerlink" title="15、恢复本地修改"></a>15、恢复本地修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　revert　[--recursive]　文件名</span><br></pre></td></tr></table></figure><p>注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</p><blockquote><p><strong>例子：</strong><br>svn revert foo.c               #丢弃对一个文件的修改<br>svn revert –recursive .     #恢复一整个目录的文件，. 为当前目录</p></blockquote><h4 id="16、把工作拷贝更新到别的URL"><a href="#16、把工作拷贝更新到别的URL" class="headerlink" title="16、把工作拷贝更新到别的URL"></a>16、把工作拷贝更新到别的URL</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　switch　http://目录全路径　本地目录全路径</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn switch <a href="http://localhost/test/456" target="_blank" rel="noopener">http://localhost/test/456</a> .  # (原为123的分支)当前所在目录分支到localhost/test/456</p></blockquote><h4 id="17、解决冲突"><a href="#17、解决冲突" class="headerlink" title="17、解决冲突"></a>17、解决冲突</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　resolved　[本地目录全路径]</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>$ svn update<br>C foo.c<br>Updated to revision 31.<br>如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：<br>$ ls<br>foo.c<br>foo.c.mine<br>foo.c.r30<br>foo.c.r31<br>当你解决了foo.c的冲突，并且准备提交，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。<br>你可以仅仅删除冲突的文件并且提交，但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。</p></blockquote><h4 id="18、不checkout而查看输出特定文件或URL的内容"><a href="#18、不checkout而查看输出特定文件或URL的内容" class="headerlink" title="18、不checkout而查看输出特定文件或URL的内容"></a>18、不checkout而查看输出特定文件或URL的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　cat　http://文件全路径</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn cat <a href="http://localhost/test/readme.txt" target="_blank" rel="noopener">http://localhost/test/readme.txt</a></p></blockquote><h4 id="19、新建一个分支copy"><a href="#19、新建一个分支copy" class="headerlink" title="19、新建一个分支copy"></a>19、新建一个分支copy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn copy branchA branchB  -m &quot;make B branch&quot; // 从branchA拷贝出一个新分支branchB</span><br></pre></td></tr></table></figure><p>20、合并内容到分支merge<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn merge branchA branchB  // 把对branchA的修改合并到分支branchB</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、检出&quot;&gt;&lt;a href=&quot;#1、检出&quot; class=&quot;headerlink&quot; title=&quot;1、检出&quot;&gt;&lt;/a&gt;1、检出&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;简写：svn co xxx&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;例子：&lt;/strong&gt;&lt;br&gt;svn checkout svn://localhost/测试工具 /home/testtools –username ben&lt;br&gt;svn checkout &lt;a href=&quot;http://localhost/test/testapp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://localhost/test/testapp&lt;/a&gt; –username ben&lt;br&gt;注：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。&lt;br&gt;　　其中 username 与 password前是两个短线，不是一个。&lt;br&gt;　　不指定本地目录全路径，则检出到当前目录下。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="SVN" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/SVN/"/>
    
    
      <category term="SVN" scheme="http://yoursite.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>SVN 详解之客户端安装（二）</title>
    <link href="http://yoursite.com/2018/03/15/SVN-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/15/SVN-详解之客户端安装（二）/</id>
    <published>2018-03-15T06:10:26.000Z</published>
    <updated>2018-03-15T07:28:08.379Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Linux-下安装"><a href="#Linux-下安装" class="headerlink" title="Linux 下安装"></a>Linux 下安装</h4><p>CentOS 系统可使用yum 软件包管理器直接安装，Debian、Ubuntu 系统可使用apt-get 软件包管理器直接安装。此处，我们使用一种通用的安装方式，源码安装。</p><h5 id="1、下载及解压"><a href="#1、下载及解压" class="headerlink" title="1、下载及解压"></a>1、下载及解压</h5><p>下载地址：<a href="http://subversion.apache.org/download/" target="_blank" rel="noopener"><font color="red">传送门</font></a><br><code>tar xvf subversion-1.9.7.tar.bz2</code><br><a id="more"></a></p><h5 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/subersion</span><br><span class="line">cd subversion-1.9.7</span><br><span class="line">./configure --prefix=/usr/local/subversion  #指定安装路径</span><br></pre></td></tr></table></figure><h5 id="3、解析及安装文件"><a href="#3、解析及安装文件" class="headerlink" title="3、解析及安装文件"></a>3、解析及安装文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure><h5 id="4、测试及建立软链接"><a href="#4、测试及建立软链接" class="headerlink" title="4、测试及建立软链接"></a>4、测试及建立软链接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/subversion/bin</span><br><span class="line">svn</span><br><span class="line">ln -s /usr/local/subversion/bin/svn /sbin/svn</span><br><span class="line">cd /</span><br><span class="line">svn</span><br></pre></td></tr></table></figure><h4 id="Windows下安装"><a href="#Windows下安装" class="headerlink" title="Windows下安装"></a>Windows下安装</h4><h5 id="1、SVN客户端下载及安装"><a href="#1、SVN客户端下载及安装" class="headerlink" title="1、SVN客户端下载及安装"></a>1、SVN客户端下载及安装</h5><p>下载地址：<a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener"><font color="red">传送门</font></a><br>安装根据下一步操作即可完成…</p><h5 id="2、SVN客户端配置"><a href="#2、SVN客户端配置" class="headerlink" title="2、SVN客户端配置"></a>2、SVN客户端配置</h5><p>这里要特别声明一下——<font color="red">SVN客户端不是指一个桌面应用程序，而是集成到系统的右键菜单中的插件。</font>因此使用客户端向资源库下载项目资源、提交项目资源等都是通过右键菜单来完成的。</p><p>在桌面空白处右键：<br><img src="/uploads/2018/03/svn_image_01.png" alt=""></p><p>选择  设置 ，打开设置面板：<br>可以设置语言：<br><img src="/uploads/2018/03/svn_image_02.png" alt=""><br>也可以设置 项目资源的图标，通过不同图标来指示下载到本地的项目资源文件发生了什么变化，比如：修改、新增、删除等等。</p><h5 id="3、SVN-基础操作"><a href="#3、SVN-基础操作" class="headerlink" title="3、SVN 基础操作"></a>3、SVN 基础操作</h5><h6 id="（1）检出"><a href="#（1）检出" class="headerlink" title="（1）检出"></a>（1）检出</h6><p>在你的本地项目文件夹或随便一个地方，右键空白处弹出菜单，选择 SVN检出。然后，通过从SVN服务端获取的 <font color="red">资源库URL+具体的项目文件夹名</font> 下载相应项目，并可以知道下载项目的保存位置<br><img src="/uploads/2018/03/svn_image_03.png" alt=""></p><h6 id="（2）修改及提交"><a href="#（2）修改及提交" class="headerlink" title="（2）修改及提交"></a>（2）修改及提交</h6><ol><li>把项目下载到本机后，其实就是一个普通的项目文件而已，你可以在里面添加文件、修改文件、删除文件等等。</li><li>提交修改<br>在项目文件空白处右键，选择 SVN提交。然后，输入 <font color="red">本次提交的版本更新信息（所作修改的注释）、勾选要提交的操作内容，点击 确定，即可把本机项目提交到SVN服务器资源库，覆盖掉资源库项目从而实现更新。</font><br>（如果发生提交冲突，即两人都提交修改，后提交者由于版本落后会提交失败。这时可以先把自己的项目备份，然后从服务端下载最新的项目（下面有讲SVN更新），再把自己的项目覆盖到本地项目文件夹，最后SVN提交即可成功提交）<br>（SVN不提供历史版本功能，所以项目被覆盖后就找不回来了，所以切记备份。如果需要历史版本的保存功能，推荐使用Git）<br><img src="/uploads/2018/03/svn_image_04.png" alt=""></li></ol><h6 id="（3）更新"><a href="#（3）更新" class="headerlink" title="（3）更新"></a>（3）更新</h6><p>如果别人修改了SVN服务端资源库上的项目，你想下载最新的项目，则在 本机项目文件空白处单击鼠标右键，选择 SVN更新 ，即可自动完成下载，并会提示所作的更新有哪些。注意：<font color="red">在原项目文件夹内选择SVN更新的话，会自动覆盖掉原有内容。建议：先备份，再更新，防止自己本来的项目内容丢失。</font><br><img src="/uploads/2018/03/svn_image_05.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Linux-下安装&quot;&gt;&lt;a href=&quot;#Linux-下安装&quot; class=&quot;headerlink&quot; title=&quot;Linux 下安装&quot;&gt;&lt;/a&gt;Linux 下安装&lt;/h4&gt;&lt;p&gt;CentOS 系统可使用yum 软件包管理器直接安装，Debian、Ubuntu 系统可使用apt-get 软件包管理器直接安装。此处，我们使用一种通用的安装方式，源码安装。&lt;/p&gt;
&lt;h5 id=&quot;1、下载及解压&quot;&gt;&lt;a href=&quot;#1、下载及解压&quot; class=&quot;headerlink&quot; title=&quot;1、下载及解压&quot;&gt;&lt;/a&gt;1、下载及解压&lt;/h5&gt;&lt;p&gt;下载地址：&lt;a href=&quot;http://subversion.apache.org/download/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font color=&quot;red&quot;&gt;传送门&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;code&gt;tar xvf subversion-1.9.7.tar.bz2&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="SVN" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/SVN/"/>
    
    
      <category term="SVN" scheme="http://yoursite.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>SVN 详解之服务器搭建（一）</title>
    <link href="http://yoursite.com/2018/03/15/SVN-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/15/SVN-详解之服务器搭建（一）/</id>
    <published>2018-03-15T06:09:57.000Z</published>
    <updated>2018-03-15T07:28:42.868Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、使用-yum-安装SVN"><a href="#1、使用-yum-安装SVN" class="headerlink" title="1、使用 yum 安装SVN"></a>1、使用 yum 安装SVN</h4><p><code>[root@singledb ~]# yum install -y subversion</code></p><h4 id="2、验证安装版本及是否成功安装"><a href="#2、验证安装版本及是否成功安装" class="headerlink" title="2、验证安装版本及是否成功安装"></a>2、验证安装版本及是否成功安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@singledb ~]# svnserve --version</span><br><span class="line">svnserve, version 1.4.2 (r22196)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="3、创建-SVN-版本库"><a href="#3、创建-SVN-版本库" class="headerlink" title="3、创建 SVN 版本库"></a>3、创建 SVN 版本库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@singledb ~]# mkdir /var/svn  //创建存放版本库文件的目录</span><br><span class="line">[root@singledb ~]# svnadmin create /var/svn/testsvn  //创建版本库</span><br></pre></td></tr></table></figure><h4 id="4、SVN-配置"><a href="#4、SVN-配置" class="headerlink" title="4、SVN 配置"></a>4、SVN 配置</h4><p>创建版本库后，在这个目录下会生成3个配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@singledb conf]# pwd</span><br><span class="line">/var/svn/testsvn/conf</span><br><span class="line">[root@singledb conf]# ls</span><br><span class="line">authz  passwd  svnserve.conf</span><br></pre></td></tr></table></figure></p><blockquote><p>（1）svnserve.conf：  svn服务配置文件。<br>（2）passwd： 用户名口令文件，负责账号和密码的用户名单管理。<br>（3）authz： 权限配置文件，控制账号的读写权限。 </p></blockquote><p><strong>svnserve.conf 文件， 该文件配置项分为以下5项：</strong></p><ul><li>anon-access： 控制非鉴权用户访问版本库的权限。</li><li>auth-access：  控制鉴权用户访问版本库的权限。</li><li>password-db： 指定用户名口令文件名。</li><li>authz-db：指定权限配置文件名，通过该文件可以实现以路径为基础的访问控制。</li><li>realm：指定版本库的认证域，即在登录时提示的认证域名称。若两个版本库的认证域相同，建议使用相同的用户名口令数据文件</li></ul><font color="red">（注意：将此五项都给去注释的时候，一定要顶格，不然会报错； realm指要认证的版本库，填写自己要配置的版本库即可）</font><p><strong>authz  文件 ：</strong></p><blockquote><p>在网上找到一个很好的配置例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[groups]</span><br><span class="line">admin = john, kate</span><br><span class="line">devteam1 = john, rachel, sally</span><br><span class="line">devteam2 = kate, peter, mark</span><br><span class="line">docs = bob, jane, mike</span><br><span class="line">training = zak</span><br><span class="line">##这里把不同用户放到不同的组里面，下面在设置目录访问权限的时候，用目录来操作就可以了。</span><br><span class="line"># 为所有库指定默认访问规则</span><br><span class="line"># 所有人可以读，管理员可以写，危险分子没有任何权限</span><br><span class="line">[/]  ##对应我测试里的：/u02/svn 目录</span><br><span class="line">* = r</span><br><span class="line">@admin = rw</span><br><span class="line">dangerman =</span><br><span class="line"># 允许开发人员可以完全访问他们的项目版本库</span><br><span class="line">[proj1:/]</span><br><span class="line">@devteam1 = rw</span><br><span class="line">[proj2:/]</span><br><span class="line">@devteam2 = rw</span><br><span class="line">[bigproj:/]</span><br><span class="line">@devteam1 = rw</span><br><span class="line">@devteam2 = rw</span><br><span class="line">trevor = rw</span><br><span class="line"># 文档编写人员对所有的docs目录有写权限</span><br><span class="line">[/trunk/doc]</span><br><span class="line">@docs = rw</span><br><span class="line"># 培训人员可以完全访问培训版本库</span><br><span class="line">[TrainingRepos:/]</span><br><span class="line">@training = rw</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>下面我们来配置我们的authz文件：</strong><br>（一）普通版，用户权限无限大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[/]</span><br><span class="line">admin = ben</span><br><span class="line">dev = ben, nana</span><br></pre></td></tr></table></figure></p><p>（二）晋级版，使用 groups 组权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@singledb conf]# cat authz</span><br><span class="line">[groups]</span><br><span class="line">admin = ben</span><br><span class="line">dev = ben, nana</span><br><span class="line"></span><br><span class="line">[bensvn:/]</span><br><span class="line">@admin = rw</span><br><span class="line">ben = rw</span><br><span class="line"></span><br><span class="line">[commonsvn:/]</span><br><span class="line">@admin = rw</span><br><span class="line">@dev = rw</span><br></pre></td></tr></table></figure></p><p><strong>Passwd 文件 ：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line"># harry = harryssecret</span><br><span class="line"># sally = sallyssecret</span><br><span class="line">ben = ben1234</span><br><span class="line">nana = nana1234</span><br></pre></td></tr></table></figure></p><h4 id="5、启动和停止SVN服务"><a href="#5、启动和停止SVN服务" class="headerlink" title="5、启动和停止SVN服务"></a>5、启动和停止SVN服务</h4><p>启动SVN服务：<br><code>svnserve -d -r /home/svn   （/home/svn 为版本库的根目录）</code><br>关闭SVN服务：<br>① 使用以下命令查找进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# ps aux | grep svn</span><br><span class="line">root      8530  0.0  0.0 112660   972 pts/0    R+   14:44   0:00 grep --color=auto svn</span><br><span class="line">root     31964  0.0  0.0 166336   908 ?        Ss   11:28   0:00 svnserve -d -r /var/svn</span><br></pre></td></tr></table></figure></p><p>② 使用Kill命令杀死进程<br><code>kill -s 9 31964        （31964为进程ID）</code></p><h4 id="6、客户端检出访问-svn-服务器"><a href="#6、客户端检出访问-svn-服务器" class="headerlink" title="6、客户端检出访问 svn 服务器"></a>6、客户端检出访问 svn 服务器</h4><p><code>svn co svn://118.24.8.229/&lt;repo&gt;</code> 即可检出代码（注：repo为代码库名称）。会弹出输入用户名和密码。</p><p><strong>注：我们搭建的SVN是独立服务器形式运行的，没有和Apache整合，所以SVN地址为：svn://xxx/xxx，而不是<a href="http://xxx/xxx或https://xxx/xxx。" target="_blank" rel="noopener">http://xxx/xxx或https://xxx/xxx。</a></strong><br>Apache 搭建HTTP方式访问SVN服务器：<a href="http://blog.csdn.net/robertohuang/article/details/55504445" target="_blank" rel="noopener"><font color="red">传送门</font></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、使用-yum-安装SVN&quot;&gt;&lt;a href=&quot;#1、使用-yum-安装SVN&quot; class=&quot;headerlink&quot; title=&quot;1、使用 yum 安装SVN&quot;&gt;&lt;/a&gt;1、使用 yum 安装SVN&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[root@singledb ~]# yum install -y subversion&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;2、验证安装版本及是否成功安装&quot;&gt;&lt;a href=&quot;#2、验证安装版本及是否成功安装&quot; class=&quot;headerlink&quot; title=&quot;2、验证安装版本及是否成功安装&quot;&gt;&lt;/a&gt;2、验证安装版本及是否成功安装&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@singledb ~]# svnserve --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svnserve, version 1.4.2 (r22196)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="SVN" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/SVN/"/>
    
    
      <category term="SVN" scheme="http://yoursite.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>代码版本管理系统</title>
    <link href="http://yoursite.com/2018/03/15/%E4%BB%A3%E7%A0%81%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/03/15/代码版本管理系统/</id>
    <published>2018-03-15T06:07:43.000Z</published>
    <updated>2018-03-15T06:12:11.722Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码版本管理系统的概述"><a href="#代码版本管理系统的概述" class="headerlink" title="代码版本管理系统的概述"></a>代码版本管理系统的概述</h4><h5 id="1、什么是版本控制"><a href="#1、什么是版本控制" class="headerlink" title="1、什么是版本控制"></a>1、什么是版本控制</h5><p>版本控制的核心是这样一个简单的概念，即对一个或者多个文件的追踪过程，随着这些文件演变成一个或多个产品的过程。特别是版本控制追踪什么变化，是什么改变了它，为什么会这样。版本控制系统提供了一个有益的说明，这些说明在传统的文件管理中是找不到的。</p><p>需要注意的是版本控制使用不仅是局限于程序员。版本控制可以被任何人用来维护文件目录，因此即便你不是程序也可以因此受益。<br><a id="more"></a></p><h5 id="2、集中式版本控制介绍"><a href="#2、集中式版本控制介绍" class="headerlink" title="2、集中式版本控制介绍"></a>2、集中式版本控制介绍</h5><p>集中化的版本控制系统(Centralized Version Control Systems，简称 CVCS)应运而生。 这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。</p><p>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p><h5 id="3、分布式版本控制介绍"><a href="#3、分布式版本控制介绍" class="headerlink" title="3、分布式版本控制介绍"></a>3、分布式版本控制介绍</h5><p>于是分布式版本控制系统(Distributed Version Control System，简称 DVCS)面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p><h5 id="4、SVN与Git的最主要的区别？"><a href="#4、SVN与Git的最主要的区别？" class="headerlink" title="4、SVN与Git的最主要的区别？"></a>4、SVN与Git的最主要的区别？</h5><p>　　SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p><p>　　Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h5 id="5、总结："><a href="#5、总结：" class="headerlink" title="5、总结："></a>5、总结：</h5><p>分布式代码版本管理系统并不一定适合所有团队，比如中小团队可能更关心的只是成本更低，简单易用，那么SVN等这类集中式版本管理工具还是更为适合。但是不管团队最终选用什么代码版本管理工具，只要适合自己的团队的开发流程和工作方式，并且代码管理顺畅就可以了。</p><h4 id="代码版本管理系统的历史"><a href="#代码版本管理系统的历史" class="headerlink" title="代码版本管理系统的历史"></a>代码版本管理系统的历史</h4><p>代码版本管理系统大致可以分为三个时代：</p><h5 id="第一代：本地式"><a href="#第一代：本地式" class="headerlink" title="第一代：本地式"></a>第一代：本地式</h5><p>这代主要的特点提供本地代码版本控制，比如SCCS(1972)、 PVCS(1985)等。<br>这代主要实现了基本的代码版本管理，但缺点是无法让多人同时对一个版本库进行修改。这个也和当时软件规模不够大有关，也没有这样的需求。</p><h5 id="第二代：客户端-服务器式"><a href="#第二代：客户端-服务器式" class="headerlink" title="第二代：客户端-服务器式"></a>第二代：客户端-服务器式</h5><p>这代主要的特点是提供集中式服务器端代码版本控制,比如 CVS(1986), ClearCase(1992), Visual SourceSafe(1994), Perforce(1995), Subversion(2000) 等。</p><p>这代主要是实现了中心服务器端的代码版本管理，特点是可以让多人同时对一个代码版本库进行同步和修改，但缺点也相当明显：</p><ul><li>在无法连接服务器的情况下，无法查看日志以及提交和比较代码版本（慢速网络和远程异地工作的程序员的痛），以及当服务或者网络出现问题的时候很多人员就会无法工作。</li><li>不支持local branch，导致branch创建管理复杂，并且一旦创建就很难修改（快速迭代开发中的程序员的痛）</li><li>由于只有一个中心端服务器，一旦发生灾难性问题，那么所有日志都会丢失，所以需要经常做备份（备份需要不小的成本）</li><li>如果软件代码量过于庞大，一般会出现速度缓慢的情况，因为每次的日志查询、不同版本之间的代码比较和代码提交等操作都需要和服务器通信，造成服务器端的负载过大。</li></ul><h5 id="第三代：分布式"><a href="#第三代：分布式" class="headerlink" title="第三代：分布式"></a>第三代：分布式</h5><p>这代主要的特点是提供分布式代码版本控制,比如Git(2005), Mercurial(2005)等。<br>这代结合了第一代和第二代的优点并实现了分布式的代码版本管理。<br>这代的优点：分布式管理，在没有和服务器有连接的情况下仍然可以查看日志，提交代码，创建分支；支持local branch，可以快速方便的实现各种分支管理；支持分布式，从而可以实现分块管理，以及负载分流管理。<br>缺点是有一定的学习曲线，比如分布方式下的代码同步，local branch的理解与运用，分布式代码管理的理解与运用等。详细的比较可以参考：这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;代码版本管理系统的概述&quot;&gt;&lt;a href=&quot;#代码版本管理系统的概述&quot; class=&quot;headerlink&quot; title=&quot;代码版本管理系统的概述&quot;&gt;&lt;/a&gt;代码版本管理系统的概述&lt;/h4&gt;&lt;h5 id=&quot;1、什么是版本控制&quot;&gt;&lt;a href=&quot;#1、什么是版本控制&quot; class=&quot;headerlink&quot; title=&quot;1、什么是版本控制&quot;&gt;&lt;/a&gt;1、什么是版本控制&lt;/h5&gt;&lt;p&gt;版本控制的核心是这样一个简单的概念，即对一个或者多个文件的追踪过程，随着这些文件演变成一个或多个产品的过程。特别是版本控制追踪什么变化，是什么改变了它，为什么会这样。版本控制系统提供了一个有益的说明，这些说明在传统的文件管理中是找不到的。&lt;/p&gt;
&lt;p&gt;需要注意的是版本控制使用不仅是局限于程序员。版本控制可以被任何人用来维护文件目录，因此即便你不是程序也可以因此受益。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="SVN" scheme="http://yoursite.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>Git 详解之常用命令汇总（四）</title>
    <link href="http://yoursite.com/2018/03/14/Git-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/14/Git-详解之常用命令汇总（四）/</id>
    <published>2018-03-14T09:48:01.000Z</published>
    <updated>2018-03-15T06:09:27.010Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Git提交三步走："><a href="#Git提交三步走：" class="headerlink" title="Git提交三步走："></a>Git提交三步走：</h4><p>（1）git add xx<br>git add xx命令可以将xx文件添加到暂存区，如果有很多改动可以通过 git add -A .来一次添加所有改变的文件。<br>注意 -A 选项后面还有一个句点。 git add -A表示添加所有内容， git add . 表示添加新文件和编辑过的文件不包括删除的文件; git add -u 表示添加编辑或者删除的文件，不包括新添加的文件<br>（2）git commit -m “注释”<br>（3）git push origin 分支名称，一般使用：git push origin master</p><p>正常来说，这三步基本满足需求了。<br><a id="more"></a></p><h4 id="下面进行命令的详细介绍"><a href="#下面进行命令的详细介绍" class="headerlink" title="下面进行命令的详细介绍"></a>下面进行命令的详细介绍</h4><p><code>git checkout</code>  查看当前分支</p><p><code>git branch name</code>  新建分支name<br><code>git checkout name</code>  切换当前分支为name</p><p><font color="red">合并语句：</font><code>git checkout -b name</code>  新建分支并切换到分支name</p><p><code>git add filename</code>  增加文件到分支<br><code>git commit -m &quot;remark&quot;</code>  提交修改内容到分支并添加注释</p><p><font color="red">合并语句：</font><code>git commit -m &quot;remark&quot; filename</code></p><p><code>git diff filename</code>  查看文件修改了什么内容</p><p><code>git status</code>  查看当前工作区状态</p><p><code>git checkout master</code><br><code>git merge name</code>  合并分支到master分支</p><p><code>git branch -d name</code>  删除name分支</p><p><code>git log --graph --pretty=oneline --abbrev-commit</code>  用git log查看分支历史</p><h4 id="特殊需求详解："><a href="#特殊需求详解：" class="headerlink" title="特殊需求详解："></a>特殊需求详解：</h4><h5 id="1、合并文件："><a href="#1、合并文件：" class="headerlink" title="1、合并文件："></a>1、合并文件：</h5><p><code>git merge name</code> 这种合并 Git会优先选择 Fast forward模式，这种模式下，删除分支后，会丢掉分支信息<br>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样从分支历史上就可以看出来分支信息。<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>  合并分支dev并禁用Fast forward模式 </p><h5 id="2、冲突解决："><a href="#2、冲突解决：" class="headerlink" title="2、冲突解决："></a>2、冲突解决：</h5><p>① 手动修改冲突文件并再次提交<br>打开产生冲突的文件后，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，>>>>>>>标记出不同分支的内容，其中<code>&lt;&lt;&lt;HEAD</code>是指主分支修改的内容，<code>&gt;&gt;&gt;&gt;&gt;fenzhi1</code> 是指fenzhi1上修改的内容，我们可以修改后保存即解决冲突。</p><h5 id="3、版本回退："><a href="#3、版本回退：" class="headerlink" title="3、版本回退："></a>3、版本回退：</h5><p>（1）使用<code>HEAD^</code>回退版本，<code>HEAD^</code>回退上个版本，<code>HEAD^^</code>回退上上个版本，以此类推。如果回退前100个版本的话，使用<code>HEAD~100</code>即可。<br><code>git reset --hard HEAD^</code><br><code>git reset --hard HEAD~100</code></p><p>（2）使用commit_id回退版本<br><code>git log</code> 查看需要回退的 commit_id<br><code>git reflog</code> 查看未来版本的 commit_id<br><code>git reset --hard commit_id</code><br>（注：这个回退可以回到以前版本，也可回到未来版本，只要知道commit_id即可）</p><h5 id="4、撤销修改："><a href="#4、撤销修改：" class="headerlink" title="4、撤销修改："></a>4、撤销修改：</h5><p>在工作区：（就是开发环境本地）<br><code>git checkout -- file</code>  可以丢弃工作区的修改。<strong>（注：如果没有 -- 的话，那么命令就变成创建分支了。）</strong></p><p>在暂存区：（已经 git add了）<br><code>git reset HEAD file</code>  可以把暂存区的修改撤销掉，重新放回到工作区</p><p>在本地版本中：（已经提交到分支）<br>只能版本回退了</p><h5 id="5、删除文件："><a href="#5、删除文件：" class="headerlink" title="5、删除文件："></a>5、删除文件：</h5><p>工作区删除：<br><code>rm file</code><br>工作区删除后文件恢复：<br><code>git checkout -- file</code><br>版本库删除：<br><code>git rm file</code><br><code>git commit -m &#39;remark&#39;</code><br>（注：删除后必须得提交更新版本库）</p><h5 id="6、BUG分支"><a href="#6、BUG分支" class="headerlink" title="6、BUG分支"></a>6、BUG分支</h5><p><code>git stash</code>  把当前工作现场“储藏”起来，等以后恢复现场后继续工作<br><code>git stash list</code>  查看工作现场存储到什么地方<br><code>git stash apply</code>  恢复，但stash内容并不删除<br><code>git stash pop</code>  恢复，但同时把stash内容也删除</p><h5 id="7、多人协作"><a href="#7、多人协作" class="headerlink" title="7、多人协作"></a>7、多人协作</h5><p><code>git remote</code>  查看远程库的信息 -v 更详细信息<br>推送分支： 就是把该分支上的所有本地提交推送到远程库。<br><code>git push origin master</code><br>抓取分支：把线上最新的提交抓下来<br><code>git pull</code></p><h4 id="工作模式通常是这样："><a href="#工作模式通常是这样：" class="headerlink" title="工作模式通常是这样："></a>工作模式通常是这样：</h4><p>1、首先，可以试图用git push origin branch-name推送自己的修改；<br>2、如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；<br>3、如果合并有冲突，则解决冲突，并在本地提交；<br>4、没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！<br>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。<br>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Git提交三步走：&quot;&gt;&lt;a href=&quot;#Git提交三步走：&quot; class=&quot;headerlink&quot; title=&quot;Git提交三步走：&quot;&gt;&lt;/a&gt;Git提交三步走：&lt;/h4&gt;&lt;p&gt;（1）git add xx&lt;br&gt;git add xx命令可以将xx文件添加到暂存区，如果有很多改动可以通过 git add -A .来一次添加所有改变的文件。&lt;br&gt;注意 -A 选项后面还有一个句点。 git add -A表示添加所有内容， git add . 表示添加新文件和编辑过的文件不包括删除的文件; git add -u 表示添加编辑或者删除的文件，不包括新添加的文件&lt;br&gt;（2）git commit -m “注释”&lt;br&gt;（3）git push origin 分支名称，一般使用：git push origin master&lt;/p&gt;
&lt;p&gt;正常来说，这三步基本满足需求了。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 详解之客户端安装（三）</title>
    <link href="http://yoursite.com/2018/03/14/Git-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/14/Git-详解之客户端安装（三）/</id>
    <published>2018-03-14T09:47:43.000Z</published>
    <updated>2018-03-15T06:09:21.835Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Linux下安装"><a href="#一、Linux下安装" class="headerlink" title="一、Linux下安装"></a>一、Linux下安装</h4><p>首先，你可以试着输入git，看看系统有没有安装Git：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program &apos;git&apos; is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p><p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。<br>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。<br><a id="more"></a></p><p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code> 这几个命令安装就好了。</p><h4 id="二、windows下安装"><a href="#二、windows下安装" class="headerlink" title="二、windows下安装"></a>二、windows下安装</h4><p>windows下客户端分为两种：<br>（1）Git客户端程序。<br>　　Git目前最新版本2.16.2<br>　　Git官网下载地址：<a href="http://git-scm.com/" target="_blank" rel="noopener"><font color="red">传送门</font></a><br>（2）Git客户端图形化操作程序 TortoiseGit。<br>　　TortoiseGit目前最新版本2.6.0<br>　　TortoiseGit官网下载地址：<a href="http://tortoisegit.org/download/" target="_blank" rel="noopener"><font color="red">传送门</font></a></p><p>安装过程可以按照程序的默认选项，都选择“下一步”安装完成。</p><p><strong>下面以 Git客户端程序为例来安装：</strong></p><blockquote><p>1.双击安装程序“Git-2.10.2-64-bit.exe”<br>2.点击“Next” ，根据自己的情况，选择程序的安装目录。<br>3.继续点击“Next”，显示截图如下：<br><img src="/uploads/2018/03/git_image_01.jpg" alt=""><br><strong>说明：</strong><br>（1）图标组件(Addition icons) : 选择是否创建桌面快捷方式。<br>（2）桌面浏览(Windows Explorer integration) : 浏览源码的方法，使用bash 或者 使用Git GUI工具。<br>（3）关联配置文件 : 是否关联 git 配置文件, 该配置文件主要显示文本编辑器的样式。<br>（4）关联shell脚本文件 : 是否关联Bash命令行执行的脚本文件。<br>（5）使用TrueType编码 : 在命令行中是否使用TruthType编码, 该编码是微软和苹果公司制定的通用编码。<br>4.选择完之后，点击“Next”，开始菜单快捷方式目录：设置开始菜单中快捷方式的目录名称, 也可以选择不在开始菜单中创建快捷方式。<br>5.点击“Next”，显示截图如下：<br><img src="/uploads/2018/03/git_image_02.jpg" alt=""><br><strong>设置环境变量</strong><br>选择使用什么样的命令行工具，一般情况下我们默认使用Git Bash即可：<br>（1）Git自带：使用Git自带的Git Bash命令行工具。<br>（2）系统自带CMD：使用Windows系统的命令行工具。<br>（3）二者都有：上面二者同时配置，但是注意，这样会将windows中的find.exe 和 sort.exe工具覆盖，如果不懂这些尽量不要选择。<br>6.选择之后，继续点击“Next”，显示如下：<br><img src="/uploads/2018/03/git_image_03.jpg" alt=""><br><strong>选择提交的时候换行格式</strong><br>（1）检查出windows格式转换为unix格式：将windows格式的换行转为unix格式的换行再进行提交。<br>（2）检查出原来格式转为unix格式：不管什么格式的，一律转为unix格式的换行再进行提交。<br>（3）不进行格式转换 : 不进行转换，检查出什么，就提交什么。<br>7.选择之后，点击“Next”<br>8.选择之后，点击“Next”<br>9.选择之后，点击“Install”，开始安装</p></blockquote><p>这样，我们的Git客户端就安装完成了。</p><p>安装完成后，在开始菜单里面能够找到 “Git –&gt; Git Bash”,如下：<br><img src="/uploads/2018/03/git_image_04.JPG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、Linux下安装&quot;&gt;&lt;a href=&quot;#一、Linux下安装&quot; class=&quot;headerlink&quot; title=&quot;一、Linux下安装&quot;&gt;&lt;/a&gt;一、Linux下安装&lt;/h4&gt;&lt;p&gt;首先，你可以试着输入git，看看系统有没有安装Git：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The program &amp;apos;git&amp;apos; is currently not installed. You can install it by typing:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。&lt;br&gt;如果你碰巧用Debian或Ubuntu Linux，通过一条&lt;code&gt;sudo apt-get install git&lt;/code&gt;就可以直接完成Git的安装，非常简单。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 详解之服务器搭建（二）</title>
    <link href="http://yoursite.com/2018/03/14/Git-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/14/Git-详解之服务器搭建（二）/</id>
    <published>2018-03-14T09:46:31.000Z</published>
    <updated>2018-03-15T06:09:17.082Z</updated>
    
    <content type="html"><![CDATA[<p>服务器环境：CentOS7 + Git(version 1.8.3.1)</p><h4 id="1、安装Git"><a href="#1、安装Git" class="headerlink" title="1、安装Git"></a>1、安装Git</h4><p>　　<code>yum install -y git</code><br>安装完后，查看 Git 版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# git version</span><br><span class="line">git version 1.8.3.1</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="2、新建Git账号，用来管理Git服务"><a href="#2、新建Git账号，用来管理Git服务" class="headerlink" title="2、新建Git账号，用来管理Git服务"></a>2、新建Git账号，用来管理Git服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# id git</span><br><span class="line">id: git：无此用户</span><br><span class="line">[root@VM_0_7_centos ~]# useradd git</span><br><span class="line">[root@VM_0_7_centos ~]# passwd git</span><br></pre></td></tr></table></figure><h4 id="3、服务器端创建Git仓库"><a href="#3、服务器端创建Git仓库" class="headerlink" title="3、服务器端创建Git仓库"></a>3、服务器端创建Git仓库</h4><p>设置 /data/git/gittest.git 为 Git 仓库<br>然后把 Git 仓库的 owner 修改为 git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# mkdir -p /data/git/gittest.git</span><br><span class="line">[root@VM_0_7_centos ~]# git init --bare /data/git/gittest.git</span><br><span class="line">Initialized empty Git repository in /data/git/gittest.git/</span><br><span class="line">[root@VM_0_7_centos ~]# cd /data/git/</span><br><span class="line">[root@VM_0_7_centos git]# chown -R git:git gittest.git/</span><br></pre></td></tr></table></figure></p><h4 id="4、客户端首次-clone-远程仓库"><a href="#4、客户端首次-clone-远程仓库" class="headerlink" title="4、客户端首次 clone 远程仓库"></a>4、客户端首次 clone 远程仓库</h4><p>进入 Git Bash 命令行客户端，创建项目地址（设置在  /d/MyProjects/gittest.git）并进入；<br>然后从 Linux Git 服务器上 clone 项目：<br><code>$ git clone git@118.24.8.229:/data/git/gittest.git</code></p><p>如果SSH用的不是默认的22端口，则需要使用以下的命令（假设SSH端口号是7700）：<br><code>$ git clone ssh://git@118.24.8.229:7700/home/data/gittest.git</code></p><p>当第一次连接到目标 Git 服务器时会得到一个提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &apos;gittest&apos;...</span><br><span class="line">The authenticity of host &apos;118.24.8.229 (118.24.8.229)&apos; can&apos;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:witKSLOMzfgWBcs78t5LfqmSJ+JEm2/PBEaR0d9mnqA.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br></pre></td></tr></table></figure></p><p>选择 yes：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &apos;118.24.8.229&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">git@118.24.8.229&apos;s password:</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure></p><p>后面提示要输入密码，可以采用 SSH 公钥来进行验证（下面会进行说明）。</p><h4 id="5、服务器端Git打开RSA认证"><a href="#5、服务器端Git打开RSA认证" class="headerlink" title="5、服务器端Git打开RSA认证"></a>5、服务器端Git打开RSA认证</h4><p>进入 /etc/ssh 目录，编辑 sshd_config，打开以下三个配置的注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#RSAAuthentication yes</span><br><span class="line">#PubkeyAuthentication yes</span><br><span class="line">#AuthorizedKeysFile     .ssh/authorized_keys</span><br></pre></td></tr></table></figure></p><blockquote><p>##RSAAuthentication用来设置是否开启RSA密钥验证，只针对SSH1<font color="red">（注：对于SSH2来说，没有此项配置）</font></p><p>##PubkeyAuthentication用来设置是否开启公钥验证，如果使用公钥验证的方式登录时，则设置为yes</p><p>##AuthorizedKeysFile用来设置公钥验证文件的路径，与PubkeyAuthentication配合使用,默认值是”.ssh/authorized_keys”。</p></blockquote><p>保存并重启 sshd 服务：<br><code>[root@VM_0_7_centos git]# systemctl restart sshd</code></p><p>由AuthorizedKeysFile 得知公钥的存放路径是 <code>.ssh/authorized_keys</code>，实际上是 <code>$Home/.ssh/authorized_keys</code>，由于管理 Git 服务的用户是 git，所以实际存放公钥的路径是 <code>/home/git/.ssh/authorized_keys</code>。</p><h4 id="6、客户端创建SSH公钥和私钥并将公钥导入服务器端"><a href="#6、客户端创建SSH公钥和私钥并将公钥导入服务器端" class="headerlink" title="6、客户端创建SSH公钥和私钥并将公钥导入服务器端"></a>6、客户端创建SSH公钥和私钥并将公钥导入服务器端</h4><p><code>$ ssh-keygen -t rsa</code><br>此时 C:\Users\用户名.ssh 下会多出两个文件 id_rsa 和 id_rsa.pub</p><blockquote><p>id_rsa 是私钥<br>id_rsa.pub 是公钥</p></blockquote><p>回到 Git Bash 下，导入文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh git@118.24.8.229 `cat &gt;&gt; ~/.ssh/authorized_keys &lt; ~/.ssh/id_rsa.pub`</span><br><span class="line">git@118.24.8.229&apos;s password:</span><br><span class="line">Last login: Wed Mar 14 21:01:33 2018 from 113.46.182.66</span><br></pre></td></tr></table></figure></p><p>需要输入服务器端 git 用户的密码</p><p>回到服务器端，查看 .ssh 下是否存在 authorized_keys 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos .ssh]# ll -h</span><br><span class="line">total 12K</span><br><span class="line">-rw------- 1 git git  401 Mar 14 14:34 authorized_keys</span><br><span class="line">-rw------- 1 git git 1.7K Mar 14 14:32 id_rsa</span><br><span class="line">-rw-r--r-- 1 git git  399 Mar 14 14:32 id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>可以查看一下是否是客户端生成的公钥。</p><blockquote><font color="red">重要：<br>修改 .ssh 目录的权限为 700<br>修改 .ssh/authorized_keys 文件的权限为 600</font></blockquote><h4 id="7、客户端再次-clone-远程仓库"><a href="#7、客户端再次-clone-远程仓库" class="headerlink" title="7、客户端再次 clone 远程仓库"></a>7、客户端再次 clone 远程仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@118.24.8.229:/data/git/gittest.git</span><br><span class="line">fatal: destination path &apos;gittest&apos; already exists and is not an empty directory.</span><br></pre></td></tr></table></figure><p>项目已经 clone 了</p><h4 id="8、禁止-Git-用户-SSH-登录服务器"><a href="#8、禁止-Git-用户-SSH-登录服务器" class="headerlink" title="8、禁止 Git 用户 SSH 登录服务器"></a>8、禁止 Git 用户 SSH 登录服务器</h4><p>编辑 /etc/passwd<br>找到：<br><code>git:x:502:504::/home/git:/bin/bash</code><br>修改为<br><code>git:x:502:504::/home/git:/bin/git-shell</code><br>此时 git 用户可以正常通过 ssh 使用 git，但无法通过 ssh 登录系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务器环境：CentOS7 + Git(version 1.8.3.1)&lt;/p&gt;
&lt;h4 id=&quot;1、安装Git&quot;&gt;&lt;a href=&quot;#1、安装Git&quot; class=&quot;headerlink&quot; title=&quot;1、安装Git&quot;&gt;&lt;/a&gt;1、安装Git&lt;/h4&gt;&lt;p&gt;　　&lt;code&gt;yum install -y git&lt;/code&gt;&lt;br&gt;安装完后，查看 Git 版本&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@VM_0_7_centos ~]# git version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git version 1.8.3.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 详解之协议篇（一）</title>
    <link href="http://yoursite.com/2018/03/14/Git-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%8D%8F%E8%AE%AE%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/14/Git-详解之协议篇（一）/</id>
    <published>2018-03-14T09:46:12.000Z</published>
    <updated>2018-03-15T06:09:05.101Z</updated>
    
    <content type="html"><![CDATA[<p><strong>协议</strong><br>Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。下面分别介绍一下哪些情形应该使用（或避免使用）这些协议。</p><p>值得注意的是，除了 HTTP 协议外，其他所有协议都要求在服务器端安装并运行 Git。<br><a id="more"></a></p><h4 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h4><p>最基本的就是本地协议（Local protocol），所谓的远程仓库在该协议中的表示，就是硬盘上的另一个目录。这常见于团队每一个成员都对一个共享的文件系统（例如 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。后面一种情况并不安全，因为所有代码仓库实例都储存在同一台电脑里，增加了灾难性数据损失的可能性。</p><p>如果你使用一个共享的文件系统，就可以在一个本地文件系统中克隆仓库，推送和获取。克隆的时候只需要将远程仓库的路径作为 URL 使用，比如下面这样：<br>　　<code>$ git clone /opt/git/project.git</code></p><p>要添加一个本地仓库作为现有 Git 项目的远程仓库，可以这样做：<br>　　<code>$ git remote add local_proj /opt/git/project.git</code></p><p>然后就可以像在网络上一样向这个远程仓库推送和获取数据了。</p><h4 id="SSH-协议（推荐）"><a href="#SSH-协议（推荐）" class="headerlink" title="SSH 协议（推荐）"></a>SSH 协议<font color="red">（推荐）</font></h4><p>Git 使用的传输协议中最常见的可能就是 SSH 了。这是因为大多数环境已经支持通过 SSH 对服务器的访问 — 即便还没有，架设起来也很容易。SSH 也是唯一一个同时支持读写操作的网络协议。另外两个网络协议（HTTP 和 Git）通常都是只读的，所以虽然二者对大多数人都可用，但执行写操作时还是需要 SSH。SSH 同时也是一个验证授权的网络协议；而因为其普遍性，一般架设和使用都很容易。</p><p>通过 SSH 克隆一个 Git 仓库，你可以像下面这样给出 ssh:// 的 URL：<br>　　<code>$ git clone ssh://user@server/project.git</code></p><p>或者不指明某个协议 — 这时 Git 会默认使用 SSH ：<br>　　<code>$ git clone user@server:project.git</code></p><p>（注：SSH 的限制在于你不能通过它实现仓库的匿名访问。即使仅为读取数据，人们也必须在能通过 SSH 访问主机的前提下才能访问仓库，这使得 SSH 不利于开源的项目。如果你仅仅在公司网络里使用，SSH 可能是你唯一需要使用的协议。）</p><h4 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h4><p>接下来是 Git 协议。这是一个包含在 Git 软件包中的特殊守护进程； 它会监听一个提供类似于 SSH 服务的特定端口（9418），而无需任何授权。打算支持 Git 协议的仓库，需要先创建 git-daemon-export-ok 文件 — 它是协议进程提供仓库服务的必要条件 — 但除此之外该服务没有什么安全措施。要么所有人都能克隆 Git 仓库，要么谁也不能。这也意味着该协议通常不能用来进行推送。你可以允许推送操作；然而由于没有授权机制，一旦允许该操作，网络上任何一个知道项目 URL 的人将都有推送权限。不用说，这是十分罕见的情况。</p><p>（注：Git 协议是现存最快的传输协议。如果你在提供一个有很大访问量的公共项目，或者一个不需要对读操作进行授权的庞大项目，架设一个 Git 守护进程来供应仓库是个不错的选择。Git 协议消极的一面是缺少授权机制。用 Git 协议作为访问项目的唯一方法通常是不可取的。一般的做法是，同时提供 SSH 接口，让几个开发者拥有推送（写）权限，其他人通过 git:// 拥有只读权限。 Git 协议可能也是最难架设的协议。）</p><h4 id="HTTP-S-协议"><a href="#HTTP-S-协议" class="headerlink" title="HTTP/S 协议"></a>HTTP/S 协议</h4><p>最后还有 HTTP 协议。HTTP 或 HTTPS 协议的优美之处在于架设的简便性。基本上，只需要把 Git 的裸仓库文件放在 HTTP 的根目录下，配置一个特定的 post-update 挂钩（hook）就可以搞定（Git 挂钩的细节见第 7 章）。此后，每个能访问 Git 仓库所在服务器上 web 服务的人都可以进行克隆操作。下面的操作可以允许通过 HTTP 对仓库进行读取：</p><p>$ cd /var/www/htdocs/<br>$ git clone –bare /path/to/git_project gitproject.git<br>$ cd gitproject.git<br>$ mv hooks/post-update.sample hooks/post-update<br>$ chmod a+x hooks/post-update<br>这样就可以了。Git 附带的 post-update 挂钩会默认运行合适的命令（git update-server-info）来确保通过 HTTP 的获取和克隆正常工作。这条命令在你用 SSH 向仓库推送内容时运行；之后，其他人就可以用下面的命令来克隆仓库：</p><p>$ git clone <a href="http://example.com/gitproject.git" target="_blank" rel="noopener">http://example.com/gitproject.git</a></p><p>（注：使用 HTTP 协议的好处是易于架设。几条必要的命令就可以让全世界读取到仓库的内容。花费不过几分钟。HTTP 协议不会占用过多服务器资源。因为它一般只用到静态的 HTTP 服务提供所有数据。你可以通过 HTTPS 提供只读的仓库，这意味着你可以加密传输内容。但是，HTTP 协议的消极面在于，相对来说客户端效率更低。克隆或者下载仓库内容可能会花费更多时间，而且 HTTP 传输的体积和网络开销比其他任何一个协议都大。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;协议&lt;/strong&gt;&lt;br&gt;Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。下面分别介绍一下哪些情形应该使用（或避免使用）这些协议。&lt;/p&gt;
&lt;p&gt;值得注意的是，除了 HTTP 协议外，其他所有协议都要求在服务器端安装并运行 Git。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7默认Python升级</title>
    <link href="http://yoursite.com/2018/03/13/CentOS-7%E9%BB%98%E8%AE%A4Python%E5%8D%87%E7%BA%A7/"/>
    <id>http://yoursite.com/2018/03/13/CentOS-7默认Python升级/</id>
    <published>2018-03-13T10:01:05.000Z</published>
    <updated>2018-03-14T06:16:06.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>CentOS 7 中默认安装了 Python，版本比较低（2.7.5），为了使用新版 3.x，需要对旧版本进行升级。</p><p>由于很多基本的命令、软件包都依赖旧版本，比如：yum。所以，在更新 Python 时，建议不要删除旧版本（新旧版本可以共存）。</p><h3 id="安装Python3-6-4"><a href="#安装Python3-6-4" class="headerlink" title="安装Python3.6.4"></a>安装Python3.6.4</h3><a id="more"></a><h4 id="（1）下载并解压缩"><a href="#（1）下载并解压缩" class="headerlink" title="（1）下载并解压缩"></a>（1）下载并解压缩</h4><p>下载地址：<a href="https://www.python.org/downloads/release/python-364/" title="Python3.x" target="_blank" rel="noopener"><font color="red">传送门</font></a><br>此处我选择的版本是Python3.6.4：<br>　　<code>wget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tgz</code><br>解压缩：<br>　　<code>tar -xvf Python-3.6.4.tgz</code></p><h4 id="（2）检测编译环境"><a href="#（2）检测编译环境" class="headerlink" title="（2）检测编译环境"></a>（2）检测编译环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Python-3.6.4/</span><br><span class="line">./configure</span><br></pre></td></tr></table></figure><p>执行 ./configure 时，如果报错：</p><blockquote><p>configure: error: no acceptable C compiler found in $PATH</p></blockquote><p>说明没有安装合适的编译器。这时，需要安装/升级 gcc 及其它依赖包。<br>　　<code>yum install make gcc gcc-c++</code><br>完成之后，重新执行：<br>　　<code>./configure</code></p><h4 id="（3）编译-amp-安装"><a href="#（3）编译-amp-安装" class="headerlink" title="（3）编译 &amp; 安装"></a>（3）编译 &amp; 安装</h4><p>　　<code>make &amp; make install</code><br>安装中如果报错：</p><blockquote><p>zipimport.ZipImportError: can’t decompress data; zlib not available</p></blockquote><p>说明是因为缺少zlib 的相关工具包导致的，知道了问题所在，那么我们只需要安装相关依赖包即可，<br>① 打开终端，输入一下命令安装zlib相关依赖包：<br>　　<code>yum -y install zlib*</code> 或 <code>yum -y install zlib zlib-devel</code>（未试）</p><p>② 进入 python安装包,修改Module路径的setup文件：<br>　　<code>vim Module/Setup.dist</code><br>找到以下这行代码，去掉注释：</p><blockquote><p>#zlib zlibmodule.c -I$(prefix)/include -L$(exec_prefix)/lib -lz</p></blockquote><p>然后再次执行编译 &amp; 安装。</p><h3 id="设置Python默认版本"><a href="#设置Python默认版本" class="headerlink" title="设置Python默认版本"></a>设置Python默认版本</h3><h4 id="（1）查看Python版本"><a href="#（1）查看Python版本" class="headerlink" title="（1）查看Python版本"></a>（1）查看Python版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# python -V</span><br><span class="line">Python 2.7.5</span><br><span class="line">[root@VM_0_7_centos ~]# python3 -V</span><br><span class="line">Python 3.6.4</span><br></pre></td></tr></table></figure><p>查看Python命令路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# which python</span><br><span class="line">/usr/bin/python</span><br><span class="line">[root@VM_0_7_centos ~]# which python3</span><br><span class="line">/usr/local/bin/python3</span><br></pre></td></tr></table></figure></p><h4 id="（2）设置Python3-x为默认版本"><a href="#（2）设置Python3-x为默认版本" class="headerlink" title="（2）设置Python3.x为默认版本"></a>（2）设置Python3.x为默认版本</h4><p>查看Python默认版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# ll /usr/bin/ | grep python</span><br><span class="line">-rwxr-xr-x. 1 root root      11232 Aug 10  2017 abrt-action-analyze-python</span><br><span class="line">lrwxrwxrwx. 1 root root          7 Jan  9 18:20 python -&gt; python2</span><br><span class="line">lrwxrwxrwx. 1 root root          9 Jan  9 18:20 python2 -&gt; python2.7</span><br><span class="line">-rwxr-xr-x. 1 root root       7136 Aug  4  2017 python2.7</span><br></pre></td></tr></table></figure></p><p>更改Python默认版本，将原来 python 的软链接重命名：<br>　　<code>mv /usr/bin/python /usr/bin/python.bak</code><br>将 python 链接至 python3：<br>　　<code>ln -s /usr/local/bin/python3 /usr/bin/python</code><br>这时，再查看 Python 的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# python -V</span><br><span class="line">Python 3.6.4</span><br></pre></td></tr></table></figure></p><p>输出的是 3.x，说明已经使用的是 python3了。</p><h3 id="配置yum"><a href="#配置yum" class="headerlink" title="配置yum"></a>配置yum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# yum</span><br><span class="line">  File &quot;/usr/bin/yum&quot;, line 30</span><br><span class="line">    except KeyboardInterrupt, e:</span><br><span class="line">                            ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>升级 Python 之后，由于将默认的 python 指向了 python3，yum 不能正常使用，需要编辑 yum 的配置文件：<br>　　<code>vi /usr/bin/yum</code><br>同时修改：<br>　　<code>vi /usr/libexec/urlgrabber-ext-down</code><br>将 #!/usr/bin/python 改为 #!/usr/bin/python2.7，保存退出即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;CentOS 7 中默认安装了 Python，版本比较低（2.7.5），为了使用新版 3.x，需要对旧版本进行升级。&lt;/p&gt;
&lt;p&gt;由于很多基本的命令、软件包都依赖旧版本，比如：yum。所以，在更新 Python 时，建议不要删除旧版本（新旧版本可以共存）。&lt;/p&gt;
&lt;h3 id=&quot;安装Python3-6-4&quot;&gt;&lt;a href=&quot;#安装Python3-6-4&quot; class=&quot;headerlink&quot; title=&quot;安装Python3.6.4&quot;&gt;&lt;/a&gt;安装Python3.6.4&lt;/h3&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CSS 图片居中问题（水平居中和垂直居中）</title>
    <link href="http://yoursite.com/2018/03/13/CSS-%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98%EF%BC%88%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/13/CSS-图片居中问题（水平居中和垂直居中）/</id>
    <published>2018-03-13T03:29:17.000Z</published>
    <updated>2018-03-13T03:38:33.545Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、水平居中"><a href="#1、水平居中" class="headerlink" title="1、水平居中"></a>1、水平居中</h4><p>（1）利用margin: 0 auto实现图片水平居中<br>利用margin: 0 auto实现图片居中就是在图片上加上css样式margin: 0 auto 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center; width: 500px; border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">         style=&quot;margin: 0 auto;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>（2）利用文本的水平居中属性text-align: center<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center; width: 500px; border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">         style=&quot;display: inline-block;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2、垂直居中"><a href="#2、垂直居中" class="headerlink" title="2、垂直居中"></a>2、垂直居中</h4><p>（1）利用高==行高实现图片垂直居中<br>这种方法是要知道高度才可以使用，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center; width: 500px;height:200px; </span><br><span class="line">            line-height:200px; border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">         style=&quot;display: inline-block; vertical-align: middle;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>（2）利用table实现图片垂直居中<br>利用table的方法是利用了table的垂直居中属性，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center; width: 500px;height:200px; </span><br><span class="line">            display: table;border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;span style=&quot;display: table-cell; vertical-align: middle; &quot;&gt;</span><br><span class="line">        &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">             style=&quot;display: inline-block;&quot; /&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这里使用display: table;和display: table-cell;来模拟table，这种方法并不兼容IE6/IE7，IE67不支持display: table，如果你不需要支持IE67那就可以用<br><strong>（缺点：当你设置了display: table;可能会改变你的原有布局）</strong></p><p>（3）利用绝对定位实现图片垂直居中<br>如果已知图片的宽度和高度可以这样，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width: 500px;height:200px; position: relative; border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">         style=&quot;width: 120px; height: 40px;position: absolute; left:50%; top: 50%; </span><br><span class="line">                margin-left: -60px;margin-top: -20px;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>（4）移动端可以利用flex布局实现css图片垂直居中<br>移动端一般浏览器版本都比较高，所以可以大胆的使用flex布局，（flex布局参考css3的flex布局用法）演示代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*css代码：*/</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.ui-flex &#123;</span><br><span class="line">    display: -webkit-box !important;</span><br><span class="line">    display: -webkit-flex !important;</span><br><span class="line">    display: -ms-flexbox !important;</span><br><span class="line">    display: flex !important;</span><br><span class="line">    -webkit-flex-wrap: wrap;</span><br><span class="line">    -ms-flex-wrap: wrap;</span><br><span class="line">    flex-wrap: wrap</span><br><span class="line">&#125;</span><br><span class="line">.ui-flex, .ui-flex *, .ui-flex :after, .ui-flex :before &#123;</span><br><span class="line">    box-sizing: border-box</span><br><span class="line">&#125;</span><br><span class="line">.ui-flex.justify-center &#123;</span><br><span class="line">    -webkit-box-pack: center;</span><br><span class="line">    -webkit-justify-content: center;</span><br><span class="line">    -ms-flex-pack: center;</span><br><span class="line">    justify-content: center</span><br><span class="line">&#125;</span><br><span class="line">.ui-flex.center &#123;</span><br><span class="line">    -webkit-box-pack: center;</span><br><span class="line">    -webkit-justify-content: center;</span><br><span class="line">    -ms-flex-pack: center;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    -webkit-box-align: center;</span><br><span class="line">    -webkit-align-items: center;</span><br><span class="line">    -ms-flex-align: center;</span><br><span class="line">    align-items: center</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">/*html代码：*/</span><br><span class="line">&lt;div class=&quot;ui-flex justify-center center&quot; </span><br><span class="line">     style=&quot;border: green solid 1px; width: 500px; height: 200px;&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">        &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; style=&quot;&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、水平居中&quot;&gt;&lt;a href=&quot;#1、水平居中&quot; class=&quot;headerlink&quot; title=&quot;1、水平居中&quot;&gt;&lt;/a&gt;1、水平居中&lt;/h4&gt;&lt;p&gt;（1）利用margin: 0 auto实现图片水平居中&lt;br&gt;利用margin: 0 auto实现图片居中就是在图片上加上css样式margin: 0 auto 如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div style=&amp;quot;text-align: center; width: 500px; border: green solid 1px;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;img alt=&amp;quot;&amp;quot; src=&amp;quot;https://www.baidu.com/img/baidu_jgylogo3.gif&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         style=&amp;quot;margin: 0 auto;&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
      <category term="CSS问题" scheme="http://yoursite.com/categories/CSS/CSS%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="CSS问题" scheme="http://yoursite.com/tags/CSS%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>CSS 获取同类中第几个元素</title>
    <link href="http://yoursite.com/2018/03/13/CSS-%E8%8E%B7%E5%8F%96%E5%90%8C%E7%B1%BB%E4%B8%AD%E7%AC%AC%E5%87%A0%E4%B8%AA%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2018/03/13/CSS-获取同类中第几个元素/</id>
    <published>2018-03-13T03:28:46.000Z</published>
    <updated>2018-03-13T03:33:51.403Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，我们可能会碰到这样的需求：想让列表中的第一个部分显示不同的样式，想让列表中的偶数部分显示不同的背景颜色，想让列表中的最后一部分样式不一样……这样的需求，我们怎样来实现？<br>我们还可以通过CSS来实现，CSS给我们提供了几个非常有用的样式参数：first-child、last-child、nth-child(n)。下面，详细看一下它们的使用。<br><a id="more"></a></p><h4 id="1、first-child"><a href="#1、first-child" class="headerlink" title="1、first-child"></a>1、first-child</h4><p>first-child表示选择列表中的第一个标签。代码如下：<br>　　<code>li:first-child{background:#090}</code><br>上面的意思是，li 列表中的 第一个li模块的背景颜色。</p><h4 id="2、last-child"><a href="#2、last-child" class="headerlink" title="2、last-child"></a>2、last-child</h4><p>last-child表示选择列表中的最后一个标签，代码如下：<br>　　<code>li:last-child{background:#090}</code></p><h4 id="3、nth-child-3"><a href="#3、nth-child-3" class="headerlink" title="3、nth-child(3)"></a>3、nth-child(3)</h4><p>表示选择列表中的第3个标签，代码如下：<br>　　<code>li:nth-child(3){background:#090}</code><br>上面代码中的3也可以改成其它数字，如4、5等。想选择第几个标签，就填写几。</p><h4 id="4、nth-child-2n"><a href="#4、nth-child-2n" class="headerlink" title="4、nth-child(2n)"></a>4、nth-child(2n)</h4><p>这个表示选择列表中的偶数标签，即选择 第2、第4、第6…… 标签。</p><h4 id="5、nth-child-2n-1"><a href="#5、nth-child-2n-1" class="headerlink" title="5、nth-child(2n-1)"></a>5、nth-child(2n-1)</h4><p>这个表示选择列表中的奇数标签，即选择 第1、第3、第5、第7……标签。</p><h4 id="6、nth-child-n-3"><a href="#6、nth-child-n-3" class="headerlink" title="6、nth-child(n+3)"></a>6、nth-child(n+3)</h4><p>这个表示选择列表中的标签从第3个开始到最后。</p><h4 id="7、nth-child-n-3"><a href="#7、nth-child-n-3" class="headerlink" title="7、nth-child(-n+3)"></a>7、nth-child(-n+3)</h4><p>这个表示选择列表中的标签从0到3，即小于3的标签。</p><h4 id="8、nth-last-child-3"><a href="#8、nth-last-child-3" class="headerlink" title="8、nth-last-child(3)"></a>8、nth-last-child(3)</h4><p>这个表示选择列表中的倒数第3个标签。</p><p>上面这些CSS样式是非常有用的，在我们的网页开发过程中，会派上非常大的用场，可以给我们的网页带来不一样的风格。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前端开发中，我们可能会碰到这样的需求：想让列表中的第一个部分显示不同的样式，想让列表中的偶数部分显示不同的背景颜色，想让列表中的最后一部分样式不一样……这样的需求，我们怎样来实现？&lt;br&gt;我们还可以通过CSS来实现，CSS给我们提供了几个非常有用的样式参数：first-child、last-child、nth-child(n)。下面，详细看一下它们的使用。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
      <category term="CSS问题" scheme="http://yoursite.com/categories/CSS/CSS%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="CSS问题" scheme="http://yoursite.com/tags/CSS%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端切图技巧总结</title>
    <link href="http://yoursite.com/2018/03/09/%E5%89%8D%E7%AB%AF%E5%88%87%E5%9B%BE%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/09/前端切图技巧总结/</id>
    <published>2018-03-09T08:13:30.000Z</published>
    <updated>2018-03-09T08:20:56.363Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、传统切图方法"><a href="#一、传统切图方法" class="headerlink" title="一、传统切图方法"></a>一、传统切图方法</h4><p>使用范围：需要切多张图，带背景的<br>1.打开下载的psd文件<br>出现下面没关系，直接点确定即可<br><img src="/uploads/2018/03/photoshop_001.JPG" alt=""><br><a id="more"></a></p><p>打开后，因为文件比较长所以看不清细节，所以我们要放大图片到合适的大小。 </p><blockquote><font color="red">放大图片：”CTRL” +“+”<br>缩小图片：“CTRL”+ “-”</font></blockquote><p>然后我们来认识下photoshop中的一些工具<br><img src="/uploads/2018/03/photoshop_01.JPG" alt=""></p><p>2.修改参考线<br>我们可以看到我们的图片中很多条蓝色的参考线，这些线是设计人员用来设计用的，有的文件中的线会直接把我们需要切的东西给包裹出来，但是像我们练习的这个文件中的参考线特别的多，特别的密集，很多我们都不需要，所以我们先把这些参考线都清除掉。</p><p>删除参考线：选择移动工具，然后把要删除的参考线往标尺上拖，往上或者往左都可以</p><p>没有参考线的可能是参考线被隐藏了，通过<font color="red">“CTRL”+“ALT”+“;”</font>就可以显示出来了。<br><img src="/uploads/2018/03/photoshop_02.gif" alt=""></p><p>我们只要把挡住图标的参考线给删除就可以</p><p>3.选择要切的图标<br>这里我们就切几个页面上的图标，文字部分我们都可以通过代码来实现，所以就不切了。<br><img src="/uploads/2018/03/photoshop_03.gif" alt=""></p><blockquote><p>①选择工具栏第一个“移动工具”<br>②然后查看上面选项栏“自动选择”有没有被选中，没有被选中点击选中，将它旁边的“组”改为“图层”，这样我们点击图标的时候，右下角的图层面板就能自动的选中对应的图层<br>③点击我们要切的图标，然后到右下角的图层面板，点击当前选中的这个图层旁边的小眼睛来隐藏当前图层，通过显隐来确定是不是我们要切的图标<br>④确认了我们要切的图标后，分别从水平标尺和竖直标尺的地方拉取参考线来把图标给包裹住。因为我们当前选中的就是我们要切的图层，所以当参考线拖过去的时候会自动吸附到图标的边缘。<br>⑤用同样的方法把图标都用参考线包裹出来，最下面一排，要把图标切成一样高的才好，所以以第一个的上边界和下边界为基准。</p></blockquote><p>4.切片需要的图标<br>现在，我们已经用参考线把我们的图标给包裹出来了，下面，我们要用切片工具来切出我们的图标<br><img src="/uploads/2018/03/photoshop_04.gif" alt=""></p><blockquote><p>①选择切片工具，左边工具栏从上往下数第五个，然后右键就可以找到，然后选中<br>②然后找到我们刚才用参考线包裹的图标，从左上角一直拖到右下角，因为有参考线的帮助，所以软件能够自动吸附到参考线上，所以只要大概找准左上角和右下角就可以选取出来<br>③用同样的方法把剩下的都选取出来 </p></blockquote><p>5.将切片存储为图片</p><blockquote><p>①选择 “文件”=》“存储为Web所用格式”<br><img src="/uploads/2018/03/photoshop_05.JPG" alt=""><br>②调整缩放比例，让图片能完整的在窗口显示<br>③在窗口中，从左上角一直拖到右下角，选中所有切片，这样我们才能把切片都存储为我们想要的格式<br>④存储为png-24格式，png-24格式的图片质量比较高<br><img src="/uploads/2018/03/photoshop_06.JPG" alt=""><br>⑤保存，选择用户所有切片可以只保存我们自己切出来的切片<br><img src="/uploads/2018/03/photoshop_07.JPG" alt=""><br>⑥然后查看保存的文件里面就多了一个images文件夹，里面就是我们切出来的图片</p></blockquote><p><strong>（注：但是这样做会发现png格式的背景还是有的，而且如果只是需要一张图的时候，还要这样切就会比较麻烦，所以(二)中会介绍一些切一两个小图标的方法）</strong></p><h4 id="二、切单个图标方法"><a href="#二、切单个图标方法" class="headerlink" title="二、切单个图标方法"></a>二、切单个图标方法</h4><p>之前介绍了传统的切图技巧，主要用于切多张图片的时候，但很多时候我们可能只需要切一两张图标，如果还用传统的方法就会很繁琐，所以这次分享一种导出单个图标的方法。</p><p>1.还是之前的文件，这次我们就切一个图标<br><img src="/uploads/2018/03/photoshop_08.JPG" alt=""></p><p>2.选择移动工具，并在选项中选中“自动选择”和“图层”<br><img src="/uploads/2018/03/photoshop_09.JPG" alt=""></p><p>3.点击我们要切的图标，这里是点击中间的笔，然后右边的图层面板就会自动聚焦到对应的图层，通过点击左边的小眼睛来确定是不是我们想要的图层。<br><img src="/uploads/2018/03/photoshop_10.JPG" alt=""></p><p>4.这里我们找到了我们需要的图标有两部分组成，里面的笔和外面的圆，两个图层被放在了一个组里面<br><img src="/uploads/2018/03/photoshop_11.JPG" alt=""></p><p>5.在icon文件上右键，选择“转换为智能对象”<br><img src="/uploads/2018/03/photoshop_12.JPG" alt=""></p><p>6.然后，我们会发现，两个图层合并为了一个图层，这个就是我们需要的图标<br><img src="/uploads/2018/03/photoshop_13.JPG" alt=""></p><p>7.在icon图层上右键，选择“编辑内容”，出现提示框的话直接点击“确定”即可<br><img src="/uploads/2018/03/photoshop_14.JPG" alt=""></p><p>8.然后，我们的图标就被单独提取出来了<br><img src="/uploads/2018/03/photoshop_15.JPG" alt=""></p><p>9.选择“文件”=》“存储为”，将我们的图标保存为PNG格式就大功告成了！ </p><h4 id="三、自动生成图标方法"><a href="#三、自动生成图标方法" class="headerlink" title="三、自动生成图标方法"></a>三、自动生成图标方法</h4><p>1.打开给大家准备的psd文件<br>2.选择“编辑”=》“首选项”=》“增效工具”<br><img src="/uploads/2018/03/photoshop_16.JPG" alt=""></p><p>3.勾选“启用生成器”，选择“确定”<br><img src="/uploads/2018/03/photoshop_17.JPG" alt=""></p><p>4.重启一下photoshop</p><p>5.重启后，重新打开我们的文件，感觉参考线太碍事了，我们用快捷键“CTRL”+“；”把参考线隐藏了。</p><p>6.选择“文件”=》“生成”=》“图像资源”<br><img src="/uploads/2018/03/photoshop_18.JPG" alt=""></p><p>7.用之前一样的方法找到我们要的图标的图层<br><img src="/uploads/2018/03/photoshop_19.JPG" alt=""></p><p>8.我们需要的图标放在了icon这个分组中，现在我们将icon重命名为icon.png<br><img src="/uploads/2018/03/photoshop_20.JPG" alt=""></p><p>9.现在我们打开我们存放psd文件的文件夹中，可以发现现在多了一个文件夹<br><img src="/uploads/2018/03/photoshop_21.JPG" alt=""></p><p>10.打开这个多出来的文件夹就会看到我们的图标躺在那里了，是不是很激动！！！<br>11.我们还可以继续把第二个图标重命名为icon.jpg<br>12.然后会发现刚才那个文件夹中又多了一个icon.jpg文件<br>13.当然还可以把图标改为icon.svg（注：有时候不可以，原因未查）<br>16.如果不想要要这个图标，我们可以把文件的命名重新改回来 </p><p>这个方法生成图标非常的方便，很适合我们生成svg图片，可以保存到fontello或者iconfont中，强烈建议！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、传统切图方法&quot;&gt;&lt;a href=&quot;#一、传统切图方法&quot; class=&quot;headerlink&quot; title=&quot;一、传统切图方法&quot;&gt;&lt;/a&gt;一、传统切图方法&lt;/h4&gt;&lt;p&gt;使用范围：需要切多张图，带背景的&lt;br&gt;1.打开下载的psd文件&lt;br&gt;出现下面没关系，直接点确定即可&lt;br&gt;&lt;img src=&quot;/uploads/2018/03/photoshop_001.JPG&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="切图篇" scheme="http://yoursite.com/tags/%E5%88%87%E5%9B%BE%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Flask - 相关知识点总结</title>
    <link href="http://yoursite.com/2018/03/06/Flask-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/06/Flask-相关知识点总结/</id>
    <published>2018-03-06T10:46:40.000Z</published>
    <updated>2018-03-06T10:48:01.046Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、Flask入口文件集成-shell"><a href="#1、Flask入口文件集成-shell" class="headerlink" title="1、Flask入口文件集成 shell"></a>1、Flask入口文件集成 shell</h4><p>每次启动shell 会话都要导入数据库实例和模型，这真是份枯燥的工作。为了避免一直重复导入，我们可以做些配置，让Flask-Script 的shell 命令自动导入特定的对象。</p><p>若想把对象添加到导入列表中，我们要为shell 命令注册一个make_context 回调函数，如示例5-7 所示。<br><a id="more"></a><br>示例5-7　hello.py：为shell 命令添加一个上下文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.script import Shell</span><br><span class="line">def make_shell_context():</span><br><span class="line">    return dict(app=app, db=db, User=User, Role=Role)</span><br><span class="line">manager.add_command(&quot;shell&quot;, Shell(make_context=make_shell_context))</span><br></pre></td></tr></table></figure></p><p>make_shell_context() 函数注册了程序、数据库实例以及模型，因此这些对象能直接导入shell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python hello.py shell</span><br><span class="line">&gt;&gt;&gt; app</span><br><span class="line">&lt;Flask &apos;app&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; db</span><br><span class="line">&lt;SQLAlchemy engine=&apos;sqlite:////home/flask/flasky/data.sqlite&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; User</span><br><span class="line">&lt;class &apos;app.User&apos;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2、Flash消息"><a href="#2、Flash消息" class="headerlink" title="2、Flash消息"></a>2、Flash消息</h4><p>请求完成后，有时需要让用户知道状态发生了变化。这里可以使用确认消息、警告或者错误提醒。一个典型例子是，用户提交了有一项错误的登录表单后，服务器发回的响应重新渲染了登录表单，并在表单上面显示一个消息，提示用户用户名或密码错误。</p><p>这种功能是Flask 的核心特性。如示例所示，flash() 函数可实现这种效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, render_template, session, redirect, url_for, flash</span><br><span class="line">@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line">def index():</span><br><span class="line">form = NameForm()</span><br><span class="line">if form.validate_on_submit():</span><br><span class="line">old_name = session.get(&apos;name&apos;)</span><br><span class="line">if old_name is not None and old_name != form.name.data:</span><br><span class="line">flash(&apos;Looks like you have changed your name!&apos;)</span><br><span class="line">session[&apos;name&apos;] = form.name.data</span><br><span class="line">return redirect(url_for(&apos;index&apos;))</span><br><span class="line">return render_template(&apos;index.html&apos;, form = form, name = session.get(&apos;name&apos;))</span><br></pre></td></tr></table></figure></p><p>在这个示例中，每次提交的名字都会和存储在用户会话中的名字进行比较，而会话中存储的名字是前一次在这个表单中提交的数据。如果两个名字不一样，就会调用flash() 函数，在发给客户端的下一个响应中显示一个消息。</p><p>仅调用flash() 函数并不能把消息显示出来，程序使用的模板要渲染这些消息。最好在基模板中渲染Flash 消息，因为这样所有页面都能使用这些消息。Flask 把get_flashed_messages() 函数开放给模板，用来获取并渲染消息，如示例所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&#123;% for message in get_flashed_messages() %&#125;</span><br><span class="line">&lt;div class=&quot;alert alert-warning&quot;&gt;</span><br><span class="line">&lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;</span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block page_content %&#125;&#123;% endblock %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>在模板中使用循环是因为在之前的请求循环中每次调用flash() 函数时都会生成一个消息，所以可能有多个消息在排队等待显示。get_flashed_messages() 函数获取的消息在下次调用时不会再次返回，因此Flash 消息只显示一次，然后就消失了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、Flask入口文件集成-shell&quot;&gt;&lt;a href=&quot;#1、Flask入口文件集成-shell&quot; class=&quot;headerlink&quot; title=&quot;1、Flask入口文件集成 shell&quot;&gt;&lt;/a&gt;1、Flask入口文件集成 shell&lt;/h4&gt;&lt;p&gt;每次启动shell 会话都要导入数据库实例和模型，这真是份枯燥的工作。为了避免一直重复导入，我们可以做些配置，让Flask-Script 的shell 命令自动导入特定的对象。&lt;/p&gt;
&lt;p&gt;若想把对象添加到导入列表中，我们要为shell 命令注册一个make_context 回调函数，如示例5-7 所示。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Flask - 认证扩展</title>
    <link href="http://yoursite.com/2018/03/06/Flask-%E8%AE%A4%E8%AF%81%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/03/06/Flask-认证扩展/</id>
    <published>2018-03-06T10:43:25.000Z</published>
    <updated>2018-03-06T10:44:11.349Z</updated>
    
    <content type="html"><![CDATA[<p>Flask-Login：管理已登录用户的用户会话。<br>Werkzeug：计算密码散列值并进行核对。<br>itsdangerous：生成并核对加密安全令牌。</p><h4 id="1、密码安全性-使用Werkzeug实现密码散列"><a href="#1、密码安全性-使用Werkzeug实现密码散列" class="headerlink" title="1、密码安全性 - 使用Werkzeug实现密码散列"></a>1、密码安全性 - 使用Werkzeug实现密码散列</h4><p>众所周知，大多数用户都在不同的网站中使用相同的密码，因此，即便不保存任何敏感信息，攻击者获得存储在数据库中的密码之后，也能访问用户在其他网站中的账户。<br><a id="more"></a><br>若想保证数据库中用户密码的安全，关键在于不能存储密码本身，而要存储密码的散列值。计算密码散列值的函数接收密码作为输入，使用一种或多种加密算法转换密码，最终得到一个和原始密码没有关系的字符序列。核对密码时，密码散列值可代替原始密码，因为计算散列值的函数是可复现的：只要输入一样，结果就一样。</p><p>Werkzeug 中的security 模块能够很方便地实现密码散列值的计算。这一功能的实现只需要两个函数，分别用在注册用户和验证用户阶段。</p><ul><li>generate_password_hash(password, method=pbkdf2:sha1, salt_length=8)：这个函数将原始密码作为输入，以字符串形式输出密码的散列值，输出的值可保存在用户数据库中。method 和salt_length 的默认值就能满足大多数需求。</li><li>check_password_hash(hash, password)：这个函数的参数是从数据库中取回的密码散列值和用户输入的密码。返回值为True 表明密码正确。</li></ul><p>示例8-1 展示了创建的User 模型为支持密码散列所做的改动。<br>示例8-1　app/models.py：在User 模型中加入密码散列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from werkzeug.security import generate_password_hash, check_password_hash</span><br><span class="line">class User(db.Model):</span><br><span class="line">    __tablename__ == &apos;users&apos;</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    username = db.Column(db.String(64), unique=True, index=True)</span><br><span class="line">    password_hash = db.Column(db.String(128))</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def password(self):</span><br><span class="line">        raise AttributeError(&apos;password is not a readable attribute&apos;)</span><br><span class="line"></span><br><span class="line">    @password.setter</span><br><span class="line">    def password(self, password):</span><br><span class="line">        self.password_hash = generate_password_hash(password)</span><br><span class="line">    </span><br><span class="line">    def verify_password(self, password):</span><br><span class="line">        return check_password_hash(self.password_hash, password)</span><br><span class="line">    </span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;User %r&gt;&apos; % self.username</span><br></pre></td></tr></table></figure></p><p>计算密码散列值的函数通过名为password 的只写属性实现。设定这个属性的值时，赋值方法会调用Werkzeug 提供的generate_password_hash() 函数，并把得到的结果赋值给password_hash 字段。如果试图读取password 属性的值，则会返回错误，原因很明显，因为生成散列值后就无法还原成原来的密码了。</p><p>verify_password 方法接受一个参数（ 即密码）， 将其传给Werkzeug 提供的check_password_hash() 函数，和存储在User 模型中的密码散列值进行比对。如果这个方法返回True，就表明密码是正确的。</p><h4 id="2、使用Flask-Login认证用户"><a href="#2、使用Flask-Login认证用户" class="headerlink" title="2、使用Flask-Login认证用户"></a>2、使用Flask-Login认证用户</h4><p>用户登录程序后，他们的认证状态要被记录下来，这样浏览不同的页面时才能记住这个状态。Flask-Login 是个非常有用的小型扩展，专门用来管理用户认证系统中的认证状态，且不依赖特定的认证机制。</p><h5 id="（1）准备用于登录的用户模型"><a href="#（1）准备用于登录的用户模型" class="headerlink" title="（1）准备用于登录的用户模型"></a>（1）准备用于登录的用户模型</h5><p>要想使用Flask-Login 扩展，程序的User 模型必须实现几个方法。需要实现的方法如表8-1所示。<br>表8-1　Flask-Login要求实现的用户方法</p><table><thead><tr><th>方　　法</th><th>说　　明</th></tr></thead><tbody><tr><td>is_authenticated()</td><td>如果用户已经登录，必须返回True，否则返回False</td></tr><tr><td>is_active()</td><td>如果允许用户登录，必须返回True，否则返回False。如果要禁用账户，可以返回False</td></tr><tr><td>is_anonymous()</td><td>对普通用户必须返回False</td></tr><tr><td>get_id()</td><td>必须返回用户的唯一标识符，使用Unicode 编码字符串</td></tr></tbody></table><p>这4 个方法可以在模型类中作为方法直接实现，不过还有一种更简单的替代方案。Flask-Login 提供了一个UserMixin 类，其中包含这些方法的默认实现，且能满足大多数需求。修改后的User 模型如示例8-6 所示。</p><p>示例8-6　app/models.py：修改User 模型，支持用户登录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.login import UserMixin</span><br><span class="line">class User(UserMixin, db.Model):</span><br><span class="line">    __tablename__ = &apos;users&apos;</span><br><span class="line">    id = db.Column(db.Integer, primary_key = True)</span><br><span class="line">    email = db.Column(db.String(64), unique=True, index=True)</span><br><span class="line">    username = db.Column(db.String(64), unique=True, index=True)</span><br><span class="line">    password_hash = db.Column(db.String(128))</span><br></pre></td></tr></table></figure></p><p>注意，示例中同时还添加了email 字段。在这个程序中，用户使用电子邮件地址登录，因为相对于用户名而言，用户更不容易忘记自己的电子邮件地址。</p><p>Flask-Login 在程序的工厂函数中初始化，如示例8-7 所示。<br>示例8-7　app/<strong>init</strong>.py：初始化Flask-Login<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.login import LoginManager</span><br><span class="line"></span><br><span class="line">login_manager = LoginManager()</span><br><span class="line">login_manager.session_protection = &apos;strong&apos;</span><br><span class="line">login_manager.login_view = &apos;auth.login&apos;</span><br><span class="line"></span><br><span class="line">def create_app(config_name):</span><br><span class="line">    # ...</span><br><span class="line">    login_manager.init_app(app)</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure></p><p>LoginManager 对象的session_protection 属性可以设为None、’basic’ 或’strong’，以提供不同的安全等级防止用户会话遭篡改。设为’strong’ 时，Flask-Login 会记录客户端IP地址和浏览器的用户代理信息，如果发现异动就登出用户。login_view 属性设置登录页面的端点。如果登录路由在蓝本中定义，因此要在前面加上蓝本的名字。</p><p>最后，Flask-Login 要求程序实现一个回调函数，使用指定的标识符加载用户。这个函数的定义如示例8-8 所示。</p><p>示例8-8　app/models.py：加载用户的回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from . import login_manager</span><br><span class="line"></span><br><span class="line">@login_manager.user_loader</span><br><span class="line">def load_user(user_id):</span><br><span class="line">    return User.query.get(int(user_id))</span><br></pre></td></tr></table></figure></p><p>加载用户的回调函数接收以Unicode 字符串形式表示的用户标识符。如果能找到用户，这个函数必须返回用户对象；否则应该返回None。</p><h5 id="（2）保护路由"><a href="#（2）保护路由" class="headerlink" title="（2）保护路由"></a>（2）保护路由</h5><p>为了保护路由只让认证用户访问，Flask-Login 提供了一个login_required 修饰器。用法演示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.login import login_required</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/secret&apos;)</span><br><span class="line">@login_required</span><br><span class="line">def secret():</span><br><span class="line">    return &apos;Only authenticated users are allowed!&apos;</span><br></pre></td></tr></table></figure></p><p>如果未认证的用户访问这个路由，Flask-Login 会拦截请求，把用户发往登录页面。</p><h4 id="3、使用itsdangerous生成确认令牌"><a href="#3、使用itsdangerous生成确认令牌" class="headerlink" title="3、使用itsdangerous生成确认令牌"></a>3、使用itsdangerous生成确认令牌</h4><p>为验证电子邮件地址，用户注册后，程序会立即发送一封确认邮件。新账户先被标记成待确认状态，用户按照邮件中的说明操作后，才能证明自己可以被联系上。账户确认过程中，往往会要求用户点击一个包含确认令牌的特殊URL 链接。</p><p>确认邮件中最简单的确认链接是<a href="http://www.example.com/auth/confirm/" target="_blank" rel="noopener">http://www.example.com/auth/confirm/</a><id> 这种形式的URL，其中id 是数据库分配给用户的数字id。用户点击链接后，处理这个路由的视图函数就将收到的用户id 作为参数进行确认，然后将用户状态更新为已确认。</id></p><p>但这种实现方式显然不是很安全，只要用户能判断确认链接的格式，就可以随便指定URL中的数字，从而确认任意账户。解决方法是把URL 中的id 换成将相同信息安全加密后得到的令牌。</p><p>下面这个简短的shell 会话显示了如何使用itsdangerous 包生成包含用户id 的安全令牌：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python manage.py shell</span><br><span class="line">&gt;&gt;&gt; from manage import app</span><br><span class="line">&gt;&gt;&gt; from itsdangerous import TimedJSONWebSignatureSerializer as Serializer</span><br><span class="line">&gt;&gt;&gt; s = Serializer(app.config[&apos;SECRET_KEY&apos;], expires_in = 3600)</span><br><span class="line">&gt;&gt;&gt; token = s.dumps(&#123; &apos;confirm&apos;: 23 &#125;)</span><br><span class="line">&gt;&gt;&gt; token</span><br><span class="line">&apos;eyJhbGciOiJIUzI1NiIsImV4cCI6MTM4MTcxODU1OCwiaWF0IjoxMzgxNzE0OTU4fQ.ey ...&apos;</span><br><span class="line">&gt;&gt;&gt; data = s.loads(token)</span><br><span class="line">&gt;&gt;&gt; data</span><br><span class="line">&#123;u&apos;confirm&apos;: 23&#125;</span><br></pre></td></tr></table></figure></p><p>itsdangerous 提供了多种生成令牌的方法。其中，TimedJSONWebSignatureSerializer 类生成具有过期时间的JSON Web 签名（JSON Web Signatures，JWS）。这个类的构造函数接收的参数是一个密钥，在Flask 程序中可使用SECRET_KEY 设置。</p><p>dumps() 方法为指定的数据生成一个加密签名，然后再对数据和签名进行序列化，生成令牌字符串。expires_in 参数设置令牌的过期时间，单位为秒。</p><p>为了解码令牌，序列化对象提供了loads() 方法，其唯一的参数是令牌字符串。这个方法会检验签名和过期时间，如果通过，返回原始数据。如果提供给loads() 方法的令牌不正确或过期了，则抛出异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask-Login：管理已登录用户的用户会话。&lt;br&gt;Werkzeug：计算密码散列值并进行核对。&lt;br&gt;itsdangerous：生成并核对加密安全令牌。&lt;/p&gt;
&lt;h4 id=&quot;1、密码安全性-使用Werkzeug实现密码散列&quot;&gt;&lt;a href=&quot;#1、密码安全性-使用Werkzeug实现密码散列&quot; class=&quot;headerlink&quot; title=&quot;1、密码安全性 - 使用Werkzeug实现密码散列&quot;&gt;&lt;/a&gt;1、密码安全性 - 使用Werkzeug实现密码散列&lt;/h4&gt;&lt;p&gt;众所周知，大多数用户都在不同的网站中使用相同的密码，因此，即便不保存任何敏感信息，攻击者获得存储在数据库中的密码之后，也能访问用户在其他网站中的账户。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>物联网入门必备</title>
    <link href="http://yoursite.com/2018/03/06/%E7%89%A9%E8%81%94%E7%BD%91%E5%85%A5%E9%97%A8%E5%BF%85%E5%A4%87/"/>
    <id>http://yoursite.com/2018/03/06/物联网入门必备/</id>
    <published>2018-03-06T03:20:52.000Z</published>
    <updated>2018-03-06T10:49:55.139Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是物联网？"><a href="#什么是物联网？" class="headerlink" title="什么是物联网？"></a>什么是物联网？</h4><p>物联网是新一代信息技术的重要组成部分，也是“信息化”时代的重要发展阶段。其英文名称是：“Internet of things（IoT）”。顾名思义，物联网就是物物相连的互联网。这有两层意思：其一，物联网的核心和基础仍然是互联网，是在互联网基础上的延伸和扩展的网络；其二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信，也就是物物相息。物联网通过智能感知、识别技术与普适计算等通信感知技术，广泛应用于网络的融合中，也因此被称为继计算机、互联网之后世界信息产业发展的第三次浪潮。物联网是互联网的应用拓展，与其说物联网是网络，不如说物联网是业务和应用。因此，应用创新是物联网发展的核心，以用户体验为核心的创新2.0是物联网发展的灵魂。<br><a id="more"></a></p><h4 id="什么是认知物联网？"><a href="#什么是认知物联网？" class="headerlink" title="什么是认知物联网？"></a>什么是认知物联网？</h4><p>简单地说，认知物联网是将认知计算技术与互连设备产生的数据和这些设备可以执行的操作结合使用。您可能已经知道物联网，也知道我们所说的传感器和执行器的意思。从认知计算方面讲，物联网又是什么意思呢？当然，认知意味着思考，而计算机不具备普通人类的思考能力，它们现在可以执行一些人类认为是思考 的基本功能。认知涉及三个关键要素：</p><ul><li>理解</li><li>推理</li><li>学习</li></ul><p>在计算机中，系统理解意味着，能够读入大量的结构化和非结构化数据，并从中获取其意义，也就是说，建立一个概念、实体和关系的模型。推理 意味着，使用这个模型能够得出答案或解决相关问题，无需专门对答案和解决方案进行编程。而学习 意味着，能够自动地从数据推断出新的知识，这是大规模理解的一个关键组成部分。<br><img src="/uploads/2018/03/cognitive-iot-blog.jpg" alt=""></p><p>构建大规模的概念和关系的复杂模型过于费时，且成本高昂。此外，有许多关系是事先不知道或不明确的，所以只能让机器自动分析大数据集来发现模式，然后才能真正发现这些关系。</p><h4 id="会思考的物体"><a href="#会思考的物体" class="headerlink" title="会思考的物体"></a>会思考的物体</h4><p>认知计算对于物联网非常重要，这有几个关键原因。</p><ul><li><p><strong>生成数据的速率和规模：</strong>学习有助于优化流程或系统，在结合有关系统的传感器数据与其他上下文信息的基础上，使其更加高效。从设备生成的数据快速超越了人类通过分析去发现重要模式和学习的能力。应用机器学习对于能够扩展物联网是必不可少的。</p></li><li><p><strong>计算转移到物理世界：</strong>随着越来越多各种年龄和技术技能水平的人在与物联网系统进行交互，我们需要超越当前的机器接口范式，这种范式要求人类学会与机器交互所需的抽象和专用接口。此外，这种转移需要走向更加以人类为中心的接口。换句话说，人们需要能够用自然语言与物联网系统（物体）进行交互。该系统必须开始理解人类。来自麻省理工媒体实验室 (MIT Media Lab) 的作者 David Rose 提出了术语 “魔法对象 (enchanted objects) ” 来描述看似智能的行为，我们可以通过物联网和认知计算将这些行为注入连接的设备。</p></li><li><p><strong>多种数据源和数据类型的集成：</strong>在物联网中，存在许多数据源，可以提供相关的信息或上下文，有助于更好地理解和制定决策。数据有多种不同的类型，包括数字传感器数据、音频、视频、非结构化的文本数据、位置数据等，消化和分析这些数据类型并通过这些数据类型识别相关性和模式的能力，是一项非常强大的功能。通过掌握上下文可以大大提高对人类操作者的意图的理解，这包括物理环境、时间维度，甚至是情绪状况。通过集成多个不同的数据源可以完善推理和决策，例如，关联传感器数据与声学数据。</p></li></ul><h4 id="人类感知设备"><a href="#人类感知设备" class="headerlink" title="人类感知设备"></a>人类感知设备</h4><p><strong>认知物联网</strong> 是下一次飞跃，它通过学习并将更多的人类意识注入到与我们交互的设备和环境中，提高传感器驱动的复杂系统的准确性和效率。这一飞跃可以让我们的物体 用我们的语言（而不是其他方式）来理解我们，并与我们进行交互。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是物联网？&quot;&gt;&lt;a href=&quot;#什么是物联网？&quot; class=&quot;headerlink&quot; title=&quot;什么是物联网？&quot;&gt;&lt;/a&gt;什么是物联网？&lt;/h4&gt;&lt;p&gt;物联网是新一代信息技术的重要组成部分，也是“信息化”时代的重要发展阶段。其英文名称是：“Internet of things（IoT）”。顾名思义，物联网就是物物相连的互联网。这有两层意思：其一，物联网的核心和基础仍然是互联网，是在互联网基础上的延伸和扩展的网络；其二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信，也就是物物相息。物联网通过智能感知、识别技术与普适计算等通信感知技术，广泛应用于网络的融合中，也因此被称为继计算机、互联网之后世界信息产业发展的第三次浪潮。物联网是互联网的应用拓展，与其说物联网是网络，不如说物联网是业务和应用。因此，应用创新是物联网发展的核心，以用户体验为核心的创新2.0是物联网发展的灵魂。&lt;br&gt;
    
    </summary>
    
      <category term="物联网" scheme="http://yoursite.com/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="科技前沿" scheme="http://yoursite.com/tags/%E7%A7%91%E6%8A%80%E5%89%8D%E6%B2%BF/"/>
    
      <category term="物联网" scheme="http://yoursite.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>区块链入门必备</title>
    <link href="http://yoursite.com/2018/03/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E5%BF%85%E5%A4%87/"/>
    <id>http://yoursite.com/2018/03/06/区块链入门必备/</id>
    <published>2018-03-06T02:44:47.000Z</published>
    <updated>2018-03-06T03:21:45.859Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、区块链是什么？"><a href="#1、区块链是什么？" class="headerlink" title="1、区块链是什么？"></a>1、区块链是什么？</h4><p>区块链是一种防篡改的、共享的数字化账本，用于记录公有或私有对等网络中的交易。账本分发给网络中的所有成员节点，在通过哈希密码算法链接的区块的顺序链中，永久记录网络中的对等节点之间发生的资产交易的历史记录。</p><p>所有经过确认和证明的交易都从链的开头一直链接到最新的区块，因此得名区块链。区块链可以充当单一事实来源，而且区块链网络中的成员只能查看与他们相关的交易。<br><a id="more"></a></p><h4 id="2、区块链网络的工作原理"><a href="#2、区块链网络的工作原理" class="headerlink" title="2、区块链网络的工作原理"></a>2、区块链网络的工作原理</h4><p>区块链网络中的成员节点不依赖于第三方（比如金融机构）来仲裁交易，它们使用共识协议来协商账本内容，使用哈希加密算法和数字签名来确保交易的完整性。</p><p>共识性能确保共享账本是精确副本，并降低了发生交易欺诈的风险，因为篡改需要在许多地方同时执行。哈希加密算法（比如 SHA256 计算算法）能确保对交易输入的任何改动 — 甚至是最细微的改动 — 都会计算出一个不同的哈希值，表明交易输入可能被损坏。数字签名确保交易源自发送方（已使用私钥签名）而不是冒名顶替者。</p><p>去中心化对等区块链网络可阻止任何单个或一组参与者控制底层基础架构或破坏整个系统。网络中的参与者是平等的，都遵守相同的协议。它们可以是个人、国家代表、企业或所有这三种参与者的组合。</p><p>在其核心，该系统会记录交易的时间顺序，而且所有节点都使用选定的共识模型来协商交易的有效性。这会使交易不可逆并被网络中的所有成员接受。</p><h4 id="3、区块链技术的商业优势"><a href="#3、区块链技术的商业优势" class="headerlink" title="3、区块链技术的商业优势"></a>3、区块链技术的商业优势</h4><p>在传统业务网络中，所有参与者都维护着自己的账本，这些账本之间的重复和差异会导致争议、更长的结算时间，而且因为需要中介，还会导致相关的间接管理成本。但是，通过使用基于区块链的共享账本，交易在通过共识性验证并写入账本后，就不能再更改，这样企业就能节省时间和成本，同时减少风险。</p><p>区块链共识机制提供了经过整合的、一致的数据集的优势，减少了错误，拥有近实时的引用数据，而且参与者能够灵活更改其拥有的资产的描述。</p><p>因为没有参与成员拥有共享账本中所含信息的来源，所以区块链技术会提高参与成员之间的交易信息流中的可信度和完整性。</p><p>区块链技术的不变性机制降低了审计和合规性成本，增加了透明性。而且在使用区块链技术的业务网络上，合约得以智能、自动化执行并最终确认，所以企业会获得更高的执行速度、更低的成本和更少的风险，所有这些使企业能构建新收入流来与客户交互。</p><h4 id="4、如何才算是好的区块链用例？"><a href="#4、如何才算是好的区块链用例？" class="headerlink" title="4、如何才算是好的区块链用例？"></a>4、如何才算是好的区块链用例？</h4><p>要确定您的用例是否适合使用区块链，请询问自己以下问题：</p><ol><li>是否涉及业务网络？</li><li>是否使用共识性来验证交易？</li><li>是否需要审计线索或来源？</li><li>交易记录是否必须不可变或防篡改？</li><li>争议的解决方法是否会是最终解决方法？<br>如果第一个问题和其他问题中的至少一个问题的答案为“是”，那么您的用例就会从区块链技术受益。要成为合适的解决方案，区块链必须涉及一个网络，但该网络可以具有多种形式。该网络可位于企业之间，比如供应链，或者该网络可以在一个企业内。例如：在企业内，可以使用区块链网络在部门之间共享参考数据，或者创建审计或合规性网络。该网络也可存在于个人之间，比如需要在区块链上存储数据、数字资产或合约的人。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、区块链是什么？&quot;&gt;&lt;a href=&quot;#1、区块链是什么？&quot; class=&quot;headerlink&quot; title=&quot;1、区块链是什么？&quot;&gt;&lt;/a&gt;1、区块链是什么？&lt;/h4&gt;&lt;p&gt;区块链是一种防篡改的、共享的数字化账本，用于记录公有或私有对等网络中的交易。账本分发给网络中的所有成员节点，在通过哈希密码算法链接的区块的顺序链中，永久记录网络中的对等节点之间发生的资产交易的历史记录。&lt;/p&gt;
&lt;p&gt;所有经过确认和证明的交易都从链的开头一直链接到最新的区块，因此得名区块链。区块链可以充当单一事实来源，而且区块链网络中的成员只能查看与他们相关的交易。&lt;br&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="科技前沿" scheme="http://yoursite.com/tags/%E7%A7%91%E6%8A%80%E5%89%8D%E6%B2%BF/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 大型程序的结构</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-大型程序的结构/</id>
    <published>2018-03-05T10:04:46.000Z</published>
    <updated>2018-03-06T02:20:59.991Z</updated>
    
    <content type="html"><![CDATA[<p>尽管在单一脚本中编写小型Web 程序很方便，但这种方法并不能广泛使用。程序变复杂后，使用单个大型源码文件会导致很多问题。</p><p>不同于大多数其他的Web 框架，Flask 并不强制要求大型项目使用特定的组织方式，程序结构的组织方式完全由开发者决定。在本章，我们将介绍一种使用包和模块组织大型程序的方式。本书后续示例都将采用这种结构。</p><h4 id="1、项目结构"><a href="#1、项目结构" class="headerlink" title="1、项目结构"></a>1、项目结构</h4><p>Flask 程序的基本结构如示例7-1 所示。<br><a id="more"></a><br><strong>示例7-1　多文件Flask 程序的基本结构</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">|-flasky</span><br><span class="line">　　|-app/</span><br><span class="line">　　　　|-templates/</span><br><span class="line">　　　　|-static/</span><br><span class="line">　　　　|-main/</span><br><span class="line">　　　　　　|-__init__.py</span><br><span class="line">　　　　　　|-errors.py</span><br><span class="line">　　　　　　|-forms.py</span><br><span class="line">　　　　　　|-views.py</span><br><span class="line">　　　　|-__init__.py</span><br><span class="line">　　　　|-email.py</span><br><span class="line">　　　　|-models.py</span><br><span class="line">　　|-migrations/</span><br><span class="line">　　|-tests/</span><br><span class="line">　　　　|-__init__.py</span><br><span class="line">　　　　|-test*.py</span><br><span class="line">　　|-venv/</span><br><span class="line">　　|-requirements.txt</span><br><span class="line">　　|-config.py</span><br><span class="line">　　|-manage.py</span><br></pre></td></tr></table></figure></p><p>这种结构有4 个顶级文件夹：</p><ul><li>Flask程序一般都保存在名为app 的包中；</li><li>和之前一样，migrations文件夹包含数据库迁移脚本；</li><li>单元测试编写在 tests包中；</li><li>和之前一样，venv 文件夹包含 Python 虚拟环境。</li></ul><p>同时还创建了一些新文件：</p><ul><li>requirements.txt列出了所有依赖包，便于在其他电脑中重新生成相同的虚拟环境；</li><li>config.py 存储配置；</li><li>manage.py用于启动程序以及其他的程序任务。</li></ul><p>为了帮助你完全理解这个结构，下面几节讲解把hello.py 程序转换成这种结构的过程。</p><h4 id="2、配置选项"><a href="#2、配置选项" class="headerlink" title="2、配置选项"></a>2、配置选项</h4><p>程序经常需要设定多个配置。这方面最好的例子就是开发、测试和生产环境要使用不同的数据库，这样才不会彼此影响。</p><p>我们不再使用hello.py 中简单的字典状结构配置，而使用层次结构的配置类。config.py 文件的内容如示例7-2 所示。</p><p>示例7-2　config.py：程序的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">basedir = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line"></span><br><span class="line">class Config:</span><br><span class="line">    SECRET_KEY = os.environ.get(&apos;SECRET_KEY&apos;) or &apos;hard to guess string&apos;</span><br><span class="line">    SQLALCHEMY_COMMIT_ON_TEARDOWN = True</span><br><span class="line">    FLASKY_MAIL_SUBJECT_PREFIX = &apos;[Flasky]&apos;</span><br><span class="line">    FLASKY_MAIL_SENDER = &apos;Flasky Admin &lt;flasky@example.com&gt;&apos;</span><br><span class="line">    FLASKY_ADMIN = os.environ.get(&apos;FLASKY_ADMIN&apos;)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def init_app(app):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class DevelopmentConfig(Config):</span><br><span class="line">    DEBUG = True</span><br><span class="line">    MAIL_SERVER = &apos;smtp.googlemail.com&apos;</span><br><span class="line">    MAIL_PORT = 587</span><br><span class="line">    MAIL_USE_TLS = True</span><br><span class="line">    MAIL_USERNAME = os.environ.get(&apos;MAIL_USERNAME&apos;)</span><br><span class="line">    MAIL_PASSWORD = os.environ.get(&apos;MAIL_PASSWORD&apos;)</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;DEV_DATABASE_URL&apos;) or \</span><br><span class="line">        &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data-dev.sqlite&apos;)</span><br><span class="line"></span><br><span class="line">class TestingConfig(Config):</span><br><span class="line">    TESTING = True</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;TEST_DATABASE_URL&apos;) or \</span><br><span class="line">        &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data-test.sqlite&apos;)</span><br><span class="line"></span><br><span class="line">class ProductionConfig(Config):</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;DATABASE_URL&apos;) or \</span><br><span class="line">        &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;)</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    &apos;development&apos;: DevelopmentConfig,</span><br><span class="line">    &apos;testing&apos;: TestingConfig,</span><br><span class="line">    &apos;production&apos;: ProductionConfig,</span><br><span class="line">    &apos;default&apos;: DevelopmentConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基类Config 中包含通用配置，子类分别定义专用的配置。如果需要，你还可添加其他配置类。</p><p>为了让配置方式更灵活且更安全，某些配置可以从环境变量中导入。例如，SECRET_KEY 的值，这是个敏感信息，可以在环境中设定，但系统也提供了一个默认值，以防环境中没有定义。</p><p>在3 个子类中，SQLALCHEMY_DATABASE_URI 变量都被指定了不同的值。这样程序就可在不同的配置环境中运行，每个环境都使用不同的数据库。</p><p>配置类可以定义init_app() 类方法，其参数是程序实例。在这个方法中，可以执行对当前环境的配置初始化。现在，基类Config 中的init_app() 方法为空。</p><p>在这个配置脚本末尾，config 字典中注册了不同的配置环境，而且还注册了一个默认配置。</p><h4 id="3、程序包"><a href="#3、程序包" class="headerlink" title="3、程序包"></a>3、程序包</h4><p>程序包用来保存程序的所有代码、模板和静态文件。我们可以把这个包直接称为app（应用），如果有需求，也可使用一个程序专用名字。templates 和static 文件夹是程序包的一部分，因此这两个文件夹被移到了app 中。数据库模型和电子邮件支持函数也被移到了这个包中，分别保存为app/models.py 和app/email.py。</p><h5 id="（1）使用程序工厂函数"><a href="#（1）使用程序工厂函数" class="headerlink" title="（1）使用程序工厂函数"></a>（1）使用程序工厂函数</h5><p>在单个文件中开发程序很方便，但却有个很大的缺点，因为程序在全局作用域中创建，所以无法动态修改配置。运行脚本时，程序实例已经创建，再修改配置为时已晚。这一点对单元测试尤其重要，因为有时为了提高测试覆盖度，必须在不同的配置环境中运行程序。这个问题的解决方法是延迟创建程序实例，把创建过程移到可显式调用的工厂函数中。这种方法不仅可以给脚本留出配置程序的时间，还能够创建多个程序实例，这些实例有时在测试中非常有用。程序的工厂函数在app 包的构造文件中定义，如示例7-3 所示。</p><p>构造文件导入了大多数正在使用的Flask 扩展。由于尚未初始化所需的程序实例，所以没有初始化扩展，创建扩展类时没有向构造函数传入参数。create_app() 函数就是程序的工厂函数，接受一个参数，是程序使用的配置名。配置类在config.py 文件中定义，其中保存的配置可以使用Flask app.config 配置对象提供的from_object() 方法直接导入程序。至于配置对象，则可以通过名字从config 字典中选择。程序创建并配置好后，就能初始化扩展了。在之前创建的扩展对象上调用init_app() 可以完成初始化过程。</p><p>示例7-3　app/__init__.py：程序包的构造文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, render_template</span><br><span class="line">from flask.ext.bootstrap import Bootstrap</span><br><span class="line">from flask.ext.mail import Mail</span><br><span class="line">from flask.ext.moment import Moment</span><br><span class="line">from flask.ext.sqlalchemy import SQLAlchemy</span><br><span class="line">from config import config</span><br><span class="line"></span><br><span class="line">bootstrap = Bootstrap()</span><br><span class="line">mail = Mail()</span><br><span class="line">moment = Moment()</span><br><span class="line">db = SQLAlchemy()</span><br><span class="line"></span><br><span class="line">def create_app(config_name):</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(config[config_name])</span><br><span class="line">    config[config_name].init_app(app)</span><br><span class="line"></span><br><span class="line">    bootstrap.init_app(app)</span><br><span class="line">    mail.init_app(app)</span><br><span class="line">    moment.init_app(app)</span><br><span class="line">    db.init_app(app)</span><br><span class="line"></span><br><span class="line">    # 附加路由和自定义的错误页面</span><br><span class="line"></span><br><span class="line">    return app</span><br></pre></td></tr></table></figure></p><p>工厂函数返回创建的程序示例，不过要注意，现在工厂函数创建的程序还不完整，因为没<br>有路由和自定义的错误页面处理程序。</p><h5 id="（2）在蓝本中实现程序功能"><a href="#（2）在蓝本中实现程序功能" class="headerlink" title="（2）在蓝本中实现程序功能"></a>（2）在蓝本中实现程序功能</h5><p>转换成程序工厂函数的操作让定义路由变复杂了。在单脚本程序中，程序实例存在于全局作用域中，路由可以直接使用app.route 修饰器定义。但现在程序在运行时创建，只有调用create_app() 之后才能使用app.route 修饰器，这时定义路由就太晚了。和路由一样，自定义的错误页面处理程序也面临相同的困难，因为错误页面处理程序使用app.errorhandler 修饰器定义。</p><p>幸好Flask 使用蓝本提供了更好的解决方法。蓝本和程序类似，也可以定义路由。不同的是，在蓝本中定义的路由处于休眠状态，直到蓝本注册到程序上后，路由才真正成为程序的一部分。使用位于全局作用域中的蓝本时，定义路由的方法几乎和单脚本程序一样。</p><p>和程序一样，蓝本可以在单个文件中定义，也可使用更结构化的方式在包中的多个模块中创建。为了获得最大的灵活性，程序包中创建了一个子包，用于保存蓝本。示例7-4 是这个子包的构造文件，蓝本就创建于此。</p><p>示例7-4　app/main/__init__.py：创建蓝本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from flask import Blueprint</span><br><span class="line">main = Blueprint(&apos;main&apos;, __name__)</span><br><span class="line">from . import views, errors</span><br></pre></td></tr></table></figure></p><p>通过实例化一个Blueprint 类对象可以创建蓝本。这个构造函数有两个必须指定的参数：蓝本的名字和蓝本所在的包或模块。和程序一样，大多数情况下第二个参数使用Python 的__name__ 变量即可。</p><p>程序的路由保存在包里的app/main/views.py 模块中，而错误处理程序保存在app/main/errors.py 模块中。导入这两个模块就能把路由和错误处理程序与蓝本关联起来。注意，这些模块在app/main/__init__.py 脚本的末尾导入，这是为了避免循环导入依赖，因为在views.py 和errors.py 中还要导入蓝本main。</p><p>蓝本在工厂函数create_app() 中注册到程序上，如示例7-5 所示。<br>示例7-5　app/__init__.py：注册蓝本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def create_app(config_name):</span><br><span class="line">    # ...</span><br><span class="line">    from .main import main as main_blueprint</span><br><span class="line">    app.register_blueprint(main_blueprint)</span><br><span class="line">    </span><br><span class="line">    return app</span><br></pre></td></tr></table></figure></p><p>示例7-6 显示了错误处理程序。<br>示例7-6　app/main/errors.py：蓝本中的错误处理程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from flask import render_template</span><br><span class="line">from . import main</span><br><span class="line"></span><br><span class="line">@main.app_errorhandler(404)</span><br><span class="line">def page_not_found(e):</span><br><span class="line">    return render_template(&apos;404.html&apos;), 404</span><br><span class="line"></span><br><span class="line">@main.app_errorhandler(500)</span><br><span class="line">def internal_server_error(e):</span><br><span class="line">    return render_template(&apos;500.html&apos;), 500</span><br></pre></td></tr></table></figure></p><p>在蓝本中编写错误处理程序稍有不同，如果使用errorhandler 修饰器，那么只有蓝本中的错误才能触发处理程序。要想注册程序全局的错误处理程序，必须使用app_errorhandler。</p><p>在蓝本中定义的程序路由如示例7-7 所示。<br>示例7-7　app/main/views.py：蓝本中定义的程序路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">from flask import render_template, session, redirect, url_for</span><br><span class="line">from . import main</span><br><span class="line">from .forms import NameForm</span><br><span class="line">from .. import db</span><br><span class="line">from ..models import User</span><br><span class="line"></span><br><span class="line">@main.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line">def index():</span><br><span class="line">    form = NameForm()</span><br><span class="line">    if form.validate_on_submit():</span><br><span class="line">        # ...</span><br><span class="line">        return redirect(url_for(&apos;.index&apos;))</span><br><span class="line">    return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;),</span><br><span class="line">        known=session.get(&apos;known&apos;, False), current_time=datetime.utcnow())</span><br></pre></td></tr></table></figure></p><p>在蓝本中编写视图函数主要有两点不同：第一，和前面的错误处理程序一样，路由修饰器由蓝本提供；第二，url_for() 函数的用法不同。你可能还记得，url_for() 函数的第一个参数是路由的端点名，在程序的路由中，默认为视图函数的名字。例如，在单脚本程序中，index() 视图函数的URL 可使用url_for(‘index’) 获取。</p><p>在蓝本中就不一样了，Flask 会为蓝本中的全部端点加上一个命名空间，这样就可以在不同的蓝本中使用相同的端点名定义视图函数，而不会产生冲突。命名空间就是蓝本的名字（Blueprint 构造函数的第一个参数），所以视图函数index() 注册的端点名是main.index，其URL 使用url_for(‘main.index’) 获取。</p><p>url_for() 函数还支持一种简写的端点形式，在蓝本中可以省略蓝本名，例如url_for(‘.index’)。在这种写法中，命名空间是当前请求所在的蓝本。这意味着同一蓝本中的重定向可以使用简写形式，但跨蓝本的重定向必须使用带有命名空间的端点名。</p><p>为了完全修改程序的页面，表单对象也要移到蓝本中，保存于app/main/forms.py 模块。</p><h4 id="4、启动脚本"><a href="#4、启动脚本" class="headerlink" title="4、启动脚本"></a>4、启动脚本</h4><p>顶级文件夹中的manage.py 文件用于启动程序。脚本内容如示例7-8 所示。<br>示例7-8　manage.py：启动脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import os</span><br><span class="line">from app import create_app, db</span><br><span class="line">from app.models import User, Role</span><br><span class="line">from flask.ext.script import Manager, Shell</span><br><span class="line">from flask.ext.migrate import Migrate, MigrateCommand</span><br><span class="line"></span><br><span class="line">app = create_app(os.getenv(&apos;FLASK_CONFIG&apos;) or &apos;default&apos;)</span><br><span class="line"></span><br><span class="line">manager = Manager(app)</span><br><span class="line">migrate = Migrate(app, db)</span><br><span class="line"></span><br><span class="line">def make_shell_context():</span><br><span class="line">    return dict(app=app, db=db, User=User, Role=Role)</span><br><span class="line">manager.add_command(&quot;shell&quot;, Shell(make_context=make_shell_context))</span><br><span class="line"></span><br><span class="line">manager.add_command(&apos;db&apos;, MigrateCommand)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure></p><p>这个脚本先创建程序。如果已经定义了环境变量FLASK_CONFIG，则从中读取配置名；否则使用默认配置。然后初始化Flask-Script、Flask-Migrate 和为Python shell 定义的上下文。出于便利，脚本中加入了shebang 声明，所以在基于Unix 的操作系统中可以通过./manage.py 执行脚本，而不用使用复杂的python manage.py。</p><h4 id="5、需求文件"><a href="#5、需求文件" class="headerlink" title="5、需求文件"></a>5、需求文件</h4><p>程序中必须包含一个requirements.txt 文件，用于记录所有依赖包及其精确的版本号。如果要在另一台电脑上重新生成虚拟环境，这个文件的重要性就体现出来了，例如部署程序时使用的电脑。pip 可以使用如下命令自动生成这个文件：<br>　　<code>(venv) $ pip freeze &gt;requirements.txt</code></p><p>安装或升级包后，最好更新这个文件。需求文件的内容示例如下：</p><blockquote><p>Flask==0.10.1<br>Flask-Bootstrap==3.0.3.1<br>Flask-Mail==0.9.0<br>Flask-Migrate==1.1.0<br>Flask-Moment==0.2.0<br>Flask-SQLAlchemy==1.0<br>Flask-Script==0.6.6<br>Flask-WTF==0.9.4<br>Jinja2==2.7.1<br>Mako==0.9.1<br>MarkupSafe==0.18<br>SQLAlchemy==0.8.4<br>WTForms==1.0.5<br>Werkzeug==0.9.4<br>alembic==0.6.2<br>blinker==1.3<br>itsdangerous==0.23</p></blockquote><p>如果你要创建这个虚拟环境的完全副本，可以创建一个新的虚拟环境，并在其上运行以下命令：<br>　　<code>(venv) $ pip install -r requirements.txt</code></p><p>当你阅读本书时，该示例requirements.txt 文件中的版本号可能已经过期了。如果愿意，你可以试着使用这些包的最新版。如果遇到问题，你可以随时换回这个需求文件中的版本，因为这些版本和程序兼容。</p><h4 id="6、单元测试"><a href="#6、单元测试" class="headerlink" title="6、单元测试"></a>6、单元测试</h4><p>这个程序很小，所以没什么可测试的。不过为了演示，我们可以编写两个简单的测试，如示例7-9 所示。</p><p>示例7-9　tests/test_basics.py：单元测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line">from flask import current_app</span><br><span class="line">from app import create_app, db</span><br><span class="line"></span><br><span class="line">class BasicsTestCase(unittest.TestCase):</span><br><span class="line">    def setUp(self):</span><br><span class="line">        self.app = create_app(&apos;testing&apos;)</span><br><span class="line">        self.app_context = self.app.app_context()</span><br><span class="line">        self.app_context.push()</span><br><span class="line">        db.create_all()</span><br><span class="line">    </span><br><span class="line">    def tearDown(self):</span><br><span class="line">        db.session.remove()</span><br><span class="line">        db.drop_all()</span><br><span class="line">        self.app_context.pop()</span><br><span class="line"></span><br><span class="line">    def test_app_exists(self):</span><br><span class="line">        self.assertFalse(current_app is None)</span><br><span class="line">        def test_app_is_testing(self):</span><br><span class="line">        self.assertTrue(current_app.config[&apos;TESTING&apos;])</span><br></pre></td></tr></table></figure></p><p>这个测试使用Python 标准库中的unittest 包编写。setUp() 和tearDown() 方法分别在各测试前后运行，并且名字以test_ 开头的函数都作为测试执行。</p><p>setUp() 方法尝试创建一个测试环境，类似于运行中的程序。首先，使用测试配置创建程序，然后激活上下文。这一步的作用是确保能在测试中使用current_app，像普通请求一样。然后创建一个全新的数据库，以备不时之需。数据库和程序上下文在tearDown() 方法中删除。</p><p>第一个测试确保程序实例存在。第二个测试确保程序在测试配置中运行。若想把tests 文件夹作为包使用，需要添加tests/__init__.py 文件，不过这个文件可以为空，因为unittest 包会扫描所有模块并查找测试。</p><p>为了运行单元测试，你可以在manage.py 脚本中添加一个自定义命令。示例7-10 展示了如何添加test 命令。</p><p>示例7-10　manage.py：启动单元测试的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@manager.command</span><br><span class="line">def test():</span><br><span class="line">    &quot;&quot;&quot;Run the unit tests.&quot;&quot;&quot;</span><br><span class="line">    import unittest</span><br><span class="line">    tests = unittest.TestLoader().discover(&apos;tests&apos;)</span><br><span class="line">    unittest.TextTestRunner(verbosity=2).run(tests)</span><br></pre></td></tr></table></figure></p><p>manager.command 修饰器让自定义命令变得简单。修饰函数名就是命令名，函数的文档字符串会显示在帮助消息中。test() 函数的定义体中调用了unittest 包提供的测试运行函数。</p><p>单元测试可使用下面的命令运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python manage.py test</span><br><span class="line">test_app_exists (test_basics.BasicsTestCase) ... ok</span><br><span class="line">test_app_is_testing (test_basics.BasicsTestCase) ... ok</span><br><span class="line">.----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.001s</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><h4 id="7、创建数据库"><a href="#7、创建数据库" class="headerlink" title="7、创建数据库"></a>7、创建数据库</h4><p>重组后的程序和单脚本版本使用不同的数据库。</p><p>首选从环境变量中读取数据库的URL，同时还提供了一个默认的SQLite 数据库做备用。3种配置环境中的环境变量名和SQLite 数据库文件名都不一样。例如，在开发环境中，数据库URL 从环境变量DEV_DATABASE_URL 中读取，如果没有定义这个环境变量，则使用名为data-dev.sqlite 的SQLite 数据库。</p><p>不管从哪里获取数据库URL，都要在新数据库中创建数据表。如果使用Flask-Migrate 踪迁移，可使用如下命令创建数据表或者升级到最新修订版本：<br>　　<code>(venv) $ python manage.py db upgrade</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管在单一脚本中编写小型Web 程序很方便，但这种方法并不能广泛使用。程序变复杂后，使用单个大型源码文件会导致很多问题。&lt;/p&gt;
&lt;p&gt;不同于大多数其他的Web 框架，Flask 并不强制要求大型项目使用特定的组织方式，程序结构的组织方式完全由开发者决定。在本章，我们将介绍一种使用包和模块组织大型程序的方式。本书后续示例都将采用这种结构。&lt;/p&gt;
&lt;h4 id=&quot;1、项目结构&quot;&gt;&lt;a href=&quot;#1、项目结构&quot; class=&quot;headerlink&quot; title=&quot;1、项目结构&quot;&gt;&lt;/a&gt;1、项目结构&lt;/h4&gt;&lt;p&gt;Flask 程序的基本结构如示例7-1 所示。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 数据库之Flask-SQLAlchemy管理数据库</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BFlask-SQLAlchemy%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-数据库之Flask-SQLAlchemy管理数据库/</id>
    <published>2018-03-05T08:03:11.000Z</published>
    <updated>2018-03-06T02:24:36.616Z</updated>
    
    <content type="html"><![CDATA[<p>Flask-SQLAlchemy 是一个Flask 扩展，简化了在Flask 程序中使用SQLAlchemy 的操作。SQLAlchemy 是一个很强大的关系型数据库框架，支持多种数据库后台。SQLAlchemy 提供了高层ORM，也提供了使用数据库原生SQL 的低层功能。</p><p>和其他大多数扩展一样，Flask-SQLAlchemy 也使用pip 安装：<br>　　<code>(venv) $ pip install flask-sqlalchemy</code><br><a id="more"></a><br>在Flask-SQLAlchemy 中，数据库使用URL 指定。最流行的数据库引擎采用的数据库URL格式如表5-1 所示。</p><p><strong>表5-1　FLask-SQLAlchemy数据库URL</strong></p><table><thead><tr><th>数据库引擎</th><th>URL</th></tr></thead><tbody><tr><td>MySQL</td><td>mysql://username:password@hostname/database</td></tr><tr><td>Postgres</td><td>postgresql://username:password@hostname/database</td></tr><tr><td>SQLite（Unix）</td><td>sqlite:////absolute/path/to/database</td></tr><tr><td>SQLite（Windows）</td><td>sqlite:///c:/absolute/path/to/database</td></tr></tbody></table><p>在这些URL 中，hostname 表示MySQL 服务所在的主机，可以是本地主机（localhost），也可以是远程服务器。数据库服务器上可以托管多个数据库，因此database 表示要使用的数据库名。如果数据库需要进行认证，username 和password 表示数据库用户密令。<br><em>（注：SQLite 数据库不需要使用服务器，因此不用指定hostname、username 和password。URL 中的database 是硬盘上文件的文件名。）</em></p><p>程序使用的数据库URL 必须保存到Flask 配置对象的SQLALCHEMY_DATABASE_URI 键中。配置对象中还有一个很有用的选项，即SQLALCHEMY_COMMIT_ON_TEARDOWN 键，将其设为True时，每次请求结束后都会自动提交数据库中的变动。其他配置选项的作用请参阅Flask-SQLAlchemy 的文档。示例5-1 展示了如何初始化及配置一个简单的SQLite 数据库。</p><p>示例5-1　hello.py：配置数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.sqlalchemy import SQLAlchemy</span><br><span class="line">basedir = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;)</span><br><span class="line">app.config[&apos;SQLALCHEMY_COMMIT_ON_TEARDOWN&apos;] = True</span><br><span class="line">db = SQLAlchemy(app)</span><br></pre></td></tr></table></figure></p><p>db 对象是SQLAlchemy 类的实例，表示程序使用的数据库，同时还获得了Flask-SQLAlchemy提供的所有功能。</p><h4 id="1、定义模型"><a href="#1、定义模型" class="headerlink" title="1、定义模型"></a>1、定义模型</h4><p>模型这个术语表示程序使用的持久化实体。在ORM 中，模型一般是一个Python 类，类中的属性对应数据库表中的列。</p><p>Flask-SQLAlchemy 创建的数据库实例为模型提供了一个基类以及一系列辅助类和辅助函数，可用于定义模型的结构。图5-1 中的roles 表和users 表可定义为模型Role 和User，如示例5-2 所示。</p><p>示例5-2　hello.py：定义Role 和User 模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Role(db.Model):</span><br><span class="line">    __tablename__ = &apos;roles&apos;</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    name = db.Column(db.String(64), unique=True)</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;Role %r&gt;&apos; % self.name</span><br><span class="line">class User(db.Model):</span><br><span class="line">    __tablename__ = &apos;users&apos;</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    username = db.Column(db.String(64), unique=True, index=True)</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;User %r&gt;&apos; % self.username</span><br></pre></td></tr></table></figure></p><p>类变量__tablename__ 定义在数据库中使用的表名。如果没有定义__tablename__，Flask-SQLAlchemy 会使用一个默认名字，但默认的表名没有遵守使用复数形式进行命名的约定，所以最好由我们自己来指定表名。其余的类变量都是该模型的属性，被定义为db.Column类的实例。</p><p>db.Column 类构造函数的第一个参数是数据库列和模型属性的类型。表5-2 列出了一些可用的列类型以及在模型中使用的Python 类型。</p><p><strong>表5-2　最常用的SQLAlchemy列类型</strong></p><table><thead><tr><th>类型名</th><th>Python类型</th><th>说　　明</th></tr></thead><tbody><tr><td>Integer</td><td>int</td><td>普通整数，一般是32 位</td></tr><tr><td>SmallInteger</td><td>int</td><td>取值范围小的整数，一般是16 位</td></tr><tr><td>BigInteger</td><td>int 或long</td><td>不限制精度的整数</td></tr><tr><td>Float</td><td>float</td><td>浮点数</td></tr><tr><td>Numeric</td><td>decimal.Decimal</td><td>定点数</td></tr><tr><td>String</td><td>str</td><td>变长字符串</td></tr><tr><td>Text</td><td>str</td><td>变长字符串，对较长或不限长度的字符串做了优化</td></tr><tr><td>Unicode</td><td>unicode</td><td>变长Unicode 字符串</td></tr><tr><td>UnicodeText</td><td>unicode</td><td>变长Unicode 字符串，对较长或不限长度的字符串做了优化</td></tr><tr><td>Boolean</td><td>bool</td><td>布尔值</td></tr><tr><td>Date</td><td>datetime.date</td><td>日期</td></tr><tr><td>Time</td><td>datetime.time</td><td>时间</td></tr><tr><td>DateTime</td><td>datetime.datetime</td><td>日期和时间</td></tr><tr><td>Interval</td><td>datetime.timedelta</td><td>时间间隔</td></tr><tr><td>Enum</td><td>str</td><td>一组字符串</td></tr><tr><td>PickleType</td><td>任何Python 对象</td><td>自动使用Pickle 序列化</td></tr><tr><td>LargeBinary</td><td>str</td><td>二进制文件</td></tr></tbody></table><p>db.Column 中其余的参数指定属性的配置选项。表5-3 列出了一些可用选项。</p><p><strong>表5-3　最常使用的SQLAlchemy列选项</strong></p><table><thead><tr><th>选项名</th><th>说　　明</th></tr></thead><tbody><tr><td>primary_key</td><td>如果设为True，这列就是表的主键</td></tr><tr><td>unique</td><td>如果设为True，这列不允许出现重复的值</td></tr><tr><td>index</td><td>如果设为True，为这列创建索引，提升查询效率</td></tr><tr><td>nullable</td><td>如果设为True，这列允许使用空值；如果设为False，这列不允许使用空值</td></tr><tr><td>default</td><td>为这列定义默认值</td></tr></tbody></table><p><strong>（注：Flask-SQLAlchemy 要求每个模型都要定义主键，这一列经常命名为id。）</strong></p><p>虽然没有强制要求，但这两个模型都定义了__repr()__ 方法，返回一个具有可读性的字符串表示模型，可在调试和测试时使用。</p><h4 id="2、关系"><a href="#2、关系" class="headerlink" title="2、关系"></a>2、关系</h4><p>关系型数据库使用关系把不同表中的行联系起来。图5-1 所示的关系图表示用户和角色之间的一种简单关系。这是角色到用户的一对多关系，因为一个角色可属于多个用户，而每个用户都只能有一个角色。</p><p>图5-1 中的一对多关系在模型类中的表示方法如示例5-3 所示。</p><p>示例5-3　hello.py：关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Role(db.Model):</span><br><span class="line">    # ...</span><br><span class="line">    users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;)</span><br><span class="line"></span><br><span class="line">class User(db.Model):</span><br><span class="line">    # ...</span><br><span class="line">    role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;))</span><br></pre></td></tr></table></figure></p><p>如图5-1 所示，关系使用users 表中的外键连接了两行。添加到User 模型中的role_id 列被定义为外键，就是这个外键建立起了关系。传给db.ForeignKey() 的参数’roles.id’ 表明，这列的值是roles 表中行的id 值。</p><p>添加到Role 模型中的users 属性代表这个关系的面向对象视角。对于一个Role 类的实例，其users 属性将返回与角色相关联的用户组成的列表。db.relationship() 的第一个参数表明这个关系的另一端是哪个模型。如果模型类尚未定义，可使用字符串形式指定。</p><p>db.relationship() 中的backref 参数向User 模型中添加一个role 属性，从而定义反向关系。这一属性可替代role_id 访问Role 模型，此时获取的是模型对象，而不是外键的值。</p><p>大多数情况下，db.relationship() 都能自行找到关系中的外键，但有时却无法决定把哪一列作为外键。例如，如果User 模型中有两个或以上的列定义为Role 模型的外键，SQLAlchemy 就不知道该使用哪列。如果无法决定外键，你就要为db.relationship() 提供额外参数，从而确定所用外键。表5-4 列出了定义关系时常用的配置选项。</p><p><strong>表5-4　常用的SQLAlchemy关系选项</strong></p><table><thead><tr><th>选项名</th><th>说　　明</th></tr></thead><tbody><tr><td>backref</td><td>在关系的另一个模型中添加反向引用</td></tr><tr><td>primaryjoin</td><td>明确指定两个模型之间使用的联结条件。只在模棱两可的关系中需要指定</td></tr><tr><td>lazy</td><td>指定如何加载相关记录。可选值有select（首次访问时按需加载）、immediate（源对象加载后就加载）、joined（加载记录，但使用联结）、subquery（立即加载，但使用子查询），noload（永不加载）和dynamic（不加载记录，但提供加载记录的查询）</td></tr><tr><td>uselist</td><td>如果设为Fales，不使用列表，而使用标量值</td></tr><tr><td>order_by</td><td>指定关系中记录的排序方式</td></tr><tr><td>secondary</td><td>指定多对多关系中关系表的名字</td></tr><tr><td>secondaryjoin</td><td>SQLAlchemy 无法自行决定时，指定多对多关系中的二级联结条件</td></tr></tbody></table><p>除了一对多之外，还有几种其他的关系类型。一对一关系可以用前面介绍的一对多关系表示，但调用db.relationship() 时要把uselist 设为False，把“多”变成“一”。多对一关系也可使用一对多表示，对调两个表即可，或者把外键和db.relationship() 都放在“多”这一侧。最复杂的关系类型是多对多，需要用到第三张表，这个表称为关系表。</p><h4 id="3、数据库操作"><a href="#3、数据库操作" class="headerlink" title="3、数据库操作"></a>3、数据库操作</h4><h5 id="（1）创建表"><a href="#（1）创建表" class="headerlink" title="（1）创建表"></a>（1）创建表</h5><p>首先，我们要让Flask-SQLAlchemy 根据模型类创建数据库。方法是使用db.create_all()函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py shell</span><br><span class="line">&gt;&gt;&gt; from hello import db</span><br><span class="line">&gt;&gt;&gt; db.create_all()</span><br></pre></td></tr></table></figure></p><p>如果你查看程序目录，会发现新建了一个名为data.sqlite 的文件。这个SQLite 数据库文件的名字就是在配置中指定的。如果数据库表已经存在于数据库中，那么db.create_all()不会重新创建或者更新这个表。如果修改模型后要把改动应用到现有的数据库中，这一特性会带来不便。更新现有数据库表的粗暴方式是先删除旧表再重新创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.drop_all()</span><br><span class="line">&gt;&gt;&gt; db.create_all()</span><br></pre></td></tr></table></figure></p><p>（注：遗憾的是，这个方法有个我们不想看到的副作用，它把数据库中原有的数据都销毁了。末尾将会介绍一种更好的方式用于更新数据库。）</p><h5 id="（2）插入行"><a href="#（2）插入行" class="headerlink" title="（2）插入行"></a>（2）插入行</h5><p>下面这段代码创建了一些角色和用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from hello import Role, User</span><br><span class="line">&gt;&gt;&gt; admin_role = Role(name=&apos;Admin&apos;)</span><br><span class="line">&gt;&gt;&gt; mod_role = Role(name=&apos;Moderator&apos;)</span><br><span class="line">&gt;&gt;&gt; user_role = Role(name=&apos;User&apos;)</span><br><span class="line">&gt;&gt;&gt; user_john = User(username=&apos;john&apos;, role=admin_role)</span><br><span class="line">&gt;&gt;&gt; user_susan = User(username=&apos;susan&apos;, role=user_role)</span><br><span class="line">&gt;&gt;&gt; user_david = User(username=&apos;david&apos;, role=user_role)</span><br></pre></td></tr></table></figure></p><p>模型的构造函数接受的参数是使用关键字参数指定的模型属性初始值。注意，role 属性也可使用，虽然它不是真正的数据库列，但却是一对多关系的高级表示。这些新建对象的id属性并没有明确设定，因为主键是由Flask-SQLAlchemy 管理的。现在这些对象只存在于Python 中，还未写入数据库。因此id 尚未赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(admin_role.id)</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; print(mod_role.id)</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; print(user_role.id)</span><br><span class="line">None</span><br></pre></td></tr></table></figure></p><p>通过数据库会话管理对数据库所做的改动，在Flask-SQLAlchemy 中，会话由db.session表示。准备把对象写入数据库之前，先要将其添加到会话中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.session.add(admin_role)</span><br><span class="line">&gt;&gt;&gt; db.session.add(mod_role)</span><br><span class="line">&gt;&gt;&gt; db.session.add(user_role)</span><br><span class="line">&gt;&gt;&gt; db.session.add(user_john)</span><br><span class="line">&gt;&gt;&gt; db.session.add(user_susan)</span><br><span class="line">&gt;&gt;&gt; db.session.add(user_david)</span><br></pre></td></tr></table></figure></p><p>或者简写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.session.add_all([admin_role, mod_role, user_role,</span><br><span class="line">... user_john, user_susan, user_david])</span><br></pre></td></tr></table></figure></p><p>为了把对象写入数据库，我们要调用commit() 方法提交会话：<br><code>&gt;&gt;&gt; db.session.commit()</code></p><p>再次查看id 属性，现在它们已经赋值了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(admin_role.id)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(mod_role.id)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; print(user_role.id)</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>数据库会话能保证数据库的一致性。提交操作使用原子方式把会话中的对象全部写入数据库。如果在写入会话的过程中发生了错误，整个会话都会失效。如果你始终把相关改动放在会话中提交，就能避免因部分更新导致的数据库不一致性。</p><h5 id="（3）修改行"><a href="#（3）修改行" class="headerlink" title="（3）修改行"></a>（3）修改行</h5><p>在数据库会话上调用add() 方法也能更新模型。我们继续在之前的shell 会话中进行操作，下面这个例子把”Admin” 角色重命名为”Administrator”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; admin_role.name = &apos;Administrator&apos;</span><br><span class="line">&gt;&gt;&gt; db.session.add(admin_role)</span><br><span class="line">&gt;&gt;&gt; db.session.commit()</span><br></pre></td></tr></table></figure></p><h5 id="（4）删除行"><a href="#（4）删除行" class="headerlink" title="（4）删除行"></a>（4）删除行</h5><p>数据库会话还有个delete() 方法。下面这个例子把”Moderator” 角色从数据库中删除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.session.delete(mod_role)</span><br><span class="line">&gt;&gt;&gt; db.session.commit()</span><br></pre></td></tr></table></figure></p><p>注意，删除与插入和更新一样，提交数据库会话后才会执行。</p><h5 id="（5）查询行"><a href="#（5）查询行" class="headerlink" title="（5）查询行"></a>（5）查询行</h5><p>Flask-SQLAlchemy 为每个模型类都提供了query 对象。最基本的模型查询是取回对应表中的所有记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Role.query.all()</span><br><span class="line">[&lt;Role u&apos;Administrator&apos;&gt;, &lt;Role u&apos;User&apos;&gt;]</span><br><span class="line">&gt;&gt;&gt; User.query.all()</span><br><span class="line">[&lt;User u&apos;john&apos;&gt;, &lt;User u&apos;susan&apos;&gt;, &lt;User u&apos;david&apos;&gt;]</span><br></pre></td></tr></table></figure></p><p>使用过滤器可以配置query 对象进行更精确的数据库查询。下面这个例子查找角色为”User” 的所有用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; User.query.filter_by(role=user_role).all()</span><br><span class="line">[&lt;User u&apos;susan&apos;&gt;, &lt;User u&apos;david&apos;&gt;]</span><br></pre></td></tr></table></figure></p><p>若要查看SQLAlchemy 为查询生成的原生SQL 查询语句，只需把query 对象转换成字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(User.query.filter_by(role=user_role))</span><br><span class="line">&apos;SELECT users.id AS users_id, users.username AS users_username,</span><br><span class="line">users.role_id AS users_role_id FROM users WHERE :param_1 = users.role_id&apos;</span><br></pre></td></tr></table></figure></p><p>filter_by() 等过滤器在query 对象上调用，返回一个更精确的query 对象。多个过滤器可以一起调用，直到获得所需结果。</p><p>表5-5 列出了可在query 对象上调用的常用过滤器。完整的列表参见SQLAlchemy 文档（<a href="http://docs.sqlalchemy.org）。" target="_blank" rel="noopener">http://docs.sqlalchemy.org）。</a></p><p><strong>表5-5　常用的SQLAlchemy查询过滤器</strong></p><table><thead><tr><th>过滤器</th><th>说　　明</th></tr></thead><tbody><tr><td>filter()</td><td>把过滤器添加到原查询上，返回一个新查询</td></tr><tr><td>filter_by()</td><td>把等值过滤器添加到原查询上，返回一个新查询</td></tr><tr><td>limit()</td><td>使用指定的值限制原查询返回的结果数量，返回一个新查询</td></tr><tr><td>offset()</td><td>偏移原查询返回的结果，返回一个新查询</td></tr><tr><td>order_by()</td><td>根据指定条件对原查询结果进行排序，返回一个新查询</td></tr><tr><td>group_by()</td><td>根据指定条件对原查询结果进行分组，返回一个新查询</td></tr></tbody></table><p>在查询上应用指定的过滤器后，通过调用all() 执行查询，以列表的形式返回结果。除了all() 之外，还有其他方法能触发查询执行。表5-6 列出了执行查询的其他方法。</p><p><strong>表5-6　最常使用的SQLAlchemy查询执行函数</strong></p><table><thead><tr><th>方　法</th><th>说　　明</th></tr></thead><tbody><tr><td>all()</td><td>以列表形式返回查询的所有结果</td></tr><tr><td>first()</td><td>返回查询的第一个结果，如果没有结果，则返回None</td></tr><tr><td>first_or_404()</td><td>返回查询的第一个结果，如果没有结果，则终止请求，返回404 错误响应</td></tr><tr><td>get()</td><td>返回指定主键对应的行，如果没有对应的行，则返回None</td></tr><tr><td>get_or_404()</td><td>返回指定主键对应的行，如果没找到指定的主键，则终止请求，返回404 错误响应</td></tr><tr><td>count()</td><td>返回查询结果的数量</td></tr><tr><td>paginate()</td><td>返回一个Paginate 对象，它包含指定范围内的结果</td></tr></tbody></table><p>关系和查询的处理方式类似。下面这个例子分别从关系的两端查询角色和用户之间的一对多关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; users = user_role.users</span><br><span class="line">&gt;&gt;&gt; users</span><br><span class="line">[&lt;User u&apos;susan&apos;&gt;, &lt;User u&apos;david&apos;&gt;]</span><br><span class="line">&gt;&gt;&gt; users[0].role</span><br><span class="line">&lt;Role u&apos;User&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>这个例子中的user_role.users 查询有个小问题。执行user_role.users 表达式时，隐含的查询会调用all() 返回一个用户列表。query 对象是隐藏的，因此无法指定更精确的查询过滤器。就这个特定示例而言，返回一个按照字母顺序排序的用户列表可能更好。如果修改了关系的设置，加入了lazy = ‘dynamic’ 参数，从而禁止自动执行查询。</p><h4 id="4、使用Flask-Migrate实现数据库迁移"><a href="#4、使用Flask-Migrate实现数据库迁移" class="headerlink" title="4、使用Flask-Migrate实现数据库迁移"></a>4、使用Flask-Migrate实现数据库迁移</h4><p>在开发程序的过程中，你会发现有时需要修改数据库模型，而且修改之后还需要更新数据库。</p><p>仅当数据库表不存在时，Flask-SQLAlchemy 才会根据模型进行创建。因此，更新表的唯一方式就是先删除旧表，不过这样做会丢失数据库中的所有数据。</p><p>更新表的更好方法是使用数据库迁移框架。源码版本控制工具可以跟踪源码文件的变化，类似地，数据库迁移框架能跟踪数据库模式的变化，然后增量式的把变化应用到数据库中。</p><p>SQLAlchemy 的主力开发人员编写了一个迁移框架，称为Alembic（<a href="https://alembic.readthedocs.org/en/latest/index.html）。除了直接使用Alembic" target="_blank" rel="noopener">https://alembic.readthedocs.org/en/latest/index.html）。除了直接使用Alembic</a> 之外，Flask 程序还可使用Flask-Migrate（<a href="http://flask-migrate.readthedocs.org/en/latest/）扩展。这个扩展对Alembic" target="_blank" rel="noopener">http://flask-migrate.readthedocs.org/en/latest/）扩展。这个扩展对Alembic</a> 做了轻量级包装，并集成到Flask-Script 中，所有操作都通过Flask-Script 命令完成。</p><h5 id="（1）创建迁移仓库"><a href="#（1）创建迁移仓库" class="headerlink" title="（1）创建迁移仓库"></a>（1）创建迁移仓库</h5><p>首先，我们要在虚拟环境中安装Flask-Migrate：<br>　　<code>(venv) $ pip install flask-migrate</code><br>这个扩展的初始化方法如示例5-8 所示。</p><p>示例5-8　hello.py：配置Flask-Migrate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.migrate import Migrate, MigrateCommand</span><br><span class="line"># ...</span><br><span class="line">migrate = Migrate(app, db)</span><br><span class="line">manager.add_command(&apos;db&apos;, MigrateCommand)</span><br></pre></td></tr></table></figure></p><p>为了导出数据库迁移命令，Flask-Migrate 提供了一个MigrateCommand 类，可附加到Flask-Script 的manager 对象上。在这个例子中，MigrateCommand 类使用db 命令附加。</p><p>在维护数据库迁移之前，要使用init 子命令创建迁移仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py db init</span><br><span class="line">Creating directory /home/flask/flasky/migrations...done</span><br><span class="line">Creating directory /home/flask/flasky/migrations/versions...done</span><br><span class="line">Generating /home/flask/flasky/migrations/alembic.ini...done</span><br><span class="line">Generating /home/flask/flasky/migrations/env.py...done</span><br><span class="line">Generating /home/flask/flasky/migrations/env.pyc...done</span><br><span class="line">Generating /home/flask/flasky/migrations/README...done</span><br><span class="line">Generating /home/flask/flasky/migrations/script.py.mako...done</span><br><span class="line">Please edit configuration/connection/logging settings in</span><br><span class="line">&apos;/home/flask/flasky/migrations/alembic.ini&apos; before proceeding.</span><br></pre></td></tr></table></figure></p><p>这个命令会创建migrations 文件夹，所有迁移脚本都存放其中。</p><h5 id="（2）创建迁移脚本"><a href="#（2）创建迁移脚本" class="headerlink" title="（2）创建迁移脚本"></a>（2）创建迁移脚本</h5><p>在Alembic 中，数据库迁移用迁移脚本表示。脚本中有两个函数，分别是upgrade() 和downgrade()。upgrade() 函数把迁移中的改动应用到数据库中，downgrade() 函数则将改动删除。Alembic 具有添加和删除改动的能力，因此数据库可重设到修改历史的任意一点。</p><p>我们可以使用revision 命令手动创建Alembic 迁移，也可使用migrate 命令自动创建。手动创建的迁移只是一个骨架，upgrade() 和downgrade() 函数都是空的，开发者要使用Alembic 提供的Operations 对象指令实现具体操作。自动创建的迁移会根据模型定义和数据库当前状态之间的差异生成upgrade() 和downgrade() 函数的内容。</p><p>migrate 子命令用来自动创建迁移脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py db migrate -m &quot;initial migration&quot;</span><br><span class="line">INFO [alembic.migration] Context impl SQLiteImpl.</span><br><span class="line">INFO [alembic.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO [alembic.autogenerate] Detected added table &apos;roles&apos;</span><br><span class="line">INFO [alembic.autogenerate] Detected added table &apos;users&apos;</span><br><span class="line">INFO [alembic.autogenerate.compare] Detected added index</span><br><span class="line">&apos;ix_users_username&apos; on &apos;[&apos;username&apos;]&apos;</span><br><span class="line">Generating /home/flask/flasky/migrations/versions/1bc</span><br><span class="line">594146bb5_initial_migration.py...done</span><br></pre></td></tr></table></figure></p><h5 id="（3）更新数据库"><a href="#（3）更新数据库" class="headerlink" title="（3）更新数据库"></a>（3）更新数据库</h5><p>检查并修正好迁移脚本之后，我们可以使用db upgrade 命令把迁移应用到数据库中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py db upgrade</span><br><span class="line">INFO [alembic.migration] Context impl SQLiteImpl.</span><br><span class="line">INFO [alembic.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO [alembic.migration] Running upgrade None -&gt; 1bc594146bb5, initial migration</span><br></pre></td></tr></table></figure></p><p>对第一个迁移来说， 其作用和调用db.create_all() 方法一样。但在后续的迁移中，upgrade 命令能把改动应用到数据库中，且不影响其中保存的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask-SQLAlchemy 是一个Flask 扩展，简化了在Flask 程序中使用SQLAlchemy 的操作。SQLAlchemy 是一个很强大的关系型数据库框架，支持多种数据库后台。SQLAlchemy 提供了高层ORM，也提供了使用数据库原生SQL 的低层功能。&lt;/p&gt;
&lt;p&gt;和其他大多数扩展一样，Flask-SQLAlchemy 也使用pip 安装：&lt;br&gt;　　&lt;code&gt;(venv) $ pip install flask-sqlalchemy&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
