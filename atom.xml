<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-17T08:40:39.525Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络之URL基础知识</title>
    <link href="http://yoursite.com/2018/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BURL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/12/17/计算机网络之URL基础知识/</id>
    <published>2018-12-17T08:27:14.000Z</published>
    <updated>2018-12-17T08:40:39.525Z</updated>
    
    <content type="html"><![CDATA[<p>URI：服务器资源名被称为<strong>统一资源标识符（Uniform Resource Identifier,URI）</strong>。<br>URL：<strong>统一资源定位符（URL）</strong>是资源标识符最常见的形式。URL描述了一台特定服务器上某资源的特定位置。他们可以明确说明如何从一个精确、固定的位置获取资源。<br>URN：URI的第二种形式就是<strong>统一资源名（URN）</strong>。URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与位置无关的URN，就可以将资源四处搬移。通过URN，还可以用同一个名字通过多种网络访问协议来访问资源。（注：仍然处于实验阶段，还未大范围使用。）<br><a id="more"></a><br>URL趣谈</p><blockquote><p>黑暗岁月：<br>想要访问一个资源，需要使用FTP，连接到对应的域名上，匿名登录，切换到对应的目录，然后下载到本地。进行浏览这个文件。<br>现在，只需要将URL输入到浏览器，直接回车进行浏览即可。</p></blockquote><p>URL<br>大多数URL方案的URL语法都建立在这个由9部分构成的通用格式上：<br>    <code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code><br>几乎没有哪个URL中包含所有这些组件。URL最重要的3个部分是方案（scheme）、主机（host）和路径（path）。下表对各种组件进行了总结：</p><p><strong>通用URL组件</strong></p><table><thead><tr><th>组件</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>方案</td><td>访问服务器以获取资源时要使用那种协议</td><td>无</td></tr><tr><td>用户</td><td>某些方案访问资源时需要的用户名</td><td>匿名</td></tr><tr><td>密码</td><td>用户名后面可能要包含的密码，中间由冒号（:）分隔</td><td>&lt;E-mail地址&gt;</td></tr><tr><td>主机</td><td>资源宿主服务器的主机名或点分IP地址</td><td>无</td></tr><tr><td>端口</td><td>资源宿主服务器正在监听的端口号。很多方案都默认端口号（HTTP的默认端口号为80）</td><td>每个方案特有</td></tr><tr><td>路径</td><td>服务器上资源的本地名，有一个斜杠（/）将其与前面的URL组件分隔开来。路径组件的语法是与服务器和方案有关的（本章稍后会讲到URL路径可以分为若干个段，每段都可以有其特有的组件）</td><td>无</td></tr><tr><td>参数</td><td>某些方案会用这个组件来指定输入参数。参数为名/值对。URL中可以包含多个参数字段，他们相互之间以及与路径的其余部分之间用分号（;）分隔</td><td>无</td></tr><tr><td>查询</td><td>某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引擎以及其它因特网网关）。查询组件的内容没有通用格式。用字符“?”将其与URL的其余部分分割开来</td><td>无</td></tr><tr><td>片段</td><td>一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器，这个字段是在客户端内部使用的。通过字符“#”将其与URL的其余部分分隔开来</td><td>无</td></tr></tbody></table><p><strong>常见的方案格式</strong></p><table><thead><tr><th>方案</th><th>描述</th></tr></thead><tbody><tr><td>http</td><td>超文本传输协议方案，除了没有用户名和密码之外，与通用的URL格式相符。如果省略了端口，就默认为80。<br>基本格式：<br><code>http://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</code></td></tr><tr><td>https</td><td>方案https与方案http是一对。唯一的区别在于方案https使用了网景的SSL，SSL为HTTP连接提供了端到端的加密机制。其语法与HTTP的语法相同，默认端口为443。<br>基本格式：<br><code>http://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</code></td></tr><tr><td>mailto</td><td>Mailto URL指向的是E-mail地址。由于E-mail的行为与其他方案都有所不同（他并不指向任何可以直接访问的对象），所以mailto URL的格式与标准URL的格式也有所不同。因特网E-mail地址的语法记录在RFC 822中。<br>基本格式：<br><code>mailto:&lt;RFC-822-addr-spec&gt;</code><br>示例：<br>mailto:<a href="mailto:joe@joes-hardware.com" target="_blank" rel="noopener">joe@joes-hardware.com</a></td></tr><tr><td>ftp</td><td>文件传输协议URL可以用来从FTP服务器上下载或向其上载文件，并获取FTP服务器上的目录结构内容的列表。<br>在Web和URL出现之前FTP就已经存在了。Web应用程序将FTP作为一种数据访问方案使用。URL语法遵循下列通用格式。<br>基本格式：<br><code>ftp://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;</code><br><a href="ftp://anonymous:joe%40joes-hardware.com@prep.ai.mit.edu:21/pub/gnu/" target="_blank" rel="noopener">ftp://anonymous:joe%40joes-hardware.com@prep.ai.mit.edu:21/pub/gnu/</a></td></tr><tr><td>file</td><td>方案file表示一台指定主机（通过本地磁盘、网络文件系统或其他一些文件共享系统）上可直接访问的文件。各字段都遵循通用格式。如果省略了主机名，就默认为正在使用URL的本地主机。<br>基本格式：<br><code>file://&lt;host&gt;/&lt;path&gt;</code></td></tr><tr><td>telnet</td><td>方案telnet用于访问交互式业务。他表示的并不是对象自身，而是可通过telnet协议访问的交互式应用程序（资源）。<br>基本格式：<br><code>telnet://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/</code></td></tr><tr><td>rtsp,rtspu</td><td>RTSP URL是可以通过实时流传输协议（Real Time Streaming Protocol）解析的音/视屏媒体资源的标识符。<br>方案rtspu中的u表示它是使用UDP协议来获取资源的。<br>基本格式：<br><code>rtsp://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code><br><code>rtspu://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></td></tr><tr><td>news</td><td>省略…</td></tr></tbody></table><blockquote><p>URL是一种强有力的工具，但是并不完美。他们表示的是实际的地址，而不是准确的名字。这就意味着如果资源被移走了，URL就不再有效了。就无法对对象进行定位了。<br>为了应对这个问题，因特网工程任务组（Internet Engineering Task Force，IETF）已经对一种名为统一资源名（uniform resource name,URN）的新标准做了一段时间的研究了。无论对象搬移到什么地方（在一个Web服务器内或是在不同的Web服务器间），URN都能为对象提供一个稳定的名称。<br><strong>永久统一资源定位符（persistent uniform resource locators,PURL）</strong>是用URL来实现URN功能的一个例子。其基本思想是在搜索资源的过程中引入另一个中间层，通过一个中间<strong>资源定位符（resource locator）</strong>服务器对资源的实际URL进行登记和跟踪。客户端可以向定位符请求一个永久URL，定位符可以以一个资源作为响应，将客户端重定向到资源当前实际的URL上去。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;URI：服务器资源名被称为&lt;strong&gt;统一资源标识符（Uniform Resource Identifier,URI）&lt;/strong&gt;。&lt;br&gt;URL：&lt;strong&gt;统一资源定位符（URL）&lt;/strong&gt;是资源标识符最常见的形式。URL描述了一台特定服务器上某资源的特定位置。他们可以明确说明如何从一个精确、固定的位置获取资源。&lt;br&gt;URN：URI的第二种形式就是&lt;strong&gt;统一资源名（URN）&lt;/strong&gt;。URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与位置无关的URN，就可以将资源四处搬移。通过URN，还可以用同一个名字通过多种网络访问协议来访问资源。（注：仍然处于实验阶段，还未大范围使用。）&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>[转]计算机网络之端口问题</title>
    <link href="http://yoursite.com/2018/12/17/%E8%BD%AC-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/12/17/转-计算机网络之端口问题/</id>
    <published>2018-12-17T08:26:51.000Z</published>
    <updated>2018-12-17T08:41:51.946Z</updated>
    
    <content type="html"><![CDATA[<p>博文出处：<a href="https://blog.csdn.net/weixin_42204641/article/details/83585277" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42204641/article/details/83585277</a></p><p>搞清楚一些问题，端口就彻底了解了！</p><a id="more"></a><p>1、 端口到底是什么？<br>端口就是一个数字而已；<br>这里的一个常识是：TCP/IP协议中的端口，端口号的范围从0到65535。</p><p>2、 端口到底是用来干嘛的？<br>当系统调用一个应用程序的时候，会将该进程与一个端口绑定，这样一来，传输层传给该端口的数据都被相应的进程接收，与此同时，相应进程发给传输层的数据也都通过该端口输出。所以，<strong>端口就是用来识别系统中运行的应用程序的</strong>。</p><p>3、 一般80端口是用来www服务（网页服务）的，为什么有些网站不是80端口呢？而是别的什么端口呢？<br>我们在IE的地址栏里输入一个网址的时候（比如<a href="http://www.baidu.com.cn）是不必指定端口号的，因为在默认情况下WWW服务的端口号是“80”。" target="_blank" rel="noopener">www.baidu.com.cn）是不必指定端口号的，因为在默认情况下WWW服务的端口号是“80”。</a></p><p>网络服务是可以改的，使用其他端口号完全是可以的，要注意的是，如果不是默认端口号则应该在地址栏上指定端口号。</p><p>4、 主机和端口的关系是什么？<br>大哥比方，就好比你要去银行存钱，这家银行就可以看成是一台主机，然后，银行不可能只有一种业务，对应每种业务就有很多的窗口，那么你一进银行大门的时候，在门口的服务人员就会问你说：你好！你要办什么业务？<br>你跟他说：存钱！！<br>服务员接着就会告诉你：请到三号窗口办理！<br>这个时候你总该不会往其他的窗口跑吧？！<br>这些窗口就可以看成是port。</p><p>5、 端口映射到底是怎么回事呢？<br>就是建立内网主机IP地址和外网IP地址之间的一个映射；<br>那么当我们向这个外网的IP地址发送请求时，该请求会被转发给内网的那台IP主机上去；从而实现了外网对内网的访问，端口映射的过程如果做个类比那就是：<br>你的一个朋友来找你（网络请求），但是来找你但是不知道你住哪里（内网IP），但是他知道你的名字，（外网IP）于是你的朋友向物业告知你的名字后，物业查到了你的具体地址，几栋几单元几零几（内网IP），然后物业联系你，和你确认（端口映射），然后你的朋友就去对应的地址敲了你的门，然后你开门见到了你的朋友（外网访问到内网）<br>这里的端口，是一种逻辑端口，是TCP/IP协议中定义的端口概念而已，通常就是一些装逼文章里的虚拟端口，那些看得见的端口，就叫做接口。</p><blockquote><p>进程是个什么鬼呢？<br>应用程序调入内存运行之后，就不能叫应用程序了，得叫进程；所以进程就是跑起来的应用程序。</p></blockquote><p>6、 TCP和端口有什么关系呢？<br>TCP和联机有关，所谓的联机就是指客户端Client机和服务端Server机的联系和通信；要想实现Client和Server的通信，必须先通过TCP来实现两端的联机！！<br>TCP联机的过程是：<br>第一步：客户端向服务端发送一个TCP封包（客户端发送的时候的端口是随机的）<br>　　这等同于，客户端打电话问服务端：服务端，听得到我说话么？<br>第二步：服务端按端口的服务性质接受到请求后，向客户端发送第二个TCP封包，也就是第一个响应封包<br>　　这等同于，服务端回客户端说：我听得到！<br>第三步：客户端获得这个响应封包之后，再向服务端发送一个确认封包；<br>　　这等同于，客户端向服务端说：好的！<br>第四步：服务端接收到这个确认封包之后，客户端和服务端的联机就算真正建立了；<br>在建立了tcp联机之后，才能进行服务资源的请求-响应。</p><p>了解到这里就可以完全用几句话把TCP协议和UDP协议的区别讲清楚了<br>TCP协议是：不仅发送信息，然后还要确认信息是否送达<br>UDP协议是：只发送信息，不确认信息是否送达</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博文出处：&lt;a href=&quot;https://blog.csdn.net/weixin_42204641/article/details/83585277&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/weixin_42204641/article/details/83585277&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搞清楚一些问题，端口就彻底了解了！&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之端口解析</title>
    <link href="http://yoursite.com/2018/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/17/计算机网络之端口解析/</id>
    <published>2018-12-17T08:26:03.000Z</published>
    <updated>2018-12-17T08:30:15.267Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、端口概述"><a href="#1、端口概述" class="headerlink" title="1、端口概述"></a>1、端口概述</h4><p>在Internet上，各主机间通过TCP/TP协议发送和接收数据报，各个数据报根据其目的主机的ip地址来进行互联网络中的路由选择。可见，把数据报顺利的传送到目的主机是没有问题的。问题出在哪里呢?我们知道大多数操作系统都支持多程序（进程）同时运行，那么目的主机应该把接收到的数据报传送给众多同时运行的进程中的哪一个呢？显然这个问题有待解决，端口机制便由此被引入进来。</p><blockquote><p>请注意，端口号只具有本地意义（即只对本地机器来说才有意义），它只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口。</p></blockquote><a id="more"></a><p>本地操作系统会给那些有需求的进程分配协议端口 （protocal port，即我们常说的端口），每个协议端口由一个正整数标识，如：80，139，445，等等。当目的主机接收到数据报后，将根据报文首部的目的端口号，把数据发送到相应端口，而与此端口相对应的那个进程将会领取数据并等待下一组数据的到来。</p><p>端口其实就是队，操作系统为各个进程分配了不同的队，数据报按照目的端口被推入相应的队中，等待被进程取用，在极特殊的情况下，这个队也是有可能溢出的，不过操作系统允许各进程指定和调整自己的队的大小。</p><p>不光接受数据报的进程需要开启它自己的端口，发送数据报的进程也需要开启端口，这样，数据报中将会标识有源端口，以便接受方能顺利的回传数据报到这个端口。</p><blockquote><p>传输层标识的端口号用16位来表示，说明只能允许有65535（2^16-1）个不同的端口号。</p></blockquote><h4 id="2、端口分类"><a href="#2、端口分类" class="headerlink" title="2、端口分类"></a>2、端口分类</h4><h5 id="（1）服务器端使用的端口号"><a href="#（1）服务器端使用的端口号" class="headerlink" title="（1）服务器端使用的端口号"></a>（1）服务器端使用的端口号</h5><p>这里又分为两类，最重要的一类叫做熟知端口号（well-known port number）或系统端口号，数值为0~1023。可在网址 <a href="http://www.iana.org查到。" target="_blank" rel="noopener">www.iana.org查到。</a><br>IANA把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道。下面给出一些常用的熟知端口号：</p><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>SNMP</th><th>SNMP(trap)</th></tr></thead><tbody><tr><td>熟知端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>161</td><td>162</td></tr></tbody></table><p>另一类叫做登记端口号，数值为 1024~49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。</p><h5 id="（2）客户端使用的端口号数值为-49152-65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。"><a href="#（2）客户端使用的端口号数值为-49152-65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。" class="headerlink" title="（2）客户端使用的端口号数值为 49152~65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。"></a>（2）客户端使用的端口号数值为 49152~65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。</h5><blockquote><p>短暂端口（ephemeral port）表示这种端口的存在时间是短期的。客户进程并不在意操作系统给它分配的是哪一个端口号，因为客户进程之所以必须有一个端口号（在本地主机中必须是唯一的），是为了让传输层的实体能够找到自己。这和熟知端口不同。服务器机器一接通电源，服务器程序就运行起来。为了让因特网上所有的客户程序都能够找到服务器程序，服务器程序所使用的端口（即熟知端口）就必须是固定的，并且是众所周知的。</p></blockquote><h4 id="端口在入侵中的作用"><a href="#端口在入侵中的作用" class="headerlink" title="端口在入侵中的作用"></a>端口在入侵中的作用</h4><p>有人曾经把服务器比作房子，而把端口比作通向不同房间（服务）的门，如果不考虑细节的话，这是一个不错的比喻。入侵者要占领这间房子，势必要破门而入（物理入侵另说），那么对于入侵者来说，了解房子开了几扇门，都是什么样的门，门后面有什么东西就显得至关重要。<br>　 入侵者通常会用扫描器对目标主机的端口进行扫描，以确定哪些端口是开放的，从开放的端口，入侵者可以知道目标主机大致提供了哪些服务，进而猜测可能存在的漏洞，因此对端口的扫描可以帮助我们更好的了解目标主机，而对于管理员，扫描本机的开放端口也是做好安全防范的第一步。</p><h4 id="端口大小设置"><a href="#端口大小设置" class="headerlink" title="端口大小设置"></a>端口大小设置</h4><blockquote><p>端口大小需要先了解MTU是什么？<br>MTU是Maximum Transmission Unit的缩写，意思是网络上传送的最大数据包，它的的单位是字节。</p></blockquote><blockquote><p>大部分网络设备都是1500。如果本机的MTU比网关的MTU大，大的数据包就会被拆开来传送，这样会产生很多数据包碎片，增加丢包率，降低网络速度。把本机的MTU设成比网关的MTU小或相同，就可以减少丢包 。通俗的说也就是，如果你上传一个大的文件，速度非常慢，可能就是这种原因，当你把MTU值改小时，就可以解决。</p></blockquote><p><strong>查看本机的mtu ：</strong> <code>netstat -i</code></p><p><strong>设置本机的mtu ：</strong> <code>echo &quot;1450&quot; &gt; /sys/class/net/eth0/mtu</code> 或直接编辑eth1网卡配置文件。</p><blockquote><p>扩展：不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p></blockquote><p>在应用程序中我们用到的Data的长度最大是多少，直接取决于底层的限制。<br>我们从下到上分析一下：</p><ol><li>在链路层，由以太网的物理特性决定了数据帧的长度为(46＋18)－(1500＋18)，其中的18是数据帧的头和尾，也就是说数据帧的内容最大为1500(不包括帧头和帧尾)，即MTU(Maximum Transmission Unit)为1500；</li><li>在网络层，因为IP包的首部要占用20字节，所以这的MTU为1500－20＝1480；</li><li>在传输层，对于UDP包的首部要占用8字节，所以这的MTU为1480－8＝1472；（注：TCP的首部要占用20字节）　　</li></ol><p>所以，在应用层，你的Data最大长度为1472。当我们的UDP包中的数据多于MTU(1472)时，发送方的IP层需要分片fragmentation进行传输，而在接收方IP层则需要进行数据报重组，由于UDP是不可靠的传输协议，如果分片丢失导致重组失败，将导致UDP数据包被丢弃。</p><blockquote><p><img src="/uploads/2018/12/network_mtu_001.jpg" alt=""><br>由于以太网EthernetII最大的数据帧是1518Bytes这样，刨去以太网帧的帧头（DMAC目的MAC地址48bits=6Bytes+SMAC源MAC地址48bits=6Bytes+Type域2Bytes）14Bytes和帧尾CRC校验部分4Bytes那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值我们就把它称之为MTU。</p></blockquote><blockquote><p>如果我们定义的TCP和UDP包没有超过范围，那么我们的包在IP层就不用分包了，这样传输过程中就避免了在IP层组包发生的错误；如果超过范围，既IP数据报大于1500字节，发送方IP层就需要将数据包分成若干片，而接收方IP层就需要进行数据报的重组。更严重的是，如果使用UDP协议，当IP层组包发生错误，那么包就会被丢弃。接收方无法重组数据报，将导致丢弃整个IP数据报。UDP不保证可靠传输；但是TCP发生组包错误时，该包会被重传，保证可靠传输。</p></blockquote><p>UDP数据报的长度是指包括报头和数据部分在内的总字节数，其中报头长度固定，数据部分可变。数据报的最大长度根据操作环境的不同而各异。从理论上说，包含报头在内的数据报的最大长度为65535字节(64K)。</p><blockquote><p>注：此处的最大字节数，为系统内核缓存区大小。现在默认值已经不是65535字节，可依据机器查询。<br><code>cat /proc/sys/net/core/rmem_max</code>    //读缓存区，单位字节<br>16777216<br><code>cat /proc/sys/net/core/wmem_max</code>    //写缓存区，单位字节<br>16777216<br><code>cat /proc/sys/net/core/rmem_default</code>    //默认读缓存区<br>8388608<br><code>cat /proc/sys/net/core/wmem_default</code>    //默认写缓存区<br>8388608</p></blockquote><p>我们在用Socket编程时，UDP协议要求包小于64K（需要减去IP头(20)+UDP头(8)=65507，否则用sendto函数发送数据会返回错误）。TCP没有限定，TCP包头中就没有“包长度”字段，而完全依靠IP层去处理分帧。这就是为什么TCP常常被称作一种“流协议”的原因，开发者在使用TCP服务的时候，不必去关心数据包的大小，只需讲SOCKET看作一条数据流的入口，往里面放数据就是了，TCP协议本身会进行拥塞/流量控制。</p><h4 id="端口阻塞问题？（自我理解，不一定正确。待后期确认）"><a href="#端口阻塞问题？（自我理解，不一定正确。待后期确认）" class="headerlink" title="端口阻塞问题？（自我理解，不一定正确。待后期确认）"></a>端口阻塞问题？（自我理解，不一定正确。待后期确认）</h4><p>端口号仅仅是为了区别本地机器的进程用的，并不会出现阻塞问题。出现阻塞问题，也都是一些TCP方面的，或者是IP层面的。</p><p>传输层或网络层的发送与接收缓存打满，导致阻塞丢失数据问题，出现阻塞。（这就是为什么TCP有拥塞控制。需要检测拥塞和减少包的发送率，降低拥塞，避免网络瘫痪。）</p><p>（注：一般不会说UDP会阻塞网络，因为UDP是不可靠的传输，因此如果有阻塞发生，UDP就会丢包，没有重传机制。造成阻塞的情况，可能就是源主机一直发送数据，导致拥塞，造成网络不能正常收发数据。）</p><p>还有就是进程阻塞问题。 一般不会说端口阻塞。端口只会被禁止，通过防火墙一类的限制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、端口概述&quot;&gt;&lt;a href=&quot;#1、端口概述&quot; class=&quot;headerlink&quot; title=&quot;1、端口概述&quot;&gt;&lt;/a&gt;1、端口概述&lt;/h4&gt;&lt;p&gt;在Internet上，各主机间通过TCP/TP协议发送和接收数据报，各个数据报根据其目的主机的ip地址来进行互联网络中的路由选择。可见，把数据报顺利的传送到目的主机是没有问题的。问题出在哪里呢?我们知道大多数操作系统都支持多程序（进程）同时运行，那么目的主机应该把接收到的数据报传送给众多同时运行的进程中的哪一个呢？显然这个问题有待解决，端口机制便由此被引入进来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意，端口号只具有本地意义（即只对本地机器来说才有意义），它只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之TCP、UDP解析</title>
    <link href="http://yoursite.com/2018/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BTCP%E3%80%81UDP%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/17/计算机网络之TCP、UDP解析/</id>
    <published>2018-12-17T08:25:45.000Z</published>
    <updated>2018-12-17T08:29:16.114Z</updated>
    
    <content type="html"><![CDATA[<h4 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h4><p>OSI模型最初是用来作为开发网络通信协议族的一个工业参考标准。通过严格遵守OSI模型，不同的网络技术之间可以轻易地实现互操作。<br><img src="/uploads/2018/12/network_osi.png" alt=""><br><a id="more"></a></p><p>OSI模型包含许多被分割成层的组件。在网络数据通信的过程中，每一层完成一个特定的任务。当传输数据的时候，每一层接收到上面层格式化后的数据，对数据进行操作，然后把它传给下面的层。当接收数据的时候，每一层接收到下面层传过来的数据，对数据进行解包，然后把它传给上一层。</p><p>OSI模型的一个关键概念是虚电路。兼容OSI模型的网络栈的每一部分都不知道其上面层和下面层的行为和细节；它只是向上和向下传输数据。就模型的层次而言，每一层都有一虚电路直接连接目的主机上的对应层。就每一层而言，它的数据在目的层被解包的方式和被打包的方式是完全一样的。层不知道传输数据的实际细节；它们只知道数据是从周围层中传过来的。</p><h4 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h4><p>OSI模型是一种通用的、标准的、理论模型，今天市场上没有一个流行的网络协议完全遵守OSI模型，TCP/IP也不例外，TCP/IP协议族有自己的模型，被称为TCP/IP协议栈，又称DOD模型（Department of defense）<br><img src="/uploads/2018/12/network_tcp_ip_01.png" alt=""></p><blockquote><p>问：TCP/IP是什么？<br>答：TCP/IP是协议栈，并不是单指TCP协议、IP协议或者HTTP协议。仅仅是一个协议族，是一个统称。</p></blockquote><h4 id="TCP、UDP概述"><a href="#TCP、UDP概述" class="headerlink" title="TCP、UDP概述"></a>TCP、UDP概述</h4><h5 id="（1）用户数据报协议UDP（User-Datagram-Protocol）：UDP用户数据报"><a href="#（1）用户数据报协议UDP（User-Datagram-Protocol）：UDP用户数据报" class="headerlink" title="（1）用户数据报协议UDP（User Datagram Protocol）：UDP用户数据报"></a>（1）用户数据报协议UDP（User Datagram Protocol）：UDP用户数据报</h5><p>UDP在传送数据之前不需要先建立连接。远地主机的传输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。</p><h5 id="（2）传输控制协议TCP（Transmission-Control-Protocol）：TCP报文段"><a href="#（2）传输控制协议TCP（Transmission-Control-Protocol）：TCP报文段" class="headerlink" title="（2）传输控制协议TCP（Transmission Control Protocol）：TCP报文段"></a>（2）传输控制协议TCP（Transmission Control Protocol）：TCP报文段</h5><p>TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的传输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。</p><p><strong>使用UDP和TCP协议的各种应用和应用层协议</strong></p><table><thead><tr><th>应用</th><th>应用层协议</th><th>运输层协议</th></tr></thead><tbody><tr><td>域名解析</td><td>DNS</td><td>UDP</td></tr><tr><td>文件传送</td><td>TFTP</td><td>UDP</td></tr><tr><td>路由选择协议</td><td>RIP</td><td>UDP</td></tr><tr><td>IP地址配置</td><td>BOOTP，DHCP</td><td>UDP</td></tr><tr><td>网络管理</td><td>SNMP</td><td>UDP</td></tr><tr><td>远程文件服务器</td><td>NFS</td><td>UDP</td></tr><tr><td>多播</td><td>IGMP</td><td>UDP</td></tr><tr><td>万维网</td><td>HTTP</td><td>TCP</td></tr><tr><td>文件传送</td><td>FTP</td><td>TCP</td></tr><tr><td>远程终端接入</td><td>TELNET</td><td>TCP</td></tr></tbody></table><blockquote><p>题外话：如何将一个进程通过网络送到对应服务器的进程中？<br>解决这个问题的方法就是在传输层使用协议端口号（protocol port number），或通常简称为端口（port）。这就是说，虽然通信的终点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的目的端口（通过IP来完成），剩下的工作（即最后交付给目的进程）就由TCP来完成。</p><blockquote><p>请注意，这种在协议栈层间的抽象的协议端口是软件端口，和路由器或交换机上的硬件端口（应该称为接口）是完全不同的概念。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。</p></blockquote></blockquote><blockquote><p>扩展：TCP/IP的传输层用一个16位端口号来标志一个端口。但请注意，端口号只具有本地意义（即本机机器来说才有意义），它只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口。16位的端口号可允许有65535个不同的端口号，这个数目对一个计算机来说是足够用的。</p></blockquote><h4 id="UDP解析"><a href="#UDP解析" class="headerlink" title="UDP解析"></a>UDP解析</h4><h5 id="1、主要特点："><a href="#1、主要特点：" class="headerlink" title="1、主要特点："></a>1、主要特点：</h5><p>（1）UDP是<strong>无连接</strong>的，即发送数据之前不需要建立连接（当然发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延。<br>（2）UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有许多参数）。<br>（3）UDP是<strong>面向报文</strong>的。发送方的UDP对应程序交下来的报文，在添加首部后就向下交付给IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是<strong>保留这些报文的边界</strong>。这就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。如下图，在接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付给上层的应用进程。<br>因此，<font color="red">应用程序必须选择合适大小的报文。</font>若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这回降低IP层的效率。反之，若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。<br><img src="/uploads/2018/12/network_udp_01.png" alt=""><br>（4）UDP<strong>没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。（这对某些实时应用是很重要的。）<br>（5）UDP<strong>支持一对一、一对多、多对一和多对多的交互通信</strong>。<br>（6）UDP的<strong>首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</p><blockquote><p>虽然某些实时应用需要使用没有拥塞控制的UDP，但当很多的源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，结果大家都无法正常接收。因此，不适用拥塞控制功能的UDP有可能会引起网络产生严重的拥塞问题。</p></blockquote><h5 id="2、UDP的首部格式"><a href="#2、UDP的首部格式" class="headerlink" title="2、UDP的首部格式"></a>2、UDP的首部格式</h5><p>用户数据报UDP有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节，由四个字段组成，每个字段的长度都是两个字节。各字段意义如下：</p><table><thead><tr><th>报头字段名</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td>源端口号</td><td>16</td><td>发送主机的UDP端口</td></tr><tr><td>目的端口号</td><td>16</td><td>目标主机的UDP端口</td></tr><tr><td>消息长度</td><td>16</td><td>UDP用户数据报的长度，其最小值是8（仅有首部）</td></tr><tr><td>校验和</td><td>16</td><td>检测UDP用户数据报在传输中是否有错。有错就丢弃</td></tr></tbody></table><p><img src="/uploads/2018/12/network_udp_02.png" alt=""><br>当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交最后的终点——应用进程。</p><h4 id="TCP解析"><a href="#TCP解析" class="headerlink" title="TCP解析"></a>TCP解析</h4><h5 id="1、主要特点：-1"><a href="#1、主要特点：-1" class="headerlink" title="1、主要特点："></a>1、主要特点：</h5><p>（1）TCP是<strong>面向连接的传输层协议</strong>。这就是说，应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。<br>（2）每一条TCP连接只能有<strong>两个端点（endpoint）</strong>，每一条TCP连接只能是点对点的（一对一）。<br>（3）TCP提供<strong>可靠交付</strong>的服务。也就是说，通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。<br>（4）TCP提供<strong>全双工通信</strong>。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。<br>（5）面向字节流。TCP中的<strong>“流”（stream）指的是流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和TCP的交互时一次一个数据块（大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的<strong>无结构的字节流。</strong>TCP并不知道所传送的字节流的含义。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块就把收到的字节流交付给了上层的应用程序）。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。当然，接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。</p><h5 id="2、TCP的连接"><a href="#2、TCP的连接" class="headerlink" title="2、TCP的连接"></a>2、TCP的连接</h5><p>TCP把连接作为最基本的抽象。TCP的许多特性都与TCP是面向连接的这个基本特性有关。<br>前面已经说过，每一条TCP连接有两个端点。那么，TCP连接的端点是什么呢？ 不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口。 TCP连接的端点叫做<strong>套接字（socket）或插口</strong>。根据RFC 793的定义：端口号<strong>拼接到（contatenated with）IP</strong>地址即构成了套接字。</p><p><font color="red">每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。</font>即：<br>    TCP连接 ::= {socket1, socket2} = {(IP1:port1), (IP2:port2)}</p><blockquote><p>应用编程接口API（Application Programming Interface），即传输层与应用程序之间的一种接口，称为socket API，并简称为socket。</p></blockquote><h5 id="3、TCP报文段的首部格式"><a href="#3、TCP报文段的首部格式" class="headerlink" title="3、TCP报文段的首部格式"></a>3、TCP报文段的首部格式</h5><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP的全部功能都提现在它首部中各字段的作用。只有弄清楚TCP首部各字段的作用才能掌握TCP的工作原理。</p><p>TCP报文段首部的前20个字节是固定的，如下图，后面有4N字节是根据需要而增加的选项（N是整数）。因此TCP首部的最小长度是20字节。<br><img src="/uploads/2018/12/network_tcp_01.png" alt=""></p><table><thead><tr><th>报头字段名</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td>源端口号</td><td>16</td><td>本地通信端口，支持TCP的多路复用机制</td></tr><tr><td>目的端口号</td><td>16</td><td>远地通信端口，支持TCP的多路复用机制</td></tr><tr><td>序号（SEQ）</td><td>32</td><td>数据段第一个数据字节的序号（除含有SYN的段外）；SYN段的SYN序号（建立本次连接的初始序号）</td></tr><tr><td>确认号（ACK）</td><td>32</td><td>表示本地希望接收的下一个数据字节的序号</td></tr><tr><td>数据偏移</td><td>4</td><td>指出该段中数据的初始位置（以32位为单位）</td></tr><tr><td>保留</td><td>6</td><td>保留为今后使用，但目前应置为0</td></tr><tr><td>控制字段（CTL）</td><td></td><td></td></tr><tr><td>    URG</td><td>1</td><td>紧急指针字段有效标志，即该段中携带紧急数据</td></tr><tr><td>    ACK</td><td>1</td><td>确认号字段有效标志</td></tr><tr><td>    PSH</td><td>1</td><td>PUSH操作的标志</td></tr><tr><td>    RST</td><td>1</td><td>要求异常终止通信连接的标志</td></tr><tr><td>    SYN</td><td>1</td><td>建立同步连接的标志</td></tr><tr><td>    FIN</td><td>1</td><td>本地数据发送已结束，终止连接的标志</td></tr><tr><td>窗口</td><td>16</td><td>本地接收窗口尺寸，即本地接收缓冲区大小</td></tr><tr><td>校验和</td><td>16</td><td>包括TCP报头和数据在内的校验和</td></tr><tr><td>紧急指针</td><td>16</td><td>从段序号开始的正向位移，指向紧急数据的最后一个字节</td></tr><tr><td>选项</td><td>可变</td><td>提供任选的服务</td></tr><tr><td>填充</td><td>可变</td><td>保证TCP报头以32位为边界对齐</td></tr></tbody></table><h5 id="4、TCP的连接与释放"><a href="#4、TCP的连接与释放" class="headerlink" title="4、TCP的连接与释放"></a>4、TCP的连接与释放</h5><p>用三次握手建立TCP连接：<br><img src="/uploads/2018/12/network_tcp_02.png" alt=""></p><p>TCP连接释放的过程：<br><img src="/uploads/2018/12/network_tcp_03.png" alt=""></p><p>为什么A在TIME-WAIT状态必须等待2MSL的时间呢？这有两个理由。</p><ul><li>第一，为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。</li><li>第二，防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。<br>B只要收到了A发出的确认，就进入CLOSED状态。同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接。我们注意到，B结束TCP连接的时间要比A早一些。</li></ul><blockquote><p>除时间等待计时器外，TCP还设有一个<strong>保活计时器（keepalive timer）</strong>。设想有这样的情况：客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75秒发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p></blockquote><h5 id="5、TCP高级知识点概述"><a href="#5、TCP高级知识点概述" class="headerlink" title="5、TCP高级知识点概述"></a>5、TCP高级知识点概述</h5><p>（1）TCP是怎么保证可靠传输的？<br>通过超时重传、选择确认、滑动窗口机制来保证可靠传输。</p><p>（2）TCP的keepalive保活机制？<br>通过保活计时器来确保TCP的keepalive的连接。</p><p>（3）TCP的时延、瓶颈及存在的障碍？<br>最常见的TCP相关时延，其中包括：</p><ul><li>TCP连接建立握手；</li><li>TCP慢启动拥塞控制；</li><li>数据聚集的Nagle算法；</li><li>用于捎带确认的TCP延迟确认算法；</li><li>TIME_WAIT时延和端口耗尽。</li></ul><p>（4）拥塞控制<br>所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。<br>TCP的流量控制：利用滑动窗口实现流量控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;OSI模型&quot;&gt;&lt;a href=&quot;#OSI模型&quot; class=&quot;headerlink&quot; title=&quot;OSI模型&quot;&gt;&lt;/a&gt;OSI模型&lt;/h4&gt;&lt;p&gt;OSI模型最初是用来作为开发网络通信协议族的一个工业参考标准。通过严格遵守OSI模型，不同的网络技术之间可以轻易地实现互操作。&lt;br&gt;&lt;img src=&quot;/uploads/2018/12/network_osi.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>线上TIME_WAIT日志记录总结</title>
    <link href="http://yoursite.com/2018/12/13/%E7%BA%BF%E4%B8%8ATIME-WAIT%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/13/线上TIME-WAIT日志记录总结/</id>
    <published>2018-12-13T07:55:57.000Z</published>
    <updated>2018-12-13T07:58:55.856Z</updated>
    
    <content type="html"><![CDATA[<p>首先发现的是平响太高了，之后又降下来了。然后，开始查询原因。下面是过程记录</p><p>刚开始是追寻的问题是： CLB的“心跳”突然没了？（注：CLB是负载均衡，心跳应该是CLB那边用来检测的。是一个文件。）<br><a id="more"></a><br>查看php-fpm数量，发现有434个；最后群里有人说是他调的<br><img src="/uploads/2018/12/network_timewait_001.jpg" alt=""><br><img src="/uploads/2018/12/network_timewait_002.png" alt=""></p><p>然后就开始查询为啥“心跳”没了。<br>回答：CLB改心跳检查接口的话，如果改动比较大，应该是大面积报。最后问题回归到我们这边。</p><p>回答为啥将PHP-FPM数量调高？<br>我理解是这样的，后端有请求时间过长的接口，然后PHP-FPM都用于处理了这些请求长的接口，然后堵住了，然后导致后边的请求都在等待，包括心跳的。<br>心跳5s超时，前端CLB自己断的连接，报的499.<br><img src="/uploads/2018/12/network_timewait_003.png" alt=""><br>所以，增加了fpm的进程数。</p><p>查看PHP的error。 只报进程数不够。突然频繁启动PHP进程，结果达到最大值了。<br><img src="/uploads/2018/12/network_timewait_004.jpg" alt=""></p><p><em>说明：在这个时间点，服务器内存和CPU也都没有问题。</em></p><p>在监控记录中发现，5xx的记录有一个高峰。如下图：<br><img src="/uploads/2018/12/network_timewait_005.jpg" alt=""><br>并且，报这么多错误，项目日志中并没有记录。（说明不是项目导致的问题）</p><p>然后有人在监控记录中有了新发现，如下图：<br><img src="/uploads/2018/12/network_timewait_006.jpg" alt=""><br><img src="/uploads/2018/12/network_timewait_007.jpg" alt=""></p><p><em>注：在双十一期间，机器是10台。双十一前是2台（并且量不高）。双十一之后恢复到2台（量比以前高了点）。</em></p><p>现在确定原因了，由于双十一之后量比以前增多了，导致 timewait 增多，2台机器的端口不能够满足那么大的连接。导致频频报5xx。</p><p><strong>解决方案：</strong><br>服务器降级，多开几台低配，降低 timewait。（注：timewait不可避免，只能通过增加机器，或者是调整服务端配置，提高timewait的回收速度。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先发现的是平响太高了，之后又降下来了。然后，开始查询原因。下面是过程记录&lt;/p&gt;
&lt;p&gt;刚开始是追寻的问题是： CLB的“心跳”突然没了？（注：CLB是负载均衡，心跳应该是CLB那边用来检测的。是一个文件。）&lt;br&gt;
    
    </summary>
    
      <category term="问题" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/"/>
    
      <category term="线上业务" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1/"/>
    
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HTTP之长连接、短连接</title>
    <link href="http://yoursite.com/2018/12/11/HTTP%E4%B9%8B%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/12/11/HTTP之长连接、短连接/</id>
    <published>2018-12-11T03:58:29.000Z</published>
    <updated>2018-12-11T04:33:36.561Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、什么是长连接、短连接？"><a href="#1、什么是长连接、短连接？" class="headerlink" title="1、什么是长连接、短连接？"></a>1、什么是长连接、短连接？</h4><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<code>Connection:keep-alive</code>。<br><a id="more"></a><br>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h4 id="2、TCP连接"><a href="#2、TCP连接" class="headerlink" title="2、TCP连接"></a>2、TCP连接</h4><p>当网络通信时采用TCP协议时，在真正的读写操作之前，客户端与服务器端之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时可以释放这个连接。连接的建立依靠“三次握手”，而释放则需要“四次握手”，所以每个连接的建立都是需要资源消耗和时间消耗的。<br>经典的三次握手建立连接示意图：<br><img src="/uploads/2018/12/network_tcp_01.jpg" alt=""><br><img src="/uploads/2018/12/network_tcp_02.png" alt=""><br>经典的四次握手关闭连接示意图：<br><img src="/uploads/2018/12/network_tcp_03.jpg" alt=""><br><img src="/uploads/2018/12/network_tcp_04.jpg" alt=""></p><h5 id="（1）TCP短连接"><a href="#（1）TCP短连接" class="headerlink" title="（1）TCP短连接"></a>（1）TCP短连接</h5><p>模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。</p><p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。</p><h5 id="（2）TCP长连接"><a href="#（2）TCP长连接" class="headerlink" title="（2）TCP长连接"></a>（2）TCP长连接</h5><p>我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p>TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。</p><p>如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：</p><ul><li>客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。</li><li>客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。</li><li>客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li><li>客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。</li></ul><blockquote><p>易混淆概念：TCP的keep alive和HTTP的Keep-alive<br>TCP的keep  alive是检查当前TCP连接是否活着；HTTP的Keep-alive是要让一个TCP连接活久点。它们是不同层次的概念。</p><blockquote><p>TCP keep alive的表现：<br>当一个连接“一段时间”没有数据通讯时，一方会发出一个心跳包（Keep Alive包），如果对方有回包则表明当前连接有效，继续监控。</p></blockquote></blockquote><blockquote><p>HTTP的Keep-alive<br>（1）HTTP Keep-Alive<br>在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。<br>使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。<br>但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。<br>（2）keepalvie timeout<br>Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住keepalive_timeout秒后，才开始关闭这个连接。<br>当httpd守护进程发送完一个响应后，理应马上主动关闭相应的tcp连接，设置 keepalive_timeout后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览发过来http请求，则关闭这个http连接。</p></blockquote><h4 id="3、长短连接的优缺点："><a href="#3、长短连接的优缺点：" class="headerlink" title="3、长短连接的优缺点："></a>3、长短连接的优缺点：</h4><p>长连接和短连接的产生在于client和server采取的关闭策略。不同的应用场景适合采用不同的策略。</p><p>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p><p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽</p><h4 id="4、长短连接操作过程："><a href="#4、长短连接操作过程：" class="headerlink" title="4、长短连接操作过程："></a>4、长短连接操作过程：</h4><ul><li>短连接：<br>操作步骤：连接-&gt;传输数据-&gt;关闭连接</li><li>长连接：<br>操作步骤：连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; 。。。 -&gt;关闭连接。</li></ul><h4 id="5、什么时候用长连接，短连接？"><a href="#5、什么时候用长连接，短连接？" class="headerlink" title="5、什么时候用长连接，短连接？  　　"></a>5、什么时候用长连接，短连接？  　　</h4><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 </p><p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p><p>参考文章：<br>HTTP长连接、短连接究竟是什么？：<a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">https://www.cnblogs.com/gotodsp/p/6366163.html</a><br>HTTP 的长连接和短连接：<a href="http://blog.jobbole.com/104108/" target="_blank" rel="noopener">http://blog.jobbole.com/104108/</a><br>http keep_alive 和 tcp keep_alive：<a href="https://blog.csdn.net/lys86_1205/article/details/21234867" target="_blank" rel="noopener">https://blog.csdn.net/lys86_1205/article/details/21234867</a><br>HTTP Keep-Alive模式：<a href="http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、什么是长连接、短连接？&quot;&gt;&lt;a href=&quot;#1、什么是长连接、短连接？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是长连接、短连接？&quot;&gt;&lt;/a&gt;1、什么是长连接、短连接？&lt;/h4&gt;&lt;p&gt;在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。&lt;/p&gt;
&lt;p&gt;而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：&lt;code&gt;Connection:keep-alive&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP之TIME_WAIT解析</title>
    <link href="http://yoursite.com/2018/12/11/HTTP%E4%B9%8BTIME-WAIT%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/11/HTTP之TIME-WAIT解析/</id>
    <published>2018-12-11T03:58:23.000Z</published>
    <updated>2018-12-11T04:32:39.956Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、查看服务器连接状态信息"><a href="#1、查看服务器连接状态信息" class="headerlink" title="1、查看服务器连接状态信息"></a>1、查看服务器连接状态信息</h4><p>查看服务器TCP链接状态信息：<br><code>netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</code></p><p>它会显示例如下面的信息：<br>TIME_WAIT 814<br>CLOSE_WAIT 1<br>FIN_WAIT1 1<br>ESTABLISHED 634<br>SYN_RECV 2<br>LAST_ACK 1</p><p>常用的三个状态是：ESTABLISHED 表示正在通信（表示正常数据传输状态），TIME_WAIT 表示主动关闭（表示处理完毕，等待超时结束的请求数），CLOSE_WAIT 表示被动关闭。<br><a id="more"></a><br>具体每种状态什么意思，看下图就明白了：<br><img src="/uploads/2018/12/network_timewait_00.gif" alt=""></p><p>这么多状态不用都记住，只要了解到我上面提到的最常见的三种状态的意义就可以了。一般不到万不得已的情况也不会去查看网络状态，如果服务器出了异常，百分之八九十都是下面两种情况：</p><ol><li>服务器保持了大量TIME_WAIT状态</li><li>服务器保持了大量CLOSE_WAIT状态</li></ol><p>因为linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，而且是“占着茅坑不使劲”，一旦达到句柄数上限，新的请求就无法被处理了，接着就是大量Too Many Open Files异常，tomcat崩溃。。。</p><h4 id="2、文件句柄说明"><a href="#2、文件句柄说明" class="headerlink" title="2、文件句柄说明"></a>2、文件句柄说明</h4><p>在Linux里头“一切皆文件”，提示“Too Many Open Files异常”表示句柄不够用了。对应可能就是socket或设备打开太多导致的。</p><p>linux在文件句柄的数目上有两个级别的限制。一个是系统级别的总数限制，一个是针对用户的限制。</p><h5 id="（1）系统级别的句柄操作"><a href="#（1）系统级别的句柄操作" class="headerlink" title="（1）系统级别的句柄操作"></a>（1）系统级别的句柄操作</h5><ul><li>查看系统的句柄限制：<br><code>sysctl -a | grep fs.file-max</code><br>或者<br><code>cat /proc/sys/fs/file-max</code></li><li>修改句柄数限制：<br><code>sysctl -w fs.file-max 797692</code><br>或者<br><code>echo &quot;797692&quot; &gt; /proc/sys/fs/file-max</code><br>两者作用是相同的，前者改内核参数，后者直接作用于内核参数在虚拟文件系统（procfs,psuedo file system）上对应的文件而已。<br>或者<br>修改内核参数 /etc/sysctl.conf<br><code>echo &quot;fs.file-max=797692&quot; &gt;&gt; /etc/sysctl.conf</code><br>（注：查看内核参数： sysctl -p）<br>*查看整个系统目前使用的文件句柄数量命令：<br><code>cat /proc/sys/fs/file-nr</code></li></ul><h5 id="（2）用户级别的句柄操作"><a href="#（2）用户级别的句柄操作" class="headerlink" title="（2）用户级别的句柄操作"></a>（2）用户级别的句柄操作</h5><ul><li>查看当前用户的文件句柄限制： ulimit -a</li><li>修改句柄数限制：<br>修改 /etc/security/limits.conf 增加下面代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*           soft   nofile       262140</span><br><span class="line">*           hard   nofile       262140</span><br><span class="line">*           soft   nproc        102400</span><br><span class="line">*           hard   nproc        102400</span><br></pre></td></tr></table></figure></li></ul><p>（注：*标识所有用户）<br>有两种限制，一种是soft软限制，在数目超过软限制的时候系统会给出warning警告，但是达到hard硬限制的时候系统将拒绝或者异常了。<br>（注：修改之后可能需要重启shell生效。）</p><h5 id="（3）其它操作"><a href="#（3）其它操作" class="headerlink" title="（3）其它操作"></a>（3）其它操作</h5><p>查看某个进程开了那些句柄： <code>lsof -p pid</code><br>某个进程开了几个句柄： <code>lsof -p pid | wc -l</code><br>可以看到某个目录/文件被什么进程占用了，显示已打开该目录或文件的所有进程信息： <code>lsof path/filename</code></p><h4 id="3、下面来讨论下这两种情况的处理方法："><a href="#3、下面来讨论下这两种情况的处理方法：" class="headerlink" title="3、下面来讨论下这两种情况的处理方法："></a>3、下面来讨论下这两种情况的处理方法：</h4><h5 id="（1）服务器保持了大量TIME-WAIT状态"><a href="#（1）服务器保持了大量TIME-WAIT状态" class="headerlink" title="（1）服务器保持了大量TIME_WAIT状态"></a>（1）服务器保持了大量TIME_WAIT状态</h5><p>这种情况比较常见，一些爬虫服务器或者WEB服务器（如果网管在安装的时候没有做内核参数优化的话）上经常会遇到这个问题，这个问题是怎么产生的呢？</p><p>从 上面的示意图可以看得出来，TIME_WAIT是主动关闭连接的一方保持的状态，对于爬虫服务器来说他本身就是“客户端”，在完成一个爬取任务之后，他就 会发起主动关闭连接，从而进入TIME_WAIT的状态，然后在保持这个状态2MSL（max segment lifetime）时间之后，彻底关闭回收资源。为什么要这么做？明明就已经主动关闭连接了为啥还要保持资源一段时间呢？这个是TCP/IP的设计者规定 的，主要出于以下两个方面的考虑：</p><ol><li>防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失）</li><li>可靠的关闭TCP连接。在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。另外这么设计TIME_WAIT 会定时的回收资源，并不会占用很大资源的，除非短时间内接受大量请求或者受到攻击。</li></ol><blockquote><p>关于MSL引用下面一段话：<br>MSL为一个TCP Segment（某一块TCP网路封包）从来源送到目的之间可续存的时间（也就是一个网路封包再网路上传输时能存活的时间），由于RFC 793 TCP传输协议是在1981年定义的，当时的网路速度不像现在的网路那样发达，你可以想象你从浏览器输入等到第一个byte出现要等4分钟吗？在现在的网路环境下几乎不可能有这种事情发生，因此我们大可将 TIME_WAIT 状态的续存时间大幅调低，好让连接口能更快空出来给其它连线使用。</p></blockquote><blockquote><p>再引用网络资源的一段话：<br>值 得一说的是，对于基于TCP的HTTP协议，关闭TCP连接的是Server端，这样，Server端会进入TIME_WAIT状态，可 想而知，对于访 问量大的Web Server，会存在大量的TIME_WAIT状态，假如server一秒钟接收1000个请求，那么就会积压 240*1000=240，000个 TIME_WAIT的记录，维护这些状态给Server带来负担。当然现代操作系统都会用快速的查找算法来管理这些 TIME_WAIT，所以对于新的 TCP连接请求，判断是否hit中一个TIME_WAIT不会太费时间，但是有这么多状态要维护总是不好。<br>HTTP协议1.1版规定default行为是Keep-Alive，也就是会重用TCP连接传输多个 request/response，一个主要原因就是发现了这个问题</p></blockquote><p>也就是说HTTP的交互跟上面画的那个图是不一样的，关闭连接的不是客户端，而是服务器，所以web服务器也是会出现大量的TIME_WAIT的情况的。这也说清楚了，为什么我的客户端服务器会出现大量CLOSE_WAIT的情况。</p><p>现在来说如何来解决这个问题。<br>解决思路很简单，就是让服务器能够快速回收和重用那些TIME_WAIT的资源。<br>下面来看一下我们对/etc/sysctl.conf文件的修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃,不应该大于255，默认值是5，对应于180秒左右时间   </span><br><span class="line">net.ipv4.tcp_syn_retries=2  </span><br><span class="line">#net.ipv4.tcp_synack_retries=2  </span><br><span class="line">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为300秒  </span><br><span class="line">net.ipv4.tcp_keepalive_time=1200  </span><br><span class="line">net.ipv4.tcp_orphan_retries=3  </span><br><span class="line">#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间  </span><br><span class="line">net.ipv4.tcp_fin_timeout=30    </span><br><span class="line">#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。  </span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096  </span><br><span class="line">#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_syncookies = 1  </span><br><span class="line">  </span><br><span class="line">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_reuse = 1  </span><br><span class="line">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_recycle = 1  </span><br><span class="line">  </span><br><span class="line">##减少超时前的探测次数   </span><br><span class="line">net.ipv4.tcp_keepalive_probes=5   </span><br><span class="line">##优化网络设备接收队列   </span><br><span class="line">net.core.netdev_max_backlog=3000</span><br></pre></td></tr></table></figure></p><p>修改完之后执行/sbin/sysctl -p让参数生效。</p><p>这里头主要注意到的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse </span><br><span class="line">net.ipv4.tcp_tw_recycle </span><br><span class="line">net.ipv4.tcp_fin_timeout </span><br><span class="line">net.ipv4.tcp_keepalive_*</span><br></pre></td></tr></table></figure></p><p>这几个参数。</p><blockquote><p>net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle的开启都是为了回收处于TIME_WAIT状态的资源。<br>net.ipv4.tcp_fin_timeout这个时间可以减少在异常情况下服务器从FIN-WAIT-2转到TIME_WAIT的时间。<br>net.ipv4.tcp_keepalive_*一系列参数，是用来设置服务器检测连接存活的相关配置。</p></blockquote><h5 id="（2）服务器保持了大量CLOSE-WAIT状态"><a href="#（2）服务器保持了大量CLOSE-WAIT状态" class="headerlink" title="（2）服务器保持了大量CLOSE_WAIT状态"></a>（2）服务器保持了大量CLOSE_WAIT状态</h5><p>TIME_WAIT状态可以通过优化服务器参数得到解决，因为发生TIME_WAIT的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的。</p><p>但是CLOSE_WAIT就不一样了，从上面的图可以看出来，如果一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出ack信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。个人觉得这种情况，通过服务器内核参数也没办法解决，服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行。</p><p>简单来说CLOSE_WAIT数目过大是由于被动关闭连接处理不当导致的。</p><blockquote><p>我说一个场景，服务器A会去请求服务器B上面的apache获取文件资源，正常情况下，如果请求成功，那么在抓取完资源后服务器A会主动发出关闭连接的请求，这个时候就是主动关闭连接，连接状态我们可以看到是TIME_WAIT。如果一旦发生异常呢？假设请求的资源服务器B上并不存在，那么这个时候就会由服务器B发出关闭连接的请求，服务器A就是被动的关闭了连接，如果服务器A被动关闭连接之后自己并没有释放连接，那就会造成CLOSE_WAIT的状态了。</p></blockquote><p>所以很明显，问题还是处在程序里头。</p><p>参考资料：<br>服务器TIME_WAIT和CLOSE_WAIT详解和解决办法：<a href="https://www.cnblogs.com/sunxucool/p/3449068.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunxucool/p/3449068.html</a><br>HttpClient4 TIME_WAIT和CLOSE_WAIT：<a href="https://www.cnblogs.com/caoyusongnet/p/9087633.html" target="_blank" rel="noopener">https://www.cnblogs.com/caoyusongnet/p/9087633.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、查看服务器连接状态信息&quot;&gt;&lt;a href=&quot;#1、查看服务器连接状态信息&quot; class=&quot;headerlink&quot; title=&quot;1、查看服务器连接状态信息&quot;&gt;&lt;/a&gt;1、查看服务器连接状态信息&lt;/h4&gt;&lt;p&gt;查看服务器TCP链接状态信息：&lt;br&gt;&lt;code&gt;netstat -n | awk &amp;#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它会显示例如下面的信息：&lt;br&gt;TIME_WAIT 814&lt;br&gt;CLOSE_WAIT 1&lt;br&gt;FIN_WAIT1 1&lt;br&gt;ESTABLISHED 634&lt;br&gt;SYN_RECV 2&lt;br&gt;LAST_ACK 1&lt;/p&gt;
&lt;p&gt;常用的三个状态是：ESTABLISHED 表示正在通信（表示正常数据传输状态），TIME_WAIT 表示主动关闭（表示处理完毕，等待超时结束的请求数），CLOSE_WAIT 表示被动关闭。&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之uniq</title>
    <link href="http://yoursite.com/2018/11/20/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Buniq/"/>
    <id>http://yoursite.com/2018/11/20/Linux命令之uniq/</id>
    <published>2018-11-20T09:21:20.000Z</published>
    <updated>2018-11-20T09:40:43.238Z</updated>
    
    <content type="html"><![CDATA[<p>uniq - 检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">　　uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--help][--version][输入文件][输出文件]</span><br><span class="line">参数：</span><br><span class="line">　　-c或--count 在每列旁边显示该行重复出现的次数。</span><br><span class="line">　　-d或--repeated 仅显示重复出现的行列。</span><br><span class="line">　　-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。</span><br><span class="line">　　-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。</span><br><span class="line">　　-u或--unique 仅显示出一次的行列。</span><br><span class="line">　　-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt; 指定要比较的字符。</span><br><span class="line">　　--help 显示帮助。</span><br><span class="line">　　--version 显示版本信息。</span><br><span class="line">　　[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；</span><br><span class="line">　　[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><strong>描述：</strong></p><ul><li>uniq 命令删除文件中的重复行。</li><li>uniq 命令读取由 InFile 参数指定的标准输入或文件。该命令首先比较相邻的行，然后除去第二行和该行的后续副本。重复的行一定相邻。（在发出 uniq 命令之前，请使用 sort 命令使所有重复行相邻。）</li></ul><p><strong>实例：</strong><br>testfile中的原有内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat testfile      #原有内容  </span><br><span class="line">test 30  </span><br><span class="line">test 30  </span><br><span class="line">test 30  </span><br><span class="line">Hello 95  </span><br><span class="line">Hello 95  </span><br><span class="line">Hello 95  </span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85  </span><br><span class="line">Linux 85</span><br></pre></td></tr></table></figure></p><p>使用uniq 命令删除重复的行后，有如下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ uniq testfile     #删除重复行后的内容  </span><br><span class="line">test 30  </span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85</span><br></pre></td></tr></table></figure></p><p>检查文件并删除文件中重复出现的行，并在行首显示该行重复出现的次数。使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ uniq -c testfile      #删除重复行后的内容  </span><br><span class="line">3 test 30             #前面的数字的意义为该行共出现了3次  </span><br><span class="line">4 Hello 95            #前面的数字的意义为该行共出现了4次  </span><br><span class="line">2 Linux 85            #前面的数字的意义为该行共出现了2次</span><br></pre></td></tr></table></figure></p><font color="red">（当重复的行并不相邻时，uniq 命令是不起作用的，即若文件内容为以下时，uniq 命令不起作用。必须辅以sort排序后再过滤。）</font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;uniq - 检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;语法：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　uniq [-cdu][-f&amp;lt;栏位&amp;gt;][-s&amp;lt;字符位置&amp;gt;][-w&amp;lt;字符位置&amp;gt;][--help][--version][输入文件][输出文件]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-c或--count 	在每列旁边显示该行重复出现的次数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-d或--repeated 仅显示重复出现的行列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-f&amp;lt;栏位&amp;gt;或--skip-fields=&amp;lt;栏位&amp;gt; 忽略比较指定的栏位。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-s&amp;lt;字符位置&amp;gt;或--skip-chars=&amp;lt;字符位置&amp;gt; 忽略比较指定的字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-u或--unique 仅显示出一次的行列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-w&amp;lt;字符位置&amp;gt;或--check-chars=&amp;lt;字符位置&amp;gt; 指定要比较的字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　--help 显示帮助。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　--version 显示版本信息。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的SAFE UPDATE MODE</title>
    <link href="http://yoursite.com/2018/11/20/MySQL%E4%B8%AD%E7%9A%84SAFE-UPDATE-MODE/"/>
    <id>http://yoursite.com/2018/11/20/MySQL中的SAFE-UPDATE-MODE/</id>
    <published>2018-11-20T09:20:17.000Z</published>
    <updated>2018-11-20T09:25:30.761Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面：此<code>SET SQL_SAFE_UPDATES=1</code>命令可防止代码无WHERE条件更新或删除操作。</p><p>在业务中发现一个问题，报错如下：<br><img src="/uploads/2018/11/mysql_safe_update_mode.png" alt=""><br><a id="more"></a><br>在使用 <code>update</code> 的时候，报如上错误。 根据图示可发现是因为开启了 update safe mode，然后where条件中的字段没有索引导致的。</p><p>经过查找，确实发现，MySQL有SAFE UPDATE MODE模式，可使用SQL语句更改：<br><code>SET SQL_SAFE_UPDATES = 0;</code><br>相当于是解除SAFE MODE模式，则可以更新删除了。</p><p>sql_safe_updates参数可以限制不带where条件的update/delete语句执行失败，这个参数设置后，可以防止业务bug/漏洞导致把整个表都更新或者删除（线上发生过的案例），也可以防止DBA在线误操作更新/删除整张表。</p><blockquote><p>官方解释：<br>当sql_safe_updates设置为1时，UPDATE :要有where，并查询条件必须使用为索引字段，或者使用limit，或者两个条件同时存在，才能正常执行。DELETE:where条件中带有索引字段可删除，where中查询条件不是索引，得必须有limit。主要是防止UPDATE和DELETE 没有使用索引导致变更及删除大量数据。系统参数默认值为0</p></blockquote><font color="red">（经验证发现，并不是唯一索引才行（网上某些说法如此），只要是含有索引的就OK。）</font><p>为了防止线上业务出现以下3种情况影响线上服务的正常使用和不小心全表数据删除:</p><ol><li>没有加where条件的全表更新操作</li><li>加了where 条件字段，但是where 字段 没有走索引的表更新</li><li>全表delete 没有加where 条件 或者where 条件没有 走索引</li></ol><p><strong>建议:</strong> DBA 开启此参数限制 ，可以避免线上业务数据误删除操作，但是需要先在测试库开启，这样可以可以先在测试库上补充短缺的表索引，测试验证没问题再部署到线上库 邮件部从去年开始已经在严选电商线上运行。</p><p><strong>业务逻辑：</strong><br>业务中开启SAFE MODE的场景是，由于出现过代码中有更新操作，而没有传where条件，导致全部更新（幸运的是，由于更新数据量过大，更新超时，导致数据并没有被更新成功。否则，数据就得回滚了。）。没有传where条件是因为没有进行过滤验证导致的。所以，DB那边就开启了UPDATE SAFE MODE模式。<br>开启这个之后，线上数据库某些表中的字段没有索引，而<font color="red">代码中却使用了没有索引的字段做where条件进行更新。</font>才引发上面的错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面：此&lt;code&gt;SET SQL_SAFE_UPDATES=1&lt;/code&gt;命令可防止代码无WHERE条件更新或删除操作。&lt;/p&gt;
&lt;p&gt;在业务中发现一个问题，报错如下：&lt;br&gt;&lt;img src=&quot;/uploads/2018/11/mysql_safe_update_mode.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
      <category term="优化" scheme="http://yoursite.com/categories/MySQL/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="MySQL优化" scheme="http://yoursite.com/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL加锁详解</title>
    <link href="http://yoursite.com/2018/11/20/MySQL%E5%8A%A0%E9%94%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/11/20/MySQL加锁详解/</id>
    <published>2018-11-20T09:19:29.000Z</published>
    <updated>2018-11-20T09:26:10.549Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-新建数据表："><a href="#1-新建数据表：" class="headerlink" title="1. 新建数据表："></a>1. 新建数据表：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">| test  | CREATE TABLE `test` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `age` tinyint(3) NOT NULL,</span><br><span class="line">  `hobby` varchar(200) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `name` (`name`),</span><br><span class="line">  KEY `hobby` (`hobby`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 |</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-设置事物隔离级别："><a href="#2-设置事物隔离级别：" class="headerlink" title="2. 设置事物隔离级别："></a>2. 设置事物隔离级别：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set tx_isolation=&apos;READ-COMMITTED&apos;;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| READ-COMMITTED  |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><h4 id="3-测试索引对于锁的影响（事务级别：READ-COMMITTED，默认级别（REPEATABLE-READ））"><a href="#3-测试索引对于锁的影响（事务级别：READ-COMMITTED，默认级别（REPEATABLE-READ））" class="headerlink" title="3. 测试索引对于锁的影响（事务级别：READ-COMMITTED，默认级别（REPEATABLE-READ））"></a>3. 测试索引对于锁的影响（事务级别：READ-COMMITTED，默认级别（REPEATABLE-READ））</h4><h5 id="①-只含有一个主键"><a href="#①-只含有一个主键" class="headerlink" title="① 只含有一个主键"></a>① 只含有一个主键</h5><p><code>delete from test where id = 10;</code><br>这个毋庸置疑，锁的肯定是主键。在id = 10的记录上加上锁即可。<br><img src="/uploads/2018/11/mysql_index_00.jpg" alt=""></p><h5 id="②-只含有一个唯一键"><a href="#②-只含有一个唯一键" class="headerlink" title="② 只含有一个唯一键"></a>② 只含有一个唯一键</h5><p><code>delete from test where id = 10;</code><br>这个id不是主键，而是一个Unique的二级索引键值。<br><img src="/uploads/2018/11/mysql_index_01.jpg" alt=""><br>由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。</p><blockquote><p>为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p></blockquote><h5 id="③-仅含有一个普通索引"><a href="#③-仅含有一个普通索引" class="headerlink" title="③ 仅含有一个普通索引"></a>③ 仅含有一个普通索引</h5><p><code>delete from test where id = 10;</code><br>相对于前两个的变化，id列上的约束又降低了，id列不再唯一，只有一个普通的索引。<br><img src="/uploads/2018/11/mysql_index_02.jpg" alt=""><br>根据此图，可以看到，首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与②唯一的区别在于，②最多只有一个满足等值查询的记录，而③会将所有满足查询条件的记录都加锁。</p><h5 id="④-即含有唯一键，也含有普通索引"><a href="#④-即含有唯一键，也含有普通索引" class="headerlink" title="④ 即含有唯一键，也含有普通索引"></a>④ 即含有唯一键，也含有普通索引</h5><p>（唯一索引和普通索引都会 加锁，其它地方使用主键加锁，死锁概率会增加）</p><h5 id="⑤-不含有索引-（聚簇索引上全部加锁）"><a href="#⑤-不含有索引-（聚簇索引上全部加锁）" class="headerlink" title="⑤ 不含有索引 （聚簇索引上全部加锁）"></a>⑤ 不含有索引 （聚簇索引上全部加锁）</h5><p><code>delete from test where id = 10;</code><br>(没有索引，只能走聚簇索引，进行全部扫描。)<br>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。<br><img src="/uploads/2018/11/mysql_index_03.jpg" alt=""><br>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。</p><h4 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4. 死锁"></a>4. 死锁</h4><p>死锁是指两个或者多个事务在同一资源上相互作用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。</p><h5 id="（1）互锁"><a href="#（1）互锁" class="headerlink" title="（1）互锁"></a>（1）互锁</h5><p><img src="/uploads/2018/11/mysql_deadlock_01.jpg" alt=""><br>最常见的死锁，每个事务执行两条SQL，分别持有了一把锁，然后加另一把锁，产生死锁。</p><h5 id="（2）数据查询顺序导致加锁"><a href="#（2）数据查询顺序导致加锁" class="headerlink" title="（2）数据查询顺序导致加锁"></a>（2）数据查询顺序导致加锁</h5><p><img src="/uploads/2018/11/mysql_deadlock_02.jpg" alt=""><br>虽然每个Session都只有一条语句，仍旧会产生死锁。要分析这个死锁，首先必须用到本文前面提到的MySQL加锁的规则。针对Session 1，从name索引出发，读到的[hdc, 1]，[hdc, 6]均满足条件，不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10]。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。</p><font color="red">（注：死锁的发生与否，并不在于事务中有多少条SQL语句，死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。）</font>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-新建数据表：&quot;&gt;&lt;a href=&quot;#1-新建数据表：&quot; class=&quot;headerlink&quot; title=&quot;1. 新建数据表：&quot;&gt;&lt;/a&gt;1. 新建数据表：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;| test  | CREATE TABLE `test` (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `name` varchar(50) NOT NULL DEFAULT &amp;apos;&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `age` tinyint(3) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `hobby` varchar(200) NOT NULL DEFAULT &amp;apos;&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (`id`),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UNIQUE KEY `name` (`name`),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY `hobby` (`hobby`)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 |&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>PHP-FPM配置文件详解</title>
    <link href="http://yoursite.com/2018/10/24/PHP-FPM%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/10/24/PHP-FPM配置文件详解/</id>
    <published>2018-10-24T09:15:18.000Z</published>
    <updated>2018-10-24T09:35:04.860Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>过滤php-fpm.conf文件中注释行。<br><code>grep -Env &quot;^$|;&quot; php-fpm.conf</code><br>grep - 过滤命令<br>　　-E - 使用正则表达示进行匹配<br>　　-n - 显示行号<br>　　-v - 剔除匹配的项（默认是筛选匹配的项）<br>　　^ - 开头匹配<br>　　$ - 代表空行<br>　　| - 正则中的或运算<br>　　; - ;开头行</p></blockquote><a id="more"></a><h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[www]</span><br><span class="line">user = www#进程的发起用户和用户组，用户user是必须设置，group不是</span><br><span class="line">group = www</span><br><span class="line">listen = 127.0.0.1:9000#监听ip和端口</span><br><span class="line"></span><br><span class="line">pm = dynamic#选择进程池管理器如何控制子进程的数量</span><br><span class="line">pm.max_children = 5</span><br><span class="line">pm.start_servers = 2</span><br><span class="line">pm.min_spare_servers = 1</span><br><span class="line">pm.max_spare_servers = 3</span><br><span class="line"> </span><br><span class="line">slowlog = /opt/webserver/logs/php/$pool.log.slow #用于记录慢请求</span><br><span class="line">request_slowlog_timeout = 3#慢日志请求超时时间，对一个php程序进行跟踪。</span><br><span class="line">;request_terminate_timeout = 0　　#终止请求超时时间，在worker进程被杀掉之后，提供单个请求的超时间隔。由于某种原因不停止脚本执行时，应该使用该选项，0表示关闭不启用</span><br></pre></td></tr></table></figure><blockquote><p>static： 对于子进程的开启数路给定一个锁定的值(pm.max_children)<br>dynamic： 子进程的数目为动态的，它的数目基于下面的指令的值(以下为dynamic适用参数)<br>　　pm.max_children： 同一时刻能够存货的最大子进程的数量<br>　　pm.start_servers： 在启动时启动的子进程数量<br>　　pm.min_spare_servers： 处于空闲”idle”状态的最小子进程，如果空闲进程数量小于这个值，那么相应的子进程会被创建<br>　　pm.max_spare_servers： 最大空闲子进程数量，空闲子进程数量超过这个值，那么相应的子进程会被杀掉。<br>ondemand： 在启动时不会创建，只有当发起请求链接时才会创建(pm.max_children, pm.process_idle_timeout)</p></blockquote><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>在php-fpm的配置文件中，有两个指令非常重要，就是”pm.max_children” 和 “request_terminate_timeout”</p><p>（1）第一个指令”pm.max_children” 确定了php-fpm的处理能力，原则上时越多越好，但这个是在内存足够打的前提下，每开启一个php-fpm进程要占用近30M左右的内存<br>如果请求访问较多，那么可能会出现502，504错误。对于502错误来说，属于繁忙进程而造成的，对于504来说，就是客户发送的请求在限定的时间内没有得到相应，过多的请求导致“504  Gateway  Time-out”。这里也有可能是服务器带宽问题。</p><p>（2）另外一个需要注意的指令”request_terminate_timeout”，它决定php-fpm进程的连接/发送和读取的时间，如果设置过小很容易出现”502 Bad Gateway” 和 “504  Gateway  Time-out”，默认为0，就是说没有启用，不加限制，但是这种设置前提是你的php-fpm足够健康，这个需要根据实际情况加以限定</p><h4 id="附属PHP-FPM配置文件"><a href="#附属PHP-FPM配置文件" class="headerlink" title="附属PHP-FPM配置文件"></a>附属PHP-FPM配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">pid = run/php-fpm.pid</span><br><span class="line">#pid设置，默认在安装目录中的var/run/php-fpm.pid，建议开启</span><br><span class="line"></span><br><span class="line">error_log = log/php-fpm.log</span><br><span class="line">#错误日志，默认在安装目录中的var/log/php-fpm.log</span><br><span class="line"></span><br><span class="line">log_level = notice</span><br><span class="line">#错误级别. 可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice.</span><br><span class="line"></span><br><span class="line">emergency_restart_threshold = 60</span><br><span class="line">emergency_restart_interval = 60s</span><br><span class="line">#表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。</span><br><span class="line"></span><br><span class="line">process_control_timeout = 0</span><br><span class="line">#设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.</span><br><span class="line"></span><br><span class="line">daemonize = yes</span><br><span class="line">#后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。</span><br><span class="line"></span><br><span class="line">listen = 127.0.0.1:9000</span><br><span class="line">#fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: &apos;ip:port&apos;, &apos;port&apos;, &apos;/path/to/unix/socket&apos;. 每个进程池都需要设置.</span><br><span class="line"></span><br><span class="line">listen.backlog = -1</span><br><span class="line">#backlog数，-1表示无限制，由操作系统决定，此行注释掉就行。backlog含义参考：http://www.3gyou.cc/?p=41</span><br><span class="line"></span><br><span class="line">listen.allowed_clients = 127.0.0.1</span><br><span class="line">#允许访问FastCGI进程的IP，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接</span><br><span class="line"></span><br><span class="line">listen.owner = www</span><br><span class="line">listen.group = www</span><br><span class="line">listen.mode = 0666</span><br><span class="line">#unix socket设置选项，如果使用tcp方式访问，这里注释即可。</span><br><span class="line"></span><br><span class="line">user = www</span><br><span class="line">group = www</span><br><span class="line">#启动进程的帐户和组</span><br><span class="line"></span><br><span class="line">pm = dynamic #对于专用服务器，pm可以设置为static。</span><br><span class="line">#如何控制子进程，选项有static和dynamic。如果选择static，则由pm.max_children指定固定的子进程数。如果选择dynamic，则由下开参数决定：</span><br><span class="line">pm.max_children #，子进程最大数</span><br><span class="line">pm.start_servers #，启动时的进程数</span><br><span class="line">pm.min_spare_servers #，保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程</span><br><span class="line">pm.max_spare_servers #，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理</span><br><span class="line"></span><br><span class="line">pm.max_requests = 1000</span><br><span class="line">#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 &apos;0&apos; 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.</span><br><span class="line"></span><br><span class="line">pm.status_path = /status</span><br><span class="line">#FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到</span><br><span class="line"></span><br><span class="line">ping.path = /ping</span><br><span class="line">#FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。</span><br><span class="line"></span><br><span class="line">ping.response = pong</span><br><span class="line">#用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong.</span><br><span class="line"></span><br><span class="line">request_terminate_timeout = 0</span><br><span class="line">#设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的&apos;max_execution_time&apos;因为某些特殊原因没有中止运行的脚本有用. 设置为 &apos;0&apos; 表示 &apos;Off&apos;.当经常出现502错误时可以尝试更改此选项。</span><br><span class="line"></span><br><span class="line">request_slowlog_timeout = 10s</span><br><span class="line">#当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 &apos;0&apos; 表示 &apos;Off&apos;</span><br><span class="line"></span><br><span class="line">slowlog = log/$pool.log.slow</span><br><span class="line">#慢请求的记录日志,配合request_slowlog_timeout使用</span><br><span class="line"></span><br><span class="line">rlimit_files = 1024</span><br><span class="line">#设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。</span><br><span class="line"></span><br><span class="line">rlimit_core = 0</span><br><span class="line">#设置核心rlimit最大限制值. 可用值: &apos;unlimited&apos; 、0或者正整数. 默认值: 系统定义值.</span><br><span class="line"></span><br><span class="line">chroot =</span><br><span class="line">#启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用.</span><br><span class="line"></span><br><span class="line">chdir =</span><br><span class="line">#设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时）</span><br><span class="line"></span><br><span class="line">catch_workers_output = yes</span><br><span class="line">#重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;过滤php-fpm.conf文件中注释行。&lt;br&gt;&lt;code&gt;grep -Env &amp;quot;^$|;&amp;quot; php-fpm.conf&lt;/code&gt;&lt;br&gt;grep - 过滤命令&lt;br&gt;　　-E - 使用正则表达示进行匹配&lt;br&gt;　　-n - 显示行号&lt;br&gt;　　-v - 剔除匹配的项（默认是筛选匹配的项）&lt;br&gt;　　^ - 开头匹配&lt;br&gt;　　$ - 代表空行&lt;br&gt;　　| - 正则中的或运算&lt;br&gt;　　; - ;开头行&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="PHP-FPM" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/PHP-FPM/"/>
    
    
      <category term="PHP-FPM" scheme="http://yoursite.com/tags/PHP-FPM/"/>
    
  </entry>
  
  <entry>
    <title>INI配置文件的格式</title>
    <link href="http://yoursite.com/2018/10/24/INI%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/24/INI配置文件的格式/</id>
    <published>2018-10-24T09:14:55.000Z</published>
    <updated>2018-10-24T09:26:34.226Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习Go语言的时候，发现好多Go框架中的配置文件都支持INI格式的。当然，不仅仅是Go框架，PHP语言的好多框架也使用INI格式的配置文件，例如Yaf等。因此，需要梳理一下INI格式。常用的配置文件格式还有很多，如XML配置文件等。<br><a id="more"></a></p><blockquote><p>在早期的windows桌面系统中主要是用INI文件作为系统的配置文件，从win95以后开始转向使用注册表，但是还有很多系统配置是使用INI文件的。其实INI文件就是简单的text文件，只不过这种txt文件要遵循一定的INI文件格式。现在的WINCE系统上也常常用INI文件作为配置文件。“.INI ”就是英文 “initialization”的头三个字母的缩写；当然INI file的后缀名也不一定是”.ini”也可以是”.cfg”，”.conf ”或者是”.txt”。</p></blockquote><h4 id="INI文件由节、键、值组成"><a href="#INI文件由节、键、值组成" class="headerlink" title="INI文件由节、键、值组成"></a>INI文件由节、键、值组成</h4><p><strong>节</strong><br>　　[section]  </p><p><strong>参数（键=值） </strong><br>　　name=value</p><p><strong>注解</strong><br>　　注解使用分号表示（;）。在分号后面的文字，直到该行结尾都全部为注解。</p><font color="red">INI文件的格式很简单，最基本的三个要素是：parameters，sections和comments。</font><h4 id="什么是parameters？"><a href="#什么是parameters？" class="headerlink" title="什么是parameters？"></a>什么是parameters？</h4><p>INI所包含的最基本的“元素”就是parameter；每一个parameter都有一个name和一个value，name和value是由等号“=”隔开。name在等号的左边。<br>如：<br>　　name = value</p><h4 id="什么是sections-？"><a href="#什么是sections-？" class="headerlink" title="什么是sections ？"></a>什么是sections ？</h4><p>所有的parameters都是以sections为单位结合在一起的。所有的section名称都是独占一行，并且sections名字都被方括号包围着（[ and ])。在section声明后的所有parameters都是属于该section。对于一个section没有明显的结束标志符，一个section的开始就是上一个section的结束，或者是end of the file。Sections一般情况下不能被nested，当然特殊情况下也可以实现sections的嵌套。<br>section如下所示：<br>　　[section]</p><h4 id="什么是comments-？"><a href="#什么是comments-？" class="headerlink" title="什么是comments ？"></a>什么是comments ？</h4><p>在INI文件中注释语句是以分号“；”开始的。所有的所有的注释语句不管多长都是独占一行直到结束的。在分号和行结束符之间的所有内容都是被忽略的。<br>注释实例如下：<br>;comments text</p><p>当然，上面讲的都是最经典的INI文件格式，随着使用的需求INI文件的格式也出现了很多变种；</p><h4 id="INI实例"><a href="#INI实例" class="headerlink" title="INI实例"></a>INI实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; last modified 1 April 2001 by John Doe</span><br><span class="line">[owner]</span><br><span class="line">name = John Doe</span><br><span class="line">organization = Acme Products</span><br><span class="line"></span><br><span class="line">[database]</span><br><span class="line">server=192.0.2.42</span><br><span class="line">; use IP address in case network name resolution is not working</span><br><span class="line">port=143</span><br><span class="line">file = &quot;acme payroll.dat&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习Go语言的时候，发现好多Go框架中的配置文件都支持INI格式的。当然，不仅仅是Go框架，PHP语言的好多框架也使用INI格式的配置文件，例如Yaf等。因此，需要梳理一下INI格式。常用的配置文件格式还有很多，如XML配置文件等。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码499解析</title>
    <link href="http://yoursite.com/2018/10/24/HTTP%E7%8A%B6%E6%80%81%E7%A0%81499%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/10/24/HTTP状态码499解析/</id>
    <published>2018-10-24T09:13:51.000Z</published>
    <updated>2018-10-24T09:32:04.934Z</updated>
    
    <content type="html"><![CDATA[<p>日志记录中HTTP状态码出现499错误有多种情况，我遇到的一种情况是nginx反代到一个永远打不开的后端，就这样了，日志状态记录是499、发送字节数是0。</p><p>499错误是什么？让我们看看NGINX的源码中的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx_string(ngx_http_error_495_page), /* 495, https certificate error */</span><br><span class="line">ngx_string(ngx_http_error_496_page), /* 496, https no certificate */</span><br><span class="line">ngx_string(ngx_http_error_497_page), /* 497, http to https */</span><br><span class="line">ngx_string(ngx_http_error_404_page), /* 498, canceled */</span><br><span class="line">ngx_null_string,                    /* 499, client has closed connection */</span><br></pre></td></tr></table></figure></p><p>可以看到，499对应的是 “client has closed connection”。这很有可能是因为服务器端处理的时间过长，客户端“不耐烦”了。<br><a id="more"></a></p><p><strong>Nginx 499错误的原因及解决方法</strong><br>打开Nginx的access.log发现在最后一次的提交是出现了HTTP1.1 499 0 -这样的错误，在百度搜索nginx 499错误，结果都是说客户端主动断开了连接。</p><p>但经过我的测试这显然不是客户端的问题，因为使用端口+IP直接访问后端服务器不存在此问题，后来测试nginx发现如果两次提交post过快就会出现499的情况，看来是nginx认为是不安全的连接，主动拒绝了客户端的连接.</p><p>但搜索相关问题一直找不到解决方法，最后终于在google上搜索到一英文论坛上有关于此错误的解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_ignore_client_abort on;</span><br><span class="line">Don’t know if this is safe.</span><br></pre></td></tr></table></figure></p><p>就是说要配置参数 proxy_ignore_client_abort on;<br>表示代理服务端不要主要主动关闭客户端连接。</p><p>以此配置重启nginx,问题果然得到解决。只是安全方面稍有欠缺，但比总是出现找不到服务器好多了。</p><p>还有一种原因是 我后来测试发现 确实是客户端关闭了连接,或者说连接超时 ,无论你设置多少超时时间多没用 原来是php进程不够用了 改善一下php进程数 问题解决 默认测试环境才开5个子进程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志记录中HTTP状态码出现499错误有多种情况，我遇到的一种情况是nginx反代到一个永远打不开的后端，就这样了，日志状态记录是499、发送字节数是0。&lt;/p&gt;
&lt;p&gt;499错误是什么？让我们看看NGINX的源码中的定义：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ngx_string(ngx_http_error_495_page), /* 495, https certificate error */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ngx_string(ngx_http_error_496_page), /* 496, https no certificate */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ngx_string(ngx_http_error_497_page), /* 497, http to https */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ngx_string(ngx_http_error_404_page), /* 498, canceled */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ngx_null_string,                    /* 499, client has closed connection */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到，499对应的是 “client has closed connection”。这很有可能是因为服务器端处理的时间过长，客户端“不耐烦”了。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Shell常用知识点总结</title>
    <link href="http://yoursite.com/2018/10/23/Shell%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/10/23/Shell常用知识点总结/</id>
    <published>2018-10-23T10:42:55.000Z</published>
    <updated>2018-10-23T10:49:08.709Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、整型变量自增的几种方法"><a href="#1、整型变量自增的几种方法" class="headerlink" title="1、整型变量自增的几种方法"></a>1、整型变量自增的几种方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line">a=$(($a+1))</span><br><span class="line">a=$[$a+1]</span><br><span class="line">a=`expr $a + 1`</span><br><span class="line">let a++</span><br><span class="line">let a+=1</span><br><span class="line">((a++))</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2、读取文件中的内容"><a href="#2、读取文件中的内容" class="headerlink" title="2、读取文件中的内容"></a>2、读取文件中的内容</h4><p>（1）直接读取对应文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">      echo $line     #这里可根据实际用途变化</span><br><span class="line">done &lt; urfile</span><br></pre></td></tr></table></figure></p><p>（2）使用管道符形式读取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">cat urfile | while read line</span><br><span class="line">do</span><br><span class="line">    echo $line</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>（注意：以上代码中urfile 为被读取的文件）</p><p>（3）将文件赋值给变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">last | while read wOne wTwo wThree</span><br><span class="line">do</span><br><span class="line">echo $wOne&quot;,&quot;$wTwo&quot;,&quot;$wThree</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h4 id="3、判断文件是否为空"><a href="#3、判断文件是否为空" class="headerlink" title="3、判断文件是否为空"></a>3、判断文件是否为空</h4><p><code>if [[ ! -s filename ]]</code> # 如果文件存在且为空，-s代表存在不为空，！将它取反</p><h4 id="4、比较两个字符串的大小"><a href="#4、比较两个字符串的大小" class="headerlink" title="4、比较两个字符串的大小"></a>4、比较两个字符串的大小</h4><p>&lt;    小于，在ASCII字母顺序下，如：<br>    <code>if [[ &quot;$a&quot; &lt; &quot;$b&quot; ]]</code><br>    <code>if [ &quot;$a&quot; \&lt; &quot;$b&quot; ]</code><br>&#60;    大于，在ASCII字母顺序下，如：<br>    <code>if [[ &quot;$a&quot; &gt; &quot;$b&quot; ]]</code><br>    <code>if [ &quot;$a&quot; \&gt; &quot;$b&quot; ]</code><br>注意：在[]结构中”&gt;”需要被转义。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、整型变量自增的几种方法&quot;&gt;&lt;a href=&quot;#1、整型变量自增的几种方法&quot; class=&quot;headerlink&quot; title=&quot;1、整型变量自增的几种方法&quot;&gt;&lt;/a&gt;1、整型变量自增的几种方法&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a=$(($a+1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a=$[$a+1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a=`expr $a + 1`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let a++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let a+=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;((a++))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux之常用命令集锦</title>
    <link href="http://yoursite.com/2018/10/12/Linux%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6/"/>
    <id>http://yoursite.com/2018/10/12/Linux之常用命令集锦/</id>
    <published>2018-10-12T04:24:19.000Z</published>
    <updated>2018-10-23T07:16:55.815Z</updated>
    
    <content type="html"><![CDATA[<p>Linux命令的格式是这样的：<br>　　<code>命令名称 [命令参数] [命令对象]</code><br>注意，命令名称、命令参数、命令对象之间请用空格键分隔。<br>命令对象一般是指要处理的文件、目录、用户等资源，而命令参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用--与-作为前缀。</p><p><strong>命令参数的长格式与短格式示例：</strong></p><table><thead><tr><th>长格式</th><th>man –help</th></tr></thead><tbody><tr><td>短格式</td><td>man -h</td></tr></tbody></table><a id="more"></a><p><strong>1、man</strong><br>man命令中常用按键以及用途</p><style>    table th:first-of-type {        width: 30%;    }</style><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>PaGe down</td><td>向下翻一页</td></tr><tr><td>PaGe up</td><td>向上翻一页</td></tr><tr><td>home</td><td>直接前往首页</td></tr><tr><td>end</td><td>直接前往尾页</td></tr><tr><td>/</td><td>从上至下搜索某个关键词，如“/linux”</td></tr><tr><td>?</td><td>从下至上搜索某个关键词，如“?linux”</td></tr><tr><td>n</td><td>定位到下一个搜索到的关键词</td></tr><tr><td>N</td><td>定位到上一个搜索到的关键词</td></tr><tr><td>q</td><td>退出帮助文档</td></tr></tbody></table><p><strong>man 命令帮助信息的结构以及意义</strong></p><table><thead><tr><th>结构名称</th><th>代表意义</th></tr></thead><tbody><tr><td>NAME</td><td>命令的名称</td></tr><tr><td>SYNOPSIS</td><td>参数的大致使用方法</td></tr><tr><td>DESCRIPTION</td><td>介绍说明</td></tr><tr><td>EXAMPLES</td><td>演示（附带简单说明）</td></tr><tr><td>OVERVIEW</td><td>概述</td></tr><tr><td>DEFAULTS</td><td>默认的功能</td></tr><tr><td>OPTIONS</td><td>具体的可用选项（带介绍）</td></tr><tr><td>ENVIRONMENT</td><td>环境变量</td></tr><tr><td>FILES</td><td>用到的文件</td></tr><tr><td>SEE ALSO</td><td>相关的资料</td></tr><tr><td>HISTORY</td><td>维护历史与联系方式</td></tr></tbody></table><h4 id="一、常用系统工作命令"><a href="#一、常用系统工作命令" class="headerlink" title="一、常用系统工作命令"></a>一、常用系统工作命令</h4><h5 id="1、echo-选项-命令"><a href="#1、echo-选项-命令" class="headerlink" title="1、echo [选项] 命令"></a>1、echo [选项] 命令</h5><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-e</td><td>若字符串出现以下字符，则特别加以处理，而不会将它当成一般文字输出（类似一些特殊字符）</td></tr><tr><td>-n</td><td>不要在最后自动换行</td></tr></tbody></table><h5 id="2、date命令"><a href="#2、date命令" class="headerlink" title="2、date命令"></a>2、date命令</h5><p>格式： date [选项] [+指定的格式]<br>date 命令中输入以“+”号开头的参数，即可按照指定格式来输出系统的时间或日期。<br><strong>date命令中的参数以及作用</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>%t</td><td>跳格[Tab 键]</td></tr><tr><td>%Y</td><td>年</td></tr><tr><td>%m</td><td>月</td></tr><tr><td>%d</td><td>日</td></tr><tr><td>%H</td><td>小时（00～23）</td></tr><tr><td>%I</td><td>小时（00～12）</td></tr><tr><td>%M</td><td>分钟（00～59）</td></tr><tr><td>%S</td><td>秒（00～59）</td></tr><tr><td>%j</td><td>今年中的第几天</td></tr></tbody></table><h5 id="3、reboot命令"><a href="#3、reboot命令" class="headerlink" title="3、reboot命令"></a>3、reboot命令</h5><h5 id="4、poweroff命令"><a href="#4、poweroff命令" class="headerlink" title="4、poweroff命令"></a>4、poweroff命令</h5><h5 id="5、wget命令"><a href="#5、wget命令" class="headerlink" title="5、wget命令"></a>5、wget命令</h5><p>wget 命令的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载</td></tr></tbody></table><h5 id="6、ps命令"><a href="#6、ps命令" class="headerlink" title="6、ps命令"></a>6、ps命令</h5><p>ps 命令的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><h5 id="7、top命令"><a href="#7、top命令" class="headerlink" title="7、top命令"></a>7、top命令</h5><h5 id="8、pidof命令"><a href="#8、pidof命令" class="headerlink" title="8、pidof命令"></a>8、pidof命令</h5><p>用于查询某个指定服务进程的PID值。<br>格式：pidof [参数] [服务名称]</p><h5 id="9、kill命令"><a href="#9、kill命令" class="headerlink" title="9、kill命令"></a>9、kill命令</h5><p>格式：kill [参数] [进程PID]</p><h5 id="10、killall命令"><a href="#10、killall命令" class="headerlink" title="10、killall命令"></a>10、killall命令</h5><p>格式：killall [参数] [服务名称]</p><h5 id="11、ln-命令"><a href="#11、ln-命令" class="headerlink" title="11、ln 命令"></a>11、ln 命令</h5><p>用于创建链接文件，格式为“ln [选项] 目标”。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-s</td><td>创建“符号链接”（如果不带-s 参数，则默认创建硬链接）</td></tr><tr><td>-f</td><td>强制创建文件或目录的链接</td></tr><tr><td>-i</td><td>覆盖前先询问</td></tr><tr><td>-v</td><td>显示创建链接的过程</td></tr></tbody></table><h5 id="12、scp-命令"><a href="#12、scp-命令" class="headerlink" title="12、scp 命令"></a>12、scp 命令</h5><p>scp（secure copy）是一个基于 SSH 协议在网络之间进行安全传输的命令，其格式为“scp [参数] 本地文件 远程帐户@远程 IP 地址:远程目录”。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-v</td><td>显示详细的连接进度</td></tr><tr><td>-P</td><td>指定远程主机的 sshd 端口号</td></tr><tr><td>-r</td><td>用于传送文件夹</td></tr><tr><td>-6</td><td>使用 IPv6 协议</td></tr></tbody></table><h4 id="二、系统状态检测命令"><a href="#二、系统状态检测命令" class="headerlink" title="二、系统状态检测命令"></a>二、系统状态检测命令</h4><p>查看Linux主机公网IP<br><code>curl ifconfig.me</code></p><h5 id="1、ifconfig命令"><a href="#1、ifconfig命令" class="headerlink" title="1、ifconfig命令"></a>1、ifconfig命令</h5><p>其实主要查看的就是网卡名称、inet 参数后面的 IP 地址、ether 参数后面的网卡物理地址（又称为 MAC 地址），<br>以及 RX、TX 的接收数据包与发送数据包的个数及累计流量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# ifconfig</span><br><span class="line">eno16777728: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</span><br><span class="line">inet 192.168.10.10 netmask 255.255.255.0 broadcast 192.168.10.255</span><br><span class="line">inet6 fe80::20c:29ff:fec4:a409 prefixlen 64 scopeid 0x20&lt;link&gt;</span><br><span class="line">ether 00:0c:29:c4:a4:09 txqueuelen 1000 (Ethernet)</span><br><span class="line">RX packets 36 bytes 3176 (3.1 KiB)</span><br><span class="line">RX errors 0 dropped 0 overruns 0 frame 0</span><br><span class="line">TX packets 38 bytes 4757 (4.6 KiB)</span><br><span class="line">TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</span><br></pre></td></tr></table></figure></p><h5 id="2、uname-命令"><a href="#2、uname-命令" class="headerlink" title="2、uname 命令"></a>2、uname 命令</h5><p>格式：uname [-a]</p><h5 id="3、uptime-命令"><a href="#3、uptime-命令" class="headerlink" title="3、uptime 命令"></a>3、uptime 命令</h5><p>查看系统的负载信息。格式为 uptime<br>平均负载值指的是系统在最近 1 分钟、5 分钟、15 分钟内的压力情况（下面加粗的信息部分）；<br>负载值越低越好，尽量不要长期超过 1，在生产环境中不要超过 5。</p><h5 id="4、free-命令"><a href="#4、free-命令" class="headerlink" title="4、free 命令"></a>4、free 命令</h5><p>用于显示当前系统中内存的使用量信息，格式为“free [-h]”。</p><h5 id="5、who命令"><a href="#5、who命令" class="headerlink" title="5、who命令"></a>5、who命令</h5><p>用于查看当前登入主机的用户终端信息，格式为“who [参数]”。</p><h5 id="6、last命令"><a href="#6、last命令" class="headerlink" title="6、last命令"></a>6、last命令</h5><p>用于查看所有系统的登录记录，格式为“last [参数]”。</p><h5 id="7、history命令"><a href="#7、history命令" class="headerlink" title="7、history命令"></a>7、history命令</h5><p>用于显示历史执行过的命令，格式为“history [-c]”。<br>默认显示1000，如果觉得 1000 不够用，还可以自定义/etc/profile 文件中的HISTSIZE 变量值。<br>在使用 history 命令时，如果使用-c 参数则会清空所有的命令历史记录。</p><h4 id="三、工作目录切换命令"><a href="#三、工作目录切换命令" class="headerlink" title="三、工作目录切换命令"></a>三、工作目录切换命令</h4><h5 id="1、pwd"><a href="#1、pwd" class="headerlink" title="1、pwd"></a>1、pwd</h5><h5 id="2、cd"><a href="#2、cd" class="headerlink" title="2、cd"></a>2、cd</h5><h5 id="3、ls"><a href="#3、ls" class="headerlink" title="3、ls"></a>3、ls</h5><h4 id="四、文本文件编辑命令"><a href="#四、文本文件编辑命令" class="headerlink" title="四、文本文件编辑命令"></a>四、文本文件编辑命令</h4><h5 id="1、查看文件"><a href="#1、查看文件" class="headerlink" title="1、查看文件"></a>1、查看文件</h5><p>cat： 由第一行开始显示档案内容<br>tac： 从最后一行开始显示，可以看出 tac 是 cat 的反向显示！<br>nl： 显示的时候，顺便输出行号！<br>more： 一页一页的显示档案内容，以百分比的形式分页显示。<br>less 与 more 类似，但是比 more 更好的是，他可以[pg dn][pg up]翻页！对于显示的内容可以使用”/字符”输入要查找的字符或者字符串并高亮显示。<br>head： 查看头几行<br>tail： 查看尾几行<br>od： 以二进制的方式读取档案内容！</p><h5 id="2、tr命令"><a href="#2、tr命令" class="headerlink" title="2、tr命令"></a>2、tr命令</h5><p>用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。</p><h5 id="3、wc命令"><a href="#3、wc命令" class="headerlink" title="3、wc命令"></a>3、wc命令</h5><p>用于统计指定文本的行数（-l）、字数（-w）、字节数（-c），格式为“wc [参数] 文本”。</p><h5 id="4、stat命令"><a href="#4、stat命令" class="headerlink" title="4、stat命令"></a>4、stat命令</h5><p>用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”。</p><h5 id="5、cut命令"><a href="#5、cut命令" class="headerlink" title="5、cut命令"></a>5、cut命令</h5><p>用于按“列”提取文本字符，格式为“cut [参数] 文本”。<br>使用-f 参数来设置需要看的列数，还需要使用-d 参数来设置间隔符号<br>示例：<code>cut -d: -f1 /etc/passwd</code></p><h5 id="6、diff命令"><a href="#6、diff命令" class="headerlink" title="6、diff命令"></a>6、diff命令</h5><p>用于比较多个文本文件的差异，格式为“diff [参数] 文件”。</p><h4 id="五、文件目录管理命令"><a href="#五、文件目录管理命令" class="headerlink" title="五、文件目录管理命令"></a>五、文件目录管理命令</h4><h5 id="1、touch命令"><a href="#1、touch命令" class="headerlink" title="1、touch命令"></a>1、touch命令</h5><p>用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。</p><h5 id="2、mkdir命令"><a href="#2、mkdir命令" class="headerlink" title="2、mkdir命令"></a>2、mkdir命令</h5><p>用于创建空白的目录，格式为“mkdir [选项] 目录”。</p><h5 id="3、cp命令"><a href="#3、cp命令" class="headerlink" title="3、cp命令"></a>3、cp命令</h5><p>用于复制文件或目录，格式为“cp [选项] 源文件 目标文件”。</p><h5 id="4、mv命令"><a href="#4、mv命令" class="headerlink" title="4、mv命令"></a>4、mv命令</h5><p>用于剪切文件或将文件重命名，格式为“mv [选项] 源文件 [目标路径|目标文件名]”。</p><h5 id="5、rm命令"><a href="#5、rm命令" class="headerlink" title="5、rm命令"></a>5、rm命令</h5><p>用于删除文件或目录，格式为“rm [选项] 文件”。</p><h5 id="6、dd命令"><a href="#6、dd命令" class="headerlink" title="6、dd命令"></a>6、dd命令</h5><p>用于按照指定大小和个数的数据块来复制文件或转换文件，格式为“dd [参数]”。<br>dd 命令的参数及其作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>if</td><td>输入的文件名称</td></tr><tr><td>of</td><td>输出的文件名称</td></tr><tr><td>bs</td><td>设置每个“块”的大小</td></tr><tr><td>count</td><td>设置要复制“块”的个数</td></tr></tbody></table><p>Linux系统中有一个名为/dev/zero 的设备文件，这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以使用它作为 dd命令的输入文件，来生成一个指定大小的文件。<br>例如我们可以用 dd 命令从/dev/zero 设备文件中取出一个大小为 560MB 的数据块，然后保存成名为 560_file 的文件。<br><code>dd if=/dev/zero of=560_file count=1 bs=560MB</code></p><h5 id="7、file命令"><a href="#7、file命令" class="headerlink" title="7、file命令"></a>7、file命令</h5><p>用于查看文件的类型，格式为“file 文件名”。</p><h4 id="六、打包压缩与搜索命令"><a href="#六、打包压缩与搜索命令" class="headerlink" title="六、打包压缩与搜索命令"></a>六、打包压缩与搜索命令</h4><h5 id="1、tar-命令"><a href="#1、tar-命令" class="headerlink" title="1、tar 命令"></a>1、tar 命令</h5><p>用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。<br>tar 命令的参数及其作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>创建压缩文件</td></tr><tr><td>-x</td><td>解开压缩文件</td></tr><tr><td>-t</td><td>查看压缩包内有哪些文件</td></tr><tr><td>-z</td><td>用 Gzip 压缩或解压</td></tr><tr><td>-j</td><td>用 bzip2 压缩或解压</td></tr><tr><td>-v</td><td>显示压缩或解压的过程</td></tr><tr><td>-f</td><td>目标文件名</td></tr><tr><td>-p</td><td>保留原始的权限与属性</td></tr><tr><td>-P</td><td>使用绝对路径来压缩</td></tr><tr><td>-C</td><td>指定解压到的目录</td></tr></tbody></table><p>注：-c 参数用于创建压缩文件，-x 参数用于解压文件，因此这两个参数不能同时使用。</p><p>非常推荐使用-v 参数向用户不断显示压缩或解压的过程。</p><ul><li>-C 参数用于指定要解压到哪个指定的目录。</li><li>-f 参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称。</li></ul><p>常用组合命令：<br><code>tar -czvf 压缩包名称.tar.gz 要打包的目录</code><br><code>tar -xzvf 压缩包名称.tar.gz -C 解压到的目录</code></p><h5 id="2、grep命令"><a href="#2、grep命令" class="headerlink" title="2、grep命令"></a>2、grep命令</h5><p>用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。<br>grep 命令的参数及其作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>将可执行文件（binary）当作文本文件（text）来搜索</td></tr><tr><td>-c</td><td>仅显示找到的行数</td></tr><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-n</td><td>显示行号</td></tr><tr><td>-v</td><td>反向选择—仅列出没有“关键词”的行</td></tr></tbody></table><p>最常用的参数：-n 参数用来显示搜索到信息的行号；-v 参数用于反选信息（即没有包含关键词的所有信息行）。</p><h5 id="3、find命令"><a href="#3、find命令" class="headerlink" title="3、find命令"></a>3、find命令</h5><p>用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”。<br>find 命令中的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-name</td><td>匹配名称</td></tr><tr><td>-perm</td><td>匹配权限（mode 为完全匹配，-mode 为包含即可）</td></tr><tr><td>-user</td><td>匹配所有者</td></tr><tr><td>-group</td><td>匹配所有组</td></tr><tr><td>-mtime -n +n</td><td>匹配修改内容的时间（-n 指 n 天以内，+n 指 n 天以前）</td></tr><tr><td>-atime -n +n</td><td>匹配访问文件的时间（-n 指 n 天以内，+n 指 n 天以前）</td></tr><tr><td>-ctime -n +n</td><td>匹配修改文件权限的时间（-n 指 n 天以内，+n 指 n 天以前）</td></tr><tr><td>-nouser</td><td>匹配无所有者的文件</td></tr><tr><td>-nogroup</td><td>匹配无所有组的文件</td></tr><tr><td>-newer f1 !f2</td><td>匹配比文件 f1 新但比 f2 旧的文件</td></tr><tr><td>–type b/d/c/p/l/f</td><td>匹配文件类型（后面的字母参数依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</td></tr><tr><td>-size</td><td>匹配文件的大小（+50KB 为查找超过 50KB 的文件，而-50KB 为查找小于 50KB 的文件）</td></tr><tr><td>-prune</td><td>忽略某个目录</td></tr><tr><td>-exec …… {}\;</td><td>后面可跟用于进一步处理搜索结果的命令（下文会有演示）</td></tr></tbody></table><blockquote><p>重点是 “-exec {}  \;” 参数，其中的{}表示find命令搜索出的每一个文件，并且命令的结尾必须是“\;”。<br><code>[root@linuxprobe ~]# find / -user linuxprobe -exec cp -a {} /root/findresults/ \;</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux命令的格式是这样的：&lt;br&gt;　　&lt;code&gt;命令名称 [命令参数] [命令对象]&lt;/code&gt;&lt;br&gt;注意，命令名称、命令参数、命令对象之间请用空格键分隔。&lt;br&gt;命令对象一般是指要处理的文件、目录、用户等资源，而命令参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用--与-作为前缀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令参数的长格式与短格式示例：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;长格式&lt;/th&gt;
&lt;th&gt;man –help&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;短格式&lt;/td&gt;
&lt;td&gt;man -h&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《Linux就该这么学》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8ALinux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux之常用知识点总结</title>
    <link href="http://yoursite.com/2018/10/12/Linux%E4%B9%8B%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/10/12/Linux之常用知识点总结/</id>
    <published>2018-10-12T04:24:05.000Z</published>
    <updated>2018-10-12T06:53:35.649Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、重置root管理员密码"><a href="#1、重置root管理员密码" class="headerlink" title="1、重置root管理员密码"></a>1、重置root管理员密码</h4><p><code>cat /etc/redhat-release</code>    查看系统信息<br>（1）重启 Linux 系统主机并出现引导界面时，按下键盘上的 e 键进入内核编辑界面<br>（2）在 linux16 参数这行的最后面追加“rd.break”参数，然后按下 Ctrl + X 组合键来运行修<br>改过的内核程序<br>（3）大约 30 秒过后，进入到系统的紧急求援模式<br>（4）依次输入以下命令，等待系统重启操作完毕，然后就可以使用新密码 linuxprobe 来登录<br>Linux 系统了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount,rw /sysroot</span><br><span class="line">chroot /sysroot</span><br><span class="line">passwd</span><br><span class="line">touch /.autorelabel</span><br><span class="line">exit</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="2、常用的RPM软件包命令"><a href="#2、常用的RPM软件包命令" class="headerlink" title="2、常用的RPM软件包命令"></a>2、常用的RPM软件包命令</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>安装软件的命令格式</td><td>rpm -ivh filename.rpm</td></tr><tr><td>升级软件的命令格式</td><td>rpm -Uvh filename.rpm</td></tr><tr><td>卸载软件的命令格式</td><td>rpm -e filename.rpm</td></tr><tr><td>查询软件描述信息的命令格式</td><td>rpm -qpi filename.rpm</td></tr><tr><td>列出软件文件信息的命令格式</td><td>rpm -qpl filename.rpm</td></tr><tr><td>查询文件属于哪个 RPM 的命令格式</td><td>rpm -qf filename</td></tr></tbody></table><h4 id="3、常见的Yum命令"><a href="#3、常见的Yum命令" class="headerlink" title="3、常见的Yum命令"></a>3、常见的Yum命令</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>yum repolist all</td><td>列出所有仓库</td></tr><tr><td>yum list all</td><td>列出仓库中所有软件包</td></tr><tr><td>yum info 软件包名称 查</td><td>看软件包信息</td></tr><tr><td>yum install 软件包名称</td><td>安装软件包</td></tr><tr><td>yum reinstall 软件包名称</td><td>重新安装软件包</td></tr><tr><td>yum update 软件包名称</td><td>升级软件包</td></tr><tr><td>yum remove 软件包名称</td><td>移除软件包</td></tr><tr><td>yum clean all</td><td>清除所有仓库缓存</td></tr><tr><td>yum check-update</td><td>检查可更新的软件包</td></tr><tr><td>yum grouplist</td><td>查看系统中已经安装的软件包组</td></tr><tr><td>yum groupinstall 软件包组</td><td>安装指定的软件包组</td></tr><tr><td>yum groupremove 软件包组</td><td>移除指定的软件包组</td></tr><tr><td>yum groupinfo 软件包组</td><td>查询指定的软件包组信息</td></tr></tbody></table><h4 id="4、RHEL7-systemctl常用命令"><a href="#4、RHEL7-systemctl常用命令" class="headerlink" title="4、RHEL7 systemctl常用命令"></a>4、RHEL7 systemctl常用命令</h4><p><strong>systemctl 管理服务的启动、重启、停止、重载、查看状态等常用命令</strong></p><table><thead><tr><th>System V init（RHEL 6）</th><th>systemctl RHEL 7</th><th>作用</th></tr></thead><tbody><tr><td>service foo start</td><td>systemctl start foo.service</td><td>启动服务</td></tr><tr><td>service foo restart</td><td>systemctl restart foo.service</td><td>重启服务</td></tr><tr><td>service foo stop</td><td>systemctl stop foo.service</td><td>停止服务</td></tr><tr><td>service foo reload</td><td>systemctl reload foo.service</td><td>重新加载配置文件（不终止服务）</td></tr><tr><td>service foo status</td><td>systemctl status foo.service</td><td>查看服务状态</td></tr></tbody></table><p><strong>systemctl 设置服务开机启动、不启动、查看各级别下服务启动状态等常用命令</strong></p><table><thead><tr><th>System V init（RHEL 6）</th><th>systemctl RHEL 7</th><th>作用</th></tr></thead><tbody><tr><td>chkconfig foo on</td><td>systemctl enable foo.service</td><td>开机自动启动</td></tr><tr><td>chkconfig foo off</td><td>systemctl disable foo.service</td><td>开机不自动启动</td></tr><tr><td>chkconfig foo</td><td>systemctl is-enabled foo.service</td><td>查看特定服务是否为开机自动启动</td></tr><tr><td>chkconfig –list</td><td>systemctl list-unit-files –type=service</td><td>查看各个级别下服务的启动与禁用情况</td></tr></tbody></table><h4 id="5、输入、输出重定向"><a href="#5、输入、输出重定向" class="headerlink" title="5、输入、输出重定向"></a>5、输入、输出重定向</h4><p><strong>输入重定向中用到的符号及其作用</strong></p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件 1 &gt; 文件2</td><td>将文件 1 作为命令的标准输入并将标准输出到文件 2</td></tr></tbody></table><p><strong>输出重定向中用到的符号及其作用</strong></p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h4 id="6、常用的转义字符"><a href="#6、常用的转义字符" class="headerlink" title="6、常用的转义字符"></a>6、常用的转义字符</h4><p><strong>4 个最常用的转义字符如下所示。</strong></p><ul><li>反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。</li><li>单引号（’’）：转义其中所有的变量为单纯的字符串。</li><li>双引号（””）：保留其中的变量属性，不进行转义处理。</li><li>反引号（``）：把其中的命令执行后返回结果。</li></ul><h4 id="7、Linux-系统中最重要的-10-个环境变量"><a href="#7、Linux-系统中最重要的-10-个环境变量" class="headerlink" title="7、Linux 系统中最重要的 10 个环境变量"></a>7、Linux 系统中最重要的 10 个环境变量</h4><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的 Shell 解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h4 id="8、Linux系统中常见的目录名称以及相应内容"><a href="#8、Linux系统中常见的目录名称以及相应内容" class="headerlink" title="8、Linux系统中常见的目录名称以及相应内容"></a>8、Linux系统中常见的目录名称以及相应内容</h4><table><thead><tr><th>目录名称</th><th>应放置文件的内容</th></tr></thead><tbody><tr><td>/boot</td><td>开启所需文件——内核、开机菜单以及所需配置文件等</td></tr><tr><td>/dev</td><td>以文件形式存放任何设备与接口</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/home</td><td>用户家目录</td></tr><tr><td>/bin</td><td>存放单用户模式下还可以操作的命令</td></tr><tr><td>/lib</td><td>开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数</td></tr><tr><td>/sbin</td><td>开机过程中需要的命令</td></tr><tr><td>/media</td><td>用于挂载设备文件的目录</td></tr><tr><td>/opt</td><td>放置第三方的软件</td></tr><tr><td>/root</td><td>系统管理员的家目录</td></tr><tr><td>/srv</td><td>一些网络服务的数据文件目录</td></tr><tr><td>/tmp</td><td>任何人均可使用的“共享”临时目录</td></tr><tr><td>/proc</td><td>虚拟文件系统，例如系统内核、进程、外部设备及网络状态等</td></tr><tr><td>/usr/local</td><td>用户自行安装的软件</td></tr><tr><td>/usr/sbin</td><td>Linux系统开机时不会使用到的软件/命令/脚本</td></tr><tr><td>/usr/share</td><td>帮助与说明文件，也可放置共享文件</td></tr><tr><td>/var</td><td>主要存放经常变化的文件，如日志</td></tr><tr><td>/lost+found</td><td>当文件系统发生错误时，将一些丢失的文件片段存放在这里</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、重置root管理员密码&quot;&gt;&lt;a href=&quot;#1、重置root管理员密码&quot; class=&quot;headerlink&quot; title=&quot;1、重置root管理员密码&quot;&gt;&lt;/a&gt;1、重置root管理员密码&lt;/h4&gt;&lt;p&gt;&lt;code&gt;cat /etc/redhat-release&lt;/code&gt;    查看系统信息&lt;br&gt;（1）重启 Linux 系统主机并出现引导界面时，按下键盘上的 e 键进入内核编辑界面&lt;br&gt;（2）在 linux16 参数这行的最后面追加“rd.break”参数，然后按下 Ctrl + X 组合键来运行修&lt;br&gt;改过的内核程序&lt;br&gt;（3）大约 30 秒过后，进入到系统的紧急求援模式&lt;br&gt;（4）依次输入以下命令，等待系统重启操作完毕，然后就可以使用新密码 linuxprobe 来登录&lt;br&gt;Linux 系统了。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mount -o remount,rw /sysroot&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;chroot /sysroot&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;passwd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;touch /.autorelabel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reboot&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《Linux就该这么学》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8ALinux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux之用户身份与权限</title>
    <link href="http://yoursite.com/2018/10/12/Linux%E4%B9%8B%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90/"/>
    <id>http://yoursite.com/2018/10/12/Linux之用户身份与权限/</id>
    <published>2018-10-12T04:23:54.000Z</published>
    <updated>2018-10-12T06:39:45.505Z</updated>
    
    <content type="html"><![CDATA[<p>在RHEL 7系统中，用户身份有下面这些：</p><ul><li>管理员UID为0：系统的管理员用户。</li><li>系统用户UID为1~999：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会有独立的系统用户负责运行，进而有效控制被破坏范围。</li><li>普通用户UID从1000开始：是由管理员创建的用于日常工作的用户。</li></ul><p>Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。<br>如果该用户以后被归纳入其他用户组，则这个其他用户组称之为扩展用户组。<br>（注：一个用户只有一个基本用户组，但是可以有多个扩展用户组。）<br><a id="more"></a></p><h4 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h4><h5 id="1、useradd-命令"><a href="#1、useradd-命令" class="headerlink" title="1、useradd 命令"></a>1、useradd 命令</h5><p>用于创建新的用户，格式为“useradd [选项] 用户名”。<br><strong>useradd 命令中的用户参数以及作用</strong></p><style>table th:first-of-type {    width: 20%;}</style><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-d</td><td>指定用户的家目录（默认为/home/username）</td></tr><tr><td>-e</td><td>账户的到期时间，格式为YYYY-MM-DD</td></tr><tr><td>-u</td><td>指定改用户的默认UID</td></tr><tr><td>-g</td><td>指定一个初始的用户基本组（必须已存在）</td></tr><tr><td>-G</td><td>指定一个或多个扩展用户组</td></tr><tr><td>-N</td><td>不创建与用户同名的基本用户组</td></tr><tr><td>-s</td><td>指定该用户的默认Shell解释器</td></tr></tbody></table><h5 id="2、groupadd-命令"><a href="#2、groupadd-命令" class="headerlink" title="2、groupadd 命令"></a>2、groupadd 命令</h5><p>用于创建用户组，格式为“groupadd [选项] 群组名”。</p><h5 id="3、usermod-命令"><a href="#3、usermod-命令" class="headerlink" title="3、usermod 命令"></a>3、usermod 命令</h5><p>用于修改用户的属性，格式为“usermod [选项] 用户名”。<br><strong>usermod 命令中的参数及作用</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>填写用户账户的备注信息</td></tr><tr><td>-d -m</td><td>参数-m 与参数-d 连用，可重新指定用户的家目录并自动把旧的数据转移过去</td></tr><tr><td>-e</td><td>账户的到期时间，格式为 YYYY-MM-DD</td></tr><tr><td>-g</td><td>变更所属用户组</td></tr><tr><td>-G</td><td>变更扩展用户组</td></tr><tr><td>-L</td><td>锁定用户禁止其登录系统</td></tr><tr><td>-U</td><td>解锁用户，允许其登录系统</td></tr><tr><td>-s</td><td>变更默认终端</td></tr><tr><td>-u</td><td>修改用户的 UID</td></tr></tbody></table><h5 id="4、passwd-命令"><a href="#4、passwd-命令" class="headerlink" title="4、passwd 命令"></a>4、passwd 命令</h5><p>用于修改用户密码、过期时间、认证信息等，格式为“passwd [选项] [用户名]”。<br><strong>passwd 命令中的参数以及作用</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-l</td><td>锁定用户，禁止其登录</td></tr><tr><td>-u</td><td>解除锁定，允许用户登录</td></tr><tr><td>–stdin</td><td>允许通过标准输入修改用户密码，如 echo “NewPassWord” &#124; passwd –stdin Username</td></tr><tr><td>-d</td><td>使该用户可用空密码登录系统</td></tr><tr><td>-e</td><td>强制用户在下次登录时修改密码</td></tr><tr><td>-S</td><td>显示用户的密码是否被锁定，以及密码所采用的加密算法名称</td></tr></tbody></table><h5 id="5、userdel-命令"><a href="#5、userdel-命令" class="headerlink" title="5、userdel 命令"></a>5、userdel 命令</h5><p>用于删除用户，格式为“userdel [选项] 用户名”。<br><strong>userdel 命令的参数以及作用</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-f</td><td>强制删除用户</td></tr><tr><td>-r</td><td>同时删除用户及用户家目录</td></tr></tbody></table><h4 id="二、文件权限与归属"><a href="#二、文件权限与归属" class="headerlink" title="二、文件权限与归属"></a>二、文件权限与归属</h4><p>Linux系统中一切都是文件。文件的类型不尽相同，因此Linux系统使用了不同的字符来加以区分，常见的字符如下所示：</p><ul><li>-: 普通文件</li><li>d: 目录文件</li><li>l: 链接文件</li><li>b: 块设备文件</li><li>c: 字符设备文件</li><li>p: 管道文件</li></ul><p>在 Linux 系统中，每个文件都有所属的所有者和所有组，并且规定了文件的所有者、所有组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。<br>对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。<br>对目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p><h4 id="三、文件的特殊权限"><a href="#三、文件的特殊权限" class="headerlink" title="三、文件的特殊权限"></a>三、文件的特殊权限</h4><h5 id="1、SUID（待补充）"><a href="#1、SUID（待补充）" class="headerlink" title="1、SUID（待补充）"></a>1、SUID（待补充）</h5><h5 id="2、SGID（待补充）"><a href="#2、SGID（待补充）" class="headerlink" title="2、SGID（待补充）"></a>2、SGID（待补充）</h5><h5 id="3、SBIT"><a href="#3、SBIT" class="headerlink" title="3、SBIT"></a>3、SBIT</h5><p>SBIT 特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。</p><h5 id="4、文件的隐藏属性"><a href="#4、文件的隐藏属性" class="headerlink" title="4、文件的隐藏属性"></a>4、文件的隐藏属性</h5><h6 id="（1）chattr-命令"><a href="#（1）chattr-命令" class="headerlink" title="（1）chattr 命令"></a>（1）chattr 命令</h6><p>用于设置文件的隐藏权限，格式为“chattr [参数] 文件”。<br>如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，<br>如果想要把某个隐藏功能移出文件，则需要追加“-参数”。<br><strong>chattr 命令中用于隐藏权限的参数及其作用</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>i</td><td>无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件</td></tr><tr><td>a</td><td>仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）</td></tr><tr><td>S</td><td>文件内容在变更后立即同步到硬盘（sync）</td></tr><tr><td>s</td><td>彻底从硬盘中删除，不可恢复（用 0 填充原文件所在硬盘区域）</td></tr><tr><td>A</td><td>不再修改这个文件或目录的最后访问时间（atime）</td></tr><tr><td>b</td><td>不再修改文件或目录的存取时间</td></tr><tr><td>D</td><td>检查压缩文件中的错误</td></tr><tr><td>d</td><td>使用 dump 命令备份时忽略本文件/目录</td></tr><tr><td>c</td><td>默认将文件或目录进行压缩</td></tr><tr><td>u</td><td>当删除该文件后依然保留其在硬盘中的数据，方便日后恢复</td></tr><tr><td>t</td><td>让文件系统支持尾部合并（tail-merging）</td></tr><tr><td>X</td><td>可以直接访问压缩文件中的内容</td></tr></tbody></table><h6 id="（2）lsattr-命令"><a href="#（2）lsattr-命令" class="headerlink" title="（2）lsattr 命令"></a>（2）lsattr 命令</h6><p>用于显示文件的隐藏权限，格式为“lsattr [参数] 文件”。</p><h5 id="5、su-命令与sudo服务"><a href="#5、su-命令与sudo服务" class="headerlink" title="5、su 命令与sudo服务"></a>5、su 命令与sudo服务</h5><h6 id="（1）su-命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）。"><a href="#（1）su-命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）。" class="headerlink" title="（1）su 命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）。"></a>（1）su 命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）。</h6><p>（注：当从 root 管理员切换到普通用户时是不需要密码验证的，而从普通用户切换成 root管理员就需要进行密码验证了；）</p><h6 id="（2）sudo-命令把特定命令的执行权限赋予给指定用户"><a href="#（2）sudo-命令把特定命令的执行权限赋予给指定用户" class="headerlink" title="（2）sudo 命令把特定命令的执行权限赋予给指定用户"></a>（2）sudo 命令把特定命令的执行权限赋予给指定用户</h6><p>用于给普通用户提供额外的权限来完成原本 root 管理员才能完成的任务，格式为“sudo [参数] 命令名称”。<br><strong>sudo 服务中的可用参数以及作用</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-h</td><td>列出帮助信息</td></tr><tr><td>-l</td><td>列出当前用户可执行的命令</td></tr><tr><td>-u</td><td>用户名或 UID 值 以指定的用户身份执行命令</td></tr><tr><td>-k</td><td>清空密码的有效时间，下次执行 sudo 时需要再次进行密码验证</td></tr><tr><td>-b</td><td>在后台执行指定的命令</td></tr><tr><td>-p</td><td>更改询问密码的提示语</td></tr></tbody></table><p><strong>总结来说，sudo 命令具有如下功能：</strong></p><ul><li>限制用户执行指定的命令：</li><li>记录用户执行的每一条命令；</li><li>配置文件（/etc/sudoers）提供集中的用户管理、权限与主机等参数；</li><li>验证密码的后 5 分钟内（默认值）无须再让用户再次验证密码。</li></ul><p><strong>修改sudo服务的配置文件：</strong><br>（注：只有root管理员才可以使用）</p><ol><li>使用visudo 命令打开 /etc/sudoers文件并编辑。</li><li>在<code>root ALL=(ALL) ALL</code> 改行下面新增加一行，修改对应用户名称</li><li>到此即可使用sudo服务，但是需要输入用户密码。免密使用可添加 NOPASSWD:ALL即可。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在RHEL 7系统中，用户身份有下面这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理员UID为0：系统的管理员用户。&lt;/li&gt;
&lt;li&gt;系统用户UID为1~999：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会有独立的系统用户负责运行，进而有效控制被破坏范围。&lt;/li&gt;
&lt;li&gt;普通用户UID从1000开始：是由管理员创建的用于日常工作的用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。&lt;br&gt;如果该用户以后被归纳入其他用户组，则这个其他用户组称之为扩展用户组。&lt;br&gt;（注：一个用户只有一个基本用户组，但是可以有多个扩展用户组。）&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《Linux就该这么学》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8ALinux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker之Dockerfile配置LNMP服务实战篇</title>
    <link href="http://yoursite.com/2018/09/30/Docker%E4%B9%8BDockerfile%E9%85%8D%E7%BD%AELNMP%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <id>http://yoursite.com/2018/09/30/Docker之Dockerfile配置LNMP服务实战篇/</id>
    <published>2018-09-30T04:13:48.000Z</published>
    <updated>2018-09-30T04:16:43.582Z</updated>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="http://blog.51cto.com/zpf666/1905555" target="_blank" rel="noopener">传送门</a><br>supervisor：<a href="https://www.cnblogs.com/zhoujinyi/p/6073705.html" target="_blank" rel="noopener">传送门</a><br>详细Dockers学习记录参考：<a href="https://www.cnblogs.com/CloudMan6/tag/%E5%AE%B9%E5%99%A8/default.html?page=10" target="_blank" rel="noopener">传送门</a></p><p>待整理…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考博客：&lt;a href=&quot;http://blog.51cto.com/zpf666/1905555&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;supervisor：&lt;a href=&quot;https://www.cnblogs.com
      
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker之手动配置LNMP服务实战篇</title>
    <link href="http://yoursite.com/2018/09/30/Docker%E4%B9%8B%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AELNMP%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <id>http://yoursite.com/2018/09/30/Docker之手动配置LNMP服务实战篇/</id>
    <published>2018-09-30T04:01:07.000Z</published>
    <updated>2018-09-30T04:07:04.253Z</updated>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="https://blog.csdn.net/xy752068432/article/details/75975065" target="_blank" rel="noopener">传送门</a></p><h5 id="1、安装MySQL"><a href="#1、安装MySQL" class="headerlink" title="1、安装MySQL"></a>1、安装MySQL</h5><ol><li><p>拉取MySQL5.6版本<br><code>docker pull mysql:5.6</code></p></li><li><p>创建并启动一个容器<br><code>docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=xy123456 --name test_mysql mysql:5.6</code></p><a id="more"></a></li><li><p>进入到mysql容器后，我们通过创建一个远程可以访问的用户，这样我们就能从别的主机访问到我们的数据库了。<br>（注：容器中默认是没有vim的，所以我们首先要安装vim,需要注意的是安装前记得先执行apt-get update命令，不然安装会出现问题。）<br><code>docker exec -it test_mysql /bin/bash</code></p></li></ol><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进入数据库授权并新建用户</span><br><span class="line">&gt;mysql -uroot -p &quot;xy123456&quot;</span><br><span class="line">&gt;create database test;</span><br><span class="line">&gt;grant all privileges on test.* to &apos;test&apos;@&apos;%&apos; identified by &apos;123456&apos;;</span><br><span class="line">&gt;grant all privileges on *.* to &apos;root&apos;@&apos;%&apos;;</span><br><span class="line">&gt;exit;</span><br></pre></td></tr></table></figure><h5 id="2、安装PHP"><a href="#2、安装PHP" class="headerlink" title="2、安装PHP"></a>2、安装PHP</h5><ol><li><p>拉取PHP版本<br><code>docker pull php:7.0-fpm</code></p></li><li><p>创建一个phpfpm容器<br><code>docker run -d -v $PWD/nginx/www/html:/var/www/html -p 9001:9000 --link test_mysql:mysql --name test_phpfpm php:7.0-fpm</code></p></li><li><p>进入容器中，并在 /var/www/html 下新建一个 index.php文件；查看宿主机中的 ./nginx/www/html下是否也有 index.php</p></li><li><p>在容器中，需要安装<code>pdo_mysql</code>模块，在docker容器中可以这样来安装<br><code>docker-php-ext-install pdo_mysql</code><br>然后，通过命令 <code>php -m</code> 查看我们的PHP所有模块（后面会用到PDO来测试数据库的连通性）。</p></li></ol><h5 id="3、安装Nginx"><a href="#3、安装Nginx" class="headerlink" title="3、安装Nginx"></a>3、安装Nginx</h5><ol><li><p>拉取Nginx版本<br><code>docker pull nginx:1.10.3</code></p></li><li><p>创建一个Nginx容器<br><code>docker run -d -p 8080:80 --name test_nginx -v $PWD/nginx/www/html:/var/www/html --link test_phpfpm:phpfpm nginx:1.10.3</code></p></li><li><p>进入容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y vim</span><br><span class="line">apt-get install -y net-tools</span><br></pre></td></tr></table></figure></li></ol><p>再容器里找到nginx的配置文件，并修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root           /var/www/html;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    fastcgi_pass   phpfpm:9000;//这里改成我们之前--link进来的容器，也可以直接用php容器的ip</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME $document_root$fastcdi_script_name;//如果你的根目录和php容器的根目录不一样，这里的$document_root需要换成你php下的根目录，不然php就找不到文件了</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>（注：docker容器中服务修改配置，需要重新启动，才能生效。）</strong></p><h5 id="4、测试连通性"><a href="#4、测试连通性" class="headerlink" title="4、测试连通性"></a>4、测试连通性</h5><ol><li>直接访问nginx，检测nginx端口是否映射成功。（失败可在容器中查看nginx日志。）</li><li>访问php文件，检测nginx与php的连通性。（失败可查看容器日志，<code>docker logs container_id -f</code>）</li><li>通过php文件操作数据库，检测nginx、php与mysql的连通性。</li></ol><p>检测代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">try &#123;</span><br><span class="line">    $con = new PDO(&apos;mysql:host=mysql;dbname=test&apos;, &apos;xuye&apos;, &apos;xy123456&apos;);</span><br><span class="line">    $con-&gt;query(&apos;SET NAMES UTF8&apos;);</span><br><span class="line">    $res =  $con-&gt;query(&apos;select * from test&apos;);</span><br><span class="line">    while ($row = $res-&gt;fetch(PDO::FETCH_ASSOC)) &#123;</span><br><span class="line">        echo &quot;id:&#123;$row[&apos;id&apos;]&#125; name:&#123;$row[&apos;name&apos;]&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (PDOException $e) &#123;</span><br><span class="line">     echo &apos;错误原因：&apos;  . $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结说明：</p><ol><li>同一个host下容器之间通信，由于现在的版本，只要默认生成的容器，都会加入到Docker默认的docker0网络下。相互之间可通信。（缺点：相同端口的容器只可开启一个容器。）</li><li>承接上面，在生成容器的时候，可不添加 –link仍可相互通信。（已验证。–link可更改容器中使用的容器名称）</li></ol><p><strong>常用命令特殊安装：</strong></p><table><thead><tr><th>安装命令</th><th>安装包</th><th>命令</th></tr></thead><tbody><tr><td>ps</td><td>procps</td><td>apt-get install -y procps</td></tr><tr><td>netstat</td><td>net-tools</td><td>apt-get install -y net-tools</td></tr><tr><td>ping</td><td>inetutils-ping</td><td>apt-get install inetutils-ping</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考博客：&lt;a href=&quot;https://blog.csdn.net/xy752068432/article/details/75975065&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;1、安装MySQL&quot;&gt;&lt;a href=&quot;#1、安装MySQL&quot; class=&quot;headerlink&quot; title=&quot;1、安装MySQL&quot;&gt;&lt;/a&gt;1、安装MySQL&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;拉取MySQL5.6版本&lt;br&gt;&lt;code&gt;docker pull mysql:5.6&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建并启动一个容器&lt;br&gt;&lt;code&gt;docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=xy123456 --name test_mysql mysql:5.6&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker之容器间通信</title>
    <link href="http://yoursite.com/2018/09/30/Docker%E4%B9%8B%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2018/09/30/Docker之容器间通信/</id>
    <published>2018-09-30T04:00:38.000Z</published>
    <updated>2018-09-30T04:08:03.837Z</updated>
    
    <content type="html"><![CDATA[<p>容器之间可通过 IP，Docker DNS Server 或 joined 容器三种方式通信。</p><h4 id="IP-通信"><a href="#IP-通信" class="headerlink" title="IP 通信"></a>IP 通信</h4><p>两个容器要能通信，必须要有属于同一个网络的网卡。<br>满足这个条件后，容器就可以通过 IP 交互了。具体做法是在容器创建时通过 –network 指定相应的网络，或者通过 docker network connect 将现有容器加入到指定网络。<br><a id="more"></a></p><h4 id="Docker-DNS-Server"><a href="#Docker-DNS-Server" class="headerlink" title="Docker DNS Server"></a>Docker DNS Server</h4><p>通过 IP 访问容器虽然满足了通信的需求，但还是不够灵活。因为我们在部署应用之前可能无法确定 IP，部署之后再指定要访问的 IP 会比较麻烦。对于这个问题，可以通过 docker 自带的 DNS 服务解决。</p><p>从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过“容器名”通信。方法很简单，只要在启动时用 –name 为容器命名就可以了。</p><p>下面启动两个容器 bbox1 和 bbox2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network=my_net2 --name=bbox1 busybox</span><br><span class="line">docker run -it --network=my_net2 --name=bbox2 busybox</span><br></pre></td></tr></table></figure></p><p>然后，bbox2 就可以直接 ping 到 bbox1 了：<br><img src="/uploads/2018/09/docker-network-communication-01.jpg" alt=""></p><p>使用 docker DNS 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的。下面验证一下：<br>创建 bbox3 和 bbox4，均连接到 bridge 网络。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=bbox3 busybox</span><br><span class="line">docker run -it --name=bbox4 busybox</span><br></pre></td></tr></table></figure></p><p>bbox4 无法 ping 到 bbox3。<br><img src="/uploads/2018/09/docker-network-communication-02.jpg" alt=""></p><h4 id="joined-容器"><a href="#joined-容器" class="headerlink" title="joined 容器"></a>joined 容器</h4><p>joined 容器是另一种实现容器间通信的方式。<br>joined 容器非常特别，它可以使两个或多个容器共享一个网络栈，共享网卡和配置信息，joined 容器之间可以通过 127.0.0.1 直接通信。请看下面的例子：</p><p>先创建一个 httpd 容器，名字为 web1。<br><code>docker run -d -it --name=web1 httpd</code><br>然后创建 busybox 容器并通过 <code>--network=container:web1</code> 指定 jointed 容器为 web1：<br><img src="/uploads/2018/09/docker-network-communication-03.jpg" alt=""></p><p>请注意 busybox 容器中的网络配置信息，下面我们查看一下 web1 的网络：<br><img src="/uploads/2018/09/docker-network-communication-04.jpg" alt=""></p><p>看！busybox 和 web1 的网卡 mac 地址与 IP 完全一样，它们共享了相同的网络栈。busybox 可以直接用 127.0.0.1 访问 web1 的 http 服务。<br><img src="/uploads/2018/09/docker-network-communication-05.jpg" alt=""></p><p>joined 容器非常适合以下场景：</p><ol><li>不同容器中的程序希望通过 loopback 高效快速地通信，比如 web server 与 app server。</li><li>希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。</li></ol><p>容器之间的通信我们已经搞清楚了，接下来要考虑的是容器如何与外部世界通信？</p><h4 id="容器如何访问到外部世界？"><a href="#容器如何访问到外部世界？" class="headerlink" title="容器如何访问到外部世界？"></a>容器如何访问到外部世界？</h4><p><strong>容器默认就能访问外网。</strong><br>详细信息查看博客：<a href="https://www.cnblogs.com/CloudMan6/p/7107407.html" target="_blank" rel="noopener">传送门</a></p><h4 id="外部世界如何访问容器？"><a href="#外部世界如何访问容器？" class="headerlink" title="外部世界如何访问容器？"></a>外部世界如何访问容器？</h4><p>答案是：<strong>端口映射。</strong></p><p>docker 可将容器对外提供服务的端口映射到 host 的某个端口，外网通过该端口访问容器。容器启动时通过-p参数映射端口：<br><img src="/uploads/2018/09/docker-network-communication-06.jpg" alt=""></p><p>容器启动后，可通过 docker ps 或者 docker port 查看到 host 映射的端口。在上面的例子中，httpd 容器的 80 端口被映射到 host 32773 上，这样就可以通过 <code>&lt;host ip&gt;:&lt;32773&gt;</code> 访问容器的 web 服务了。<br><img src="/uploads/2018/09/docker-network-communication-07.jpg" alt=""></p><p>除了映射动态端口，也可在 -p 中指定映射到 host 某个特定端口，例如可将 80 端口映射到 host 的 8080 端口：<br><img src="/uploads/2018/09/docker-network-communication-08.jpg" alt=""></p><p>每一个映射的端口，host 都会启动一个 docker-proxy 进程来处理访问容器的流量：<br><img src="/uploads/2018/09/docker-network-communication-09.jpg" alt=""></p><p>以 0.0.0.0:32773-&gt;80/tcp 为例分析整个过程：<br><img src="/uploads/2018/09/docker-network-communication-10.jpg" alt=""></p><ol><li>docker-proxy 监听 host 的 32773 端口。</li><li>当 curl 访问 10.0.2.15:32773 时，docker-proxy 转发给容器 172.17.0.2:80。</li><li>httpd 容器响应请求并返回结果。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器之间可通过 IP，Docker DNS Server 或 joined 容器三种方式通信。&lt;/p&gt;
&lt;h4 id=&quot;IP-通信&quot;&gt;&lt;a href=&quot;#IP-通信&quot; class=&quot;headerlink&quot; title=&quot;IP 通信&quot;&gt;&lt;/a&gt;IP 通信&lt;/h4&gt;&lt;p&gt;两个容器要能通信，必须要有属于同一个网络的网卡。&lt;br&gt;满足这个条件后，容器就可以通过 IP 交互了。具体做法是在容器创建时通过 –network 指定相应的网络，或者通过 docker network connect 将现有容器加入到指定网络。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
</feed>
