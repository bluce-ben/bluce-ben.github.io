<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-19T03:24:34.038Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FTP 客户端报错集锦</title>
    <link href="http://yoursite.com/2018/03/19/FTP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8A%A5%E9%94%99%E9%9B%86%E9%94%A6/"/>
    <id>http://yoursite.com/2018/03/19/FTP-客户端报错集锦/</id>
    <published>2018-03-19T03:19:53.000Z</published>
    <updated>2018-03-19T03:24:34.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、ftp-客户端连接报错，如下："><a href="#1、ftp-客户端连接报错，如下：" class="headerlink" title="1、ftp 客户端连接报错，如下："></a>1、ftp 客户端连接报错，如下：</h4><blockquote><p><img src="/uploads/2018/03/ftp_connect_error.png" alt="" title="ftp连接超时"></p></blockquote><p>经查看是因为 服务器端对应的 21号端口未开启，开启即可，命令如下：<br><code>iptables -I INPUT 4 -p tcp -m tcp --dport 21 -j ACCEPT</code><br><a id="more"></a></p><h4 id="2、ftp-客户端连接成功，而读取目录失败，如下："><a href="#2、ftp-客户端连接成功，而读取目录失败，如下：" class="headerlink" title="2、ftp 客户端连接成功，而读取目录失败，如下："></a>2、ftp 客户端连接成功，而读取目录失败，如下：</h4><blockquote><p><img src="/uploads/2018/03/ftp_writedir_error.png" alt="" title="ftp读取目录失败"></p></blockquote><p>经过查找，发现是因为ftp数据连接模式的问题，ftp连接模式有两种：PORT（主动模式）和PASV（被动模式）。两者的前面文章中已经说明两者的区别，在这里我选择“主动模式”，只开放ftp服务端20端口传输数据，客户端随机产生大于1024端口号。<br>然后，开启服务端20端口权限即可，命令如下：<br><code>iptables -I INPUT 4 -p tcp -m tcp --dport 20 -j ACCEPT</code></p><h4 id="3、ftp-客户端能够下载数据，却不能上传数据，如下："><a href="#3、ftp-客户端能够下载数据，却不能上传数据，如下：" class="headerlink" title="3、ftp 客户端能够下载数据，却不能上传数据，如下："></a>3、ftp 客户端能够下载数据，却不能上传数据，如下：</h4><blockquote><p><img src="/uploads/2018/03/ftp_trans_error.png" alt="" title="ftp文件传输错误"></p></blockquote><p>经过一番查找，发现应该是我本身一堆错误导致的。包括ftp 用户组使用但未创建，ftp用户根目录权限未给予正确的ftp用户组（注：根目录创建是root用户，因此所有者及所属组都是root。所以其他用户都不能操作）。因此，我做了如下修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 首先，创建用户组</span><br><span class="line">groupadd ftpgroup</span><br><span class="line"># 将用户添加进用户组</span><br><span class="line">usermod -g ftpgroup ftp1</span><br><span class="line"># 更改用户根目录所属组</span><br><span class="line">chown -R :ftpgroup ceshi/</span><br><span class="line"># 更改用户根目录所属组权限为可写</span><br><span class="line">chmod -R g+w ceshi/</span><br></pre></td></tr></table></figure></p><h4 id="4、ftp-拒绝登陆，如下："><a href="#4、ftp-拒绝登陆，如下：" class="headerlink" title="4、ftp 拒绝登陆，如下："></a>4、ftp 拒绝登陆，如下：</h4><blockquote><p><img src="/uploads/2018/03/ftp_refuse_error.png" alt="" title="ftp拒绝登陆"></p></blockquote><p>原因是配置文件中 <code>allow_writeable_chroot=YES</code> 不存在，而<code>chroot_local_user=YES</code>已经开启。所以导致 ftp 拒绝登陆。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、ftp-客户端连接报错，如下：&quot;&gt;&lt;a href=&quot;#1、ftp-客户端连接报错，如下：&quot; class=&quot;headerlink&quot; title=&quot;1、ftp 客户端连接报错，如下：&quot;&gt;&lt;/a&gt;1、ftp 客户端连接报错，如下：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/2018/03/ftp_connect_error.png&quot; alt=&quot;&quot; title=&quot;ftp连接超时&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经查看是因为 服务器端对应的 21号端口未开启，开启即可，命令如下：&lt;br&gt;&lt;code&gt;iptables -I INPUT 4 -p tcp -m tcp --dport 21 -j ACCEPT&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="FTP" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/"/>
    
    
      <category term="FTP" scheme="http://yoursite.com/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>FTP 服务器配置流程详解</title>
    <link href="http://yoursite.com/2018/03/19/FTP-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/19/FTP-服务器配置流程详解/</id>
    <published>2018-03-19T03:19:06.000Z</published>
    <updated>2018-03-19T03:31:29.475Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、修改-FTP服务器配置文件"><a href="#1、修改-FTP服务器配置文件" class="headerlink" title="1、修改 FTP服务器配置文件"></a>1、修改 FTP服务器配置文件</h4><p>① 安装完之后在/etc/vsftpd/路径下会存在三个配置文件。</p><blockquote><p><strong>vsftpd.conf：</strong> 主配置文件<br><strong>ftpusers：</strong> 指定哪些用户不能访问FTP服务器,这里的用户包括root在内的一些重要用户。<br><strong>user_list：</strong> 指定的用户是否可以访问ftp服务器，通过vsftpd.conf文件中的userlist_deny的配置来决定配置中的用户是否可以访问，userlist_enable=YES ，userlist_deny=YES ，userlist_file=/etc/vsftpd/user_list 这三个配置允许文件中的用户访问FTP。（<font color="red">注：文件中用户名一行一个</font>）</p></blockquote><a id="more"></a><blockquote><blockquote><ul><li>userlist_enable=YES, userlist_deny=NO(或缺省), user_list文件中的用户允许登陆，未出现在此文件中的用户不允许（默认）</li><li>userlist_enable=NO(或缺省), userlist_deny=YES, user_list文件中的用户不允许登陆，未出现再次文件中的用户允许</li><li>userlist_enable=YES, userlist_deny=YES, user_list文件中的用户不能访问FTP<br>（<font color="red">注：ftpusers文件中的用户为禁止登陆用户，此文件的权限大于user_list文件的权限</font>）</li></ul></blockquote></blockquote><p>② vsftpd.conf 默认配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# cat /etc/vsftpd/vsftpd.conf.bak | grep &apos;^[^#]&apos;</span><br><span class="line">anonymous_enable=YES</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">local_umask=022</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">xferlog_std_format=YES</span><br><span class="line">listen=NO</span><br><span class="line">listen_ipv6=YES</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">userlist_enable=YES</span><br><span class="line">tcp_wrappers=YES</span><br></pre></td></tr></table></figure></p><p>③ 设置 chroot 来限制用户根目录（一般此处是为了限制FTP用户到网站根目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>选项 <code>chroot_local_user=YES</code> 意味着本地用户将进入 chroot 环境，当登录以后默认情况下是其 home 目录。</li><li>选项 <code>chroot_list_file=/etc/vsftpd/chroot_list</code> 指定在此文件中的用户被限制在根目录中。（此文件缺省时，表示所有用户都被限制）</li><li>选项 <code>allow_writeable_chroot=YES</code> 可以允许 chroot 目录具有可写权限。（注：vsftpd默认是不允许chroot目录有可写权限）</li></ul></blockquote><h4 id="2、创建-FTP用户"><a href="#2、创建-FTP用户" class="headerlink" title="2、创建 FTP用户"></a>2、创建 FTP用户</h4><p>① 增加 FTP组<br><code>groupadd ftpgroup</code></p><p>② 增加用户并设置其目录为 /data/www/ceshi<br><code>useradd -g ftpgroup -d /data/www/ceshi -M ftp1</code></p><p>③ 设置用户口令<br><code>passwd ftp1</code></p><p>④ 更改用户根目录所属组及权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R :ftpgroup /data/www/ceshi</span><br><span class="line">chmod -R g+w /data/www/ceshi</span><br></pre></td></tr></table></figure></p><p>⑤ 将用户添加进 chroot_list文件：（即设置用户根目录）<br><code>vi /etc/vsftpd/chroot_list</code><br>（注：一行一个用户名）</p><p>⑥ 重启vsftpd<br><code>systemctl restart vsftpd.service</code></p><h4 id="3、测试-FTP"><a href="#3、测试-FTP" class="headerlink" title="3、测试 FTP"></a>3、测试 FTP</h4><p>可通过 FileZilla 连接FTP服务器<br><img src="/uploads/2018/03/ftp_filezilla_setting.png" alt="" title="FileZilla设置"></p><blockquote><p>① 点击‘文件’，打开站点管理器<br>② 如果有跳过此步，如果没有设置新站点<br>③ 协议选择“FTP文件传输协议”即可<br>④ 加密选择“普通FTP”即可<br>⑤ 传输设置 选择主动模式（即PORT模式）<br>⑥ 其它信息填写完整，点击连接</p></blockquote><p>如果报错，请看另一篇《FTP 客户端报错集锦》。</p><h4 id="4、常用-FTP命令总结"><a href="#4、常用-FTP命令总结" class="headerlink" title="4、常用 FTP命令总结"></a>4、常用 FTP命令总结</h4><h5 id="（1）建立用户账号"><a href="#（1）建立用户账号" class="headerlink" title="（1）建立用户账号"></a>（1）建立用户账号</h5><blockquote><p>useradd<br>　-c（备注）    加上备注文字<br>　-d（登入目录）        指定用户登入时的起始目录<br>　-g（群组）    指定用户所属的群组<br>　-s         指定用户登入后所使用的shell<br>例如：<code>useradd -d /alidata/www81/ceshi -g ftp -s /sbin/nologin ftp3</code></p></blockquote><h5 id="（2）删除用户账号"><a href="#（2）删除用户账号" class="headerlink" title="（2）删除用户账号"></a>（2）删除用户账号</h5><blockquote><p>userdel<br>语法： <code>userdel [-r] [用户账号]</code><br>补充说明：userdel 可删除用户账号与相关的文件。若不加参数，则仅删除用户账号，而不删除相关文件。<br>例如：<code>userdel -r ftp3</code></p></blockquote><h5 id="（3）修改用户账号"><a href="#（3）修改用户账号" class="headerlink" title="（3）修改用户账号"></a>（3）修改用户账号</h5><blockquote><p>usermod<br>语法： <code>usermod [-LU][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-g &lt;群组&gt;][-s ]</code><br>补充说明：可用来修改用户账号的各项设定<br>例如：<code>usermod -s /sbin/nologin tes</code></p></blockquote><h4 id="5、附本人配置的-vsftpd-conf"><a href="#5、附本人配置的-vsftpd-conf" class="headerlink" title="5、附本人配置的 vsftpd.conf"></a>5、附本人配置的 vsftpd.conf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=YES</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">local_umask=022</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">xferlog_std_format=YES</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line">listen=NO</span><br><span class="line">listen_ipv6=YES</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">userlist_enable=YES</span><br><span class="line">tcp_wrappers=YES</span><br><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、修改-FTP服务器配置文件&quot;&gt;&lt;a href=&quot;#1、修改-FTP服务器配置文件&quot; class=&quot;headerlink&quot; title=&quot;1、修改 FTP服务器配置文件&quot;&gt;&lt;/a&gt;1、修改 FTP服务器配置文件&lt;/h4&gt;&lt;p&gt;① 安装完之后在/etc/vsftpd/路径下会存在三个配置文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;vsftpd.conf：&lt;/strong&gt; 主配置文件&lt;br&gt;&lt;strong&gt;ftpusers：&lt;/strong&gt; 指定哪些用户不能访问FTP服务器,这里的用户包括root在内的一些重要用户。&lt;br&gt;&lt;strong&gt;user_list：&lt;/strong&gt; 指定的用户是否可以访问ftp服务器，通过vsftpd.conf文件中的userlist_deny的配置来决定配置中的用户是否可以访问，userlist_enable=YES ，userlist_deny=YES ，userlist_file=/etc/vsftpd/user_list 这三个配置允许文件中的用户访问FTP。（&lt;font color=&quot;red&quot;&gt;注：文件中用户名一行一个&lt;/font&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="FTP" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/"/>
    
    
      <category term="FTP" scheme="http://yoursite.com/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>FTP 服务器概述及安装、卸载</title>
    <link href="http://yoursite.com/2018/03/19/FTP-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%AE%89%E8%A3%85%E3%80%81%E5%8D%B8%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/03/19/FTP-服务器概述及安装、卸载/</id>
    <published>2018-03-19T03:18:10.000Z</published>
    <updated>2018-03-19T03:32:18.747Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、FTP概述"><a href="#1、FTP概述" class="headerlink" title="1、FTP概述"></a>1、FTP概述</h4><p>FTP（文件传输协议）是一个较老且最常用的标准网络协议，用于在两台计算机之间通过网络上传/下载文件。<br>FTP采用客户/服务器模式，客户机与服务器之间利用TCP建立连接，客户可以从服务器上下载文件，也可以把本地文件上传至服务器。<br>FTP服务器有匿名的和授权的两种。匿名的FTP服务器向公众开放，用户可以用“ftp”或“anonymous”为帐号，用电子邮箱地址为密码登录服务器；授权的FTP服务器必须用授权的账户名和密码才能登录服务器。通常匿名的用户权限较低，只能下载文件，不能上传文件。<br>客户机访问FTP服务器通常有两种方法：用FTP命令访问和用FTP客户端软件访问。</p><p>然而， FTP 最初的时候并不安全，因为它仅通过用户凭证（用户名和密码）传输数据，没有进行加密。如果你打算使用 FTP，需要考虑通过 SSL/TLS 配置 FTP 连接。否则，使用安全 FTP，比如 SFTP 会更好一些。<br><a id="more"></a></p><h4 id="2、知识点介绍"><a href="#2、知识点介绍" class="headerlink" title="2、知识点介绍"></a>2、知识点介绍</h4><h5 id="（1）FTP采用双TCP-连接方式"><a href="#（1）FTP采用双TCP-连接方式" class="headerlink" title="（1）FTP采用双TCP 连接方式"></a>（1）FTP采用双TCP 连接方式</h5><blockquote><p><strong>控制连接-使用TCP端口号21</strong><br>　　用于在FTP客户端和FTP服务器之间传输FTP控制命令及命令执行信息。控制连接在整个FTP会话期间一直保持打开。<br><strong>数据连接-使用TCP端口号20</strong><br>　　用于传输数据，包括数据上传、下载、文件列表发送等。数据传输结束后数据连接将终止。</p></blockquote><h5 id="（2）FTP传输方式"><a href="#（2）FTP传输方式" class="headerlink" title="（2）FTP传输方式"></a>（2）FTP传输方式</h5><blockquote><p>FTP主动数据传输方式<br>主动方式也称为PORT方式，是FTP协议最初定义的数据传输连接方式，主要特点是：</p><ul><li>FTP客户端通过向FTP服务器发送PORT命令，告诉服务器该客户端用于传输数据的临时端口号（大于1024的随机端口）</li><li>当需要传送数据时，<font color="red">服务器通过TCP端口号20与客户端的临时端口建立数据传输通道</font>，完成数据传输</li></ul></blockquote><p>在建立数据连接的过程中，由服务器主动发起连接，因此被称为主动方式。</p><blockquote><p>FTP被动数据传输方式<br>被动方式也称为PASV方式，被动方式的主要特点是：</p><ul><li>FTP客户端通过向FTP服务器发送PASV命令，告诉服务器进入被动方式。<font color="red">服务器选择临时端口号(1024~5000之间的随机端口)并告知客户端</font></li><li>当需要传送数据时，客户端主动与服务器的临时端口号建立数据传输通道，完成数据传输。</li></ul></blockquote><p>在整个过程中，由于服务器总是被动接收客户端的数据连接，因此被称为被动方式。</p><h5 id="（3）FTP用户的类型"><a href="#（3）FTP用户的类型" class="headerlink" title="（3）FTP用户的类型"></a>（3）FTP用户的类型</h5><p><strong>匿名用户：</strong>anonymous或ftp<br><strong>本地用户：</strong><br>　　帐号名称、密码等信息保存在passwd、shadow文件中<br><strong>虚拟用户：</strong><br>　　使用独立的帐号/密码数据文件<br>　　user_list zhangsan 123456 /var/pub</p><h4 id="3、在Centos-7中安装FTP-服务器"><a href="#3、在Centos-7中安装FTP-服务器" class="headerlink" title="3、在Centos 7中安装FTP 服务器"></a>3、在Centos 7中安装FTP 服务器</h4><p>非常简单，使用 yum只需要一条命令即可。<br><code>yum -y install vsftpd</code></p><h4 id="4、卸载FTP-服务器"><a href="#4、卸载FTP-服务器" class="headerlink" title="4、卸载FTP 服务器"></a>4、卸载FTP 服务器</h4><p>① 查看当前服务器中的vsftpd 包<br><code>rpm -qa|grep vsftpd</code><br>例如结果为：vsftpd-2.2.2-13.el6_6.1.x86_64</p><p>② 执行卸载<br><code>rpm -e vsftpd-2.2.2-13.el6_6.1.x86_64</code><br>返回：卸载时自动备份vsftp的用户列表文件</p><blockquote><p>warning: /etc/vsftpd/vsftpd.conf saved as /etc/vsftpd/vsftpd.conf.rpmsave<br>warning: /etc/vsftpd/user_list saved as /etc/vsftpd/user_list.rpmsave</p></blockquote><p>③ 删除上面的文件<br><code>rm -rf /etc/vsftpd</code></p><p>④ 查看vsftpd是否还在开机启动项中<br><code>chkconfig --list</code></p><p>⑤ 查看vsftpd运行状态<br><code>service vsftpd status</code></p><blockquote><p>返回：vsftpd: unrecognized service（无法识别vsftpd，说明卸载了vsftpd了）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、FTP概述&quot;&gt;&lt;a href=&quot;#1、FTP概述&quot; class=&quot;headerlink&quot; title=&quot;1、FTP概述&quot;&gt;&lt;/a&gt;1、FTP概述&lt;/h4&gt;&lt;p&gt;FTP（文件传输协议）是一个较老且最常用的标准网络协议，用于在两台计算机之间通过网络上传/下载文件。&lt;br&gt;FTP采用客户/服务器模式，客户机与服务器之间利用TCP建立连接，客户可以从服务器上下载文件，也可以把本地文件上传至服务器。&lt;br&gt;FTP服务器有匿名的和授权的两种。匿名的FTP服务器向公众开放，用户可以用“ftp”或“anonymous”为帐号，用电子邮箱地址为密码登录服务器；授权的FTP服务器必须用授权的账户名和密码才能登录服务器。通常匿名的用户权限较低，只能下载文件，不能上传文件。&lt;br&gt;客户机访问FTP服务器通常有两种方法：用FTP命令访问和用FTP客户端软件访问。&lt;/p&gt;
&lt;p&gt;然而， FTP 最初的时候并不安全，因为它仅通过用户凭证（用户名和密码）传输数据，没有进行加密。如果你打算使用 FTP，需要考虑通过 SSL/TLS 配置 FTP 连接。否则，使用安全 FTP，比如 SFTP 会更好一些。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="FTP" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/"/>
    
    
      <category term="FTP" scheme="http://yoursite.com/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>iptables 防火墙的规则设置</title>
    <link href="http://yoursite.com/2018/03/19/iptables-%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E8%A7%84%E5%88%99%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/03/19/iptables-防火墙的规则设置/</id>
    <published>2018-03-19T03:00:07.000Z</published>
    <updated>2018-03-19T03:14:46.082Z</updated>
    
    <content type="html"><![CDATA[<h4 id="iptables-常用命令及参数注释："><a href="#iptables-常用命令及参数注释：" class="headerlink" title="iptables 常用命令及参数注释："></a>iptables 常用命令及参数注释：</h4><blockquote><p>主要包含：<br><strong>命令表</strong><br>　　用来增加(-A、-I)删除(-D)修改(-R)查看(-L)规则等；<br><strong>常用参数</strong><br>　　用来指定协议(-p)、源地址(-s)、源端口(--sport)、目的地址(-d)、目的端口(--dport)、进入网卡(-i)、出去网卡(-o)等设定包信息（即什么样的包）；用来描述要处理包的信息。<br><strong>常用处理动作</strong><br>　　用 -j 来指定对包的处理(ACCEPT、DROP、REJECT、REDIRECT等)。</p></blockquote><a id="more"></a><p><strong>常用参数注释：</strong></p><p><font color="red">命令 -P, --policy</font><br>范例 <code>iptables -P INPUT DROP</code><br>说明 定义过滤政策。 也就是未符合过滤条件之封包，预设的处理方式。</p><p><font color="red">参数 --line-numbers</font><br>范例 <code>iptables -nL --line-numbers</code><br>说明 查询规则链表的number号。</p><p><font color="red">参数 -m state --state</font><br>范例 <code>iptables -A INPUT -m state --state RELATED,ESTABLISHED</code><br>说明 用来比对联机状态，联机状态共有四种：INVALID、ESTABLISHED、NEW 和 RELATED。</p><blockquote><p><strong>INVALID</strong> 表示该封包的联机编号（Session ID）无法辨识或编号不正确。<br><strong>ESTABLISHED</strong> 表示该封包属于某个已经建立的联机。<br><strong>NEW</strong> 表示该封包想要起始一个联机（重设联机或将联机重导向）。<br><strong>RELATED</strong> 表示该封包是属于某个已经建立的联机，所建立的新联机。例如：FTP-DATA 联机必定是源自某个 FTP 联机。</p></blockquote><h4 id="常用规则总结"><a href="#常用规则总结" class="headerlink" title="常用规则总结"></a>常用规则总结</h4><h5 id="（1）启动、停止和重启-iptables"><a href="#（1）启动、停止和重启-iptables" class="headerlink" title="（1）启动、停止和重启 iptables"></a>（1）启动、停止和重启 iptables</h5><p><code>systemctl start/stop/restart/status iptables.service</code></p><h5 id="（2）查看iptables-现有规则"><a href="#（2）查看iptables-现有规则" class="headerlink" title="（2）查看iptables 现有规则"></a>（2）查看iptables 现有规则</h5><p><code>iptables -L -n</code><br><code>iptables -Ln --line-numbers</code> #查看对应的规则numbers<br><code>iptables-save</code></p><h5 id="（3）屏蔽某个-IP"><a href="#（3）屏蔽某个-IP" class="headerlink" title="（3）屏蔽某个 IP"></a>（3）屏蔽某个 IP</h5><p><code>iptables -A INPUT -s xxx.xxx.xxx.xxx -j DROP</code><br>如果你只想屏蔽 TCP 流量，可以使用 -p 参数的指定协议，例如：<br><code>iptables -A INPUT -p tcp -s xxx.xxx.xxx.xxx -j DROP</code></p><h5 id="（4）解封某个-IP地址（即删除）"><a href="#（4）解封某个-IP地址（即删除）" class="headerlink" title="（4）解封某个 IP地址（即删除）"></a>（4）解封某个 IP地址（即删除）</h5><p><code>iptables -D INPUT -s xxx.xxx.xxx.xxx -j DROP</code><br>或<br><code>iptables -D INPUT numbers</code></p><h5 id="（5）关闭指定端口"><a href="#（5）关闭指定端口" class="headerlink" title="（5）关闭指定端口"></a>（5）关闭指定端口</h5><p>阻止特定的传出连接：<br><code>iptables -A OUTPUT -p tcp --dport xxx -j DROP</code><br>阻止特定的传入连接：<br><code>iptables -A INPUT -p tcp --dport xxx -j ACCEPT</code></p><h5 id="（6）使用Multiport控制多端口"><a href="#（6）使用Multiport控制多端口" class="headerlink" title="（6）使用Multiport控制多端口"></a>（6）使用Multiport控制多端口</h5><p>使用 multiport 我们可以一次性在单条规则中写入多个端口，例如：<br><code>iptables -A INPUT  -p tcp -m multiport --dports 22,80,443 -j ACCEPT</code><br><code>iptables -A OUTPUT -p tcp -m multiport --sports 22,80,443 -j ACCEPT</code></p><h5 id="（7）在规则中使用-IP-地址范围"><a href="#（7）在规则中使用-IP-地址范围" class="headerlink" title="（7）在规则中使用 IP 地址范围"></a>（7）在规则中使用 IP 地址范围</h5><p>在 IPtables 中 IP 地址范围是可以直接使用 CIDR 进行表示的，例如：<br><code>iptables -A OUTPUT -p tcp -d 192.168.100.0/24 --dport 22 -j ACCEPT</code></p><h5 id="（8）禁止PING"><a href="#（8）禁止PING" class="headerlink" title="（8）禁止PING"></a>（8）禁止PING</h5><p>对 Linux 禁 PING 可以使用如下规则屏蔽 ICMP 传入连接：<br><code>iptables -A INPUT -p icmp -i eth0 -j DROP</code></p><h5 id="（9）允许访问回环网卡"><a href="#（9）允许访问回环网卡" class="headerlink" title="（9）允许访问回环网卡"></a>（9）允许访问回环网卡</h5><p>环回访问（127.0.0.1）是比较重要的，建议大家都开放：<br><code>iptables -A INPUT -i lo -j ACCEPT</code><br><code>iptables -A OUTPUT -o lo -j ACCEPT</code></p><h5 id="（10）丢弃无效数据包"><a href="#（10）丢弃无效数据包" class="headerlink" title="（10）丢弃无效数据包"></a>（10）丢弃无效数据包</h5><p>很多网络攻击都会尝试用黑客自定义的非法数据包进行尝试，我们可以使用如下命令来丢弃无效数据包：<br><code>iptables -A INPUT -m conntrack --ctstate INVALID -j DROP</code></p><h5 id="（11）插入指定位置一条规则"><a href="#（11）插入指定位置一条规则" class="headerlink" title="（11）插入指定位置一条规则"></a>（11）插入指定位置一条规则</h5><p><code>iptables -I INPUT number -p tcp -m tcp --dport 21 -j ACCEPT</code><br>（<font color="red">注：插入对应的number位置，原number位置往后移</font>）</p><h4 id="常用端口总结"><a href="#常用端口总结" class="headerlink" title="常用端口总结"></a>常用端口总结</h4><table><thead><tr><th>服务</th><th>端口</th><th>是否开启</th><th>协议类型</th><th>描述</th></tr></thead><tbody><tr><td>HTTP</td><td>80</td><td>建议开启</td><td>tcp</td><td>Web服务</td></tr><tr><td>HTTPS</td><td>443</td><td>建议开启</td><td>tcp</td><td>Web加密服务</td></tr><tr><td>POP3</td><td>110</td><td>不建议开启</td><td>tcp</td><td>POP邮局协议</td></tr><tr><td>SMTP</td><td>25</td><td>不建议开启</td><td>tcp</td><td>SMTP邮件传输协议</td></tr><tr><td>FTP</td><td>21</td><td>不建议开启</td><td>tcp</td><td>FTP服务</td></tr><tr><td>SFTP</td><td>115</td><td>不建议开启</td><td>tcp</td><td>SFTP安全文本传输协议</td></tr><tr><td>SSH</td><td>22</td><td>必须开启</td><td>tcp</td><td>SSH服务</td></tr><tr><td>Telnet</td><td>23</td><td>不建议开启</td><td>tcp</td><td>不安全的文本传送</td></tr><tr><td>DNS</td><td>53</td><td>建议开启</td><td>tcp</td><td>DNS域名服务</td></tr><tr><td>TOMCAT</td><td>8080</td><td>不建议开启</td><td>tcp</td><td>tomcat服务器端口</td></tr><tr><td>MySQL</td><td>3306</td><td>不建议开启</td><td>tcp</td><td>MySQL服务器端口</td></tr></tbody></table><h4 id="附本人主机iptables规则脚本"><a href="#附本人主机iptables规则脚本" class="headerlink" title="附本人主机iptables规则脚本"></a>附本人主机iptables规则脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">iptables -F  # 清空所有默认规则</span><br><span class="line">iptables -X  # 清空所有自定义规则</span><br><span class="line">iptables -Z  # 所有封包计数器归0</span><br><span class="line"></span><br><span class="line"># 设置默认的访问规则</span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line"># 允许接受本机请求之后的返回数据（ESTABLISHED 是已经建立连接的状态）；RELATED 是为了FTP设置的</span><br><span class="line">iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A INPUT -p icmp -j ACCEPT  # 允许 ping</span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT    # 允许访问回环网卡</span><br><span class="line"></span><br><span class="line"># 自定义开启一些端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 3690 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 定义对应规则没有仍返回相应信息</span><br><span class="line">iptables -A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">iptables -A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line"># 保存更改并重启服务</span><br><span class="line">service iptables save</span><br><span class="line">systemctl restart iptables.service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;iptables-常用命令及参数注释：&quot;&gt;&lt;a href=&quot;#iptables-常用命令及参数注释：&quot; class=&quot;headerlink&quot; title=&quot;iptables 常用命令及参数注释：&quot;&gt;&lt;/a&gt;iptables 常用命令及参数注释：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;主要包含：&lt;br&gt;&lt;strong&gt;命令表&lt;/strong&gt;&lt;br&gt;　　用来增加(-A、-I)删除(-D)修改(-R)查看(-L)规则等；&lt;br&gt;&lt;strong&gt;常用参数&lt;/strong&gt;&lt;br&gt;　　用来指定协议(-p)、源地址(-s)、源端口(--sport)、目的地址(-d)、目的端口(--dport)、进入网卡(-i)、出去网卡(-o)等设定包信息（即什么样的包）；用来描述要处理包的信息。&lt;br&gt;&lt;strong&gt;常用处理动作&lt;/strong&gt;&lt;br&gt;　　用 -j 来指定对包的处理(ACCEPT、DROP、REJECT、REDIRECT等)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>系统服务管理详解</title>
    <link href="http://yoursite.com/2018/03/16/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/16/系统服务管理详解/</id>
    <published>2018-03-16T07:51:56.000Z</published>
    <updated>2018-03-16T08:32:00.661Z</updated>
    
    <content type="html"><![CDATA[<h4 id="透过systemctl-管理服务"><a href="#透过systemctl-管理服务" class="headerlink" title="透过systemctl 管理服务"></a>透过systemctl 管理服务</h4><p>基本上，systemd 这个启动服务的机制，主要是透过一只名为systemctl 的指令来处理的！跟以前systemV 需要service / chkconfig / setup / init 等指令来协助不同，systemd 就是仅有systemctl 这个指令来处理而已！所以全部的行为都得要使用systemctl。 </p><h5 id="1、单一服务-service-unit-的启动-开机启动与观察状态"><a href="#1、单一服务-service-unit-的启动-开机启动与观察状态" class="headerlink" title="1、单一服务(service unit) 的启动/开机启动与观察状态"></a>1、单一服务(service unit) 的启动/开机启动与观察状态</h5><p><font color="red">一般来说，服务的启动有两个阶段，一个是『开机的时候设定要不要启动这个服务』，以及『你现在要不要启动这个服务』</font>，这两者之间有很大的差异。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# systemctl [command] [unit]</span><br><span class="line">command主要有：</span><br><span class="line">start ：立刻启动后面接的unit</span><br><span class="line">stop ：立刻关闭后面接的unit</span><br><span class="line">restart ：立刻关闭后启动后面接的unit，亦即执行stop 再start 的意思</span><br><span class="line">reload ：不关闭后面接的unit 的情况下，重新载入设定档，让设定生效</span><br><span class="line">enable ：设定下次开机时，后面接的unit 会被启动</span><br><span class="line">disable ：设定下次开机时，后面接的unit 不会被启动</span><br><span class="line">status ：目前后面接的这个unit 的状态，会列出有没有正在执行、开机预设执行否、登录等资讯等！</span><br><span class="line">is-active ：目前有没有正在运作中</span><br><span class="line">is-enabled：开机时有没有预设要启用这个unit</span><br><span class="line"></span><br><span class="line">范例一：看看目前atd这个服务的状态为何？</span><br><span class="line">[root@study ~]# systemctl status atd.service</span><br><span class="line">atd.service - Job spooling tools</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled)</span><br><span class="line">   Active: active (running) since Mon 2015-08-10 19:17:09 CST; 5h 42min ago</span><br><span class="line"> Main PID: 1350 (atd)</span><br><span class="line">   CGroup: /system.slice/atd.service</span><br><span class="line">           └─1350 /usr/sbin/atd -f</span><br><span class="line"></span><br><span class="line">Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.</span><br><span class="line"></span><br><span class="line"># 重点在第二、三行喔～</span><br><span class="line"># Loaded：这行在说明，开机的时候这个unit 会不会启动，enabled 为开机启动，disabled 开机不会启动</span><br><span class="line"># Active：现在这个unit 的状态是正在执行(running) 或没有执行(dead)</span><br><span class="line"># 后面几行则是说明这个unit 程序的PID 状态以及最后一行显示这个服务的登录档资讯！</span><br><span class="line"># 登录档资讯格式为：『时间』 『讯息发送主机』 『哪一个服务的讯息』 『实际讯息内容』</span><br><span class="line"># 所以上面的显示讯息是：这个atd 预设开机就启动，而且现在正在运作的意思！</span><br><span class="line"></span><br><span class="line">范例二：正常关闭这个atd服务 </span><br><span class="line">[root@study ~]# systemctl stop atd.service</span><br><span class="line">[root@study ~]# systemctl status atd.service</span><br><span class="line">atd.service - Job spooling tools</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled )</span><br><span class="line">    Active: inactive (dead) since Tue 2015-08-11 01:04:55 CST; 4s ago</span><br><span class="line">  Process: 1350 ExecStart=/usr/sbin/atd -f $OPTS (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 1350 (code=exited, status=0/SUCCESS)</span><br><span class="line"></span><br><span class="line">Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.</span><br><span class="line">Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopping Job spooling tools...</span><br><span class="line">Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopped Job spooling tools.</span><br><span class="line"></span><br><span class="line">#目前这个unit下次开机还是会启动，但是现在是没在运作的状态中！同时，</span><br><span class="line"># 最后两行为新增加的登录讯息，告诉我们目前的系统状态喔！</span><br></pre></td></tr></table></figure></p><p>上面的范例中，我们已经关掉了atd ！这样作才是对的！不应该使用kill 的方式来关掉一个正常的服务！否则systemctl 会无法继续监控该服务的！那就比较麻烦。而使用systemtctl status atd 的输出结果中，第2, 3 两行很重要，因为那个是告知我们该unit 下次开机会不会预设启动，以及目前启动的状态！相当重要！最底下是这个unit 的登录档。如果你的这个unit 曾经出错过，观察这个地方也是相当重要的！</p><p>再回到systemctl status atd.service 的第三行，不是有个Active 的daemon 现在状态吗？除了running 跟dead 之外， 有没有其他的状态呢？有的，基本上有几个常见的状态：</p><ul><li><strong>active (running)：</strong>正有一只或多只程序正在系统中执行的意思，举例来说，正在执行中的vsftpd就是这种模式。</li><li><strong>active (exited)：</strong>仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行。举例来说，开机或者是挂载时才会进行一次的quotaon功能，就是这种模式！quotaon不须一直执行～只须执行一次之后，就交给档案系统去自行处理啰！通常用bash shell写的小型服务，大多是属于这种类型(无须常驻记忆体)。</li><li><strong>active (waiting)：</strong>正在执行当中，不过还再等待其他的事件才能继续处理。举例来说，列印的伫列相关服务就是这种状态！虽然正在启动中，不过，也需要真的有伫列进来(列印工作)这样他才会继续唤醒印表机服务来进行下一步列印的功能。</li><li><strong>inactive：</strong>这个服务目前没有运作的意思。</li></ul><p>既然daemon 目前的状态就有这么多种了，那么daemon 的预设状态有没有可能除了enable/disable 之外，还有其他的情况呢？当然有！</p><ul><li><strong>enabled：</strong>这个daemon将在开机时被执行</li><li><strong>disabled：</strong>这个daemon在开机时不会被执行</li><li><strong>static：</strong>这个daemon不可以自己启动(enable不可)，不过可能会被其他的enabled的服务来唤醒(相依属性的服务)</li><li><strong>mask：</strong>这个daemon无论如何都无法被启动！因为已经被强制注销(非删除)。可透过systemctl unmask方式改回原本状态</li></ul><h5 id="2、服务启动-关闭与观察的练习"><a href="#2、服务启动-关闭与观察的练习" class="headerlink" title="2、服务启动/关闭与观察的练习"></a>2、服务启动/关闭与观察的练习</h5><p>我们直接使用指令的方式来查询与设定看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 1.观察一下状态，确认是否为关闭/未启动呢？</span><br><span class="line">[root@study ~]# systemctl status chronyd.service</span><br><span class="line">hronyd.service - NTP client/server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/chronyd.service; enabled )</span><br><span class="line">   Active: active (running) since Mon 2015-08-10 19:17:07 CST; 24h ago</span><br><span class="line"> .....(底下省略).....</span><br><span class="line"></span><br><span class="line"># 2.由上面知道目前是启动的，因此立刻将他关闭，同时开机不会启动才行！</span><br><span class="line">[root@study ~]# systemctl stop chronyd.service</span><br><span class="line">[root@study ~]# systemctl disable chronyd.service</span><br><span class="line">rm &apos;/etc/systemd/system/multi-user.target.wants/chronyd.service&apos;</span><br><span class="line"># 看得很清楚～其实就是从/etc/systemd/system 底下删除一条连结档案而已～</span><br><span class="line"></span><br><span class="line">[root@study ~]# systemctl status chronyd.service</span><br><span class="line">chronyd.service - NTP client/server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/chronyd.service; disabled )</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">#如此则将chronyd这个服务完整的关闭了！</span><br></pre></td></tr></table></figure></p><p>上面是一个很简单的练习，妳先不要知道chronyd 是啥东西，只要知道透过这个方式，可以将一个服务关闭就是了！</p><h5 id="3、强迫服务注销-mask-的练习"><a href="#3、强迫服务注销-mask-的练习" class="headerlink" title="3、强迫服务注销(mask) 的练习"></a>3、强迫服务注销(mask) 的练习</h5><p>透过mask 的方式来将服务注销：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 1.保持刚刚的状态，关闭cups.service，启动cups.socket，然后注销cups.servcie </span><br><span class="line">[root@study ~]# systemctl stop cups.service</span><br><span class="line">[root@study ~]# systemctl mask cups.service</span><br><span class="line">ln -s &apos;/dev/null&apos; &apos;/etc/systemd/system/cups.service&apos;</span><br><span class="line"># 喔耶～其实这个mask 注销的动作，只是让启动的脚本变成空的装置而已！</span><br><span class="line"></span><br><span class="line">[root@study ~]# systemctl status cups.service</span><br><span class="line">cups.service</span><br><span class="line">   Loaded: masked (/dev/null)</span><br><span class="line">   Active: inactive (dead) since Tue 2015-08-11 23:14:16 CST; 52s ago</span><br><span class="line"></span><br><span class="line">[root@study ~]# systemctl start cups.service</span><br><span class="line">Failed to issue method call: Unit cups.service is masked.   #再也无法唤醒</span><br></pre></td></tr></table></figure></p><p>上面的范例你可以仔细推敲一下～原来整个启动的脚本设定档被连结到/dev/null 这个空装置～因此，无论如何你是再也无法启动这个cups.service 了！透过这个mask 功能，你就可以不必管其他相依服务可能会启动到这个想要关闭的服务了！虽然是非正规，不过很有效！</p><p>那如何取消注销呢？当然就是unmask 即可啊！</p><h5 id="4、透过systemctl-观察系统上所有的服务"><a href="#4、透过systemctl-观察系统上所有的服务" class="headerlink" title="4、透过systemctl 观察系统上所有的服务"></a>4、透过systemctl 观察系统上所有的服务</h5><p>上面谈到的是单一服务的启动/关闭/观察，以及相依服务要注销的功能。那系统上面有多少的服务存在呢？这个时候就得要透过list-units 及list-unit-files 来观察了！细部的用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# systemctl [command] [--type=TYPE] [--all]</span><br><span class="line">command:</span><br><span class="line">    list-units ：依据unit 列出目前有启动的unit。若加上--all 才会列出没启动的。</span><br><span class="line">    list-unit-files ：依据/usr/lib/systemd/system/ 内的档案，将所有档案列表说明。</span><br><span class="line">--type=TYPE：就是之前提到的unit type，主要有service, socket, target 等</span><br><span class="line"></span><br><span class="line">范例一：列出系统上面有启动的unit </span><br><span class="line">[root@study ~]# systemctl</span><br><span class="line">UNIT LOAD ACTIVE SUB DESCRIPTION</span><br><span class="line">proc-sys-fs-binfmt_mis... loaded active waiting Arbitrary Executable File Formats File System</span><br><span class="line">sys-devices-pc...:0:1:... loaded active plugged QEMU_HARDDISK</span><br><span class="line">sys-devices-pc...0:1-0... loaded active plugged QEMU_HARDDISK</span><br><span class="line">sys-devices-pc...0:0-1... loaded active plugged QEMU_DVD-ROM</span><br><span class="line">.....(中间省略).....</span><br><span class="line">vsftpd.service loaded active running Vsftpd ftp daemon</span><br><span class="line">.....(中间省略).....</span><br><span class="line">cups.socket loaded failed failed CUPS Printing Service Sockets</span><br><span class="line">.....(中间省略).....</span><br><span class="line">LOAD = Reflects whether the unit definition was properly loaded.</span><br><span class="line">ACTIVE = The high-level unit activation state, ie generalization of SUB.</span><br><span class="line">SUB = The low-level unit activation state, values depend on unit type.</span><br><span class="line"></span><br><span class="line">141 loaded units listed. Pass --all to see loaded but inactive units, too.</span><br><span class="line">To show all installed unit files use &apos;systemctl list-unit-files&apos;.</span><br><span class="line">#列出的项目中，主要的意义是：</span><br><span class="line"># UNIT ：项目的名称，包括各个unit 的类别(看副档名)</span><br><span class="line"># LOAD ：开机时是否会被载入，预设systemctl 显示的是有载入的项目而已喔！</span><br><span class="line"># ACTIVE ：目前的状态，须与后续的SUB 搭配！就是我们用systemctl status 观察时，active 的项目！</span><br><span class="line"># DESCRIPTION ：详细描述啰</span><br><span class="line"># cups 比较有趣，因为刚刚被我们玩过，所以ACTIVE 竟然是failed 的喔！被玩死了！^_^</span><br><span class="line"># 另外，systemctl 都不加参数，其实预设就是list-units 的意思！</span><br><span class="line"></span><br><span class="line">范例二：列出所有已经安装的unit有哪些？</span><br><span class="line">[root@study ~]# systemctl list-unit-files</span><br><span class="line">UNIT FILE STATE</span><br><span class="line">proc-sys-fs-binfmt_misc.automount static</span><br><span class="line">dev-hugepages.mount static</span><br><span class="line">dev-mqueue.mount static</span><br><span class="line">proc-fs-nfsd.mount static</span><br><span class="line">.....(中间省略).....</span><br><span class="line">systemd-tmpfiles-clean.timer static</span><br><span class="line"></span><br><span class="line">336 unit files listed.</span><br><span class="line"></span><br><span class="line">范例三：假设我不想要知道这么多的unit 项目，我只想要知道service 这种类别的daemon 而已，而且不论是否已经启动，通通要列出来！那该如何是好？</span><br><span class="line">[root@study ~]# systemctl list-units --type=service --all </span><br><span class="line">#只剩下*.service的项目才会出现喔！</span><br><span class="line"></span><br><span class="line">范例四：查询系统上是否有以cpu为名的服务？</span><br><span class="line">[root@study ~]# systemctl list-units --type=service --all | grep cpu</span><br><span class="line">cpupower.service loaded inactive dead Configure CPU power related settings</span><br><span class="line"># 确实有喔！可以改变CPU 电源管理机制的服务哩！</span><br></pre></td></tr></table></figure></p><p>使用systemctl list-unit-files 会将系统上所有的服务通通列出来～而不像list-units 仅以unit 分类作大致的说明。至于STATE 状态就是前两个小节谈到的开机是否会载入的那个状态项目啰！主要有enabled / disabled / mask / static 等等。</p><h5 id="5、与systemd-的daemon-运作过程相关的目录简介"><a href="#5、与systemd-的daemon-运作过程相关的目录简介" class="headerlink" title="5、与systemd 的daemon 运作过程相关的目录简介"></a>5、与systemd 的daemon 运作过程相关的目录简介</h5><p>我们在前几小节曾经谈过比较重要的systemd 启动脚本设定档在/usr/lib/systemd/system/, /etc/systemd/system/ 目录下，那还有哪些目录跟系统的daemon 运作有关呢？基本上是这样的：</p><ul><li><strong>/usr/lib/systemd/system/：</strong><br>使用CentOS官方提供的软体安装后，预设的启动脚本设定档都放在这里，这里的资料尽量不要修改～要修改时，请到/etc/systemd/system底下修改较佳！</li><li><strong>/run/systemd/system/：</strong><br>系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/lib/systemd/system/高！</li><li><strong>/etc/systemd/system/：</strong><br>管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能！执行优先序又比/run/systemd/system/高喔！</li><li><strong>/etc/sysconfig/*：</strong><br>几乎所有的服务都会将初始化的一些选项设定写入到这个目录下，举例来说，mandb所要更新的man page索引中，需要加入的参数就写入到此目录下的man-db当中喔！而网路的设定则写在/etc/sysconfig/network-scripts/这个目录内。所以，这个目录内的档案也是挺重要的；</li><li><strong>/var/lib/：</strong><br>一些会产生资料的服务都会将他的资料写入到/var/lib/目录中。举例来说，资料库管理系统Mariadb的资料库预设就是写入/var/lib/mysql/这个目录下啦！</li><li><strong>/run/：</strong><br>放置了好多daemon的暂存档，包括lock file以及PID file等等。</li></ul><p>我们知道systemd 里头有很多的本机会用到的socket 服务，里头可能会产生很多的socket file ～那你怎么知道这些socket file 放置在哪里呢？很简单！还是透过systemctl 来管理！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# systemctl list-sockets</span><br><span class="line">LISTEN UNIT ACTIVATES</span><br><span class="line">/dev/initctl systemd-initctl.socket systemd-initctl.service</span><br><span class="line">/dev/log systemd-journald.socket systemd-journald.service</span><br><span class="line">/run/dmeventd-client dm-event.socket dm-event.service</span><br><span class="line">/run/dmeventd-server dm-event.socket dm-event.service</span><br><span class="line">/run/lvm/lvmetad.socket lvm2-lvmetad.socket lvm2-lvmetad.service</span><br><span class="line">/run/systemd/journal/socket systemd-journald.socket systemd-journald.service</span><br><span class="line">/run/systemd/journal/stdout systemd-journald.socket systemd-journald.service</span><br><span class="line">/run/systemd/shutdownd systemd-shutdownd.socket systemd-shutdownd.service</span><br><span class="line">/run/udev/control systemd-udevd-control.socket systemd-udevd.service</span><br><span class="line">/var/run/avahi-daemon/socket avahi-daemon.socket avahi-daemon.service</span><br><span class="line">/var/run/cups/cups.sock cups.socket cups.service</span><br><span class="line">/var/run/dbus/system_bus_socket dbus.socket dbus.service</span><br><span class="line">/var/run/rpcbind.sock rpcbind.socket rpcbind.service</span><br><span class="line">@ISCSIADM_ABSTRACT_NAMESPACE iscsid.socket iscsid.service</span><br><span class="line">@ISCSID_UIP_ABSTRACT_NAMESPACE iscsiuio.socket iscsiuio.service</span><br><span class="line">kobject-uevent 1 systemd-udevd-kernel.socket systemd-udevd.service</span><br><span class="line"></span><br><span class="line">16 sockets listed.</span><br><span class="line">Pass --all to see loaded but inactive sockets, too.</span><br></pre></td></tr></table></figure></p><h4 id="早期的System-V-的init管理行为中-daemon的主要分类"><a href="#早期的System-V-的init管理行为中-daemon的主要分类" class="headerlink" title="早期的System V 的init管理行为中 daemon的主要分类"></a>早期的System V 的init管理行为中 daemon的主要分类</h4><p>基本上init 的管理机制有几个特色如下：</p><ul><li><strong>服务的启动、关闭与观察等方式：</strong><br>　　所有的服务启动脚本通通放置于/etc/init.d/底下，基本上都是使用bash shell script所写成的脚本程式，需要启动、关闭、重新启动、观察状态时，可以透过如下的方式来处理：<ul><li>启动：/etc/init.d/daemon start</li><li>关闭：/etc/init.d/daemon stop</li><li>重新启动：/etc/init.d/daemon restart</li><li>状态观察：/etc/init.d/daemon status</li></ul></li><li><strong>服务启动的分类：</strong><br>　　init服务的分类中，依据服务是独立启动或被一只总管程式管理而分为两大类：<ul><li>独立启动模式(stand alone)：服务独立启动，该服务直接常驻于记忆体中，提供本机或用户的服务行为，反应速度快。</li><li>总管程式(super daemon)：由特殊的xinetd 或inetd 这两个总管程式提供socket 对应或port 对应的管理。当没有用户要求某socket 或port 时， 所需要的服务是不会被启动的。若有用户要求时， xinetd 总管才会去唤醒相对应的服务程式。当该要求结束时，这个服务也会被结束掉～ 因为透过xinetd 所总管，因此这个家伙就被称为super daemon。好处是可以透过super daemon 来进行服务的时程、连线需求等的控制，缺点是唤醒服务需要一点时间的延迟。</li></ul></li><li><strong>服务的相依性问题：</strong><br>　　服务是可能会有相依性的～例如，你要启动网路服务，但是系统没有网路，那怎么可能可以唤醒网路服务呢？如果你需要连线到外部取得认证伺服器的连线，但该连线需要另一个A服务的需求，问题是，A服务没有启动，因此，你的认证服务就不可能会成功启动的！这就是所谓的服务相依性问题。<font color="red">init在管理员自己手动处理这些服务时，是没有办法协助相依服务的唤醒的！</font></li><li><strong>执行等级的分类：</strong><br>　　上面说到init是开机后核心主动呼叫的，然后init可以根据使用者自订的执行等级(runlevel)来唤醒不同的服务，以进入不同的操作界面。基本上Linux提供7个执行等级，分别是0, 1, 2…6 ，比较重要的是1)单人维护模式、3)纯文字模式、5)文字加图形界面。而各个执行等级的启动脚本是透过/etc/rc.d/rc[0-6]/SXXdaemon连结到/etc/init.d/daemon ，连结档名(SXXdaemon)的功能为： S为启动该服务，XX是数字，为启动的顺序。由于有SXX的设定，因此在开机时可以『依序执行』所有需要的服务，同时也能解决相依服务的问题。这点与管理员自己手动处理不太一样就是了。</li><li><strong>制定执行等级预设要启动的服务：</strong><br>　　若要建立如上提到的SXXdaemon的话，不需要管理员手动建立连结档，透过如下的指令可以来处理预设启动、预设不启动、观察预设启动否的行为：<ul><li>预设要启动： chkconfig daemon on</li><li>预设不启动： chkconfig daemon off</li><li>观察预设为启动否： chkconfig –list daemon</li></ul></li><li><strong>执行等级的切换行为：</strong><br>　　当你要从纯文字界面(runlevel 3)切换到图形界面(runlevel 5)，不需要手动启动、关闭该执行等级的相关服务，只要『 init 5 』即可切换，init这小子会主动去分析/etc/rc.d/rc[35].d/这两个目录内的脚本，然后启动转换runlevel中需要的服务～就完成整体的runlevel切换。</li></ul><p>基本上init 主要的功能都写在上头了，重要的指令包括daemon 本身自己的脚本(/etc/init.d/daemon) 、xinetd 这个特殊的总管程式(super daemon)、设定预设开机启动的chkconfig， 以及会影响到执行等级的init N 等。虽然CentOS 7 已经不使用init 来管理服务了，不过因为考量到某些脚本没有办法直接塞入systemd 的处理，因此这些脚本还是被保留下来， 所以，我们在这里还是稍微介绍了一下。</p><h4 id="systemd-使用的unit-分类"><a href="#systemd-使用的unit-分类" class="headerlink" title="systemd 使用的unit 分类"></a>systemd 使用的unit 分类</h4><p>从CentOS 7.x 以后，Red Hat 系列的distribution 放弃沿用多年的System V 开机启动服务的流程，就是前面提到的init 启动脚本的方法，改用systemd 这个启动服务管理机制。那么systemd 有什么好处呢？</p><ul><li><strong>平行处理所有服务，加速开机流程：</strong><br>旧的init启动脚本是『一项一项任务依序启动』的模式，因此不相依的服务也是得要一个一个的等待。但目前我们的硬体主机系统与作业系统几乎都支援多核心架构了，没道理未相依的服务不能同时启动啊！systemd就是可以让所有的服务同时启动，因此你会发现到，系统启动的速度变快了！</li><li><strong>一经要求就回应的on-demand启动方式：</strong><br>systemd全部就是仅有一只systemd服务搭配systemctl指令来处理，无须其他额外的指令来支援。不像systemV还要init, chkconfig, service…等等指令。此外， systemd由于常驻记忆体，因此任何要求(on-demand)都可以立即处理后续的daemon启动的任务。</li><li><strong>服务相依性的自我检查：</strong><br>由于systemd可以自订服务相依性的检查，因此如果B服务是架构在A服务上面启动的，那当你在没有启动A服务的情况下仅手动启动B服务时， systemd会自动帮你启动A服务喔！这样就可以免去管理员得要一项一项服务去分析的麻烦～(如果读者不是新手，应该会有印象，当你没有启动网路，但却启动NIS/NFS时，那个开机时的timeout甚至可达到10~30分钟…)</li><li><strong>依daemon功能分类：</strong><br>systemd旗下管理的服务非常多，包山包海啦～为了厘清所有服务的功能，因此，首先systemd先定义所有的服务为一个服务单位(unit)，并将该unit归类到不同的服务类型(type)去。旧的init仅分为stand alone与super daemon实在不够看，systemd将服务单位(unit)区分为service, socket, target, path, snapshot, timer等多种不同的类型(type)，方便管理员的分类与记忆。</li><li><strong>将多个daemons集合成为一个群组：</strong><br>如同systemV的init里头有个runlevel的特色，systemd亦将许多的功能集合成为一个所谓的target项目，这个项目主要在设计操作环境的建置，所以是集合了许多的daemons，亦即是执行某个target就是执行好多个daemon的意思！</li><li><strong>向下相容旧有的init服务脚本：</strong><br>基本上， systemd是可以相容于init的启动脚本的，因此，旧的init启动脚本也能够透过systemd来管理，只是更进阶的systemd功能就没有办法支援就是了。</li></ul><p>虽然如此，不过systemd 也是有些地方无法完全取代init 的！包括：</p><ul><li>在runlevel 的对应上，大概仅有runlevel 1, 3, 5 有对应到systemd 的某些target 类型而已，没有全部对应；</li><li>全部的systemd 都用systemctl 这个管理程式管理，而systemctl 支援的语法有限制，不像/etc/init.d/daemon 就是纯脚本可以自订参数，systemctl 不可自订参数。；</li><li>如果某个服务启动是管理员自己手动执行启动，而不是使用systemctl 去启动的(例如你自己手动输入crond 以启动crond 服务)，那么systemd 将无法侦测到该服务，而无法进一步管理。</li><li>systemd 启动过程中，无法与管理员透过standard input 传入讯息！因此，自行撰写systemd 的启动设定时，务必要取消互动机制～(连透过启动时传进的标准输入讯息也要避免！)</li></ul><p>不过，光是同步启动服务脚本这个功能就可以节省你很多开机的时间。同时systemd 还有很多特殊的服务类型(type) 可以提供更多有趣的功能！确实值得学一学～ 而且CentOS 7 已经用了systemd 了！既然要学，首先就得要针对systemd 管理的unit 来了解一下。</p><h5 id="1、systemd-的设定档放置目录"><a href="#1、systemd-的设定档放置目录" class="headerlink" title="1、systemd 的设定档放置目录"></a>1、systemd 的设定档放置目录</h5><p>基本上， systemd 将过去所谓的daemon 执行脚本通通称为一个服务单位(unit)，而每种服务单位依据功能来区分时，就分类为不同的类型(type)。基本的类型有包括系统服务、资料监听与交换的插槽档服务(socket)、储存系统状态的快照类型、提供不同类似执行等级分类的操作环境(target) 等等。</p><p>设定档都放置在底下的目录中：</p><ul><li><strong>/usr/lib/systemd/system/：</strong>每个服务最主要的启动脚本设定，有点类似以前的/etc/init.d底下的档案；</li><li><strong>/run/systemd/system/：</strong>系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/lib/systemd/system/高！</li><li><strong>/etc/systemd/system/：</strong>管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能！执行优先序又比/run/systemd/system/高喔！</li></ul><p>也就是说，到底系统开机会不会执行某些服务其实是看/etc/systemd/system/ 底下的设定，所以该目录底下就是一大堆连结档。而实际执行的systemd 启动脚本设定档， 其实都是放置在/usr/lib/systemd/system/ 底下的喔！因此如果你想要修改某个服务启动的设定，应该要去/usr/lib/systemd/system/ 底下修改才对！/etc/systemd/system/ 仅是连结到正确的执行脚本设定档而已。所以想要看执行脚本设定，应该就得要到/usr/lib/systemd/system/ 底下去查阅才对！</p><h5 id="2、systemd-的unit-类型分类说明"><a href="#2、systemd-的unit-类型分类说明" class="headerlink" title="2、systemd 的unit 类型分类说明"></a>2、systemd 的unit 类型分类说明</h5><p>那/usr/lib/systemd/system/ 以下的资料如何区分上述所谓的不同的类型(type) 呢？很简单！看副档名！举例来说，我们来瞧瞧上一章谈到的vsftpd 这个范例的启动脚本设定， 还有crond 与纯文字模式的multi-user 设定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# ll /usr/lib/systemd/system/ | grep -E &apos;(vsftpd|multi|cron)&apos;</span><br><span class="line">-rw-r--r--. 1 root root 284 7月30 2014 crond. service</span><br><span class="line">-rw-r--r--. 1 root root 567 3月6 06:51 multipathd.service</span><br><span class="line">-rw-r--r--. 1 root root 524 3月6 13:48 multi-user.target</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月4 17:52 multi-user.target.wants</span><br><span class="line">lrwxrwxrwx. 1 root root 17 5月4 17:52 runlevel2.target -&gt; multi-user.target</span><br><span class="line">lrwxrwxrwx. 1 root root 17 5月4 17:52 runlevel3.target -&gt; multi-user.target</span><br><span class="line">lrwxrwxrwx. 1 root root 17 5月4 17:52 runlevel4.target -&gt; multi-user.target</span><br><span class="line">-rw-r--r--. 1 root root 171 6月10 2014 vsftpd.service</span><br><span class="line">-rw-r--r--. 1 root root 184 6月10 2014 vsftpd@.service</span><br><span class="line">-rw-r--r--. 1 root root 89 6月10 2014 vsftpd.target</span><br><span class="line"># 比较重要的是上头提供的那三行特殊字体的部份！</span><br></pre></td></tr></table></figure></p><p>所以我们可以知道vsftpd 与crond 其实算是系统服务(service)，而multi-user 要算是执行环境相关的类型(target type)。根据这些副档名的类型， 我们大概可以找到几种比较常见的systemd 的服务类型如下：</p><style type="text/css">    table th:first-of-type {        width: 15%;    }</style><table><thead><tr><th>副档名</th><th>主要服务功能</th></tr></thead><tbody><tr><td>.service</td><td>一般服务类型(service unit)：主要是系统服务，包括伺服器本身所需要的本机服务以及网路服务都是！比较经常被使用到的服务大多是这种类型！所以，这也是最常见的类型了！</td></tr><tr><td>.socket</td><td>内部程序资料交换的插槽服务(socket unit)：主要是IPC (Inter-process communication) 的传输讯息插槽档(socket file) 功能。这种类型的服务通常在监控讯息传递的插槽档，当有透过此插槽档传递讯息来说要连结服务时，就依据当时的状态将该用户的要求传送到对应的daemon， 若daemon 尚未启动，则启动该daemon 后再传送用户的要求。<br>使用socket 类型的服务一般是比较不会被用到的服务，因此在开机时通常会稍微延迟启动的时间 (因为比较没有这么常用嘛！)。一般用于本机服务比较多，例如我们的图形界面很多的软体都是透过socket 来进行本机程序资料交换的行为。(这与早期的xinetd 这个super daemon 有部份的相似喔！)</td></tr><tr><td>.target</td><td>执行环境类型(target unit)：其实是一群unit 的集合，例如上面表格中谈到的multi-user.target 其实就是一堆服务的集合～也就是说， 选择执行multi-user.target 就是执行一堆其他.service 或/及.socket 之类的服务就是了！</td></tr><tr><td>.mount<br>.automount</td><td>档案系统挂载相关的服务(automount unit / mount unit)：例如来自网路的自动挂载、NFS 档案系统挂载等与档案系统相关性较高的程序管理。</td></tr><tr><td>.path</td><td>侦测特定档案或目录类型(path unit)：某些服务需要侦测某些特定的目录来提供伫列服务，例如最常见的列印服务，就是透过侦测列印伫列目录来启动列印功能！这时就得要.path 的服务类型支援了！</td></tr><tr><td>.timer</td><td>循环执行的服务(timer unit)：这个东西有点类似anacrontab 喔！不过是由systemd 主动提供的，比anacrontab 更加有弹性！</td></tr></tbody></table><p>其中又以.service 的系统服务类型最常见了！因为我们一堆网路服务都是透过这种类型来设计的啊！接下来，让我们来谈谈如何管理这些服务的启动与关闭。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;透过systemctl-管理服务&quot;&gt;&lt;a href=&quot;#透过systemctl-管理服务&quot; class=&quot;headerlink&quot; title=&quot;透过systemctl 管理服务&quot;&gt;&lt;/a&gt;透过systemctl 管理服务&lt;/h4&gt;&lt;p&gt;基本上，systemd 这个启动服务的机制，主要是透过一只名为systemctl 的指令来处理的！跟以前systemV 需要service / chkconfig / setup / init 等指令来协助不同，systemd 就是仅有systemctl 这个指令来处理而已！所以全部的行为都得要使用systemctl。 &lt;/p&gt;
&lt;h5 id=&quot;1、单一服务-service-unit-的启动-开机启动与观察状态&quot;&gt;&lt;a href=&quot;#1、单一服务-service-unit-的启动-开机启动与观察状态&quot; class=&quot;headerlink&quot; title=&quot;1、单一服务(service unit) 的启动/开机启动与观察状态&quot;&gt;&lt;/a&gt;1、单一服务(service unit) 的启动/开机启动与观察状态&lt;/h5&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;一般来说，服务的启动有两个阶段，一个是『开机的时候设定要不要启动这个服务』，以及『你现在要不要启动这个服务』&lt;/font&gt;，这两者之间有很大的差异。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7下执行firewall-cmd显示ImportError: No module named &#39;gi&#39;</title>
    <link href="http://yoursite.com/2018/03/16/CentOS-7%E4%B8%8B%E6%89%A7%E8%A1%8Cfirewall-cmd%E6%98%BE%E7%A4%BAImportError-No-module-named-gi/"/>
    <id>http://yoursite.com/2018/03/16/CentOS-7下执行firewall-cmd显示ImportError-No-module-named-gi/</id>
    <published>2018-03-16T05:17:26.000Z</published>
    <updated>2018-03-16T05:23:16.413Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在命令行下执行报错提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# firewall-cmd -h</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/bin/firewall-cmd&quot;, line 24, in &lt;module&gt;</span><br><span class="line">    from gi.repository import GObject</span><br><span class="line">ModuleNotFoundError: No module named &apos;gi&apos;</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><p>由错误信息也能够看出来是因为缺少 ‘gi’ 模块。<br>CentOS7 默认自带安装的是Python2.7版本，由于我前段时间安装了最新版的 Python3.6，且是共存的。更改了默认的Python版本为Python3，因此一些Linux命令不能使用，原因就是这些命令使用的Python2版本，由于我安装的Python3版本，并没有把所有的需要的包都安装，因此会提示缺少某些模块。（注：由此处就说明，升级Python2到Python3的时候，要保留Python2）</p><p>正确的做法就是，如果使用一些命令提示类似错误的时候，就把命令文件的头部Python版本改为CentOS默认的2.7版本即可。<br>更改方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一步，vim /usr/bin/firewall-cmd</span><br><span class="line">将#！/usr/bin/python -Es 改为 #！/usr/bin/python2 -Es（到目前为止，上面提到的问题已解决）</span><br><span class="line">第二步，vim /usr/sbin/firewalld</span><br><span class="line">将#！/usr/bin/python -Es 改为 #！/usr/bin/python2 -Es (这一步是针对于防火墙报错，进行的修改)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在命令行下执行报错提示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@VM_0_7_centos ~]# firewall-cmd -h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Traceback (most recent call last):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  File &amp;quot;/usr/bin/firewall-cmd&amp;quot;, line 24, in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    from gi.repository import GObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ModuleNotFoundError: No module named &amp;apos;gi&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Linux问题" scheme="http://yoursite.com/categories/Linux/Linux%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="firewalld" scheme="http://yoursite.com/tags/firewalld/"/>
    
  </entry>
  
  <entry>
    <title>防火墙之iptables和firewalld</title>
    <link href="http://yoursite.com/2018/03/16/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B9%8Biptables%E5%92%8Cfirewalld/"/>
    <id>http://yoursite.com/2018/03/16/防火墙之iptables和firewalld/</id>
    <published>2018-03-16T05:16:07.000Z</published>
    <updated>2018-03-16T05:26:18.810Z</updated>
    
    <content type="html"><![CDATA[<p>在RHEL 7系统中，firewalld防火墙取代了iptables防火墙。对于接触Linux系统比较早或学习过RHEL 6系统的读者来说，当他们发现曾经掌握的知识在RHEL 7中不再适用，就需要全新学习firewalld。其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已，或者说，它们只是一种服务。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。只要在这多个防火墙管理工具中任选一款并将其学透，就足以满足日常的工作需求了。<br><a id="more"></a></p><h4 id="防火墙的分类："><a href="#防火墙的分类：" class="headerlink" title="防火墙的分类："></a>防火墙的分类：</h4><p>根据工作的层次的不同来划分，常见的防火墙工作在OSI第三层，即网络层防火墙，工作在OSI第七层的称为应用层防火墙，或者代理服务器（代理网关）。</p><h5 id="1、网络层防火墙"><a href="#1、网络层防火墙" class="headerlink" title="1、网络层防火墙"></a>1、网络层防火墙</h5><p>网络层防火墙又称包过滤防火墙，在网络层对数据包进行选择，选择的依据是系统内设置的过滤逻辑，被称为访问控制列表（ACL），通过检查数据流中每个数据的源地址，目的地址，所用端口号和协议状态等因素,来确定是否允许该数据包通过。<br>特点：对用户来说透明，处理速度快且易于维护。但是一旦黑客突破防火墙，就可以轻易地伪造数据包的源地址，目的地址和IP的端口号，即“IP地址伪造”。</p><h5 id="2、应用层防火墙"><a href="#2、应用层防火墙" class="headerlink" title="2、应用层防火墙"></a>2、应用层防火墙</h5><p>代理服务型防火墙（Proxy Service）将所有跨越防火墙的网络通信链路分为两段。当代理服务器接收到用户对某个站点的访问请求后会检查该请求是否符合控制规则。如果规则允许，则代理服务器会替用户去那个站点取回所需要的信息，转发给用户。内外网用户的访问都是通过代理服务器上的“链接”来实现的，从而起到了隔离防火墙内外计算机系统的作用。<br>特点：在应用层对数据进行检查，比较安全。但是会增加防火墙的负载。</p><p>包过滤防火墙将对每一个接收到的包做出允许或拒绝的决定。具体地讲，它针对每一个数据包的包头，按照包过滤规则进行判定，与规则相匹配的包依据路由信息继续转发，否则就丢弃。包过滤是在IP层实现的，包过滤根据数据包的源IP地址、目的IP地址、协议类型（TCP包、UDP包、ICMP包）、源端口、目的端口等包头信息及数据包传输方向等信息来判断是否允许数据包通过。包过滤也包括与服务相关的过滤，这是指基于特定的服务进行包过滤，由于绝大多数服务的监听都驻留在特定TCP/UDP端口，因此，为阻断所有进入特定服务的链接，防火墙只需将所有包含特定TCP/UDP目的端口的包丢弃即可。</p><p>现实生产环境中所使用的防火墙一般都是二者结合体。即先检查网络数据，通过之后再送到应用层去检查。</p><h4 id="iptables-防火墙"><a href="#iptables-防火墙" class="headerlink" title="iptables 防火墙"></a>iptables 防火墙</h4><p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。对于如何在CentOS7系统中，从firewalld防火墙更改为iptables防火墙，可查看我的一篇文章<strong>《解决CentOS7关闭/开启防火墙出现Unit iptables.service failed to load: No such file or directory.》</strong>。</p><h5 id="1、策略与规则链"><a href="#1、策略与规则链" class="headerlink" title="1、策略与规则链"></a>1、策略与规则链</h5><p><font color="red">防火墙会从上至下的顺序来读取配置的策略规则</font>，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。一般而言，防火墙策略规则的设置有两种：一种是“通”（即放行），一种是“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许时，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。</p><p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：</p><blockquote><p>在进行路由选择前处理数据包（PREROUTING）；<br>处理流入的数据包（INPUT）；<br>处理流出的数据包（OUTPUT）；<br>处理转发的数据包（FORWARD）；<br>在进行路由选择后处理数据包（POSTROUTING）。</p></blockquote><p>一般来说，从内网向外网发送的流量一般都是可控且良性的，因此我们使用最多的就是INPUT规则链，该规则链可以增大黑客人员从外网入侵内网的难度。</p><h5 id="2、基本的命令参数"><a href="#2、基本的命令参数" class="headerlink" title="2、基本的命令参数"></a>2、基本的命令参数</h5><p>iptables是一款基于命令行的防火墙策略管理工具，具有大量参数，学习难度较大。好在对于日常的防火墙策略配置来讲，大家无需深入了解诸如“四表五链”的理论概念，只需要掌握常用的参数并做到灵活搭配即可，这就足以应对日常工作了。</p><p>iptables命令可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配，一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，<font color="red">防火墙策略规则的匹配顺序是从上至下的</font>，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误。表8-1总结归纳了常用的iptables命令参数。<br><strong>表8-1：iptables中常用的参数以及作用</strong></p><style type="text/css">    table th:first-of-type {        width: 35%;    }</style><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-P</td><td>设置默认策略</td></tr><tr><td>-F</td><td>清空规则链</td></tr><tr><td>-L</td><td>查看规则链</td></tr><tr><td>-A</td><td>在规则链的末尾加入新规则</td></tr><tr><td>-I num</td><td>在规则链的头部加入新规则</td></tr><tr><td>-D num</td><td>删除某一条规则</td></tr><tr><td>-s</td><td>匹配来源地址IP/MASK，加叹号“!”表示除这个IP外</td></tr><tr><td>-d</td><td>匹配目标地址</td></tr><tr><td>-i 网卡名称</td><td>匹配从这块网卡流入的数据</td></tr><tr><td>-o 网卡名称</td><td>匹配从这块网卡流出的数据</td></tr><tr><td>-p</td><td>匹配协议，如TCP、UDP、ICMP</td></tr><tr><td>–dport num</td><td>匹配目标端口号</td></tr><tr><td>–sport num</td><td>匹配来源端口号</td></tr></tbody></table><p>至于，具体的示例可参考我的另一篇文章<strong>《Linux 防火墙的设定》</strong>。</p><h4 id="firewalld-防火墙"><a href="#firewalld-防火墙" class="headerlink" title="firewalld 防火墙"></a>firewalld 防火墙</h4><p>RHEL 7系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。</p><p>相较于传统的防火墙管理配置工具，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。例如，我们有一台笔记本电脑，每天都要在办公室、咖啡厅和家里使用。按常理来讲，这三者的安全性按照由高到低的顺序来排列，应该是家庭、公司办公室、咖啡厅。当前，我们希望为这台笔记本电脑指定如下防火墙策略规则：在家中允许访问所有服务；在办公室内仅允许访问文件共享服务；在咖啡厅仅允许上网浏览。在以往，我们需要频繁地手动设置防火墙策略规则，而现在只需要预设好区域集合，然后只需轻点鼠标就可以自动切换了，从而极大地提升了防火墙策略的应用效率。firewalld中常见的区域名称（<font color="red">默认为public</font>）以及相应的策略规则如表8-2所示。<br><strong>表8-2：firewalld中常用的区域名称及策略规则</strong></p><table><thead><tr><th>区域</th><th>默认规则策略</th></tr></thead><tbody><tr><td>trusted</td><td>允许所有的数据包</td></tr><tr><td>home</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td></tr><tr><td>internal</td><td>等同于home区域</td></tr><tr><td>work</td><td>拒绝流入的流量，除非与流出的流量数相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td></tr><tr><td>public</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td></tr><tr><td>external</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td></tr><tr><td>dmz</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td></tr><tr><td>block</td><td>拒绝流入的流量，除非与流出的流量相关</td></tr><tr><td>drop</td><td>拒绝流入的流量，除非与流出的流量相关</td></tr></tbody></table><h5 id="1、终端管理工具"><a href="#1、终端管理工具" class="headerlink" title="1、终端管理工具"></a>1、终端管理工具</h5><p>命令行终端是一种极富效率的工作方式，firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的，大家不要一听到长格式就头大，因为RHEL 7系统支持部分命令的参数补齐，其中就包含这条命令（很酷吧）。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐表8-3中所示的长格式参数了（这太棒了）。<br><strong>表8-3：firewall-cmd命令中使用的参数以及作用</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>–get-default-zone</td><td>查询默认的区域名称</td></tr><tr><td>–set-default-zone=&lt;区域名称&gt;</td><td>设置默认的区域，使其永久生效</td></tr><tr><td>–get-zones</td><td>显示可用的区域</td></tr><tr><td>–get-services</td><td>显示预先定义的服务</td></tr><tr><td>–get-active-zones</td><td>显示当前正在使用的区域与网卡名称</td></tr><tr><td>–remove-source=</td><td>将源自此IP或子网的流量导向指定的区域</td></tr><tr><td>–remove-source=</td><td>不再将源自此IP或子网的流量导向某个指定区域</td></tr><tr><td>–add-interface=&lt;网卡名称&gt;</td><td>将源自该网卡的所有流量都导向某个指定区域</td></tr><tr><td>–change-interface=&lt;网卡名称&gt;</td><td>将某个网卡与区域进行关联</td></tr><tr><td>–list-all</td><td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>–list-all-zones</td><td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>–add-service=&lt;服务名&gt;</td><td>设置默认区域允许该服务的流量</td></tr><tr><td>–add-port=&lt;端口号/协议&gt;</td><td>设置默认区域允许该端口的流量</td></tr><tr><td>–remove-service=&lt;服务名&gt;</td><td>设置默认区域不再允许该服务的流量</td></tr><tr><td>–remove-port=&lt;端口号/协议&gt;</td><td>设置默认区域不再允许该端口的流量</td></tr><tr><td>–reload</td><td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td></tr><tr><td>–panic-on</td><td>开启应急状况模式</td></tr><tr><td>–panic-off</td><td>关闭应急状况模式</td></tr></tbody></table><p>与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加–permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd –reload命令。</p><h5 id="2、常用命令汇总"><a href="#2、常用命令汇总" class="headerlink" title="2、常用命令汇总"></a>2、常用命令汇总</h5><p>（1）安装firewalld<br><code>yum install firewalld firewall-config</code></p><p>（2）运行、停止、禁用firewalld<br>启动：# systemctl start  firewalld<br>查看状态：# systemctl status firewalld 或者 firewall-cmd –state<br>停止：# systemctl disable firewalld<br>禁用：# systemctl stop firewalld<br>systemctl mask firewalld<br>systemctl unmask firewalld</p><p>（3）配置firewalld<br>查看版本：<code>$ firewall-cmd --version</code><br>查看帮助：<code>$ firewall-cmd --help</code></p><p>查看设置：<br>显示状态：<code>$ firewall-cmd --state</code><br>查看区域信息: <code>$ firewall-cmd --get-active-zones</code><br>查看指定接口所属区域：<code>$ firewall-cmd --get-zone-of-interface=eth0</code><br>拒绝所有包：<code># firewall-cmd --panic-on</code><br>取消拒绝状态：<code># firewall-cmd --panic-off</code><br>查看是否拒绝：<code>$ firewall-cmd --query-panic</code></p><p>更新防火墙规则：<br><code># firewall-cmd --reload</code><br><code># firewall-cmd --complete-reload</code><br>两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务</p><p>将接口添加到区域，默认接口都在public<br><code># firewall-cmd --zone=public --add-interface=eth0</code><br>永久生效再加上 –permanent 然后reload防火墙</p><p>设置默认接口区域<br><code># firewall-cmd --set-default-zone=public</code><br>立即生效无需重启</p><p>打开端口（貌似这个才最常用）<br>查看所有打开的端口：<br><code># firewall-cmd --zone=dmz --list-ports</code><br>加入一个端口到区域：<br><code># firewall-cmd --zone=dmz --add-port=8080/tcp</code><br>若要永久生效方法同上</p><p>打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档<br><code># firewall-cmd --zone=work --add-service=smtp</code><br>移除服务<br><code># firewall-cmd --zone=work --remove-service=smtp</code></p><h5 id="3、示例"><a href="#3、示例" class="headerlink" title="3、示例"></a>3、示例</h5><p>接下来的实验都很简单，但是提醒大家一定要仔细查看使用的是Runtime模式还是Permanent模式。如果不关注这个细节，就算是正确配置了防火墙策略，也可能无法达到预期的效果。</p><p>查看firewalld服务当前所使用的区域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --get-default-zone</span><br><span class="line">public</span><br></pre></td></tr></table></figure></p><p>查询eno16777728网卡在firewalld服务中的区域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728</span><br><span class="line">public</span><br></pre></td></tr></table></figure></p><p>把f默认irewalld服务中eno16777728网卡的区域修改为external，并在系统重启后生效。分别查看当前与永久模式下的区域名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --permanent --zone=external --change-interface=eno16777728</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728</span><br><span class="line">public</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --permanent --get-zone-of-interface=eno16777728</span><br><span class="line">external</span><br></pre></td></tr></table></figure></p><p>把firewalld服务的当前默认区域设置为public：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --set-default-zone=public</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --get-default-zone </span><br><span class="line">public</span><br></pre></td></tr></table></figure></p><p>启动/关闭firewalld防火墙服务的应急状况模式，阻断一切网络连接（当远程控制服务器时请慎用）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --panic-on</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --panic-off</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>查询public区域是否允许请求SSH和HTTPS协议的流量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=ssh</span><br><span class="line">yes</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https</span><br><span class="line">no</span><br></pre></td></tr></table></figure></p><p>把firewalld服务中请求HTTPS协议的流量设置为永久允许，并立即生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --zone=public --add-service=https</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>把firewalld服务中请求HTTP协议的流量设置为永久拒绝，并立即生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --remove-service=http </span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --reload </span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>把在firewalld服务中访问8080和8081端口的流量策略设置为允许，但仅限当前生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --zone=public --add-port=8080-8081/tcp</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --zone=public --list-ports </span><br><span class="line">8080-8081/tcp</span><br></pre></td></tr></table></figure></p><p>把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效：<br>流量转发命令格式为<code>firewall-cmd --permanent --zone=&lt;区域&gt; --add-forward-port=port=&lt;源端口号&gt;:proto=&lt;协议&gt;:toport=&lt;目标端口号&gt;:toaddr=&lt;目标IP地址&gt;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>在客户端使用ssh命令尝试访问192.168.10.10主机的888端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@client A ~]# ssh -p 888 192.168.10.10</span><br><span class="line">The authenticity of host &apos;[192.168.10.10]:888 ([192.168.10.10]:888)&apos; can&apos;t be established.</span><br><span class="line">ECDSA key fingerprint is b8:25:88:89:5c:05:b6:dd:ef:76:63:ff:1a:54:02:1a.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &apos;[192.168.10.10]:888&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">root@192.168.10.10&apos;s password:此处输入远程root管理员的密码</span><br><span class="line">Last login: Sun Jul 19 21:43:48 2017 from 192.168.10.10</span><br></pre></td></tr></table></figure></p><p>firewalld中的富规则表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.10.0/24&quot; service name=&quot;ssh&quot; reject&quot;</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>在客户端使用ssh命令尝试访问192.168.10.10主机的ssh服务（22端口）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@client A ~]# ssh 192.168.10.10</span><br><span class="line">Connecting to 192.168.10.10:22...</span><br><span class="line">Could not connect to &apos;192.168.10.10&apos; (port 22): Connection failed.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在RHEL 7系统中，firewalld防火墙取代了iptables防火墙。对于接触Linux系统比较早或学习过RHEL 6系统的读者来说，当他们发现曾经掌握的知识在RHEL 7中不再适用，就需要全新学习firewalld。其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已，或者说，它们只是一种服务。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。只要在这多个防火墙管理工具中任选一款并将其学透，就足以满足日常的工作需求了。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="firewalld" scheme="http://yoursite.com/tags/firewalld/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>SVN 详解之多仓库管理及使用钩子hooks/post-commit实现代码自动部署（四）</title>
    <link href="http://yoursite.com/2018/03/16/SVN-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%A4%9A%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E9%92%A9%E5%AD%90hooks-post-commit%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/16/SVN-详解之多仓库管理及使用钩子hooks-post-commit实现代码自动部署（四）/</id>
    <published>2018-03-16T02:42:33.000Z</published>
    <updated>2018-03-16T03:24:00.425Z</updated>
    
    <content type="html"><![CDATA[<h4 id="多仓库管理"><a href="#多仓库管理" class="headerlink" title="多仓库管理"></a>多仓库管理</h4><h5 id="1、首先，需要明白几个概念："><a href="#1、首先，需要明白几个概念：" class="headerlink" title="1、首先，需要明白几个概念："></a>1、首先，需要明白几个概念：</h5><p>（1）多仓库管理，则每个仓库对应的配置都要单独管理。即该仓库允许那些人员访问，人员所具有的的权限等都需设定。</p><p>（2）每个仓库的配置文件只可管理本仓库的属性，不需要涉及到其他仓库，涉及到也没用。即仓库与仓库之间是独立的管理。<br><a id="more"></a></p><h5 id="2、实战演示"><a href="#2、实战演示" class="headerlink" title="2、实战演示"></a>2、实战演示</h5><p>首先，新建2个仓库，project和common。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svnadmin create /var/svn/project//开放仓库</span><br><span class="line">svnadmin create /var/svn/common//共享资源仓库</span><br></pre></td></tr></table></figure></p><p>分别对应仓库的conf/ 下文件进行配置，passwd与svnserve.conf配置类似，不予说明。其中，authz文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># project:</span><br><span class="line">[groups]</span><br><span class="line">admin = admin, ben</span><br><span class="line">test = nana</span><br><span class="line"></span><br><span class="line">[/] == [project:/]</span><br><span class="line">@admin = rw</span><br><span class="line">@test = r @只有读的权限，可用于测试</span><br><span class="line"></span><br><span class="line"># common:</span><br><span class="line">[common:/]</span><br><span class="line">@test = rw</span><br><span class="line">ben = rw</span><br></pre></td></tr></table></figure></p><p><strong>注：对于用户享有单独某个目录权限，可如下操作：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[svn:/special1] == [/special1]</span><br><span class="line">ben = rw</span><br><span class="line">[svn:/special1/special2]</span><br><span class="line">nana = rw</span><br></pre></td></tr></table></figure></p><h5 id="3、问题解决"><a href="#3、问题解决" class="headerlink" title="3、问题解决"></a>3、问题解决</h5><blockquote><p>Invalid authz configuration<br>svn: Authorization failed解决办法</p></blockquote><p>报此类错误，都是因为auth权限文件配置错误，仔细检查就可发现原因。</p><h4 id="使用钩子hooks-post-commit实现代码自动部署"><a href="#使用钩子hooks-post-commit实现代码自动部署" class="headerlink" title="使用钩子hooks/post-commit实现代码自动部署"></a>使用钩子hooks/post-commit实现代码自动部署</h4><p>配置了台svn服务器，用来保存公司项目的代码，同时svn服务器也是一台web服务器。因此希望当我本地代码commit到svn服务器时,能够触发svn服务器的钩子hooks/post-commit将新版本的代码自动update到站点目录上去。</p><blockquote><p>svn 目录：/var/svn/project<br>站点目录：/data/www/project/</p></blockquote><h5 id="1、新建post-commit钩子"><a href="#1、新建post-commit钩子" class="headerlink" title="1、新建post-commit钩子"></a>1、新建post-commit钩子</h5><p>找到svn项目的hooks目录，这里是/var/svn/project/hooks。目录中默认会几个对应操作的钩子模板，我们需要创建一个post-commit的文件。<br>复制钩子文件，进行修改：<br><code>cp hooks/post-commit.tmpl hooks/post-commit</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">export LANG=zh_CN.UTF-8</span><br><span class="line">REPOS=&quot;$1&quot;</span><br><span class="line">REV=&quot;$2&quot;</span><br><span class="line"></span><br><span class="line">SVN_PATH=/usr/bin#svn命令路径</span><br><span class="line">WEB_PATH=/data/www/project/python_movie#项目路径，即已经检出的项目，具体到项目目录</span><br><span class="line">LOG_PATH=/data/www/project/python_movie/logs/svn_deploy.log#日志文件</span><br><span class="line">SVN_USER=ben</span><br><span class="line">SVN_PASS=ben1234</span><br><span class="line"></span><br><span class="line">echo `date &quot;+%Y-%m-%d %H:%M:%S&quot;` &gt;&gt; $LOG_PATH</span><br><span class="line">echo `whoami`,$REPOS,%REV &gt;&gt; %LOG_PATH</span><br><span class="line"></span><br><span class="line">$SVN_PATH/svn update $WEB_PATH --username $SVN_USER --password $SVN_PASS --no-auth-cache &gt;&gt; $LOG_PATH</span><br></pre></td></tr></table></figure></p><font color="red">说明：<br>whoami #执行此程序的用户<br>REPOS=”$1” #svn项目绝对路径值<br>REV=”$2” #最新版本号<br>–no-auth-cache #不保存账户认证信息</font><h5 id="2、修改post-commit文件权限"><a href="#2、修改post-commit文件权限" class="headerlink" title="2、修改post-commit文件权限"></a>2、修改post-commit文件权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown www:www /var/svn/python_movie/hooks/post-commit #设置脚本所属用户组，www为web服务运行账户和组</span><br><span class="line">chmod +x /var/svn/python_movie/hooks/post-commit #添加脚本执行权限</span><br></pre></td></tr></table></figure><h5 id="3、客户端测试"><a href="#3、客户端测试" class="headerlink" title="3、客户端测试"></a>3、客户端测试</h5><p>测试的话，我这里是在本地修改版本库，点commit，然后再看web(nginx)服务器上的数据是否更新来测试。</p><h5 id="4、问题解决"><a href="#4、问题解决" class="headerlink" title="4、问题解决"></a>4、问题解决</h5><p>Checkout一份代码到web服务器上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd /data/www/project/python_movie</span><br><span class="line"># /usr/bin/svn checkout svn://127.0.0.1/python_movie</span><br></pre></td></tr></table></figure></p><blockquote><p>在日志文件中提示<br>Skipped “/data/www/project/python_movie”<br>然后提交的文件并没有自动更新到web目录下</p></blockquote><p>解决方法是：<br>首先，需要在Web目录下检出SVN项目，生成 .svn目录。原因是 Web目录下没有 .svn目录，更新时钩子不能识别Web目录下的 .svn（因为没有），因此会跳过Web目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /data/www/project/python_movie</span><br><span class="line">svn checkout svn://服务器的ip地址/python_movie ./</span><br></pre></td></tr></table></figure></p><p>然后再次提交的文件就可以自动更新到web目录下了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;多仓库管理&quot;&gt;&lt;a href=&quot;#多仓库管理&quot; class=&quot;headerlink&quot; title=&quot;多仓库管理&quot;&gt;&lt;/a&gt;多仓库管理&lt;/h4&gt;&lt;h5 id=&quot;1、首先，需要明白几个概念：&quot;&gt;&lt;a href=&quot;#1、首先，需要明白几个概念：&quot; class=&quot;headerlink&quot; title=&quot;1、首先，需要明白几个概念：&quot;&gt;&lt;/a&gt;1、首先，需要明白几个概念：&lt;/h5&gt;&lt;p&gt;（1）多仓库管理，则每个仓库对应的配置都要单独管理。即该仓库允许那些人员访问，人员所具有的的权限等都需设定。&lt;/p&gt;
&lt;p&gt;（2）每个仓库的配置文件只可管理本仓库的属性，不需要涉及到其他仓库，涉及到也没用。即仓库与仓库之间是独立的管理。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="SVN" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/SVN/"/>
    
    
      <category term="SVN" scheme="http://yoursite.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>Linux 源码包与RPM包详解</title>
    <link href="http://yoursite.com/2018/03/15/Linux-%E6%BA%90%E7%A0%81%E5%8C%85%E4%B8%8ERPM%E5%8C%85%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/15/Linux-源码包与RPM包详解/</id>
    <published>2018-03-15T09:11:19.000Z</published>
    <updated>2018-03-16T08:40:33.348Z</updated>
    
    <content type="html"><![CDATA[<h4 id="源码包与RPM包的区别"><a href="#源码包与RPM包的区别" class="headerlink" title="源码包与RPM包的区别"></a>源码包与RPM包的区别</h4><h5 id="1、安装之前的区别：概念上的区别"><a href="#1、安装之前的区别：概念上的区别" class="headerlink" title="1、安装之前的区别：概念上的区别"></a>1、安装之前的区别：概念上的区别</h5><p>比如说：源码包是开源的，比RPM包安装更自由，但是它安装更慢，更容易报错；RPM包是经过编译的，不能看到源代码，但是它安装更快，报错更容易解决，只有依赖性问题。</p><h5 id="2、安装之后的区别：安装位置不同"><a href="#2、安装之后的区别：安装位置不同" class="headerlink" title="2、安装之后的区别：安装位置不同"></a>2、安装之后的区别：安装位置不同</h5><p>RPM包不需要指定安装位置，它会安装到系统默认位置；而源码包是人为手工设置的，下面我们就来看看到底位置有什么区别<br><a id="more"></a></p><p>（1）RPM包安装位置<br>是按照在默认位置中<br><strong>RPM包默认安装路径</strong></p><table><thead><tr><th>安装位置</th><th>对应目录功能</th></tr></thead><tbody><tr><td>/etc/</td><td>配置文件安装目录</td></tr><tr><td>/usr/bin/</td><td>可执行的命令安装目录</td></tr><tr><td>/usr/lib/</td><td>程序所使用的函数库保存位置</td></tr><tr><td>/usr/share/doc/</td><td>基本的软件使用手册保存位置</td></tr><tr><td>/usr/share/man/</td><td>帮助文件保存位置</td></tr></tbody></table><p>（2）源码包安装位置<br>安装在指定位置当中，一般是 <code>/usr/local/软件名/</code></p><h5 id="3、安装位置不同带来的影响"><a href="#3、安装位置不同带来的影响" class="headerlink" title="3、安装位置不同带来的影响"></a>3、安装位置不同带来的影响</h5><p>RPM包安装的服务可以使用系统服务管理命令（service）来管理，例如RPM包安装的apache的启动方法是：<br><code>/etc/rc.d/init.d/httpd start</code><br><code>service httpd start</code></p><p>而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理，如：<br><code>/usr/local/apache2/bin/apachectl start</code></p><h4 id="RPM包详解"><a href="#RPM包详解" class="headerlink" title="RPM包详解"></a>RPM包详解</h4><h5 id="1、rpm包命名结构"><a href="#1、rpm包命名结构" class="headerlink" title="1、rpm包命名结构"></a>1、rpm包命名结构</h5><p>rpm包的组成：name-version-release.arch.rpm</p><blockquote><p>name：表示包的名称，包括主包名和分包名<br>version：表示包的版本信息<br>release：用于标识rpm包本身的发行号，可还包含适应的操作系统<br>arch:表示主机平台,noarch表示此包能安装到所以平台上面</p></blockquote><p>例如：gd-devel-2.0.35-11.el6.x86_64.rpm</p><blockquote><p>gd是这个包的主包名，devel是这个包的分包名，<br>2.0.35是表示版本信息，2为主版本，0为此版本，35为修订号，<br>11.el6中的11是表示发行号，el6表示是RHEL6，<br>x86_64是表示包适合的平台，如果是noarch这表示与平台无关</p></blockquote><h5 id="2、rpm包命令操作总结"><a href="#2、rpm包命令操作总结" class="headerlink" title="2、rpm包命令操作总结"></a>2、rpm包命令操作总结</h5><style type="text/css">    table th:first-of-type {        width: 15%;    }    table th:nth-of-type(2) {        width: 17%;    }    table th:nth-of-type(3) {        width: 50%;    }    table th:nth-of-type(4) {        width: 40%;    }</style><table><thead><tr><th>&nbsp;</th><th>option</th><th>参数解释</th><th>Example</th></tr></thead><tbody><tr><td>安装</td><td>-i</td><td>安装</td><td>&#32;</td></tr><tr><td></td><td>-v&#124;-vv&#124;-vvv</td><td>显示详细信息</td><td>&#32;</td></tr><tr><td></td><td>-h</td><td>以#显示安装进度一个#表示2%的进度</td><td>rpm -ivh zsh-4.3.10-5.el6.x86_64.rpm</td></tr><tr><td></td><td>–nodeps</td><td>忽略依赖关系</td><td>&#32;</td></tr><tr><td></td><td>–test</td><td>测试安装</td><td>&#32;</td></tr><tr><td></td><td>–replacepkgs</td><td>重新安装(安装的包已经安装了)</td><td>&#32;</td></tr><tr><td>升级</td><td>-U   -Uvh</td><td>升级+安装</td><td>&#32;</td></tr><tr><td></td><td>-F    -Fvh</td><td>升级(此包已经安装了)</td><td>&#32;</td></tr><tr><td></td><td>–force</td><td>有冲突强制升级</td><td>&#32;</td></tr><tr><td></td><td>–nodeps</td><td>忽略包依赖性关系</td><td>&#32;</td></tr><tr><td>卸载</td><td>-e</td><td>卸载</td><td>rpm  -e  包名</td></tr><tr><td></td><td>–nodeps</td><td>忽略包依赖性关系</td><td>&#32;</td></tr><tr><td>查询</td><td>-q&#124;–query</td><td>&#32;</td><td>rpm -q&#124;–query  包名</td></tr><tr><td></td><td>-qa</td><td>查看所有已经安装的包</td><td>rpm -qa  查看所有包名 <br>rpm -qa &#124; grep 包名查看某个包名</td></tr><tr><td></td><td>-qi</td><td>查看包的摘要信息</td><td>&#32;</td></tr><tr><td></td><td>-qf</td><td>查看文件是有那个包安装的</td><td>rpm  -qf  /path/to/file</td></tr><tr><td></td><td>-ql</td><td>查看包安装生成的文件清单</td><td>&#32;</td></tr><tr><td></td><td>-qc</td><td>查看包安装生成的配置文件</td><td>&#32;</td></tr><tr><td></td><td>-qd</td><td>查看包安装生成的帮助文档</td><td>&#32;</td></tr><tr><td></td><td>-q  –scripts</td><td>查看相关的脚本</td><td>rpm -q–script   包名</td></tr><tr><td></td><td>-qp[i&#124;l&#124;d&#124;c]</td><td>查看尚未安装包的详细信息</td><td>rpm -qpi /path/to/rpm_file</td></tr><tr><td>校验</td><td>-V</td><td>&#32;</td><td>rpm -V   包名</td></tr><tr><td>数据库管理</td><td>–initdb</td><td>新建</td><td>rpm  –initdb</td></tr><tr><td></td><td>–rebuilddb</td><td>重建</td><td>rpm  –rebuilddb</td></tr></tbody></table><h5 id="3、RPM包安装方法之-yum-安装"><a href="#3、RPM包安装方法之-yum-安装" class="headerlink" title="3、RPM包安装方法之 yum 安装"></a>3、RPM包安装方法之 yum 安装</h5><p>yum(Yellowdog Update  Manager),yum是RPM的前端工具，是基于RPM的一个管理工具，他能自动的解决安装rpm包产生的依赖关系。</p><blockquote><p>yum 的配置文件    /etc/yum.conf<br>yum 的repository仓库的配置文件   /etc/yum.repos.d/*.repo</p></blockquote><p>yum常用命令总结</p><style type="text/css">    table th:nth-of-type(2) {        width: 40%;    }</style><table><thead><tr><th>&#32;</th><th>操作命令</th><th>命令解释</th></tr></thead><tbody><tr><td>列表</td><td><code>yum list &lt;package_name&gt;</code></td><td>列出指定安装软件的清单</td></tr><tr><td></td><td>yum list installed</td><td>列出所有已安装的软件包</td></tr><tr><td></td><td>yum list extras</td><td>列出所有已安装但不在 Yum  仓库內的软件包</td></tr><tr><td></td><td>yum grouplist</td><td>列出所有的组</td></tr><tr><td></td><td>yum grouplist “Group1”</td><td>列出指定组的软件包列表</td></tr><tr><td>安装</td><td><code>yum -y install &lt;package_name&gt;</code></td><td>安装指定的软件</td></tr><tr><td></td><td>yum -y groupinstall “Group1” “Group2”</td><td>安装指定的组</td></tr><tr><td></td><td><code>yum -y localinstall &lt;package_name&gt;</code></td><td>用yum安装下载到本地的rpm包</td></tr><tr><td>更新</td><td>yum check-update</td><td>列出所有可更新的软件清单</td></tr><tr><td></td><td>yum update</td><td>安装所有更新软件</td></tr><tr><td></td><td><code>yum update &lt;package_name&gt;</code></td><td>更新指定的软件</td></tr><tr><td>信息</td><td>yum info</td><td>显示所有包的信息</td></tr><tr><td></td><td><code>yum info &lt;package_name&gt;</code></td><td>显示指定包的信息</td></tr><tr><td></td><td>yum groupinfo “Group1” “Group2”</td><td>显示指定组的信息</td></tr><tr><td>清除</td><td>yum clean all</td><td>清除所有yum所保存的信息</td></tr><tr><td></td><td>yum clean metadata</td><td>只清空保存的数据信息</td></tr><tr><td>其它操作</td><td>yum repolist [all&#124;enable&#124;disable]</td><td>查看yum仓库的个数，默认显示启用的</td></tr><tr><td></td><td>yum   makecache</td><td>手动生成缓存</td></tr><tr><td></td><td><code>yum search &lt;package_name&gt;</code></td><td>查询rpm包</td></tr><tr><td></td><td><code>yum reinstall &lt;package_name&gt;</code></td><td>重新安装一遍</td></tr><tr><td></td><td><code>yum provides &lt;package_name&gt;</code></td><td>列出软件包提供哪些文件</td></tr></tbody></table><h4 id="源码包详解"><a href="#源码包详解" class="headerlink" title="源码包详解"></a>源码包详解</h4><h5 id="1、tar-源码包编译安装"><a href="#1、tar-源码包编译安装" class="headerlink" title="1、tar 源码包编译安装"></a>1、tar 源码包编译安装</h5><p>编译安装的三部曲:<br>在安装三部曲之前，建议先看看解压之后目录里面的包含README, INSTALL文件，这里面的文件会告诉你详细安装步骤。</p><blockquote><p>（1）configure　　　检测编译环境<br>（2）make　　　　　进行编译<br>（3）make install　　编译安装</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;源码包与RPM包的区别&quot;&gt;&lt;a href=&quot;#源码包与RPM包的区别&quot; class=&quot;headerlink&quot; title=&quot;源码包与RPM包的区别&quot;&gt;&lt;/a&gt;源码包与RPM包的区别&lt;/h4&gt;&lt;h5 id=&quot;1、安装之前的区别：概念上的区别&quot;&gt;&lt;a href=&quot;#1、安装之前的区别：概念上的区别&quot; class=&quot;headerlink&quot; title=&quot;1、安装之前的区别：概念上的区别&quot;&gt;&lt;/a&gt;1、安装之前的区别：概念上的区别&lt;/h5&gt;&lt;p&gt;比如说：源码包是开源的，比RPM包安装更自由，但是它安装更慢，更容易报错；RPM包是经过编译的，不能看到源代码，但是它安装更快，报错更容易解决，只有依赖性问题。&lt;/p&gt;
&lt;h5 id=&quot;2、安装之后的区别：安装位置不同&quot;&gt;&lt;a href=&quot;#2、安装之后的区别：安装位置不同&quot; class=&quot;headerlink&quot; title=&quot;2、安装之后的区别：安装位置不同&quot;&gt;&lt;/a&gt;2、安装之后的区别：安装位置不同&lt;/h5&gt;&lt;p&gt;RPM包不需要指定安装位置，它会安装到系统默认位置；而源码包是人为手工设置的，下面我们就来看看到底位置有什么区别&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>解决CentOS7关闭/开启防火墙出现Unit iptables.service failed to load: No such file or directory.</title>
    <link href="http://yoursite.com/2018/03/15/%E8%A7%A3%E5%86%B3CentOS7%E5%85%B3%E9%97%AD-%E5%BC%80%E5%90%AF%E9%98%B2%E7%81%AB%E5%A2%99%E5%87%BA%E7%8E%B0Unit-iptables-service-failed-to-load-No-such-file-or-directory/"/>
    <id>http://yoursite.com/2018/03/15/解决CentOS7关闭-开启防火墙出现Unit-iptables-service-failed-to-load-No-such-file-or-directory/</id>
    <published>2018-03-15T09:11:04.000Z</published>
    <updated>2018-03-15T10:35:24.549Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS7中执行<br><code>service iptables start/stop</code></p><blockquote><p>会报错Failed to start iptables.service: Unit iptables.service failed to load: No such file or directory.</p></blockquote><p>在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，当然你可以还原传统的管理方式。或则使用新的命令进行管理。<br><a id="more"></a></p><p>1、还原传统的管理方式<br>执行一下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld  #停止 firewalld</span><br><span class="line">systemctl mask firewalld  #禁用 firewalld</span><br></pre></td></tr></table></figure></p><p>并且安装iptables-services：<br><code>yum install iptables-services</code></p><p>设置开机启动：<br><code>systemctl enable iptables</code></p><p>启动iptables：<br><code>systemctl start iptables</code></p><p>保存设置：<br>service iptables save 或者 /usr/libexec/iptables/iptables.init save</p><p>常用命令：<br>systemctl [stop|start|restart|reload] iptables（分开执行）</p><p>OK，再试一下传统管理方式应该就好使了。</p><p>2、使用新的防火墙firewalld进行管理</p><p>待补充…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS7中执行&lt;br&gt;&lt;code&gt;service iptables start/stop&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;会报错Failed to start iptables.service: Unit iptables.service failed to load: No such file or directory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，当然你可以还原传统的管理方式。或则使用新的命令进行管理。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Linux问题" scheme="http://yoursite.com/categories/Linux/Linux%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>SVN 详解之常用操作命令（三）</title>
    <link href="http://yoursite.com/2018/03/15/SVN-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/15/SVN-详解之常用操作命令（三）/</id>
    <published>2018-03-15T06:10:44.000Z</published>
    <updated>2018-03-15T06:16:45.234Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、检出"><a href="#1、检出" class="headerlink" title="1、检出"></a>1、检出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span><br><span class="line">svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名</span><br><span class="line">简写：svn co xxx</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn checkout svn://localhost/测试工具 /home/testtools –username ben<br>svn checkout <a href="http://localhost/test/testapp" target="_blank" rel="noopener">http://localhost/test/testapp</a> –username ben<br>注：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。<br>　　其中 username 与 password前是两个短线，不是一个。<br>　　不指定本地目录全路径，则检出到当前目录下。<br><a id="more"></a></p><h4 id="2、导出"><a href="#2、导出" class="headerlink" title="2、导出"></a>2、导出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn  export  [-r 版本号]  http://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">svn  export  [-r 版本号]  svn://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">svn  export  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br></pre></td></tr></table></figure><p><strong>例子：</strong><br>svn export svn://localhost/测试工具 /home/testtools –username ben<br>svn export svn://localhost/test/testapp –username ben<br>svn export /home/testapp /home/testtools<br>注：第一种从版本库导出干净工作目录树的形式是指定URL，如果指定了修订版本号，会导出相应的版本，如果没有指定修订版本，则会导出最新的，导出到指定位置。如果省略本地目录全路径，URL的最后一部分会作为本地目录的名字。<br>第二种形式是指定 本地检出的目录全路径 到 要导出的本地目录全路径，所有的本地修改将会保留，但是不在版本控制下(即没提交的新文件，因为.svn文件夹里没有与之相关的信息记录)的文件不会拷贝。</p></blockquote><h4 id="3、添加新文件"><a href="#3、添加新文件" class="headerlink" title="3、添加新文件"></a>3、添加新文件</h4><p><code>svn　add　文件名</code><br>注：告诉SVN服务器要添加文件了，还要用svn commint -m真实的上传上去！</p><blockquote><p><strong>例子：</strong><br>svn add test.php     #添加test.php<br>svn commit -m “添加我的测试用test.php“ test.php<br>svn add <em>.php         #添加当前目录下所有的php文件<br>svn commit -m “添加我的测试用全部php文件“ </em>.php</p></blockquote><h4 id="4、提交"><a href="#4、提交" class="headerlink" title="4、提交"></a>4、提交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn　commit　-m　“提交备注信息文本“　[-N]　[--no-unlock]　文件名</span><br><span class="line">简写：svn ci xxx</span><br></pre></td></tr></table></figure><p>注：必须带上-m参数，参数可以为空，但是必须写上-m</p><blockquote><p><strong>例子：</strong><br>svn commit -m “提交当前目录下的全部在版本控制下的文件“ <em>          #注意这个</em>表示全部文件<br>svn commit -m “提交我的测试用test.php“ test.php<br>svn commit -m “提交我的测试用test.php“ -N –no-unlock test.php     #保持锁就用–no-unlock开关<br>svn ci -m “提交当前目录下的全部在版本控制下的文件“ <em>             #注意这个</em>表示全部文件<br>svn ci -m “提交我的测试用test.php“ test.php<br>svn ci -m “提交我的测试用test.php“ -N –no-unlock test.php         #保持锁就用–no-unlock开关</p></blockquote><h4 id="5、更新"><a href="#5、更新" class="headerlink" title="5、更新"></a>5、更新</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn　update</span><br><span class="line">svn　update　-r　修正版本　文件名</span><br><span class="line">svn　update　文件名</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn update                         #后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本<br>svn update -r 200 test.cpp         #将版本库中的文件 test.cpp 还原到修正版本（revision）200<br>svn update test.php             #更新与版本库同步。<br>　　提交的时候提示过期冲突，需要先 update 修改文件，然后清除svn resolved，最后再提交commit。</p></blockquote><h4 id="6、删除"><a href="#6、删除" class="headerlink" title="6、删除"></a>6、删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">svn　delete　svn://路径(目录或文件的全路径) -m “删除备注信息文本”</span><br><span class="line">推荐如下操作：</span><br><span class="line">svn　delete　文件名 </span><br><span class="line">svn　ci　-m　“删除备注信息文本”</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn delete svn://localhost/testapp/test.php -m “删除测试文件test.php”<br>推荐如下操作：<br>svn delete test.php<br>svn ci -m “删除测试文件test.php”</p></blockquote><h4 id="7、比较差异"><a href="#7、比较差异" class="headerlink" title="7、比较差异"></a>7、比较差异</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn　diff　文件名 </span><br><span class="line">svn　diff　-r　修正版本号m:修正版本号n　文件名</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn diff test.php                 #将修改的文件与基础版本比较<br>svn diff -r 200:201 test.php     #对 修正版本号200 和 修正版本号201 比较差异</p></blockquote><h4 id="8、查看文件或者目录状态"><a href="#8、查看文件或者目录状态" class="headerlink" title="8、查看文件或者目录状态"></a>8、查看文件或者目录状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">svn st 目录路径/名</span><br><span class="line">svn status 目录路径/名  #目录下的文件和子目录的状态，正常状态不显示 </span><br><span class="line">　　　　　　　　　　　　　【?：不在svn的控制中；  M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 </span><br><span class="line">svn st -v 目录路径/名</span><br><span class="line">svn status -v 目录路径/名  #显示文件和子目录状态</span><br><span class="line">　　　　　　　　　　　　　　【第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人】</span><br></pre></td></tr></table></figure><p>注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。</p><h4 id="9、查看日志"><a href="#9、查看日志" class="headerlink" title="9、查看日志"></a>9、查看日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　log　文件名</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn log test.php     #显示这个文件的所有修改记录，及其版本号的变化</p></blockquote><h4 id="10、查看文件详细信息"><a href="#10、查看文件详细信息" class="headerlink" title="10、查看文件详细信息"></a>10、查看文件详细信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn info file</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn info test.php</p></blockquote><h4 id="11、帮助"><a href="#11、帮助" class="headerlink" title="11、帮助"></a>11、帮助</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn help#全部功能选项</span><br><span class="line">svn help ci #具体功能的说明</span><br></pre></td></tr></table></figure><h4 id="12、加锁-解锁"><a href="#12、加锁-解锁" class="headerlink" title="12、加锁/解锁"></a>12、加锁/解锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn　lock　-m　“加锁备注信息文本“　[--force]　文件名 </span><br><span class="line">svn　unlock　文件名</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn lock -m “锁信测试用test.php文件“ test.php<br>svn unlock test.php</p></blockquote><h4 id="13、查看版本库下的文件和目录列表"><a href="#13、查看版本库下的文件和目录列表" class="headerlink" title="13、查看版本库下的文件和目录列表"></a>13、查看版本库下的文件和目录列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn list svn://路径（目录或文件的全路径） </span><br><span class="line">简写：svn ls xx</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn list svn://localhost/test<br>svn ls svn://localhost/test      #显示svn://localhost/test目录下的所有属于版本库的文件和目录</p></blockquote><h4 id="14、创建纳入版本控制下的新目录"><a href="#14、创建纳入版本控制下的新目录" class="headerlink" title="14、创建纳入版本控制下的新目录"></a>14、创建纳入版本控制下的新目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn mkdir 目录名</span><br><span class="line">svn mkdir -m &quot;新增目录备注文本&quot; http://目录全路径</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn mkdir newdir<br>svn mkdir -m “Making a new dir.” svn://localhost/test/newdir<br>注：添加完子目录后，一定要回到根目录更新一下，不然在该目录下提交文件会提示“提交失败”</p></blockquote><p><code>svn update</code></p><blockquote><p>注：如果手工在 checkout 出来的目录中新建目录 newsubdir，再用 svn mkdir newsubdir 命令后，SVN会提示：<br>svn: 尝试用 “svn add”或 “svn add –non-recursive”代替？<br>svn: 无法创建目录“hello”: 文件已经存在<br>此时用如下命令解决：<br><code>svn add --non-recursive newsubdir</code><br>在进入这个newsubdir文件夹，用ls -a查看它下面的全部目录与文件，会发现多了：.svn目录。再用 svn mkdir -m “添hello功能模块文件” svn://localhost/test/newdir/newsubdir 命令。</p></blockquote><h4 id="15、恢复本地修改"><a href="#15、恢复本地修改" class="headerlink" title="15、恢复本地修改"></a>15、恢复本地修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　revert　[--recursive]　文件名</span><br></pre></td></tr></table></figure><p>注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</p><blockquote><p><strong>例子：</strong><br>svn revert foo.c               #丢弃对一个文件的修改<br>svn revert –recursive .     #恢复一整个目录的文件，. 为当前目录</p></blockquote><h4 id="16、把工作拷贝更新到别的URL"><a href="#16、把工作拷贝更新到别的URL" class="headerlink" title="16、把工作拷贝更新到别的URL"></a>16、把工作拷贝更新到别的URL</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　switch　http://目录全路径　本地目录全路径</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn switch <a href="http://localhost/test/456" target="_blank" rel="noopener">http://localhost/test/456</a> .  # (原为123的分支)当前所在目录分支到localhost/test/456</p></blockquote><h4 id="17、解决冲突"><a href="#17、解决冲突" class="headerlink" title="17、解决冲突"></a>17、解决冲突</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　resolved　[本地目录全路径]</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>$ svn update<br>C foo.c<br>Updated to revision 31.<br>如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：<br>$ ls<br>foo.c<br>foo.c.mine<br>foo.c.r30<br>foo.c.r31<br>当你解决了foo.c的冲突，并且准备提交，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。<br>你可以仅仅删除冲突的文件并且提交，但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。</p></blockquote><h4 id="18、不checkout而查看输出特定文件或URL的内容"><a href="#18、不checkout而查看输出特定文件或URL的内容" class="headerlink" title="18、不checkout而查看输出特定文件或URL的内容"></a>18、不checkout而查看输出特定文件或URL的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　cat　http://文件全路径</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn cat <a href="http://localhost/test/readme.txt" target="_blank" rel="noopener">http://localhost/test/readme.txt</a></p></blockquote><h4 id="19、新建一个分支copy"><a href="#19、新建一个分支copy" class="headerlink" title="19、新建一个分支copy"></a>19、新建一个分支copy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn copy branchA branchB  -m &quot;make B branch&quot; // 从branchA拷贝出一个新分支branchB</span><br></pre></td></tr></table></figure><p>20、合并内容到分支merge<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn merge branchA branchB  // 把对branchA的修改合并到分支branchB</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、检出&quot;&gt;&lt;a href=&quot;#1、检出&quot; class=&quot;headerlink&quot; title=&quot;1、检出&quot;&gt;&lt;/a&gt;1、检出&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;简写：svn co xxx&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;例子：&lt;/strong&gt;&lt;br&gt;svn checkout svn://localhost/测试工具 /home/testtools –username ben&lt;br&gt;svn checkout &lt;a href=&quot;http://localhost/test/testapp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://localhost/test/testapp&lt;/a&gt; –username ben&lt;br&gt;注：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。&lt;br&gt;　　其中 username 与 password前是两个短线，不是一个。&lt;br&gt;　　不指定本地目录全路径，则检出到当前目录下。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="SVN" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/SVN/"/>
    
    
      <category term="SVN" scheme="http://yoursite.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>SVN 详解之客户端安装（二）</title>
    <link href="http://yoursite.com/2018/03/15/SVN-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/15/SVN-详解之客户端安装（二）/</id>
    <published>2018-03-15T06:10:26.000Z</published>
    <updated>2018-03-15T07:28:08.379Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Linux-下安装"><a href="#Linux-下安装" class="headerlink" title="Linux 下安装"></a>Linux 下安装</h4><p>CentOS 系统可使用yum 软件包管理器直接安装，Debian、Ubuntu 系统可使用apt-get 软件包管理器直接安装。此处，我们使用一种通用的安装方式，源码安装。</p><h5 id="1、下载及解压"><a href="#1、下载及解压" class="headerlink" title="1、下载及解压"></a>1、下载及解压</h5><p>下载地址：<a href="http://subversion.apache.org/download/" target="_blank" rel="noopener"><font color="red">传送门</font></a><br><code>tar xvf subversion-1.9.7.tar.bz2</code><br><a id="more"></a></p><h5 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/subersion</span><br><span class="line">cd subversion-1.9.7</span><br><span class="line">./configure --prefix=/usr/local/subversion  #指定安装路径</span><br></pre></td></tr></table></figure><h5 id="3、解析及安装文件"><a href="#3、解析及安装文件" class="headerlink" title="3、解析及安装文件"></a>3、解析及安装文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure><h5 id="4、测试及建立软链接"><a href="#4、测试及建立软链接" class="headerlink" title="4、测试及建立软链接"></a>4、测试及建立软链接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/subversion/bin</span><br><span class="line">svn</span><br><span class="line">ln -s /usr/local/subversion/bin/svn /sbin/svn</span><br><span class="line">cd /</span><br><span class="line">svn</span><br></pre></td></tr></table></figure><h4 id="Windows下安装"><a href="#Windows下安装" class="headerlink" title="Windows下安装"></a>Windows下安装</h4><h5 id="1、SVN客户端下载及安装"><a href="#1、SVN客户端下载及安装" class="headerlink" title="1、SVN客户端下载及安装"></a>1、SVN客户端下载及安装</h5><p>下载地址：<a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener"><font color="red">传送门</font></a><br>安装根据下一步操作即可完成…</p><h5 id="2、SVN客户端配置"><a href="#2、SVN客户端配置" class="headerlink" title="2、SVN客户端配置"></a>2、SVN客户端配置</h5><p>这里要特别声明一下——<font color="red">SVN客户端不是指一个桌面应用程序，而是集成到系统的右键菜单中的插件。</font>因此使用客户端向资源库下载项目资源、提交项目资源等都是通过右键菜单来完成的。</p><p>在桌面空白处右键：<br><img src="/uploads/2018/03/svn_image_01.png" alt=""></p><p>选择  设置 ，打开设置面板：<br>可以设置语言：<br><img src="/uploads/2018/03/svn_image_02.png" alt=""><br>也可以设置 项目资源的图标，通过不同图标来指示下载到本地的项目资源文件发生了什么变化，比如：修改、新增、删除等等。</p><h5 id="3、SVN-基础操作"><a href="#3、SVN-基础操作" class="headerlink" title="3、SVN 基础操作"></a>3、SVN 基础操作</h5><h6 id="（1）检出"><a href="#（1）检出" class="headerlink" title="（1）检出"></a>（1）检出</h6><p>在你的本地项目文件夹或随便一个地方，右键空白处弹出菜单，选择 SVN检出。然后，通过从SVN服务端获取的 <font color="red">资源库URL+具体的项目文件夹名</font> 下载相应项目，并可以知道下载项目的保存位置<br><img src="/uploads/2018/03/svn_image_03.png" alt=""></p><h6 id="（2）修改及提交"><a href="#（2）修改及提交" class="headerlink" title="（2）修改及提交"></a>（2）修改及提交</h6><ol><li>把项目下载到本机后，其实就是一个普通的项目文件而已，你可以在里面添加文件、修改文件、删除文件等等。</li><li>提交修改<br>在项目文件空白处右键，选择 SVN提交。然后，输入 <font color="red">本次提交的版本更新信息（所作修改的注释）、勾选要提交的操作内容，点击 确定，即可把本机项目提交到SVN服务器资源库，覆盖掉资源库项目从而实现更新。</font><br>（如果发生提交冲突，即两人都提交修改，后提交者由于版本落后会提交失败。这时可以先把自己的项目备份，然后从服务端下载最新的项目（下面有讲SVN更新），再把自己的项目覆盖到本地项目文件夹，最后SVN提交即可成功提交）<br>（SVN不提供历史版本功能，所以项目被覆盖后就找不回来了，所以切记备份。如果需要历史版本的保存功能，推荐使用Git）<br><img src="/uploads/2018/03/svn_image_04.png" alt=""></li></ol><h6 id="（3）更新"><a href="#（3）更新" class="headerlink" title="（3）更新"></a>（3）更新</h6><p>如果别人修改了SVN服务端资源库上的项目，你想下载最新的项目，则在 本机项目文件空白处单击鼠标右键，选择 SVN更新 ，即可自动完成下载，并会提示所作的更新有哪些。注意：<font color="red">在原项目文件夹内选择SVN更新的话，会自动覆盖掉原有内容。建议：先备份，再更新，防止自己本来的项目内容丢失。</font><br><img src="/uploads/2018/03/svn_image_05.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Linux-下安装&quot;&gt;&lt;a href=&quot;#Linux-下安装&quot; class=&quot;headerlink&quot; title=&quot;Linux 下安装&quot;&gt;&lt;/a&gt;Linux 下安装&lt;/h4&gt;&lt;p&gt;CentOS 系统可使用yum 软件包管理器直接安装，Debian、Ubuntu 系统可使用apt-get 软件包管理器直接安装。此处，我们使用一种通用的安装方式，源码安装。&lt;/p&gt;
&lt;h5 id=&quot;1、下载及解压&quot;&gt;&lt;a href=&quot;#1、下载及解压&quot; class=&quot;headerlink&quot; title=&quot;1、下载及解压&quot;&gt;&lt;/a&gt;1、下载及解压&lt;/h5&gt;&lt;p&gt;下载地址：&lt;a href=&quot;http://subversion.apache.org/download/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font color=&quot;red&quot;&gt;传送门&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;code&gt;tar xvf subversion-1.9.7.tar.bz2&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="SVN" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/SVN/"/>
    
    
      <category term="SVN" scheme="http://yoursite.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>SVN 详解之服务器搭建（一）</title>
    <link href="http://yoursite.com/2018/03/15/SVN-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/15/SVN-详解之服务器搭建（一）/</id>
    <published>2018-03-15T06:09:57.000Z</published>
    <updated>2018-03-19T02:52:16.666Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、使用-yum-安装SVN"><a href="#1、使用-yum-安装SVN" class="headerlink" title="1、使用 yum 安装SVN"></a>1、使用 yum 安装SVN</h4><p><code>[root@singledb ~]# yum install -y subversion</code></p><h4 id="2、验证安装版本及是否成功安装"><a href="#2、验证安装版本及是否成功安装" class="headerlink" title="2、验证安装版本及是否成功安装"></a>2、验证安装版本及是否成功安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@singledb ~]# svnserve --version</span><br><span class="line">svnserve, version 1.4.2 (r22196)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="3、创建-SVN-版本库"><a href="#3、创建-SVN-版本库" class="headerlink" title="3、创建 SVN 版本库"></a>3、创建 SVN 版本库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@singledb ~]# mkdir /var/svn  //创建存放版本库文件的目录</span><br><span class="line">[root@singledb ~]# svnadmin create /var/svn/testsvn  //创建版本库</span><br></pre></td></tr></table></figure><h4 id="4、SVN-配置"><a href="#4、SVN-配置" class="headerlink" title="4、SVN 配置"></a>4、SVN 配置</h4><p>创建版本库后，在这个目录下会生成3个配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@singledb conf]# pwd</span><br><span class="line">/var/svn/testsvn/conf</span><br><span class="line">[root@singledb conf]# ls</span><br><span class="line">authz  passwd  svnserve.conf</span><br></pre></td></tr></table></figure></p><blockquote><p>（1）svnserve.conf：  svn服务配置文件。<br>（2）passwd： 用户名口令文件，负责账号和密码的用户名单管理。<br>（3）authz： 权限配置文件，控制账号的读写权限。 </p></blockquote><p><strong>svnserve.conf 文件， 该文件配置项分为以下5项：</strong></p><ul><li>anon-access： 控制非鉴权用户访问版本库的权限。</li><li>auth-access：  控制鉴权用户访问版本库的权限。</li><li>password-db： 指定用户名口令文件名。</li><li>authz-db：指定权限配置文件名，通过该文件可以实现以路径为基础的访问控制。</li><li>realm：指定版本库的认证域，即在登录时提示的认证域名称。若两个版本库的认证域相同，建议使用相同的用户名口令数据文件</li></ul><font color="red">（注意：将此五项都给去注释的时候，一定要顶格，不然会报错； realm指要认证的版本库，填写自己要配置的版本库即可）</font><p><strong>authz 文件 ：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#这里把不同用户放到不同的组里面，下面在设置目录访问权限的时候，用用户组来操作就可以了。</span><br><span class="line">（注：此处可不使用groups概念，在下方可直接添加可操作的人员即可。）</span><br><span class="line">[groups]</span><br><span class="line">admin = admin</span><br><span class="line">dev = ben,nana</span><br><span class="line">test = test</span><br><span class="line"></span><br><span class="line"># 为所有库指定默认访问规则</span><br><span class="line"># 所有人可以读，管理员可以写</span><br><span class="line">[/]</span><br><span class="line">* = r</span><br><span class="line">@admin = rw</span><br><span class="line"></span><br><span class="line"># 允许开发人员可以完全访问他们的项目版本库</span><br><span class="line">[devproject:/]</span><br><span class="line">@dev = rw</span><br><span class="line"></span><br><span class="line"># 允许测试人员访问其中的test目录</span><br><span class="line">[devproject:/test]</span><br><span class="line">@test = rw</span><br></pre></td></tr></table></figure></p><p><strong>Passwd 文件 ：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line"># harry = harryssecret</span><br><span class="line"># sally = sallyssecret</span><br><span class="line">ben = ben1234</span><br><span class="line">nana = nana1234</span><br></pre></td></tr></table></figure></p><h4 id="5、启动和停止SVN服务"><a href="#5、启动和停止SVN服务" class="headerlink" title="5、启动和停止SVN服务"></a>5、启动和停止SVN服务</h4><p>启动SVN服务：<br><code>svnserve -d -r /home/svn   （/home/svn 为版本库的根目录）</code><br>关闭SVN服务：<br>① 使用以下命令查找进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# ps aux | grep svn</span><br><span class="line">root      8530  0.0  0.0 112660   972 pts/0    R+   14:44   0:00 grep --color=auto svn</span><br><span class="line">root     31964  0.0  0.0 166336   908 ?        Ss   11:28   0:00 svnserve -d -r /var/svn</span><br></pre></td></tr></table></figure></p><p>② 使用Kill命令杀死进程<br><code>kill -s 9 31964        （31964为进程ID）</code></p><h4 id="6、客户端检出访问-svn-服务器"><a href="#6、客户端检出访问-svn-服务器" class="headerlink" title="6、客户端检出访问 svn 服务器"></a>6、客户端检出访问 svn 服务器</h4><p><code>svn co svn://118.24.8.229/&lt;repo&gt;</code> 即可检出代码（注：repo为代码库名称）。会弹出输入用户名和密码。</p><p><strong>注：我们搭建的SVN是独立服务器形式运行的，没有和Apache整合，所以SVN地址为：svn://xxx/xxx，而不是<a href="http://xxx/xxx或https://xxx/xxx。" target="_blank" rel="noopener">http://xxx/xxx或https://xxx/xxx。</a></strong><br>Apache 搭建HTTP方式访问SVN服务器：<a href="http://blog.csdn.net/robertohuang/article/details/55504445" target="_blank" rel="noopener"><font color="red">传送门</font></a></p><hr><h4 id="问题集锦"><a href="#问题集锦" class="headerlink" title="问题集锦"></a>问题集锦</h4><h5 id="（1）SVN-检出错误"><a href="#（1）SVN-检出错误" class="headerlink" title="（1）SVN 检出错误"></a>（1）SVN 检出错误</h5><blockquote><p>在 Windows下检出SVN仓库报错：<br>Unable to connect to a repository at URL ‘svn://118.24.8.229/testsvn’<br>Can’t connect to host ‘118.24.8.229’: 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。</p></blockquote><p>经查找知道，是因为服务器端的对应端口未开启：3690.<br>在服务端开启即可：<br><code>iptables -A INPUT -p tcp -m tcp --dport 3690 -j ACCEPT</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、使用-yum-安装SVN&quot;&gt;&lt;a href=&quot;#1、使用-yum-安装SVN&quot; class=&quot;headerlink&quot; title=&quot;1、使用 yum 安装SVN&quot;&gt;&lt;/a&gt;1、使用 yum 安装SVN&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[root@singledb ~]# yum install -y subversion&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;2、验证安装版本及是否成功安装&quot;&gt;&lt;a href=&quot;#2、验证安装版本及是否成功安装&quot; class=&quot;headerlink&quot; title=&quot;2、验证安装版本及是否成功安装&quot;&gt;&lt;/a&gt;2、验证安装版本及是否成功安装&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@singledb ~]# svnserve --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svnserve, version 1.4.2 (r22196)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="SVN" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/SVN/"/>
    
    
      <category term="SVN" scheme="http://yoursite.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>代码版本管理系统</title>
    <link href="http://yoursite.com/2018/03/15/%E4%BB%A3%E7%A0%81%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/03/15/代码版本管理系统/</id>
    <published>2018-03-15T06:07:43.000Z</published>
    <updated>2018-03-15T06:12:11.722Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码版本管理系统的概述"><a href="#代码版本管理系统的概述" class="headerlink" title="代码版本管理系统的概述"></a>代码版本管理系统的概述</h4><h5 id="1、什么是版本控制"><a href="#1、什么是版本控制" class="headerlink" title="1、什么是版本控制"></a>1、什么是版本控制</h5><p>版本控制的核心是这样一个简单的概念，即对一个或者多个文件的追踪过程，随着这些文件演变成一个或多个产品的过程。特别是版本控制追踪什么变化，是什么改变了它，为什么会这样。版本控制系统提供了一个有益的说明，这些说明在传统的文件管理中是找不到的。</p><p>需要注意的是版本控制使用不仅是局限于程序员。版本控制可以被任何人用来维护文件目录，因此即便你不是程序也可以因此受益。<br><a id="more"></a></p><h5 id="2、集中式版本控制介绍"><a href="#2、集中式版本控制介绍" class="headerlink" title="2、集中式版本控制介绍"></a>2、集中式版本控制介绍</h5><p>集中化的版本控制系统(Centralized Version Control Systems，简称 CVCS)应运而生。 这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。</p><p>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p><h5 id="3、分布式版本控制介绍"><a href="#3、分布式版本控制介绍" class="headerlink" title="3、分布式版本控制介绍"></a>3、分布式版本控制介绍</h5><p>于是分布式版本控制系统(Distributed Version Control System，简称 DVCS)面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p><h5 id="4、SVN与Git的最主要的区别？"><a href="#4、SVN与Git的最主要的区别？" class="headerlink" title="4、SVN与Git的最主要的区别？"></a>4、SVN与Git的最主要的区别？</h5><p>　　SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p><p>　　Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h5 id="5、总结："><a href="#5、总结：" class="headerlink" title="5、总结："></a>5、总结：</h5><p>分布式代码版本管理系统并不一定适合所有团队，比如中小团队可能更关心的只是成本更低，简单易用，那么SVN等这类集中式版本管理工具还是更为适合。但是不管团队最终选用什么代码版本管理工具，只要适合自己的团队的开发流程和工作方式，并且代码管理顺畅就可以了。</p><h4 id="代码版本管理系统的历史"><a href="#代码版本管理系统的历史" class="headerlink" title="代码版本管理系统的历史"></a>代码版本管理系统的历史</h4><p>代码版本管理系统大致可以分为三个时代：</p><h5 id="第一代：本地式"><a href="#第一代：本地式" class="headerlink" title="第一代：本地式"></a>第一代：本地式</h5><p>这代主要的特点提供本地代码版本控制，比如SCCS(1972)、 PVCS(1985)等。<br>这代主要实现了基本的代码版本管理，但缺点是无法让多人同时对一个版本库进行修改。这个也和当时软件规模不够大有关，也没有这样的需求。</p><h5 id="第二代：客户端-服务器式"><a href="#第二代：客户端-服务器式" class="headerlink" title="第二代：客户端-服务器式"></a>第二代：客户端-服务器式</h5><p>这代主要的特点是提供集中式服务器端代码版本控制,比如 CVS(1986), ClearCase(1992), Visual SourceSafe(1994), Perforce(1995), Subversion(2000) 等。</p><p>这代主要是实现了中心服务器端的代码版本管理，特点是可以让多人同时对一个代码版本库进行同步和修改，但缺点也相当明显：</p><ul><li>在无法连接服务器的情况下，无法查看日志以及提交和比较代码版本（慢速网络和远程异地工作的程序员的痛），以及当服务或者网络出现问题的时候很多人员就会无法工作。</li><li>不支持local branch，导致branch创建管理复杂，并且一旦创建就很难修改（快速迭代开发中的程序员的痛）</li><li>由于只有一个中心端服务器，一旦发生灾难性问题，那么所有日志都会丢失，所以需要经常做备份（备份需要不小的成本）</li><li>如果软件代码量过于庞大，一般会出现速度缓慢的情况，因为每次的日志查询、不同版本之间的代码比较和代码提交等操作都需要和服务器通信，造成服务器端的负载过大。</li></ul><h5 id="第三代：分布式"><a href="#第三代：分布式" class="headerlink" title="第三代：分布式"></a>第三代：分布式</h5><p>这代主要的特点是提供分布式代码版本控制,比如Git(2005), Mercurial(2005)等。<br>这代结合了第一代和第二代的优点并实现了分布式的代码版本管理。<br>这代的优点：分布式管理，在没有和服务器有连接的情况下仍然可以查看日志，提交代码，创建分支；支持local branch，可以快速方便的实现各种分支管理；支持分布式，从而可以实现分块管理，以及负载分流管理。<br>缺点是有一定的学习曲线，比如分布方式下的代码同步，local branch的理解与运用，分布式代码管理的理解与运用等。详细的比较可以参考：这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;代码版本管理系统的概述&quot;&gt;&lt;a href=&quot;#代码版本管理系统的概述&quot; class=&quot;headerlink&quot; title=&quot;代码版本管理系统的概述&quot;&gt;&lt;/a&gt;代码版本管理系统的概述&lt;/h4&gt;&lt;h5 id=&quot;1、什么是版本控制&quot;&gt;&lt;a href=&quot;#1、什么是版本控制&quot; class=&quot;headerlink&quot; title=&quot;1、什么是版本控制&quot;&gt;&lt;/a&gt;1、什么是版本控制&lt;/h5&gt;&lt;p&gt;版本控制的核心是这样一个简单的概念，即对一个或者多个文件的追踪过程，随着这些文件演变成一个或多个产品的过程。特别是版本控制追踪什么变化，是什么改变了它，为什么会这样。版本控制系统提供了一个有益的说明，这些说明在传统的文件管理中是找不到的。&lt;/p&gt;
&lt;p&gt;需要注意的是版本控制使用不仅是局限于程序员。版本控制可以被任何人用来维护文件目录，因此即便你不是程序也可以因此受益。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="SVN" scheme="http://yoursite.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>Git 详解之常用命令汇总（四）</title>
    <link href="http://yoursite.com/2018/03/14/Git-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/14/Git-详解之常用命令汇总（四）/</id>
    <published>2018-03-14T09:48:01.000Z</published>
    <updated>2018-03-15T06:09:27.010Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Git提交三步走："><a href="#Git提交三步走：" class="headerlink" title="Git提交三步走："></a>Git提交三步走：</h4><p>（1）git add xx<br>git add xx命令可以将xx文件添加到暂存区，如果有很多改动可以通过 git add -A .来一次添加所有改变的文件。<br>注意 -A 选项后面还有一个句点。 git add -A表示添加所有内容， git add . 表示添加新文件和编辑过的文件不包括删除的文件; git add -u 表示添加编辑或者删除的文件，不包括新添加的文件<br>（2）git commit -m “注释”<br>（3）git push origin 分支名称，一般使用：git push origin master</p><p>正常来说，这三步基本满足需求了。<br><a id="more"></a></p><h4 id="下面进行命令的详细介绍"><a href="#下面进行命令的详细介绍" class="headerlink" title="下面进行命令的详细介绍"></a>下面进行命令的详细介绍</h4><p><code>git checkout</code>  查看当前分支</p><p><code>git branch name</code>  新建分支name<br><code>git checkout name</code>  切换当前分支为name</p><p><font color="red">合并语句：</font><code>git checkout -b name</code>  新建分支并切换到分支name</p><p><code>git add filename</code>  增加文件到分支<br><code>git commit -m &quot;remark&quot;</code>  提交修改内容到分支并添加注释</p><p><font color="red">合并语句：</font><code>git commit -m &quot;remark&quot; filename</code></p><p><code>git diff filename</code>  查看文件修改了什么内容</p><p><code>git status</code>  查看当前工作区状态</p><p><code>git checkout master</code><br><code>git merge name</code>  合并分支到master分支</p><p><code>git branch -d name</code>  删除name分支</p><p><code>git log --graph --pretty=oneline --abbrev-commit</code>  用git log查看分支历史</p><h4 id="特殊需求详解："><a href="#特殊需求详解：" class="headerlink" title="特殊需求详解："></a>特殊需求详解：</h4><h5 id="1、合并文件："><a href="#1、合并文件：" class="headerlink" title="1、合并文件："></a>1、合并文件：</h5><p><code>git merge name</code> 这种合并 Git会优先选择 Fast forward模式，这种模式下，删除分支后，会丢掉分支信息<br>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样从分支历史上就可以看出来分支信息。<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>  合并分支dev并禁用Fast forward模式 </p><h5 id="2、冲突解决："><a href="#2、冲突解决：" class="headerlink" title="2、冲突解决："></a>2、冲突解决：</h5><p>① 手动修改冲突文件并再次提交<br>打开产生冲突的文件后，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，>>>>>>>标记出不同分支的内容，其中<code>&lt;&lt;&lt;HEAD</code>是指主分支修改的内容，<code>&gt;&gt;&gt;&gt;&gt;fenzhi1</code> 是指fenzhi1上修改的内容，我们可以修改后保存即解决冲突。</p><h5 id="3、版本回退："><a href="#3、版本回退：" class="headerlink" title="3、版本回退："></a>3、版本回退：</h5><p>（1）使用<code>HEAD^</code>回退版本，<code>HEAD^</code>回退上个版本，<code>HEAD^^</code>回退上上个版本，以此类推。如果回退前100个版本的话，使用<code>HEAD~100</code>即可。<br><code>git reset --hard HEAD^</code><br><code>git reset --hard HEAD~100</code></p><p>（2）使用commit_id回退版本<br><code>git log</code> 查看需要回退的 commit_id<br><code>git reflog</code> 查看未来版本的 commit_id<br><code>git reset --hard commit_id</code><br>（注：这个回退可以回到以前版本，也可回到未来版本，只要知道commit_id即可）</p><h5 id="4、撤销修改："><a href="#4、撤销修改：" class="headerlink" title="4、撤销修改："></a>4、撤销修改：</h5><p>在工作区：（就是开发环境本地）<br><code>git checkout -- file</code>  可以丢弃工作区的修改。<strong>（注：如果没有 -- 的话，那么命令就变成创建分支了。）</strong></p><p>在暂存区：（已经 git add了）<br><code>git reset HEAD file</code>  可以把暂存区的修改撤销掉，重新放回到工作区</p><p>在本地版本中：（已经提交到分支）<br>只能版本回退了</p><h5 id="5、删除文件："><a href="#5、删除文件：" class="headerlink" title="5、删除文件："></a>5、删除文件：</h5><p>工作区删除：<br><code>rm file</code><br>工作区删除后文件恢复：<br><code>git checkout -- file</code><br>版本库删除：<br><code>git rm file</code><br><code>git commit -m &#39;remark&#39;</code><br>（注：删除后必须得提交更新版本库）</p><h5 id="6、BUG分支"><a href="#6、BUG分支" class="headerlink" title="6、BUG分支"></a>6、BUG分支</h5><p><code>git stash</code>  把当前工作现场“储藏”起来，等以后恢复现场后继续工作<br><code>git stash list</code>  查看工作现场存储到什么地方<br><code>git stash apply</code>  恢复，但stash内容并不删除<br><code>git stash pop</code>  恢复，但同时把stash内容也删除</p><h5 id="7、多人协作"><a href="#7、多人协作" class="headerlink" title="7、多人协作"></a>7、多人协作</h5><p><code>git remote</code>  查看远程库的信息 -v 更详细信息<br>推送分支： 就是把该分支上的所有本地提交推送到远程库。<br><code>git push origin master</code><br>抓取分支：把线上最新的提交抓下来<br><code>git pull</code></p><h4 id="工作模式通常是这样："><a href="#工作模式通常是这样：" class="headerlink" title="工作模式通常是这样："></a>工作模式通常是这样：</h4><p>1、首先，可以试图用git push origin branch-name推送自己的修改；<br>2、如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；<br>3、如果合并有冲突，则解决冲突，并在本地提交；<br>4、没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！<br>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。<br>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Git提交三步走：&quot;&gt;&lt;a href=&quot;#Git提交三步走：&quot; class=&quot;headerlink&quot; title=&quot;Git提交三步走：&quot;&gt;&lt;/a&gt;Git提交三步走：&lt;/h4&gt;&lt;p&gt;（1）git add xx&lt;br&gt;git add xx命令可以将xx文件添加到暂存区，如果有很多改动可以通过 git add -A .来一次添加所有改变的文件。&lt;br&gt;注意 -A 选项后面还有一个句点。 git add -A表示添加所有内容， git add . 表示添加新文件和编辑过的文件不包括删除的文件; git add -u 表示添加编辑或者删除的文件，不包括新添加的文件&lt;br&gt;（2）git commit -m “注释”&lt;br&gt;（3）git push origin 分支名称，一般使用：git push origin master&lt;/p&gt;
&lt;p&gt;正常来说，这三步基本满足需求了。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 详解之客户端安装（三）</title>
    <link href="http://yoursite.com/2018/03/14/Git-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/14/Git-详解之客户端安装（三）/</id>
    <published>2018-03-14T09:47:43.000Z</published>
    <updated>2018-03-15T06:09:21.835Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Linux下安装"><a href="#一、Linux下安装" class="headerlink" title="一、Linux下安装"></a>一、Linux下安装</h4><p>首先，你可以试着输入git，看看系统有没有安装Git：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program &apos;git&apos; is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p><p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。<br>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。<br><a id="more"></a></p><p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code> 这几个命令安装就好了。</p><h4 id="二、windows下安装"><a href="#二、windows下安装" class="headerlink" title="二、windows下安装"></a>二、windows下安装</h4><p>windows下客户端分为两种：<br>（1）Git客户端程序。<br>　　Git目前最新版本2.16.2<br>　　Git官网下载地址：<a href="http://git-scm.com/" target="_blank" rel="noopener"><font color="red">传送门</font></a><br>（2）Git客户端图形化操作程序 TortoiseGit。<br>　　TortoiseGit目前最新版本2.6.0<br>　　TortoiseGit官网下载地址：<a href="http://tortoisegit.org/download/" target="_blank" rel="noopener"><font color="red">传送门</font></a></p><p>安装过程可以按照程序的默认选项，都选择“下一步”安装完成。</p><p><strong>下面以 Git客户端程序为例来安装：</strong></p><blockquote><p>1.双击安装程序“Git-2.10.2-64-bit.exe”<br>2.点击“Next” ，根据自己的情况，选择程序的安装目录。<br>3.继续点击“Next”，显示截图如下：<br><img src="/uploads/2018/03/git_image_01.jpg" alt=""><br><strong>说明：</strong><br>（1）图标组件(Addition icons) : 选择是否创建桌面快捷方式。<br>（2）桌面浏览(Windows Explorer integration) : 浏览源码的方法，使用bash 或者 使用Git GUI工具。<br>（3）关联配置文件 : 是否关联 git 配置文件, 该配置文件主要显示文本编辑器的样式。<br>（4）关联shell脚本文件 : 是否关联Bash命令行执行的脚本文件。<br>（5）使用TrueType编码 : 在命令行中是否使用TruthType编码, 该编码是微软和苹果公司制定的通用编码。<br>4.选择完之后，点击“Next”，开始菜单快捷方式目录：设置开始菜单中快捷方式的目录名称, 也可以选择不在开始菜单中创建快捷方式。<br>5.点击“Next”，显示截图如下：<br><img src="/uploads/2018/03/git_image_02.jpg" alt=""><br><strong>设置环境变量</strong><br>选择使用什么样的命令行工具，一般情况下我们默认使用Git Bash即可：<br>（1）Git自带：使用Git自带的Git Bash命令行工具。<br>（2）系统自带CMD：使用Windows系统的命令行工具。<br>（3）二者都有：上面二者同时配置，但是注意，这样会将windows中的find.exe 和 sort.exe工具覆盖，如果不懂这些尽量不要选择。<br>6.选择之后，继续点击“Next”，显示如下：<br><img src="/uploads/2018/03/git_image_03.jpg" alt=""><br><strong>选择提交的时候换行格式</strong><br>（1）检查出windows格式转换为unix格式：将windows格式的换行转为unix格式的换行再进行提交。<br>（2）检查出原来格式转为unix格式：不管什么格式的，一律转为unix格式的换行再进行提交。<br>（3）不进行格式转换 : 不进行转换，检查出什么，就提交什么。<br>7.选择之后，点击“Next”<br>8.选择之后，点击“Next”<br>9.选择之后，点击“Install”，开始安装</p></blockquote><p>这样，我们的Git客户端就安装完成了。</p><p>安装完成后，在开始菜单里面能够找到 “Git –&gt; Git Bash”,如下：<br><img src="/uploads/2018/03/git_image_04.JPG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、Linux下安装&quot;&gt;&lt;a href=&quot;#一、Linux下安装&quot; class=&quot;headerlink&quot; title=&quot;一、Linux下安装&quot;&gt;&lt;/a&gt;一、Linux下安装&lt;/h4&gt;&lt;p&gt;首先，你可以试着输入git，看看系统有没有安装Git：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The program &amp;apos;git&amp;apos; is currently not installed. You can install it by typing:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。&lt;br&gt;如果你碰巧用Debian或Ubuntu Linux，通过一条&lt;code&gt;sudo apt-get install git&lt;/code&gt;就可以直接完成Git的安装，非常简单。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 详解之服务器搭建（二）</title>
    <link href="http://yoursite.com/2018/03/14/Git-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/14/Git-详解之服务器搭建（二）/</id>
    <published>2018-03-14T09:46:31.000Z</published>
    <updated>2018-03-19T02:58:25.923Z</updated>
    
    <content type="html"><![CDATA[<p>服务器环境：CentOS7 + Git(version 1.8.3.1)</p><h4 id="1、安装Git"><a href="#1、安装Git" class="headerlink" title="1、安装Git"></a>1、安装Git</h4><p>　　<code>yum install -y git</code><br>安装完后，查看 Git 版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# git version</span><br><span class="line">git version 1.8.3.1</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="2、新建Git账号，用来管理Git服务"><a href="#2、新建Git账号，用来管理Git服务" class="headerlink" title="2、新建Git账号，用来管理Git服务"></a>2、新建Git账号，用来管理Git服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# id git</span><br><span class="line">id: git：无此用户</span><br><span class="line">[root@VM_0_7_centos ~]# useradd git</span><br><span class="line">[root@VM_0_7_centos ~]# passwd git</span><br></pre></td></tr></table></figure><h4 id="3、服务器端创建Git仓库"><a href="#3、服务器端创建Git仓库" class="headerlink" title="3、服务器端创建Git仓库"></a>3、服务器端创建Git仓库</h4><p>设置 /data/git/gittest.git 为 Git 仓库<br>然后把 Git 仓库的 owner 修改为 git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# mkdir -p /data/git/gittest.git</span><br><span class="line">[root@VM_0_7_centos ~]# git init --bare /data/git/gittest.git</span><br><span class="line">Initialized empty Git repository in /data/git/gittest.git/</span><br><span class="line">[root@VM_0_7_centos ~]# cd /data/git/</span><br><span class="line">[root@VM_0_7_centos git]# chown -R git:git gittest.git/</span><br></pre></td></tr></table></figure></p><h4 id="4、客户端首次-clone-远程仓库"><a href="#4、客户端首次-clone-远程仓库" class="headerlink" title="4、客户端首次 clone 远程仓库"></a>4、客户端首次 clone 远程仓库</h4><p>进入 Git Bash 命令行客户端，创建项目地址（设置在  /d/MyProjects/gittest.git）并进入；<br>然后从 Linux Git 服务器上 clone 项目：<br><code>$ git clone git@118.24.8.229:/data/git/gittest.git</code></p><p>如果SSH用的不是默认的22端口，则需要使用以下的命令（假设SSH端口号是7700）：<br><code>$ git clone ssh://git@118.24.8.229:7700/home/data/gittest.git</code></p><p>当第一次连接到目标 Git 服务器时会得到一个提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &apos;gittest&apos;...</span><br><span class="line">The authenticity of host &apos;118.24.8.229 (118.24.8.229)&apos; can&apos;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:witKSLOMzfgWBcs78t5LfqmSJ+JEm2/PBEaR0d9mnqA.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br></pre></td></tr></table></figure></p><p>选择 yes：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &apos;118.24.8.229&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">git@118.24.8.229&apos;s password:</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure></p><p>后面提示要输入密码，可以采用 SSH 公钥来进行验证（下面会进行说明）。</p><h4 id="5、服务器端Git打开RSA认证"><a href="#5、服务器端Git打开RSA认证" class="headerlink" title="5、服务器端Git打开RSA认证"></a>5、服务器端Git打开RSA认证</h4><p>进入 /etc/ssh 目录，编辑 sshd_config，打开以下三个配置的注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#RSAAuthentication yes</span><br><span class="line">#PubkeyAuthentication yes</span><br><span class="line">#AuthorizedKeysFile     .ssh/authorized_keys</span><br></pre></td></tr></table></figure></p><blockquote><p>##RSAAuthentication用来设置是否开启RSA密钥验证，只针对SSH1<font color="red">（注：对于SSH2来说，没有此项配置）</font></p><p>##PubkeyAuthentication用来设置是否开启公钥验证，如果使用公钥验证的方式登录时，则设置为yes</p><p>##AuthorizedKeysFile用来设置公钥验证文件的路径，与PubkeyAuthentication配合使用,默认值是”.ssh/authorized_keys”。</p></blockquote><p>保存并重启 sshd 服务：<br><code>[root@VM_0_7_centos git]# systemctl restart sshd</code></p><p>由AuthorizedKeysFile 得知公钥的存放路径是 <code>.ssh/authorized_keys</code>，实际上是 <code>$Home/.ssh/authorized_keys</code>，由于管理 Git 服务的用户是 git，所以实际存放公钥的路径是 <code>/home/git/.ssh/authorized_keys</code>。</p><h4 id="6、客户端创建SSH公钥和私钥并将公钥导入服务器端"><a href="#6、客户端创建SSH公钥和私钥并将公钥导入服务器端" class="headerlink" title="6、客户端创建SSH公钥和私钥并将公钥导入服务器端"></a>6、客户端创建SSH公钥和私钥并将公钥导入服务器端</h4><p><code>$ ssh-keygen -t rsa</code><br>此时 C:\Users\用户名.ssh 下会多出两个文件 id_rsa 和 id_rsa.pub</p><blockquote><p>id_rsa 是私钥<br>id_rsa.pub 是公钥</p></blockquote><p>回到 Git Bash下，导入文件：（注：需要输入服务器端 git 用户的密码）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ssh git@118.24.8.229</span><br><span class="line">git@118.24.8.229&apos;s password:</span><br><span class="line">Last login: Sun Mar 18 09:43:25 2018 from 113.46.182.66</span><br><span class="line">[git@VM_0_7_centos ~]# ll -h .ssh/authorized_keys</span><br><span class="line">-rw-rw-r-- 1 git git 0 Mar 18 09:37 .ssh/authorized_keys</span><br><span class="line">[git@VM_0_7_centos ~]$ cat &gt;&gt; ~/.ssh/authorized_keys &lt; ~/.ssh/id_rsa.pub</span><br><span class="line">[git@VM_0_7_centos ~]# ll -h .ssh/authorized_keys</span><br><span class="line">-rw-rw-r-- 1 git git 399 Mar 18 09:44 .ssh/authorized_keys</span><br><span class="line">[git@VM_0_7_centos ~]$ exit</span><br><span class="line">logout</span><br><span class="line">Connection to 118.24.8.229 closed.</span><br></pre></td></tr></table></figure></p><p>由上面可知道 公钥已经被导入到 git用户的认证文件中。</p><font color="red"><br>&gt;重要（对于服务器端）：<br>修改 .ssh 目录的权限为 700<br>修改 .ssh/authorized_keys 文件的权限为 600</font><h4 id="7、客户端再次-clone-远程仓库"><a href="#7、客户端再次-clone-远程仓库" class="headerlink" title="7、客户端再次 clone 远程仓库"></a>7、客户端再次 clone 远程仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@118.24.8.229:/data/git/gittest.git</span><br><span class="line">fatal: destination path &apos;gittest&apos; already exists and is not an empty directory.</span><br></pre></td></tr></table></figure><p>项目已经 clone 了。（注：已经不需要输入密码了）</p><h4 id="8、禁止-Git-用户-SSH-登录服务器"><a href="#8、禁止-Git-用户-SSH-登录服务器" class="headerlink" title="8、禁止 Git 用户 SSH 登录服务器"></a>8、禁止 Git 用户 SSH 登录服务器</h4><p>编辑 /etc/passwd<br>找到：<br><code>git:x:502:504::/home/git:/bin/bash</code><br>修改为<br><code>git:x:502:504::/home/git:/bin/git-shell</code><br>此时 git 用户可以正常通过 ssh 使用 git，但无法通过 ssh 登录系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ssh git@118.24.8.229</span><br><span class="line">git@118.24.8.229&apos;s password:</span><br><span class="line">Last login: Sun Mar 18 09:44:11 2018 from 113.46.182.66</span><br><span class="line">fatal: Interactive git shell is not enabled.</span><br><span class="line">hint: ~/git-shell-commands should exist and have read and execute access.</span><br><span class="line">Connection to 118.24.8.229 closed.</span><br></pre></td></tr></table></figure></p><hr><h4 id="问题集锦"><a href="#问题集锦" class="headerlink" title="问题集锦"></a>问题集锦</h4><h5 id="（1）Git本地公钥导入服务器失败"><a href="#（1）Git本地公钥导入服务器失败" class="headerlink" title="（1）Git本地公钥导入服务器失败"></a>（1）Git本地公钥导入服务器失败</h5><blockquote><p>本地 Git Bash 登陆服务器报错：<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br>Someone could be eavesdropping on you right now (man-in-the-middle attack)!<br>It is also possible that the RSA host key has just been changed.<br>The fingerprint for the RSA key sent by the remote host is<br>d0:00:7c:bc:88:5c:dc:de:89:61:44:30:00:60:f9:b2.<br>Please contact your system administrator.<br>Add correct host key in /root/.ssh/known_hosts to get rid of this message.<br>Offending key in /root/.ssh/known_hosts:1<br>RSA host key for 192.168.4.222 has changed and you have requested strict checking.<br>Host key verification failed.</p></blockquote><p><strong>解决方法：</strong><br>先查一下本地家目录的 .ssh/know_hosts 文件中是否存在服务器端的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/known_hosts</span><br><span class="line">118.24.8.229 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHrKfe2igdpfAMhukTCC0ki3gZEO4bFQviqsO6T+F/8Uqjt+XoVzKs7zmNgMEkodfpkZJ93bZyRMc2JdDRlCp9w=</span><br></pre></td></tr></table></figure></p><p>由此可知，本地已经保存了服务器端的信息，因为我是重装了Git 服务器，所以此时保存的信息已经过时了，才会报次错误。<br>解决方法就是删除已存在信息：<br>由于我本地保存的只有一条服务器端信息，可使用如下命令：<br><code>$ cat /dev/null &gt; ~/.ssh/known_hosts</code><br>如果有多条服务器信息，可使用 <code>$ vim ~/.ssh/known_hosts</code>手动删除，或者window下直接打开文件删除对应信息即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务器环境：CentOS7 + Git(version 1.8.3.1)&lt;/p&gt;
&lt;h4 id=&quot;1、安装Git&quot;&gt;&lt;a href=&quot;#1、安装Git&quot; class=&quot;headerlink&quot; title=&quot;1、安装Git&quot;&gt;&lt;/a&gt;1、安装Git&lt;/h4&gt;&lt;p&gt;　　&lt;code&gt;yum install -y git&lt;/code&gt;&lt;br&gt;安装完后，查看 Git 版本&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@VM_0_7_centos ~]# git version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git version 1.8.3.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 详解之协议篇（一）</title>
    <link href="http://yoursite.com/2018/03/14/Git-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%8D%8F%E8%AE%AE%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/14/Git-详解之协议篇（一）/</id>
    <published>2018-03-14T09:46:12.000Z</published>
    <updated>2018-03-15T06:09:05.101Z</updated>
    
    <content type="html"><![CDATA[<p><strong>协议</strong><br>Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。下面分别介绍一下哪些情形应该使用（或避免使用）这些协议。</p><p>值得注意的是，除了 HTTP 协议外，其他所有协议都要求在服务器端安装并运行 Git。<br><a id="more"></a></p><h4 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h4><p>最基本的就是本地协议（Local protocol），所谓的远程仓库在该协议中的表示，就是硬盘上的另一个目录。这常见于团队每一个成员都对一个共享的文件系统（例如 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。后面一种情况并不安全，因为所有代码仓库实例都储存在同一台电脑里，增加了灾难性数据损失的可能性。</p><p>如果你使用一个共享的文件系统，就可以在一个本地文件系统中克隆仓库，推送和获取。克隆的时候只需要将远程仓库的路径作为 URL 使用，比如下面这样：<br>　　<code>$ git clone /opt/git/project.git</code></p><p>要添加一个本地仓库作为现有 Git 项目的远程仓库，可以这样做：<br>　　<code>$ git remote add local_proj /opt/git/project.git</code></p><p>然后就可以像在网络上一样向这个远程仓库推送和获取数据了。</p><h4 id="SSH-协议（推荐）"><a href="#SSH-协议（推荐）" class="headerlink" title="SSH 协议（推荐）"></a>SSH 协议<font color="red">（推荐）</font></h4><p>Git 使用的传输协议中最常见的可能就是 SSH 了。这是因为大多数环境已经支持通过 SSH 对服务器的访问 — 即便还没有，架设起来也很容易。SSH 也是唯一一个同时支持读写操作的网络协议。另外两个网络协议（HTTP 和 Git）通常都是只读的，所以虽然二者对大多数人都可用，但执行写操作时还是需要 SSH。SSH 同时也是一个验证授权的网络协议；而因为其普遍性，一般架设和使用都很容易。</p><p>通过 SSH 克隆一个 Git 仓库，你可以像下面这样给出 ssh:// 的 URL：<br>　　<code>$ git clone ssh://user@server/project.git</code></p><p>或者不指明某个协议 — 这时 Git 会默认使用 SSH ：<br>　　<code>$ git clone user@server:project.git</code></p><p>（注：SSH 的限制在于你不能通过它实现仓库的匿名访问。即使仅为读取数据，人们也必须在能通过 SSH 访问主机的前提下才能访问仓库，这使得 SSH 不利于开源的项目。如果你仅仅在公司网络里使用，SSH 可能是你唯一需要使用的协议。）</p><h4 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h4><p>接下来是 Git 协议。这是一个包含在 Git 软件包中的特殊守护进程； 它会监听一个提供类似于 SSH 服务的特定端口（9418），而无需任何授权。打算支持 Git 协议的仓库，需要先创建 git-daemon-export-ok 文件 — 它是协议进程提供仓库服务的必要条件 — 但除此之外该服务没有什么安全措施。要么所有人都能克隆 Git 仓库，要么谁也不能。这也意味着该协议通常不能用来进行推送。你可以允许推送操作；然而由于没有授权机制，一旦允许该操作，网络上任何一个知道项目 URL 的人将都有推送权限。不用说，这是十分罕见的情况。</p><p>（注：Git 协议是现存最快的传输协议。如果你在提供一个有很大访问量的公共项目，或者一个不需要对读操作进行授权的庞大项目，架设一个 Git 守护进程来供应仓库是个不错的选择。Git 协议消极的一面是缺少授权机制。用 Git 协议作为访问项目的唯一方法通常是不可取的。一般的做法是，同时提供 SSH 接口，让几个开发者拥有推送（写）权限，其他人通过 git:// 拥有只读权限。 Git 协议可能也是最难架设的协议。）</p><h4 id="HTTP-S-协议"><a href="#HTTP-S-协议" class="headerlink" title="HTTP/S 协议"></a>HTTP/S 协议</h4><p>最后还有 HTTP 协议。HTTP 或 HTTPS 协议的优美之处在于架设的简便性。基本上，只需要把 Git 的裸仓库文件放在 HTTP 的根目录下，配置一个特定的 post-update 挂钩（hook）就可以搞定（Git 挂钩的细节见第 7 章）。此后，每个能访问 Git 仓库所在服务器上 web 服务的人都可以进行克隆操作。下面的操作可以允许通过 HTTP 对仓库进行读取：</p><p>$ cd /var/www/htdocs/<br>$ git clone –bare /path/to/git_project gitproject.git<br>$ cd gitproject.git<br>$ mv hooks/post-update.sample hooks/post-update<br>$ chmod a+x hooks/post-update<br>这样就可以了。Git 附带的 post-update 挂钩会默认运行合适的命令（git update-server-info）来确保通过 HTTP 的获取和克隆正常工作。这条命令在你用 SSH 向仓库推送内容时运行；之后，其他人就可以用下面的命令来克隆仓库：</p><p>$ git clone <a href="http://example.com/gitproject.git" target="_blank" rel="noopener">http://example.com/gitproject.git</a></p><p>（注：使用 HTTP 协议的好处是易于架设。几条必要的命令就可以让全世界读取到仓库的内容。花费不过几分钟。HTTP 协议不会占用过多服务器资源。因为它一般只用到静态的 HTTP 服务提供所有数据。你可以通过 HTTPS 提供只读的仓库，这意味着你可以加密传输内容。但是，HTTP 协议的消极面在于，相对来说客户端效率更低。克隆或者下载仓库内容可能会花费更多时间，而且 HTTP 传输的体积和网络开销比其他任何一个协议都大。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;协议&lt;/strong&gt;&lt;br&gt;Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。下面分别介绍一下哪些情形应该使用（或避免使用）这些协议。&lt;/p&gt;
&lt;p&gt;值得注意的是，除了 HTTP 协议外，其他所有协议都要求在服务器端安装并运行 Git。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7默认Python升级</title>
    <link href="http://yoursite.com/2018/03/13/CentOS-7%E9%BB%98%E8%AE%A4Python%E5%8D%87%E7%BA%A7/"/>
    <id>http://yoursite.com/2018/03/13/CentOS-7默认Python升级/</id>
    <published>2018-03-13T10:01:05.000Z</published>
    <updated>2018-03-14T06:16:06.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>CentOS 7 中默认安装了 Python，版本比较低（2.7.5），为了使用新版 3.x，需要对旧版本进行升级。</p><p>由于很多基本的命令、软件包都依赖旧版本，比如：yum。所以，在更新 Python 时，建议不要删除旧版本（新旧版本可以共存）。</p><h3 id="安装Python3-6-4"><a href="#安装Python3-6-4" class="headerlink" title="安装Python3.6.4"></a>安装Python3.6.4</h3><a id="more"></a><h4 id="（1）下载并解压缩"><a href="#（1）下载并解压缩" class="headerlink" title="（1）下载并解压缩"></a>（1）下载并解压缩</h4><p>下载地址：<a href="https://www.python.org/downloads/release/python-364/" title="Python3.x" target="_blank" rel="noopener"><font color="red">传送门</font></a><br>此处我选择的版本是Python3.6.4：<br>　　<code>wget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tgz</code><br>解压缩：<br>　　<code>tar -xvf Python-3.6.4.tgz</code></p><h4 id="（2）检测编译环境"><a href="#（2）检测编译环境" class="headerlink" title="（2）检测编译环境"></a>（2）检测编译环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Python-3.6.4/</span><br><span class="line">./configure</span><br></pre></td></tr></table></figure><p>执行 ./configure 时，如果报错：</p><blockquote><p>configure: error: no acceptable C compiler found in $PATH</p></blockquote><p>说明没有安装合适的编译器。这时，需要安装/升级 gcc 及其它依赖包。<br>　　<code>yum install make gcc gcc-c++</code><br>完成之后，重新执行：<br>　　<code>./configure</code></p><h4 id="（3）编译-amp-安装"><a href="#（3）编译-amp-安装" class="headerlink" title="（3）编译 &amp; 安装"></a>（3）编译 &amp; 安装</h4><p>　　<code>make &amp; make install</code><br>安装中如果报错：</p><blockquote><p>zipimport.ZipImportError: can’t decompress data; zlib not available</p></blockquote><p>说明是因为缺少zlib 的相关工具包导致的，知道了问题所在，那么我们只需要安装相关依赖包即可，<br>① 打开终端，输入一下命令安装zlib相关依赖包：<br>　　<code>yum -y install zlib*</code> 或 <code>yum -y install zlib zlib-devel</code>（未试）</p><p>② 进入 python安装包,修改Module路径的setup文件：<br>　　<code>vim Module/Setup.dist</code><br>找到以下这行代码，去掉注释：</p><blockquote><p>#zlib zlibmodule.c -I$(prefix)/include -L$(exec_prefix)/lib -lz</p></blockquote><p>然后再次执行编译 &amp; 安装。</p><h3 id="设置Python默认版本"><a href="#设置Python默认版本" class="headerlink" title="设置Python默认版本"></a>设置Python默认版本</h3><h4 id="（1）查看Python版本"><a href="#（1）查看Python版本" class="headerlink" title="（1）查看Python版本"></a>（1）查看Python版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# python -V</span><br><span class="line">Python 2.7.5</span><br><span class="line">[root@VM_0_7_centos ~]# python3 -V</span><br><span class="line">Python 3.6.4</span><br></pre></td></tr></table></figure><p>查看Python命令路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# which python</span><br><span class="line">/usr/bin/python</span><br><span class="line">[root@VM_0_7_centos ~]# which python3</span><br><span class="line">/usr/local/bin/python3</span><br></pre></td></tr></table></figure></p><h4 id="（2）设置Python3-x为默认版本"><a href="#（2）设置Python3-x为默认版本" class="headerlink" title="（2）设置Python3.x为默认版本"></a>（2）设置Python3.x为默认版本</h4><p>查看Python默认版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# ll /usr/bin/ | grep python</span><br><span class="line">-rwxr-xr-x. 1 root root      11232 Aug 10  2017 abrt-action-analyze-python</span><br><span class="line">lrwxrwxrwx. 1 root root          7 Jan  9 18:20 python -&gt; python2</span><br><span class="line">lrwxrwxrwx. 1 root root          9 Jan  9 18:20 python2 -&gt; python2.7</span><br><span class="line">-rwxr-xr-x. 1 root root       7136 Aug  4  2017 python2.7</span><br></pre></td></tr></table></figure></p><p>更改Python默认版本，将原来 python 的软链接重命名：<br>　　<code>mv /usr/bin/python /usr/bin/python.bak</code><br>将 python 链接至 python3：<br>　　<code>ln -s /usr/local/bin/python3 /usr/bin/python</code><br>这时，再查看 Python 的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# python -V</span><br><span class="line">Python 3.6.4</span><br></pre></td></tr></table></figure></p><p>输出的是 3.x，说明已经使用的是 python3了。</p><h3 id="配置yum"><a href="#配置yum" class="headerlink" title="配置yum"></a>配置yum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# yum</span><br><span class="line">  File &quot;/usr/bin/yum&quot;, line 30</span><br><span class="line">    except KeyboardInterrupt, e:</span><br><span class="line">                            ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>升级 Python 之后，由于将默认的 python 指向了 python3，yum 不能正常使用，需要编辑 yum 的配置文件：<br>　　<code>vi /usr/bin/yum</code><br>同时修改：<br>　　<code>vi /usr/libexec/urlgrabber-ext-down</code><br>将 #!/usr/bin/python 改为 #!/usr/bin/python2.7，保存退出即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;CentOS 7 中默认安装了 Python，版本比较低（2.7.5），为了使用新版 3.x，需要对旧版本进行升级。&lt;/p&gt;
&lt;p&gt;由于很多基本的命令、软件包都依赖旧版本，比如：yum。所以，在更新 Python 时，建议不要删除旧版本（新旧版本可以共存）。&lt;/p&gt;
&lt;h3 id=&quot;安装Python3-6-4&quot;&gt;&lt;a href=&quot;#安装Python3-6-4&quot; class=&quot;headerlink&quot; title=&quot;安装Python3.6.4&quot;&gt;&lt;/a&gt;安装Python3.6.4&lt;/h3&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CSS 图片居中问题（水平居中和垂直居中）</title>
    <link href="http://yoursite.com/2018/03/13/CSS-%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98%EF%BC%88%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/13/CSS-图片居中问题（水平居中和垂直居中）/</id>
    <published>2018-03-13T03:29:17.000Z</published>
    <updated>2018-03-13T03:38:33.545Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、水平居中"><a href="#1、水平居中" class="headerlink" title="1、水平居中"></a>1、水平居中</h4><p>（1）利用margin: 0 auto实现图片水平居中<br>利用margin: 0 auto实现图片居中就是在图片上加上css样式margin: 0 auto 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center; width: 500px; border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">         style=&quot;margin: 0 auto;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>（2）利用文本的水平居中属性text-align: center<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center; width: 500px; border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">         style=&quot;display: inline-block;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2、垂直居中"><a href="#2、垂直居中" class="headerlink" title="2、垂直居中"></a>2、垂直居中</h4><p>（1）利用高==行高实现图片垂直居中<br>这种方法是要知道高度才可以使用，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center; width: 500px;height:200px; </span><br><span class="line">            line-height:200px; border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">         style=&quot;display: inline-block; vertical-align: middle;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>（2）利用table实现图片垂直居中<br>利用table的方法是利用了table的垂直居中属性，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center; width: 500px;height:200px; </span><br><span class="line">            display: table;border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;span style=&quot;display: table-cell; vertical-align: middle; &quot;&gt;</span><br><span class="line">        &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">             style=&quot;display: inline-block;&quot; /&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这里使用display: table;和display: table-cell;来模拟table，这种方法并不兼容IE6/IE7，IE67不支持display: table，如果你不需要支持IE67那就可以用<br><strong>（缺点：当你设置了display: table;可能会改变你的原有布局）</strong></p><p>（3）利用绝对定位实现图片垂直居中<br>如果已知图片的宽度和高度可以这样，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width: 500px;height:200px; position: relative; border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">         style=&quot;width: 120px; height: 40px;position: absolute; left:50%; top: 50%; </span><br><span class="line">                margin-left: -60px;margin-top: -20px;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>（4）移动端可以利用flex布局实现css图片垂直居中<br>移动端一般浏览器版本都比较高，所以可以大胆的使用flex布局，（flex布局参考css3的flex布局用法）演示代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*css代码：*/</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.ui-flex &#123;</span><br><span class="line">    display: -webkit-box !important;</span><br><span class="line">    display: -webkit-flex !important;</span><br><span class="line">    display: -ms-flexbox !important;</span><br><span class="line">    display: flex !important;</span><br><span class="line">    -webkit-flex-wrap: wrap;</span><br><span class="line">    -ms-flex-wrap: wrap;</span><br><span class="line">    flex-wrap: wrap</span><br><span class="line">&#125;</span><br><span class="line">.ui-flex, .ui-flex *, .ui-flex :after, .ui-flex :before &#123;</span><br><span class="line">    box-sizing: border-box</span><br><span class="line">&#125;</span><br><span class="line">.ui-flex.justify-center &#123;</span><br><span class="line">    -webkit-box-pack: center;</span><br><span class="line">    -webkit-justify-content: center;</span><br><span class="line">    -ms-flex-pack: center;</span><br><span class="line">    justify-content: center</span><br><span class="line">&#125;</span><br><span class="line">.ui-flex.center &#123;</span><br><span class="line">    -webkit-box-pack: center;</span><br><span class="line">    -webkit-justify-content: center;</span><br><span class="line">    -ms-flex-pack: center;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    -webkit-box-align: center;</span><br><span class="line">    -webkit-align-items: center;</span><br><span class="line">    -ms-flex-align: center;</span><br><span class="line">    align-items: center</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">/*html代码：*/</span><br><span class="line">&lt;div class=&quot;ui-flex justify-center center&quot; </span><br><span class="line">     style=&quot;border: green solid 1px; width: 500px; height: 200px;&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">        &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; style=&quot;&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、水平居中&quot;&gt;&lt;a href=&quot;#1、水平居中&quot; class=&quot;headerlink&quot; title=&quot;1、水平居中&quot;&gt;&lt;/a&gt;1、水平居中&lt;/h4&gt;&lt;p&gt;（1）利用margin: 0 auto实现图片水平居中&lt;br&gt;利用margin: 0 auto实现图片居中就是在图片上加上css样式margin: 0 auto 如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div style=&amp;quot;text-align: center; width: 500px; border: green solid 1px;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;img alt=&amp;quot;&amp;quot; src=&amp;quot;https://www.baidu.com/img/baidu_jgylogo3.gif&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         style=&amp;quot;margin: 0 auto;&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
      <category term="CSS问题" scheme="http://yoursite.com/categories/CSS/CSS%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="CSS问题" scheme="http://yoursite.com/tags/CSS%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
