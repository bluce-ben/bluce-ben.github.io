<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-18T06:59:09.807Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络安全之常见攻击方式及解决方案</title>
    <link href="http://yoursite.com/2018/01/18/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2018/01/18/网络安全之常见攻击方式及解决方案/</id>
    <published>2018-01-18T05:50:23.000Z</published>
    <updated>2018-01-18T06:59:09.807Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、网络封包联机进入主机的流程"><a href="#1、网络封包联机进入主机的流程" class="headerlink" title="1、网络封包联机进入主机的流程"></a>1、网络封包联机进入主机的流程</h4><p>当来自一个网络上的联机要求想进入我们的主机时，这个网络封包在进入主机实际取得数据的整个流程是如何？了解了整个流程之后，你才会发现：了解要如何保护你的主机安全！</p><p>我们要将该流程更细致化说明，因为，透过这个流程分析，你会知道为啥我们的主机需要进行过一些防护之后，系统才能够比较强壮。此外，了解了网络是双向的，那么就能知道服务器与客户端都得要有 IP:port 才能够让彼此的软件互相沟通。现在，假设你的主机是 WWW 服务器，透过底下的图标，网络封包如何进入你的主机呢？<br><a id="more"></a><br><img src="/uploads/2018/01/network_packet_translate.JPG" alt="" title="网络封包进入主机的流程"></p><h5 id="1-经过防火墙的分析："><a href="#1-经过防火墙的分析：" class="headerlink" title="1. 经过防火墙的分析："></a>1. 经过防火墙的分析：</h5><p>Linux 系统有内建的防火墙机制，因此你的联机能不能成功，得要先看防火墙的脸色才行。预设的 Linux 防火墙就有两个机制，这两个机制都是独立存在的，因此我们预设就有两层防火墙。第一层是封包过滤式的 netfilter 防火墙，另一个则是透过软件管控的 TCP Wrappers 防火墙。</p><ul><li><strong>封包过滤防火墙：IP Filtering 或 Net Filter</strong><br>   要进入 Linux 本机的封包都会先通过 Linux 核心的预设防火墙，就是称为 netfilter 的咚咚，简单的说，就是 iptables 这个软件所提供的防火墙功能。为何称为封包过滤呢？因为他主要是分析 TCP/IP 的封包表头来进行过滤的机制，主要分析的是 OSI 的第二、三、四层，主要控制的就是 MAC, IP, ICMP, TCP 与 UDP 的端口与状态 (SYN, ACK…) 等。</li><li><strong>第二层防火墙：TCP Wrappers</strong><br>   通过 netfilter 之后，网络封包会开始接受 Super daemons 及 TCP_Wrappers 的检验，那个是什么呢？说穿了就是 /etc/hosts.allow 与 /etc/hosts.deny 的配置文件功能。这个功能也是针对 TCP 的 Header 进行再次的分析，同样你可以设定一些机制来抵制某些 IP 或 Port ，好让来源端的封包被丢弃或通过检验；</li></ul><p>透过防火墙的管控，我们可以将大部分来自因特网的垃圾联机丢弃，只允许自己开放的服务的联机进入本机而已，可以达到最基础的安全防护。</p><h5 id="2-服务-daemon-的基本功能："><a href="#2-服务-daemon-的基本功能：" class="headerlink" title="2. 服务 (daemon) 的基本功能："></a>2. 服务 (daemon) 的基本功能：</h5><p>预设的防火墙是 Linux 的内建功能，但防火墙主要管理的是 MAC, IP, Port 等封包表头方面的信息，如果想要管控某些目录可以进入，某些目录则无法使用的功能，那就得要透过权限以及服务器软件提供的相关功能了。举例来说，你可以在 httpd.conf 这个配置文件之内规范某些 IP 来源不能使用 httpd 这个服务来取得主机的数据，那么即使该 IP 通过前面两层的过滤，他依旧无法取得主机的资源！但要注意的是，如果 httpd 这支程序本来就有问题的话，那么 client 端将可直接利用 httpd 软件的漏洞来入侵主机，而不需要取得主机内 root 的密码！因此，要小心这些启动在因特网上面的软件！</p><h5 id="3-SELinux-对网络服务的细部权限控制："><a href="#3-SELinux-对网络服务的细部权限控制：" class="headerlink" title="3. SELinux 对网络服务的细部权限控制："></a>3. SELinux 对网络服务的细部权限控制：</h5><p>为了避免前面一个步骤的权限误用，或者是程序有问题所造成的资安状况，因此 Security Enhanced Linux (安全强化 Linux) 就来发挥它的功能！简单的说，SELinux 可以针对网络服务的权限来设定一些规则 (policy) ，让程序能够进行的功能有限，因此即使使用者的档案权限设定错误，以及程序有问题时，该程序能够进行的动作还是被限制的，即使该程序使用的是 root 的权限也一样。举例来说，前一个步骤的 httpd 真的被 cracker 攻击而让对方取得 root 的使用权，由于 httpd 已经被 SELinux 控制在 /var/www/html 里面，且能够进行的功能已经被规范住了，因此 cracker 就无法使用该程序来进行系统的进一步破坏。</p><h5 id="4-使用主机的文件系统资源："><a href="#4-使用主机的文件系统资源：" class="headerlink" title="4. 使用主机的文件系统资源："></a>4. 使用主机的文件系统资源：</h5><p>想一想，你使用浏览器连接到 WWW 主机最主要的目的是什么？当然就是读取主机的 WWW 数据！那 WWW 资料是啥？就是档案啊！所以，最终网络封包其实是要向主机要求文件系统的数据。我们这里假设你要使用 httpd 这支程序来取得系统的档案数据，但 httpd 默认是由一个系统账号名称为 httpd 来启动的，所以：你的网页数据的权限当然就是要让 httpd 这支程序可以读取才行啊！如果你前面三关的设定都 OK ，最终权限设定错误，使用者依旧无法浏览你的网页数据的。</p><p>在这些步骤之外，我们的 Linux 以及相关的软件都可能还会支持登录文件记录的功能，为了记录历史历程，以方便管理者在未来的错误查询与入侵检测，良好的分析登录档的习惯是一定要建立的，尤其是 /var/log/messages 与 /var/log/secure 这些个档案！</p><h4 id="2、常见的攻击手法与相关保护"><a href="#2、常见的攻击手法与相关保护" class="headerlink" title="2、常见的攻击手法与相关保护"></a>2、常见的攻击手法与相关保护</h4><p>上面我们了解到数据传送到本机时所需要经过的几道防线，那个权限是最后的关键！那么 cracker 是如何透过上述的流程还能够攻击你的系统？底下就让我们来分析分析。</p><h5 id="1-取得帐户信息后猜密码"><a href="#1-取得帐户信息后猜密码" class="headerlink" title="1. 取得帐户信息后猜密码"></a>1. 取得帐户信息后猜密码</h5><p>由于很多人喜欢用自己的名字来作为帐户信息，因此账号的取得是很容易的！举例来说，如果你的朋友将你的 email address 不小心泄漏出去，例如：dmtsai@your.host.name 之类的样式，那么人家就会知道你有一部主机，名称为 your.host.name，且在这部主机上面会有一个使用者账号，账号名称为 dmtsai ，之后这个坏家伙再利用某些特殊软件例如 nmap 来进行你主机的 port scan 之后，他就可以开始透过你主机有启动的软件功能来猜你这个账号的密码了！</p><p>另外，如果你常常观察你的主机登录文件，那你也会发现如果你的主机有启动 Mail server 的服务时，你的登录档就会常常出现有些怪家伙尝试以一些奇怪的常见账号在试图猜测你的密码，举例来说像：admin, administrator, webmaster …. 之类的账号，尝试来窃取你的私人信件。如果你的主机真的有这类的账号，而且这类的账号还没有良好的密码规划，那就容易【中标】！所以我们常讲，系统账号千万不能给予密码，容易被猜密码啊！</p><p>这种猜密码的攻击方式算是最早期的入侵模式之一了，攻击者知道你的账号，或者是可以猜出来你的系统有哪些账号，欠缺的就只是密码而已，因此他会【很努力的】去猜你的密码，此时，你的密码规划如果不好的话，很容易就被攻击了！主机也很容易被绑架！所以，良好的密码设置习惯是很重要的。</p><p>不过这种攻击方式比较费时，因为目前很多软件都有密码输入次数的限制，如果连续输入三次密码还不能成功的登入，那该次联机就会被断线！所以，这种攻击方式日益减少，目前偶而还会看到就是！这也是初级 cracker 会使用的方式之一。那我们要如何保护呢？基本方式是这样的：</p><blockquote><p>（1）减少信息的曝光机会：例如不要将 Email Address 随意散布到 Internet 上头；<br>（2）建立较严格的密码设定规则：包括 /etc/shadow, /etc/login.defs 等档案的设定，如果主机够稳定且不会持续加入某些账号时，也可以考虑使用 chattr 来限制账号 (/etc/passwd, /etc/shadow) 的更改；<br>（3）完善的权限设定：由于这类的攻击方式会取得你的某个使用者账号的登入权限，所以如果你的系统权限设定得宜的话，那么攻击者也仅能取得一般使用者的权限而已，对于主机的伤害比较有限！所以说，权限设定是重要的；</p></blockquote><h5 id="2-利用系统的程序漏洞【主动】攻击"><a href="#2-利用系统的程序漏洞【主动】攻击" class="headerlink" title="2. 利用系统的程序漏洞【主动】攻击"></a>2. 利用系统的程序漏洞【主动】攻击</h5><p>由上图中的第二道防线，我们知道如果你的主机有开放网络服务时，就必须有启动某个网络软件！我们也知道由于软件可能撰写方式的问题，可能产生一些会被 cracker 乱用的臭虫程序代码，而这些臭虫程序代码由于产生问题的大小，有分为 bug (臭虫，可能会造成系统的不稳定或当机) 与 Security (安全问题，程序代码撰写方式会导致系统的权限被恶意者所掌握) 等问题。</p><p>当程序的问题被公布后，某些较高阶的 cracker 会尝试撰写一些针对这个漏洞的攻击程序代码，并且将这个程序代码放置到 cracker 常去的网站上面，藉以推销自己的【功力】….. 这种攻击模式是目前最常见的，因为攻击者只要拿到攻击程序就可以进行攻击了，【而且由攻击开始到取得你系统的 root 权限不需要猜密码，不需要两分钟，就能够立刻入侵成功】。但这个玩意儿本身是靠【你主机的程序漏洞】来攻击的，所以，如果你的主机随时保持在实时更新的阶段，或者是关闭大部分不需要的程序，那就可以躲避过这个问题。因此，你应该要这样做：</p><blockquote><p>（1）关闭不需要的网络服务：开的 port 越少，可以被入侵的管道越少，一部主机负责的服务越单纯，越容易找出问题点。<br>（2）随时保持更新：这个没话讲！一定要进行的！<br>（3）关闭不需要的软件功能：举例来说，后面会提到的远程登录服务器 SSH 可以提供 root 由远程登录，那么危险的事情当然要给他取消啊！</p></blockquote><h5 id="3-利用社交工程作欺骗"><a href="#3-利用社交工程作欺骗" class="headerlink" title="3. 利用社交工程作欺骗"></a>3. 利用社交工程作欺骗</h5><p>社交工程 (Social Engineering) 指的其实很简单，就是透过人与人的互动来达到【入侵】的目的！在大公司里面，或许你可能会接到这样的电话：【我是人事部门的经理，我的账号为何突然间不能登入了？你给我看一看，恩？干脆直接帮我另建一个账号，我告诉你我要的密码是….】。如果你一时不查给他账号密码的话，你的主机可能就这样被绑走了！</p><p>社交工程的欺骗方法多的是，包括使用【好心的 email 通知】、【警告信函】、【中奖单】等等，样样都是要欺骗你的账号密码，有的则利用钓鱼方式来欺骗你在某些恶意网站上面输入你的账号密码！举例来说，一般 email 会常常收到一些活动的信件，要我们用账号密码登录，这种的就要小心了！那要如何防范呢？</p><blockquote><p>（1）追踪对谈者：不要一味的相信对方，你必须要有信心的向上呈报，不要一时心慌就中了计！<br>（2）不要随意透露账号/密码等信息：最好不要随意在 Internet 上面填写这些数据，真的很危险！因为在 Internet 上面，你永远不知道对方屏幕前面坐着的是谁？</p></blockquote><h5 id="4-利用程序功能的【被动】攻击"><a href="#4-利用程序功能的【被动】攻击" class="headerlink" title="4. 利用程序功能的【被动】攻击"></a>4. 利用程序功能的【被动】攻击</h5><p>除了主动攻击之外，还有所谓的被动攻击！那就得要由【恶意网站】讲起了。如果你喜欢上网随意浏览的话，那么有的时候可能会连上一些广告很多，或者是一堆弹出式窗口的网站，这些网站有时还会很好心的【提供你很多好用的软件自动下载与安装】的功能，如果该网站是你所信任的，例如 Red Hat, CentOS, Windows 官网的话，那还好，如果是一个你也不清楚他是干嘛的网站，那你是否要同意下载安装该软件？</p><p>如果你常常在注意一些网络危机处理的相关新闻时，常会发现 Windows 的浏览器 (IE) 有问题，有时则是全部的浏览器 (Firefox, Netscap, IE…) 都会出现问题。那你会不会觉得奇怪啊，怎么【浏览器也会有问题？】这是因为很多浏览器会主动的答应对方 WWW 主机所提供的各项程序功能，或者是自动安装来自对方主机的软件，有时浏览器还可能由于程序发生安全问题，让对方 WWW 浏览器得以传送恶意代码给你的主机来执行！</p><p>那你又会想啊，那我干嘛浏览那样的恶意网站？总是会有些粗心大意的时候啊！如果你今天不小心收到一个 email ，里面告诉你你的银行账号有问题，希望你赶紧连上某个网页去看看你的账号是否在有问题的行列中，你会不会去？如果今天有个网络消息说某某网页在提供大特价商品，那你会不会去碰碰运气？都是可能的啊！不过，这也就很容易被对方攻击到了。</p><p>那如何防备啊？当然建立良好的习惯最重要了：</p><blockquote><p>（1）随时更新主机上的所有软件：如果你的浏览器是没有问题的，那对方传递恶意代码时，你的浏览器就不会执行，那自然安全的多了！<br>（2）较小化软件的功能：举例来说，让你的收信软件不要主动的下载文件，让你的浏览器在安装某些软件时，要通过你的确认后才安装，这样就比较容易克服一些小麻烦；<br>（3）不要连接到不明的主机：因为很多时候我们都用 google 在搜寻问题的解决之道，那你如何知道对方是否是骗人的？所以，前面两点防备还是很重要的！不要以为没有连接上恶意网站就不会有问题！</p></blockquote><h5 id="5-蠕虫或木马的-rootkit"><a href="#5-蠕虫或木马的-rootkit" class="headerlink" title="5. 蠕虫或木马的 rootkit"></a>5. 蠕虫或木马的 rootkit</h5><p>rootkit 意思是说可以取得 root 权限的一群工具组 (kit)，就如同前面主动攻击程序漏洞的方法一样，rootkit 主要也是透过主机的程序漏洞。不过，rootkit 也会透过社交工程让用户下载、安装 rootkit 软件，结果让 cracker 得以简单的绑架对方主机！</p><p>rootkit 除了可以透过上述的方法来进行入侵之外，rootkit 还会伪装或者是进行自我复制，举例来说，很多的 rootkit 本身就是蠕虫或者是木马间谍程序。蠕虫会让你的主机一直发送封包向外攻击，结果会让你的网络带宽被吃光光，例如 2001-2003年间的 Nimda, Code Red 等等；至于木马程序 (Trojan Horse) 则会对你的主机进行开启后门 (开一个 port 来让 cracker 主动的入侵)，结果就是….绑架、绑架、绑架！</p><p>rootkit 其实挺不好追踪的，因为很多时候他会主动的去修改系统观察的指令，包括 ls, top, netstat, ps, who, w, last, find 等等，让你看不到某些有问题的程序，如此一来，你的 Linux 主机就很容易被当成是跳板了！有够危险！那如何防备呢？</p><blockquote><p>（1）不要随意安装不明来源的档案或者是不明网站的档案数据；<br>（2）不要让系统有太多危险的指令：例如 SUID/SGID 的程序，这些程序很可能会造成用户不当的使用，而使得木马程序有机可趁！<br>（3）可以定时以 rkhunter 之类的软件来追查：有个网站提供 rootkit 程序的检查，你可以前往下载与分析你的主机：<a href="http://www.rootkit.nl/projects/rootkit_hunter.html" target="_blank" rel="noopener">http://www.rootkit.nl/projects/rootkit_hunter.html</a></p></blockquote><h5 id="6-DDoS-攻击法-Distributed-Denial-of-Service"><a href="#6-DDoS-攻击法-Distributed-Denial-of-Service" class="headerlink" title="6. DDoS 攻击法 (Distributed Denial of Service )"></a>6. DDoS 攻击法 (Distributed Denial of Service )</h5><p>这类型的攻击中文翻译成【分布式阻断服务攻击】，从字面上的意义来看，它就是透过分散在各地的僵尸计算机进行攻击，让你的系统所提供的服务被阻断而无法顺利的提供服务给其他用户的方式。这种攻击法也很要命，而且方法有很多，最常见的就属 SYN Flood 攻击法了！当主机接收了一个带有 SYN 的 TCP 封包之后，就会启用对方要求的 port 来等待联机，并且发送出回应封包(带有 SYN/ACK 旗目标 TCP 封包)，并等待 Client 端的再次回应。</p><p>好了，在这个步骤当中我们来想一想，如果 cient 端在发送出 SYN 的封包后，却将来自 Server 端的确认封包丢弃，那么你的 Server 端就会一直空等，而且 Client 端可以透过软件功能，在短短的时间内持续发送出这样的 SYN 封包，那么你的 Server 就会持续不断的发送确认封包，并且开启大量的 port 在空等！等到全部主机的 port 都启用完毕，那么…..系统就挂了！</p><p>更可怕的是，通常攻击主机的一方不会只有一部！他会透过 Internet 上面的僵尸网络 (已经成为跳板，但网站主却没有发现的主机) 发动全体攻击，让你的主机在短时间内就立刻挂点。这种 DDoS 的攻击手法比较类似【玉石俱焚】的手段，他不是入侵你的系统，而是要让你的系统无法正常提供服务！最常被用来作为阻断式服务的网络服务就是 WWW 了，因为 WWW 通常得对整个 Internet 开放服务。</p><p>这种攻击方法也是最难处理的，因为要嘛就得要系统核心有支持自动抵挡 DDoS 攻击的机制，要嘛你就得要自行撰写侦测软件来判断！而除非你的网站非常大，并且【得罪不少人】，否则应该不会被 DDoS 攻击！</p><h5 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h5><p>上面提到的都是比较常见的攻击方法，是还有一些高竿的攻击法，不过那些攻击法都需要有比较高的技术水准，例如 IP 欺骗。他可以欺骗你主机告知该封包来源是来自信任网域，而且透过封包传送的机制，由攻击的一方持续的主动发送出确认封包与工作指令。如此一来，你的主机可能就会误判该封包确实有响应，而且是来自内部的主机。</p><p>不过我们知道因特网是有路由的，而每部主机在每一个时段的 ACK 确认码都不相同，所以这个方式要达成可以登入，会比较麻烦，所以说，不太容易发生在我们这些小型主机上面！不过你还是得要注意一下说：</p><blockquote><p>（1）设定规则完善的防火墙：利用 Linux 内建的防火墙软件 iptables 建立较为完善的防火墙，可以防范部分的攻击行为；<br>（2）核心功能：这部份比较复杂，你必须要对系统核心有很深入的了解，才有办法设定好你的核心网络功能。<br>（3）登录文件与系统监控：你可以透过分析登录文件来了解系统的状况，另外也可以透过类似 MRTG 之类的监控软件来实时了解到系统是否有异常，这些工作都是很好的努力方向！</p></blockquote><h5 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h5><p>不要以为你的主机没有啥重要数据，被入侵或被植入木马也没有关系，因为我们的服务器通常会对内部来源的主机规范的较为宽松，如果你的主机在公司内部，但是不小心被入侵的话，那么贵公司的服务器是否就会暴露在危险的环境当中了？</p><p>所以啊，主机防护还是很重要的！不要小看了！提供几个方向给大家思考看看吧：</p><blockquote><p>1.建立完善的登入密码规则限制；<br>2.完善的主机权限设定；<br>3.设定自动升级与修补软件漏洞、及移除危险软件；<br>4.在每项系统服务的设定当中，强化安全设定的项目；<br>5.利用 iptables, TCP_Wrappers 强化网络防火墙；<br>6.利用主机监控软件如 MRTG 与 logwatch 来分析主机状况与登录文件；</p></blockquote><h4 id="3、关于Linux操作系统网络安全的有效应对措施"><a href="#3、关于Linux操作系统网络安全的有效应对措施" class="headerlink" title="3、关于Linux操作系统网络安全的有效应对措施"></a>3、关于Linux操作系统网络安全的有效应对措施</h4><h5 id="（1）安装防火墙、保证账号安全"><a href="#（1）安装防火墙、保证账号安全" class="headerlink" title="（1）安装防火墙、保证账号安全"></a>（1）安装防火墙、保证账号安全</h5><p>　　在互联网的安全防御中，每台计算机的系统都会自带安全防御工具及防火墙，其主要作用在于提供给用户审核、访问及防病毒等功能的同时，有效防止非授权用户进入系统，获取相关网络资源信息，并通过恰当地配置和调试，达到限制局域网非授权用户的访问，保护系统网络安全的目的，同时，对Linux操作系统用户账号的管理也要注意加密及口令安全的保护。 </p><h5 id="（2）关闭无需服务、重要文件需加密"><a href="#（2）关闭无需服务、重要文件需加密" class="headerlink" title="（2）关闭无需服务、重要文件需加密"></a>（2）关闭无需服务、重要文件需加密</h5><p>　　Linux操作系统本身会自带很多网络服务，其中有很多是没有必要的服务，用户应当及时进行关闭服务，以免因其造成严重的安全隐患，可以先找到 /etc/services 这个文件，对其所包含的网络服务数据库进行筛选，关闭不必要的网络服务，增强安全性。另外对系统中较为重要的文件也要进行加密，以保证一旦受到攻击可以不受到损害和窃取。 </p><h5 id="（3）阻止Ping命令请求以及Finger服务"><a href="#（3）阻止Ping命令请求以及Finger服务" class="headerlink" title="（3）阻止Ping命令请求以及Finger服务"></a>（3）阻止Ping命令请求以及Finger服务</h5><p>　　上文提到，TCP/IP 协议由于自身缺陷极易受到黑客的攻击，利用其漏洞从正常数据包通道传送数据，获得有利信息。如果将系统设置为Ping命令请求阻止，便会减少黑客攻击成功的几率，提高网络的安全性。而禁止Finger服务，删除 /usr/bin 中的Finger命令，则可以防止黑客借助此命令远程或本地侵入系统，得到用户的一切相关信息，进而保护了网络的安全。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、网络封包联机进入主机的流程&quot;&gt;&lt;a href=&quot;#1、网络封包联机进入主机的流程&quot; class=&quot;headerlink&quot; title=&quot;1、网络封包联机进入主机的流程&quot;&gt;&lt;/a&gt;1、网络封包联机进入主机的流程&lt;/h4&gt;&lt;p&gt;当来自一个网络上的联机要求想进入我们的主机时，这个网络封包在进入主机实际取得数据的整个流程是如何？了解了整个流程之后，你才会发现：了解要如何保护你的主机安全！&lt;/p&gt;
&lt;p&gt;我们要将该流程更细致化说明，因为，透过这个流程分析，你会知道为啥我们的主机需要进行过一些防护之后，系统才能够比较强壮。此外，了解了网络是双向的，那么就能知道服务器与客户端都得要有 IP:port 才能够让彼此的软件互相沟通。现在，假设你的主机是 WWW 服务器，透过底下的图标，网络封包如何进入你的主机呢？&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 防火墙的设定</title>
    <link href="http://yoursite.com/2018/01/17/Linux-%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E8%AE%BE%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/01/17/Linux-防火墙的设定/</id>
    <published>2018-01-17T10:45:23.000Z</published>
    <updated>2018-01-18T07:02:57.151Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Linux 的封包过滤软件：iptables</strong><br>《防火墙的认识》这篇文章说了那么多，主要就是说明防火墙是什么，能做什么，并且知道防火墙不是万能的。下面我说一下都使用什么来设定防火墙。<br>因为不同的核心使用的防火墙机制不同，且支持的软件指令与语法也不相同，所以在 Linux 上头设定属于你自己的防火墙规则时，要注意，先用 uname -r 追踪一下你的核心版本再说，目前大部分的核心都使用 kernel 2.6 版的核心，主要是使用 iptables 这个防火墙机制。<br><a id="more"></a></p><h4 id="1、封包进入流程：规则顺序的重要性！"><a href="#1、封包进入流程：规则顺序的重要性！" class="headerlink" title="1、封包进入流程：规则顺序的重要性！"></a>1、封包进入流程：规则顺序的重要性！</h4><p>因为 iptables 是利用封包过滤的机制，所以他会分析封包的表头数据。根据表头数据与定义的【规则】来决定该封包是否可以进入主机或者是被丢弃。意思就是说：【根据封包的分析资料”比对”你预先定义的规则内容，若封包数据与规则内容相同则进行动作，否则就继续下一条规则的比对！】重点在那个【比对与分析顺序】上。</p><p>举个简单的例子，假设我预先定义 10 条防火墙规则好了，那么当 Internet 来了一个封包想要进入我的主机，那么防火墙是如何分析这个封包的呢？我们以底下的图示来说明好了：<br><img src="/uploads/2018/01/network_iptables_rules.JPG" alt="" title="5-1 封包过滤的规则动作及分析流程"></p><p>当一个网络封包要进入到主机之前，会先经由 NetFilter 进行检查，那就是 iptables 的规则了。检查通过则接受 (ACCEPT) 进入本机取得资源，如果检查不通过，则可能予以丢弃 (DROP) ！上图中主要的目的在告知你：【规则是有顺序的】！例如当网络封包进入 Rule 1 的比对时，如果比对结果符合 Rule 1 ，此时这个网络封包就会进行 Action 1 的动作，而不会理会后续的 Rule 2, Rule 3…. 等规则的分析了。<br>而如果这个封包并不符合 Rule 1 的比对，那就会进入 Rule 2 的比对了！如此一个一个规则去进行比对就是了。那如果所有的规则都不符合怎办？此时就会透过预设动作 (封包政策, Policy) 来决定这个封包的去向。所以，当你的规则顺序排列错误时，就会产生很严重的错误了。（类比 rewrite 一致）</p><h4 id="2、iptables-的表格-table-与链-chain"><a href="#2、iptables-的表格-table-与链-chain" class="headerlink" title="2、iptables 的表格 (table) 与链 (chain)"></a>2、iptables 的表格 (table) 与链 (chain)</h4><p>事实上，上图 5-1 所列出的规则仅是 iptables 众多表格当中的一个链(chain) 而已。什么是链呢？这得由 iptables 的名称说起。为什么称为 ip”tables”呢？ 因为这个防火墙软件里面有多个表格 (table) ，每个表格都定义出自己的默认政策与规则，且每个表格的用途都不相同。我们可以使用底下这张图来稍微了解一下：<br><img src="/uploads/2018/01/network_iptables_chain.JPG" alt="" title="5-3 iptables 的表格与相关链示意图"></p><p>刚刚图 5-1 的规则内容仅只是图 5-3 内的某个 chain 而已！而预设的情况下，咱们 Linux 的 iptables 至少就有三个表格，包括管理本机进出的 filter 、管理后端主机 (防火墙内部的其他计算机) 的 nat 、管理特殊旗标使用的 mangle (较少使用) 。更有甚者，我们还可以自定义额外的链呢！真是很神奇吧！每个表格与其中链的用途分别是这样的：</p><ol><li><p>filter (过滤器)：主要跟进入 Linux 本机的封包有关，这个是预设的 table ！</p><ul><li>INPUT：主要与想要进入我们 Linux 本机的封包有关；</li><li>OUTPUT：主要与我们 Linux 本机所要送出的封包有关；</li><li>FORWARD：这个咚咚与 Linux 本机比较没有关系，他可以【转递封包】到后端的计算机中，与下列 nat table 相关性较高。</li></ul></li><li><p>nat (地址转换)：是 Network Address Translation 的缩写，这个表格主要在进行来源与目的之 IP 或 port 的转换，与 Linux 本机较无关，主要与 Linux 主机后的局域网络内计算机较有相关。</p><ul><li>PREROUTING：在进行路由判断之前所要进行的规则(DNAT/REDIRECT)</li><li>POSTROUTING：在进行路由判断之后所要进行的规则(SNAT/MASQUERADE)</li><li>OUTPUT：与发送出去的封包有关</li></ul></li><li><p>mangle (破坏者)：这个表格主要是与特殊的封包的路由旗标有关，早期仅有 PREROUTING 及 OUTPUT 链，不过从 kernel 2.4.18 之后加入了 INPUT 及FORWARD 链。由于这个表格与特殊旗标相关性较高，所以像咱们这种单纯的环境当中，较少使用 mangle 这个表格。</p></li></ol><p>所以说，如果你的 Linux 是作为 www 服务，那么要开放客户端对你的 www 要求有响应，就得要处理 filter 的 INPUT 链； 而如果你的 Linux 是作为局域网络的路由器，那么就得要分析 nat 的各个链以及 filter 的 FORWARD 链才行。</p><h4 id="3、本机的-iptables-语法"><a href="#3、本机的-iptables-语法" class="headerlink" title="3、本机的 iptables 语法"></a>3、本机的 iptables 语法</h4><p>防火墙的设定主要使用的就是 iptables 这个指令而已。而防火墙是系统管理员的主要任务之一，且对于系统的影响相当的大，因此【只能让 root 使用 iptables 】，不论是设定还是观察防火墙规则！</p><h5 id="（1）规则的观察与清除"><a href="#（1）规则的观察与清除" class="headerlink" title="（1）规则的观察与清除"></a>（1）规则的观察与清除</h5><p>如果你在安装的时候选择没有防火墙的话，那么 iptables 在一开始的时候应该是没有规则的，不过，可能因为你在安装的时候就有选择系统自动帮你建立防火墙机制，那系统就会有默认的防火墙规则了！无论如何，我们先来看看目前本机的防火墙规则是如何吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-t tables] [-L] [-nv]</span><br><span class="line">选项与参数：</span><br><span class="line">    -t ：后面接 table ，例如 nat 或 filter ，若省略此项目，则使用默认的filter</span><br><span class="line">    -L ：列出目前的 table 的规则</span><br><span class="line">    -n ：不进行 IP 与 HOSTNAME 的反查，显示讯息的速度会快很多！</span><br><span class="line">    -v ：列出更多的信息，包括通过该规则的封包总位数、相关的网络接口等</span><br><span class="line">范例：列出 filter table 三条链的规则</span><br><span class="line">[root@www ~]# iptables -L -n</span><br><span class="line">Chain INPUT (policy ACCEPT) &lt;==针对 INPUT 链，且预设政策为可接受</span><br><span class="line">target prot opt source destination &lt;==说明栏</span><br><span class="line">ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED</span><br><span class="line">&lt;==第 1 条规则</span><br><span class="line">ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0</span><br><span class="line">&lt;==第 2 条规则</span><br><span class="line">ACCEPT all -- 0.0.0.0/0 0.0.0.0/0</span><br><span class="line">&lt;==第 3 条规则</span><br><span class="line">ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22</span><br><span class="line">&lt;==以下类推</span><br><span class="line">REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited</span><br><span class="line">Chain FORWARD (policy ACCEPT) &lt;==针对 FORWARD 链，且预设政策为可接受</span><br><span class="line">target prot opt source destination</span><br><span class="line">REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited</span><br><span class="line">Chain OUTPUT (policy ACCEPT) &lt;==针对 OUTPUT 链，且预设政策为可接受</span><br><span class="line">target prot opt source destination</span><br></pre></td></tr></table></figure></p><blockquote><p>在上表中，每一个 Chain 就是前面提到的每个链。Chain 那一行里面括号的 policy 就是预设的政策，那底下的 target, prot 代表什么呢？<br><strong>target：</strong>代表进行的动作， ACCEPT 是放行，而 REJECT 则是拒绝，此外，尚有 DROP (丢弃) 的项目！<br><strong>prot：</strong>代表使用的封包协议，主要有 tcp, udp 及 icmp 三种封包格式；<br><strong>opt：</strong>额外的选项说明<br><strong>source ：</strong>代表此规则是针对哪个【来源 IP】进行限制？<br><strong>destination ：</strong>代表此规则是针对哪个【目标 IP】进行限制？</p></blockquote><p>在输出结果中，第一个范例因为没有加上 -t 的选项，所以默认就是 filter 这个表格内的 INPUT, OUTPUT, FORWARD 三条链的规则啰。若针对单机来说，INPUT 与 FORWARD 算是比较重要的管制防火墙链，所以你可以发现最后一条规则的政策是 REJECT (拒绝)！虽然 INPUT 与 FORWARD 的政策是放行 (ACCEPT)，不过在最后一条规则就已经将全部的封包都拒绝了！</p><p>不过这个指令的观察只是作个格式化的查阅，要详细解释每个规则会比较不容易解析。举例来说，我们将 INPUT 的 5 条规则依据输出结果来说明一下，结果会变成：</p><blockquote><ol><li>只要是封包状态为 RELATED,ESTABLISHED 就予以接受</li><li>只要封包协议是 icmp 类型的，就予以放行</li><li>无论任何来源 (0.0.0.0/0) 且要去任何目标的封包，不论任何封包格式(prot 为 all)，通通都接受</li><li>只要是传给 port 22 的主动式联机 tcp 封包就接受</li><li>全部的封包信息通通拒绝</li></ol></blockquote><p>最有趣的应该是第 3 条规则了，怎么会所有的封包信息都予以接受？如果都接受的话，那么后续的规则根本就不会有用嘛！其实那条规则是仅针对每部主机都有的内部循环测试网络 (lo) 接口！如果没有列出接口，那么我们就很容易搞错。所以，近来建议使用 iptables-save 这个指令来观察防火墙规则！因为 iptables-save 会列出完整的防火墙规则，只是并没有规格化输出而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables-save [-t table]</span><br><span class="line">选项与参数：</span><br><span class="line">-t ：可以仅针对某些表格来输出，例如仅针对 nat 或 filter 等等</span><br><span class="line">[root@www ~]# iptables-save</span><br><span class="line"># Generated by iptables-save v1.4.7 on Fri Jul 22 15:51:52 2011</span><br><span class="line">*filter &lt;==星号开头的指的是表格，这里为 filter</span><br><span class="line">:INPUT ACCEPT [0:0] &lt;==冒号开头的指的是链，三条内建的链</span><br><span class="line">:FORWARD ACCEPT [0:0] &lt;==三条内建链的政策都是 ACCEPT 啰！</span><br><span class="line">:OUTPUT ACCEPT [680:100461]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT &lt;==针对 INPUT的规则</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT &lt;==这条很重要！针对本机内部接口开放！</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited &lt;==针对FORWARD 的规则</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure></p><p>由上面的输出来看，有底线且内容含有 lo 的那条规则当中，【 -i lo 】指的就是由 lo 适配卡进来的封包！这样看就清楚多了！因为有写到接口的关系啊！不像之前的 <code>iptables -L -n</code>！既然这个规则不是我们想要的，那该如何修改规则呢？建议，先删除规则再慢慢建立各个需要的规则！那如何清除规则？这样做就对了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-t tables] [-FXZ]</span><br><span class="line">选项与参数：</span><br><span class="line">-F ：清除所有的已订定的规则；</span><br><span class="line">-X ：杀掉所有使用者 &quot;自定义&quot; 的 chain (应该说的是 tables ）；</span><br><span class="line">-Z ：将所有的 chain 的计数与流量统计都归零</span><br><span class="line">范例：清除本机防火墙 (filter) 的所有规则</span><br><span class="line">[root@www ~]# iptables -F</span><br><span class="line">[root@www ~]# iptables -X</span><br><span class="line">[root@www ~]# iptables -Z</span><br></pre></td></tr></table></figure></p><p>由于这三个指令会将本机防火墙的所有规则都清除，但却不会改变预设政策 (policy) ，所以如果你不是在本机下达这三行指令时，很可能你会被自己挡在家门外 (若 INPUT设定为 DROP 时)！要小心啊！</p><h5 id="2）定义预设政策-policy"><a href="#2）定义预设政策-policy" class="headerlink" title="(2）定义预设政策 (policy)"></a>(2）定义预设政策 (policy)</h5><p>清除规则之后，再接下来就是要设定规则的政策！还记得政策指的是什么吗？【 当你的封包不在你设定的规则之内时，则该封包的通过与否，是以 Policy 的设定为准】，在本机方面的预设政策中，假设你对于内部的使用者有信心的话，那么 filter 内的 INPUT 链方面可以定义的比较严格一点，而 FORWARD 与 OUTPUT 则可以订定的松一些！通常都是将 INPUT 的 policy 定义为 DROP ，其他两个则定义为 ACCEPT。至于 nat table 则暂时先不理会他。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-t nat] -P [INPUT,OUTPUT,FORWARD] [ACCEPT,DROP]</span><br><span class="line">选项与参数：</span><br><span class="line">-P ：定义政策( Policy )。注意，这个 P 为大写啊！</span><br><span class="line">ACCEPT ：该封包可接受</span><br><span class="line">DROP ：该封包直接丢弃，不会让 client 端知道为何被丢弃。</span><br><span class="line">范例：将本机的 INPUT 设定为 DROP ，其他设定为 ACCEPT</span><br><span class="line">[root@www ~]# iptables -P INPUT DROP</span><br><span class="line">[root@www ~]# iptables -P OUTPUT ACCEPT</span><br><span class="line">[root@www ~]# iptables -P FORWARD ACCEPT</span><br><span class="line">[root@www ~]# iptables-save</span><br><span class="line"># Generated by iptables-save v1.4.7 on Fri Jul 22 15:56:34 2011</span><br><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">COMMIT</span><br><span class="line"># Completed on Fri Jul 22 15:56:34 2011</span><br><span class="line"># 由于 INPUT 设定为 DROP 而又尚未有任何规则，所以上面的输出结果显示：</span><br><span class="line"># 所有的封包都无法进入你的主机！是不通的防火墙设定！(网络联机是双向的)</span><br></pre></td></tr></table></figure></p><p>看到输出的结果了吧？INPUT 被修改了设定！其他的 nat table 三条链的预设政策设定也是一样的方式，例如：<code>【 iptables -t nat -P PREROUTING ACCEPT 】</code>就设定了 nat table 的 PREROUTING 链为可接受的意思！预设政策设定完毕后，来谈一谈关于各规则的封包基础比对设定吧。</p><h5 id="（3）封包的基础比对：IP-网域及接口装置"><a href="#（3）封包的基础比对：IP-网域及接口装置" class="headerlink" title="（3）封包的基础比对：IP, 网域及接口装置"></a>（3）封包的基础比对：IP, 网域及接口装置</h5><p>开始来进行防火墙规则的封包比对设定吧！既然是因特网，那么我们就由最基础的 IP, 网域及端口，亦即是 OSI 的第三层谈起，再来谈谈装置 (网络卡) 的限制等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-AI 链名] [-io 网络接口] [-p 协议] \</span><br><span class="line">&gt; [-s 来源IP/网域] [-d 目标IP/网域] -j [ACCEPT|DROP|REJECT|LOG]</span><br><span class="line">选项与参数：</span><br><span class="line">-AI 链名：针对某的链进行规则的 &quot;插入&quot; 或 &quot;累加&quot;</span><br><span class="line">  -A ：新增加一条规则，该规则增加在原本规则的最后面。例如原本已经有四条规则，</span><br><span class="line">       使用 -A 就可以加上第五条规则！</span><br><span class="line">  -I ：插入一条规则。如果没有指定此规则的顺序，默认是插入变成第一条规则。例如原本有四条规则，</span><br><span class="line">       使用 -I 则该规则变成第一条，而原本四条变成 2~5 号</span><br><span class="line">  链 ：有 INPUT, OUTPUT, FORWARD 等，此链名称又与 -io 有关，请看底下。</span><br><span class="line">-io 网络接口：设定封包进出的接口规范</span><br><span class="line">  -i ：封包所进入的那个网络接口，例如 eth0, lo 等接口。需与 INPUT 链配合；</span><br><span class="line">  -o ：封包所传出的那个网络接口，需与 OUTPUT 链配合；</span><br><span class="line">-p 协定：设定此规则适用于哪种封包格式</span><br><span class="line">  主要的封包格式有： tcp, udp, icmp 及 all 。</span><br><span class="line">-s 来源 IP/网域：设定此规则之封包的来源项目，可指定单纯的 IP 或包括网域，例如：</span><br><span class="line">  IP ：192.168.0.100</span><br><span class="line">  网域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。</span><br><span class="line">  若规范为『不许』时，则加上 ! 即可，例如：</span><br><span class="line">  -s ! 192.168.100.0/24 表示不许 192.168.100.0/24 之封包来源；</span><br><span class="line">-d 目标 IP/网域：同 -s ，只不过这里指的是目标的 IP 或网域。</span><br><span class="line">-j ：后面接动作，主要的动作有接受(ACCEPT)、丢弃(DROP)、拒绝(REJECT)及记录(LOG)</span><br></pre></td></tr></table></figure></p><p>iptables 的基本参数就如同上面所示的，仅只谈到 IP 、网域与装置等等的信息。至于 TCP, UDP 封包特有的端口 (port number) 与状态 (如 SYN 旗标)，下面谈论。</p><p><strong>示例：</strong><br>先让我们来看看最基础的几个规则，例如开放 lo 这个本机的接口以及某个 IP 来源吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">范例：设定 lo 成为受信任的装置，亦即进出 lo 的封包都予以接受</span><br><span class="line">[root@www ~]# iptables -A INPUT -i lo -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>仔细看上面并没有列出 -s, -d 等等的规则，这表示：不论封包来自何处或去到哪里，只要是来自 lo 这个界面，就予以接受！这个观念挺重要的，就是【没有指定的项目，则表示该项目完全接受】的意思！例如这个案例当中，关于 -s, -d…等等的参数没有规定时，就代表不论什么值都会被接受。</p><h5 id="4）TCP-UDP-的规则比对：针对端口设定"><a href="#4）TCP-UDP-的规则比对：针对端口设定" class="headerlink" title="(4）TCP, UDP 的规则比对：针对端口设定"></a>(4）TCP, UDP 的规则比对：针对端口设定</h5><p>在谈到 TCP 与 UDP 时，比较特殊的就是那个端口 (port)，在 TCP 方面则另外有所谓的联机封包状态，包括最常见的 SYN 主动联机的封包格式。那么如何针对这两种封包格式进行防火墙规则的设定呢？你可以这样看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-AI 链] [-io 网络接口] [-p tcp,udp] \</span><br><span class="line">&gt; [-s 来源IP/网域] [--sport 埠口范围] \</span><br><span class="line">&gt; [-d 目标IP/网域] [--dport 埠口范围] -j [ACCEPT|DROP|REJECT]</span><br><span class="line">选项与参数：</span><br><span class="line">--sport 埠口范围：限制来源的端口口号码，端口口号码可以是连续的，例如1024:65535</span><br><span class="line">--dport 埠口范围：限制目标的端口口号码。</span><br></pre></td></tr></table></figure></p><p>事实上就是多了那个 –sport 及 –dport 这两个玩意儿，重点在那个 port 上面！不过你得要特别注意，因为仅有 tcp 与 udp 封包具有端口，因此你想要使用 –dport,–sport 时，得要加上 -p tcp 或 -p udp 的参数才会成功！底下让我们来进行几个小测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">范例：想要联机进入本机 port 21 的封包都抵挡掉：</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p tcp --dport 21 -j DROP</span><br><span class="line">范例：想连到我这部主机的网络 (upd port 137,138 tcp port 139,445) 就放行</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p udp --dport 137:138 -j ACCEPT</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p tcp --dport 139 -j ACCEPT</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p tcp --dport 445 -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>除了端口之外，在 TCP 还有特殊的旗标啊！最常见的就是那个主动联机的 SYN 旗标了。我们在 iptables 里面还支持【 –syn 】的处理方式，我们以底下的例子来说明好了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">范例：将来自任何地方来源 port 1:1023 的主动联机到本机端的 1:1023 联机丢弃</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p tcp --sport 1:1023 \</span><br><span class="line">&gt; --dport 1:1023 --syn -j DROP</span><br></pre></td></tr></table></figure></p><p>一般来说，client 端启用的 port 都是大于 1024 以上的端口，而 server 端则是启用小于 1023 以下的端口在监听的。所以我们可以让来自远程的小于 1023 以下的端口数据的主动联机都给他丢弃！但不适用在 FTP 的主动联机中！</p><h5 id="（5）iptables-外挂模块：mac-与-state"><a href="#（5）iptables-外挂模块：mac-与-state" class="headerlink" title="（5）iptables 外挂模块：mac 与 state"></a>（5）iptables 外挂模块：mac 与 state</h5><p>在 kernel 2.2 以前使用 ipchains 管理防火墙时，通常会让系统管理员相当头痛！因为 ipchains 没有所谓的封包状态模块，因此我们必须要针对封包的进、出方向进行管控。举例来说，如果你想要联机到远程主机的 port 22 时，你必须要针对两条规则来设定：</p><ul><li>本机端的 1024:65535 到远程的 port 22 必须要放行 (OUTPUT 链)；</li><li>远程主机 port 22 到本机的 1024:65535 必须放行 (INPUT 链)；</li></ul><p>这会很麻烦！因为如果你要联机到 10 部主机的 port 22 时，假设 OUTPUT 为预设开启 (ACCEPT)， 你依旧需要填写十行规则，让那十部远程主机的 port 22 可以联机到你的本地端主机上。那如果开启全部的 port 22 呢？又担心某些恶意主机会主动以 port 22 联机到你的机器上！同样的道理，如果你要让本地端主机可以连到外部的 port 80 (WWW 服务)，那就更不得了！这就是网络联机是双向的一个很重要的概念！</p><p>好在我们的 iptables 免除了这个困扰！他可以透过一个状态模块来分析 【这个想要进入的封包是否为刚刚我发出去的响应？】如果是刚刚我发出去的响应，那么就可以予以接受放行！这样就不用管远程主机是否联机进来的问题了！那如何达到呢？看看底下的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables -A INPUT [-m state] [--state 状态]</span><br><span class="line">选项与参数：</span><br><span class="line">-m ：一些 iptables 的外挂模块，主要常见的有：</span><br><span class="line">  state ：状态模块</span><br><span class="line">  mac ：网络卡硬件地址 (hardware address)</span><br><span class="line">--state ：一些封包的状态，主要有：</span><br><span class="line">  INVALID ：无效的封包，例如数据破损的封包状态</span><br><span class="line">  ESTABLISHED：已经联机成功的联机状态；</span><br><span class="line">  NEW ：想要新建立联机的封包状态；</span><br><span class="line">  RELATED ：这个最常用！表示这个封包是与我们主机发送出去的封包有关</span><br><span class="line">范例：只要已建立或相关封包就予以通过，只要是不合法封包就丢弃</span><br><span class="line">[root@www ~]# iptables -A INPUT -m state \</span><br><span class="line">&gt; --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">[root@www ~]# iptables -A INPUT -m state --state INVALID -j DROP</span><br></pre></td></tr></table></figure></p><p>如此一来，我们的 iptables 就会主动分析出该封包是否为响应状态，若是的话，就直接予以接受。这样一来你就不需要针对响应的封包来撰写个别的防火墙规则了！这真是太棒了！底下我们继续谈一下 iptables 的另一个外挂，那就是针对网卡来进行放行与防御：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">范例：针对局域网络内的 aa:bb:cc:dd:ee:ff 主机开放其联机</span><br><span class="line">[root@www ~]# iptables -A INPUT -m mac --mac-source aa:bb:cc:dd:ee:ff -j ACCEPT</span><br><span class="line">选项与参数：</span><br><span class="line">--mac-source ：就是来源主机的 MAC ！</span><br></pre></td></tr></table></figure></p><p>如果你的区网当中有某些网络高手，老是可以透过修改 IP 去尝试透过路由器往外跑，那你该怎么办？难道将整个区网拒绝？并不需要的，你可以透过之前谈到的 ARP 相关概念，去捉到那部主机的 MAC ，然后透过上头的这个机制，将该主机整个 DROP 掉即可。不管他改了什么 IP ，除非他知道你是用网卡的 MAC 来管理，否则他就是出不去！</p><h5 id="（6）超阳春客户端防火墙设计与防火墙规则储存"><a href="#（6）超阳春客户端防火墙设计与防火墙规则储存" class="headerlink" title="（6）超阳春客户端防火墙设计与防火墙规则储存"></a>（6）超阳春客户端防火墙设计与防火墙规则储存</h5><p>经过上述的本机 iptables 语法分析后，接下来我们来想想，如果站在客户端且不提供网络服务的 Linux 本机角色时， 你应该要如何设计你的防火墙呢？老实说，你只要分析过 CentOS 默认的防火墙规则就会知道了，理论上， 应该要有的规则如下：</p><ol><li>规则归零：清除所有已经存在的规则 (iptables -F…)</li><li>预设政策：除了 INPUT 这个自定义链设为 DROP 外，其他为预设 ACCEPT；</li><li>信任本机：由于 lo 对本机来说是相当重要的，因此 lo 必须设定为信任装置；</li><li>回应封包：让本机主动向外要求而响应的封包可以进入本机(ESTABLISHED,RELATED)</li><li>信任用户：这是非必要的，如果你想要让区网的来源可用你的主机资源时</li></ol><p>这就是最最阳春的防火墙，你可以透过第二步骤抵挡所有远程的来源封包，而透过第四步骤让你要求的远程主机响应封包可以进入， 加上让本机的 lo 这个内部循环装置可以放行，嘿嘿！一部 client 专用的防火墙规则就 OK 了！你可以在某个 script 上面这样做即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# vim bin/firewall.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin; export PATH</span><br><span class="line"># 1. 清除规则</span><br><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -Z</span><br><span class="line"># 2. 设定政策</span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"># 3~5. 制订各项规则</span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">#iptables -A INPUT -i eth0 -s 192.168.1.0/24 -j ACCEPT</span><br><span class="line"># 6. 写入防火墙规则配置文件</span><br><span class="line">/etc/init.d/iptables save</span><br><span class="line">[root@www ~]# sh bin/firewall.sh</span><br><span class="line">iptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]</span><br></pre></td></tr></table></figure></p><p>其实防火墙也是一个服务，你可以透过<code>【chkconfig --list iptables】</code>去察看就知道了。因此，你这次修改的各种设定想要在下次开机还保存，那就得要进行<code>【 /etc/init.d/iptables save 】</code>这个指令加参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Linux 的封包过滤软件：iptables&lt;/strong&gt;&lt;br&gt;《防火墙的认识》这篇文章说了那么多，主要就是说明防火墙是什么，能做什么，并且知道防火墙不是万能的。下面我说一下都使用什么来设定防火墙。&lt;br&gt;因为不同的核心使用的防火墙机制不同，且支持的软件指令与语法也不相同，所以在 Linux 上头设定属于你自己的防火墙规则时，要注意，先用 uname -r 追踪一下你的核心版本再说，目前大部分的核心都使用 kernel 2.6 版的核心，主要是使用 iptables 这个防火墙机制。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 防火墙的认识</title>
    <link href="http://yoursite.com/2018/01/17/Linux-%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2018/01/17/Linux-防火墙的认识/</id>
    <published>2018-01-17T10:45:06.000Z</published>
    <updated>2018-01-18T07:02:45.878Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、认识防火墙"><a href="#1、认识防火墙" class="headerlink" title="1、认识防火墙"></a>1、认识防火墙</h4><p>网络安全除了随时注意相关软件的漏洞以及网络上的安全通报之外，你最好能够依据自己的环境来订定防火墙机制！这样对于你的网络环境，会比较有保障一点！那么什么是防火墙呢？其实防火墙就是透过订定一些有顺序的规则，并管制进入到我们网域内的主机 (或者可以说是网域) 数据封包的一种机制！更广义的来说，只要能够分析与过滤进出我们管理之网域的封包数据，就可以称为防火墙。</p><p>防火墙又可以分为硬件防火墙与本机的软件防火墙。硬件防火墙是由厂商设计好的主机硬件，这部硬件防火墙内的操作系统主要以提供封包数据的过滤机制为主，并将其他不必要的功能拿掉。因为单纯作为防火墙功能而已，因此封包过滤的效率较佳。至于软件防火墙呢？那就是我们主要研究的方向！软件防火墙本身就是在保护系统网络安全的一套软件(或称为机制)，例如 Netfilter 与 TCP Wrappers 都可以称为软件防火墙。<br><a id="more"></a></p><h4 id="2、为何需要防火墙"><a href="#2、为何需要防火墙" class="headerlink" title="2、为何需要防火墙"></a>2、为何需要防火墙</h4><p>封包进入本机时，会通过防火墙、服务器软件程序、SELinux 与文件系统等。所以基本上，如果你的系统 </p><ul><li>(1)已经关闭不需要而且危险的服务； </li><li>(2)已经将整个系统的所有软件都保持在最新的状态； </li><li>(3)权限设定妥当且定时进行备份工作； </li><li>(4)已经教育用户具有良好的网络、系统操作习惯。 </li></ul><p>那么你的系统实际上已经颇为安全了！要不要架设防火墙？那就见仁见智了。</p><p>不过，毕竟网络世界是很复杂的，而 Linux 主机也不是一个简单的东西，说不定哪一天你在进行某个软件的测试时，主机突然间就启动了一个网络服务，如果你没有管制该服务的使用范围，那么该服务就等于对所有 Internet 开放，那就麻烦了！因为该服务可能可以允许任何人登入你的系统，那不是挺危险？</p><p>所以，防火墙能作什么呢？防火墙最大的功能就是帮助你【限制某些服务的存取来源】！举例来说： </p><ul><li>(1)你可以限制文件传输服务 (FTP) 只在子域内的主机才能够使用，而不对整个 Internet 开放； </li><li>(2)你可以限制整部 Linux 主机仅可以接受客户端的 WWW 要求，其他的服务都关闭； </li><li>(3)你还可以限制整部主机仅能主动对外联机。</li></ul><p>反过来说，若有客户端对我们主机发送主动联机的封包状态(TCP 封包的 SYN flag)就予以抵挡等等。这些就是最主要的防火墙功能了！</p><p>所以，防火墙最重要的任务就是在规划出：</p><ol><li>切割被信任(如子域)与不被信任(如 Internet)的网段；</li><li>划分出可提供 Internet 的服务与必须受保护的服务；</li><li>分析出可接受与不可接受的封包状态；</li></ol><p>当然，咱们 Linux 的 iptables 防火墙软件还可以进行更细部深入的 NAT(Network Address Translation) 的设定，并进行更弹性的 IP 封包伪装功能，不过，对于单一主机的防火墙来说，最简单的任务还是上面那三项就是了！所以，你需不需要防火墙呢？理论上，当然需要！而且你必须要知道【你的系统哪些数据与服务需要保护】，针对需要受保护的服务来设定防火墙的规则吧！底下我们先来谈一谈，那在Linux 上头常见的防火墙类型有哪些？</p><h4 id="3、Linux-系统上防火墙的主要类别"><a href="#3、Linux-系统上防火墙的主要类别" class="headerlink" title="3、Linux 系统上防火墙的主要类别"></a>3、Linux 系统上防火墙的主要类别</h4><p>基本上，依据防火墙管理的范围，我们可以将防火墙区分为网域型与单一主机型的控管。在单一主机型的控管方面，主要的防火墙有封包过滤型的 Netfilter 与依据服务软件程序作为分析的 TCP Wrappers 两种。若以区域型的防火墙而言，由于此类防火墙都是当作路由器角色，因此防火墙类型主要则有封包过滤的 Netfilter 与利用代理服务器 (proxy server) 进行存取代理的方式了。</p><h5 id="（1）Netfilter-封包过滤机制"><a href="#（1）Netfilter-封包过滤机制" class="headerlink" title="（1）Netfilter (封包过滤机制)"></a>（1）Netfilter (封包过滤机制)</h5><p>所谓的封包过滤，亦即是分析进入主机的网络封包，将封包的表头数据捉出来进行分析，以决定该联机为放行或抵挡的机制。由于这种方式可以直接分析封包表头数据，所以包括硬件地址(MAC), 软件地址 (IP), TCP, UDP, ICMP 等封包的信息都可以进行过滤分析的功能，因此用途非常的广泛。(其实主要分析的是OSI 七层协议的 2, 3, 4 层)</p><p>在 Linux 上面我们使用核心内建的 Netfilter 这个机制，而 Netfilter 提供了 iptables 这个软件来作为防火墙封包过滤的指令。由于 Netfilter 是核心内建的功能，因此他的效率非常的高！非常适合于一般小型环境的设定！Netfilter 利用一些封包过滤的规则设定，来定义出什么资料可以接收，什么资料需要剔除，以达到保护主机的目的！</p><h5 id="（2）TCP-Wrappers-程序控管"><a href="#（2）TCP-Wrappers-程序控管" class="headerlink" title="（2）TCP Wrappers (程序控管)"></a>（2）TCP Wrappers (程序控管)</h5><p>另一种抵挡封包进入的方法，为透过服务器程序的外挂 (tcpd) 来处置的！与封包过滤不同的是，这种机制主要是分析谁对某程序进行存取，然后透过规则去分析该服务器程序谁能够联机、谁不能联机。由于主要是透过分析服务器程序来控管，因此与启动的端口无关，只与程序的名称有关。举例来说，我们知道 FTP 可以启动在非正规的 port 21 进行监听，当你透过 Linux 内建的 TCP wrappers 限制 FTP 时，那么你只要知道 FTP 的软件名称 (vsftpd) ，然后对他作限制，则不管 FTP 启动在哪个端口，都会被该规则管理的。</p><h5 id="（3）Proxy-代理服务器"><a href="#（3）Proxy-代理服务器" class="headerlink" title="（3）Proxy (代理服务器)"></a>（3）Proxy (代理服务器)</h5><p>其实代理服务器是一种网络服务，它可以【代理】用户的需求，而代为前往服务器取得相关的资料。就有点像底下这个图示吧：<br><img src="/uploads/2018/01/17/network_proxy.JPG" alt="" title="Proxy Server 的运作原理简介"></p><p>以上图为例，当 Client 端想要前往 Internet 取得 Google 的数据时，他取得数据的流程是这样的：</p><blockquote><p>1.client 会向 proxy server 要求数据，请 proxy 帮忙处理；<br>2.proxy 可以分析使用者的 IP 来源是否合法？使用者想要去的 Google 服务器是否合法？如果这个 client 的要求都合法的话，那么 proxy 就会主动的帮忙 client 前往 Google 取得资料；<br>3.Google 所回传的数据是传给 proxy server 的，所以 Google 服务器上面看到的是 proxy server 的 IP；<br>4.最后 proxy 将 Google 回传的数据送给 client。</p></blockquote><p>这样了解了吗？没错，client 并没有直接连上 Internet ，所以在实线部分(步骤 1, 4)只要 Proxy 与 Client 可以联机就可以了！此时 client 甚至不需要拥有 public IP ！而当有人想要攻击 client 端的主机时，除非他能够攻破 Proxy server ，否则是无法与 client 联机的！<br>另外，一般 proxy 主机通常仅开放 port 80, 21, 20 等 WWW 与 FTP 的端口而已，而且通常 Proxy 就架设在路由器上面，因此可以完整的掌控局域网络内的对外联机！让你的 LAN 变的更安全啊！</p><h4 id="4、防火墙的使用限制"><a href="#4、防火墙的使用限制" class="headerlink" title="4、防火墙的使用限制"></a>4、防火墙的使用限制</h4><p>从前面的分析中，我们已经知道过封包滤式防火墙主要在分析 OSI 七层协议当中的 2, 3, 4 层，既然如此的话，Linux 的 Netfilter 机制到底可以做些什么事情呢？其实可以进行的分析工作主要有：</p><h5 id="（1）拒绝让-Internet-的封包进入主机的某些端口"><a href="#（1）拒绝让-Internet-的封包进入主机的某些端口" class="headerlink" title="（1）拒绝让 Internet 的封包进入主机的某些端口"></a>（1）拒绝让 Internet 的封包进入主机的某些端口</h5><p>这个应该不难了解。例如你的 port 21 这个 FTP 相关的端口，若只想要开放给内部网络的话，那么当 Internet 来的封包想要进入你的 port 21 时，就可以将该数据封包丢掉！因为我们可以分析的到该封包表头的端口号码！</p><h5 id="（2）拒绝让某些来源-IP-的封包进入"><a href="#（2）拒绝让某些来源-IP-的封包进入" class="headerlink" title="（2）拒绝让某些来源 IP 的封包进入"></a>（2）拒绝让某些来源 IP 的封包进入</h5><p>例如你已经发现某个 IP 主要都是来自攻击行为的主机，那么只要来自该 IP 的数据封包，就将他丢弃！这样也可以达到基础的安全！</p><h5 id="（3）拒绝让带有某些特殊旗标-flag-的封包进入"><a href="#（3）拒绝让带有某些特殊旗标-flag-的封包进入" class="headerlink" title="（3）拒绝让带有某些特殊旗标 (flag) 的封包进入"></a>（3）拒绝让带有某些特殊旗标 (flag) 的封包进入</h5><p>最常拒绝的就是带有 SYN 的主动联机的旗标了！只要一经发现，你就可以将该封包丢弃！（因为都是一些攻击封包，占着茅坑不拉屎！）</p><h5 id="（4）分析硬件地址-MAC-来决定联机与否"><a href="#（4）分析硬件地址-MAC-来决定联机与否" class="headerlink" title="（4）分析硬件地址 (MAC) 来决定联机与否"></a>（4）分析硬件地址 (MAC) 来决定联机与否</h5><p>如果你的局域网络里面有比较捣蛋的但是又具有比较高强的网络功力的高手时，如果你使用 IP 来抵挡他使用网络的权限，而他却懂得反正换一个 IP 就好了，都在同一个网域内！同样还是在搞破坏！！怎么办？没关系，我们可以死锁他的网络卡硬件地址啊！因为 MAC 是焊在网络卡上面的，所以你只要分析到该使用者所使用的 MAC 之后，可以利用防火墙将该 MAC 锁住，除非他能够一换再换他的网络卡来取得新的 MAC，否则换 IP 是没有用的！</p><p>虽然 Netfilter 防火墙已经可以做到这么多的事情，不过，还是有很多事情没有办法透过 Netfilter 来完成！什么？设定防火墙之后还不安全啊！那当然啦！谁说设定了防火墙之后你的系统就一定安全？防火墙虽然可以防止不受欢迎的封包进入我们的网络当中，不过，某些情况下，他并不能保证我们的网络一定就很安全。举几个例子来谈一谈：<br><strong>（1）防火墙并不能很有效的抵挡病毒或木马程序</strong><br>假设你已经开放了 WWW 的服务，那么你的 WWW 主机上面，防火墙一定得要将 WWW 服务的 port 开放给 Client 端登入才行吧！否则你的 WWW 主机设定了等于没有用对吧！也就是说，只要进入你的主机的封包是要求 WWW 数据的，就可以通过你的防火墙。那好了，【万一你的 WWW 服务器软件有漏洞，或者本身向你要求 WWW 服务的该封包就是病毒在侦测你的系统】时，你的防火墙可是一点办法也没有啊！因为本来设定的规则就是会让他通过。<br><strong>（2）防火墙对于来自内部 LAN 的攻击较无承受力</strong><br>一般来说，我们对于 LAN 里面的主机都没有什么防火墙的设定，因为是我们自己的 LAN ，所以当然就设定为信任网域了！不过，LAN 里面总是可能有些网络小白，虽然他们不是故意要搞破坏，但是他们就是不懂！所以就乱用网络。这个时候就很糟糕，因为防火墙对于内部的规则设定通常比较少，所以就容易造成内部员工对于网络误用或滥用的情况。</p><p>所以，在你的 Linux 主机实地上网之前，还是得先：</p><ul><li>（1）关闭几个不安全的服务；</li><li>（2）升级几个可能有问题的套件；</li><li>（3）架设好最起码的安全防护–防火墙–</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、认识防火墙&quot;&gt;&lt;a href=&quot;#1、认识防火墙&quot; class=&quot;headerlink&quot; title=&quot;1、认识防火墙&quot;&gt;&lt;/a&gt;1、认识防火墙&lt;/h4&gt;&lt;p&gt;网络安全除了随时注意相关软件的漏洞以及网络上的安全通报之外，你最好能够依据自己的环境来订定防火墙机制！这样对于你的网络环境，会比较有保障一点！那么什么是防火墙呢？其实防火墙就是透过订定一些有顺序的规则，并管制进入到我们网域内的主机 (或者可以说是网域) 数据封包的一种机制！更广义的来说，只要能够分析与过滤进出我们管理之网域的封包数据，就可以称为防火墙。&lt;/p&gt;
&lt;p&gt;防火墙又可以分为硬件防火墙与本机的软件防火墙。硬件防火墙是由厂商设计好的主机硬件，这部硬件防火墙内的操作系统主要以提供封包数据的过滤机制为主，并将其他不必要的功能拿掉。因为单纯作为防火墙功能而已，因此封包过滤的效率较佳。至于软件防火墙呢？那就是我们主要研究的方向！软件防火墙本身就是在保护系统网络安全的一套软件(或称为机制)，例如 Netfilter 与 TCP Wrappers 都可以称为软件防火墙。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>基础网络概念（三）</title>
    <link href="http://yoursite.com/2018/01/16/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/16/基础网络概念（三）/</id>
    <published>2018-01-16T10:33:33.000Z</published>
    <updated>2018-01-18T06:58:16.163Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、网络"><a href="#1、网络" class="headerlink" title="1、网络"></a>1、网络</h4><p>网络是由节点和连线构成，表示诸多对象及其相互联系。在数学上，网络是一种图，一般认为专指加权图。网络除了数学定义外，还有具体的物理含义，即网络是从某种相同类型的实际问题中抽象出来的模型。在计算机领域中，网络是信息传输、接收、共享的虚拟平台，通过它把各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络是人类发展史来最重要的发明，提高了科技和人类社会的发展。<br><a id="more"></a></p><h4 id="2、网络类型："><a href="#2、网络类型：" class="headerlink" title="2、网络类型："></a>2、网络类型：</h4><p><strong>地理位置：</strong></p><ul><li>1.局域网（LAN）：一般限定在较小的区域内，小于10km的范围，通常采用有线的方式连接起来。</li><li>2.城域网（MAN）：规模局限在一座城市的范围内，10～100km的区域。</li><li>3.广域网（WAN）：网络跨越国界、洲界，甚至全球范围。<br>局域网和广域网是网络的热点。局域网是组成其他两种类型网络的基础，城域网一般都加入了广域网。广域网的典型代表是internet网。</li><li>4.个人网：个人局域网就是在个人工作地方把属于个人使用的电子设备（如便携电脑等）用无线技术连接起来的网络，因此也常称为无线个人局域网WPAN，其范围大约在10m左右。</li></ul><p><strong>传输介质：</strong></p><ul><li>1.有线网：采用同轴电缆和双绞线来连接的计算机网络。</li><li>2.光纤网：光纤网也是有线网的一种，但由于其特殊性而单独列出，光纤网采用光导纤维作传输介质。光纤传输距离长，传输率高，可达数千兆bps，抗干扰性强，不会受到电子监听设备的监听，是高安全性网络的理想选择。</li><li>3.无线网：用电磁波作为载体来传输数据。</li></ul><h4 id="3、互联网"><a href="#3、互联网" class="headerlink" title="3、互联网"></a>3、互联网</h4><p>互联网（英语：Internet），又称网际网络，或音译因特网(Internet)、英特网，互联网始于1969年美国的阿帕网。是网络与网络之间所串连成的庞大网络，这些网络以一组通用的协议相连，形成逻辑上的单一巨大国际网络。通常internet泛指互联网，而Internet则特指因特网。这种将计算机网络互相联接在一起的方法可称作“网络互联”，在这基础上发展出覆盖全世界的全球性互联网络称互联网，即是互相连接一起的网络结构。互联网并不等同万维网，万维网只是一建基于超文本相互链接而成的全球性系统，且是互联网所能提供的服务其中之一。</p><p><strong>互联网运行原理：</strong><br>计算机网络是由许多计算机组成的，要实现网络的计算机之间传输数据，必须要做两件事，数据传输目的地址和保证数据迅速可靠传输的措施，这是因为数据在传输　过程中很容易丢失或传错，Internet使用一种专门的计算机语言(协议)，以保证数据安全、可靠地到达指定的目的地，这种语言分两部TCP(Transmission Control Protocol　传输控制协议)和 IP (Internet Protocol网间协议)sure网络营销理论。　TCP/IP协议的数据传输过程：TCP/IP协议所采用的通信方式是分组交换方式。所谓分组交换，简单说就是数据　在传输时分成若干段，每个数据段称为一个数据包，TCP/IP协议的基本传输单位是数据包，TCP/IP协议主要包括两个主要的协议，即TCP协议和IP协议，这两个协议可以　联合使用，也可以与其他协议联合使用，它们在数据传输过程中主要完成以下功能：</p><ul><li>1) 首先由TCP协议把数据分成若干数据包，给每个数据包写上序号，以便接收端把数据还原成原来的格式。</li><li>2) IP协议给每个数据包写上发送主机和接收主机的地址，一旦写上源地址和目的地址，数据包就可以在物理网上传送数据了。IP协议还具有利用路由算法进行路由选择的功能。</li><li>3) 这些数据包可以通过不同的传输途径(路由)进行传输，由于路径不同，加上其它的原因，可能出现顺序颠倒、数据丢失、数据失真甚至重复的现象。这些问题都由TCP协议来处理，它具有检查和处理错误的功能， 必要时还可以请求发送端重发。简言之，IP协议负责数据的传输，而TCP协议负责数据的可靠传输。</li></ul><h4 id="4、因特网"><a href="#4、因特网" class="headerlink" title="4、因特网"></a>4、因特网</h4><p>因特网（Internet）是一组全球信息资源的总汇。有一种粗略的说法，认为INTERNET是由于许多小的网络（子网）互联而成的一个逻辑网，每个子网中连接着若干台计算机（主机）。Internet以相互交流信息资源为目的，基于一些共同的协议，并通过许多路由器和公共互联网而成，它是一个信息资源和资源共享的集合。</p><h4 id="5、万维网"><a href="#5、万维网" class="headerlink" title="5、万维网"></a>5、万维网</h4><p>WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为Web。 分为Web客户端和Web服务器程序。 WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。 是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。<br>万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</p><h4 id="6、三者之间的关系"><a href="#6、三者之间的关系" class="headerlink" title="6、三者之间的关系"></a>6、三者之间的关系</h4><p>互联网、因特网、万维网三者的关系是：互联网包含因特网，因特网包含万维网，凡是能彼此通信的设备组成的网络就叫互联网。所以，即使仅有两台机器，不论用何种技术使其彼此通信，也叫互联网。国际标准的互联网写法是Internet，因特网是互联网的一种。因特网可不是仅有两台机器组成的互联网，它是由上千万台设备组成的互联网。因特网使用TCP/IP协议让不同的设备可以彼此通信。但使用TCP/IP协议的网络并不一定是因特网，一个局域网也可以使用TCP/IP协议。判断自己是否接入的是因特网，首先是看自己电脑是否安装了 TCP/IP协议，其次看是否拥有一个公网地址（所谓公网地址，就是所有私网地址以外的地址）。<br>因特网是基于TCP/IP协议实现的，TCP/IP协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如FTP、SMTP、HTTP。只要应用层使用的是HTTP协议，就称为万维网（World Wide Web）。之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为您的个人浏览器和百度网的服务器之间使用的是HTTP协议在交流。</p><h4 id="7、网络预测"><a href="#7、网络预测" class="headerlink" title="7、网络预测"></a>7、网络预测</h4><p><strong>（1）语义网</strong><br>SirTim Berners-Lee（Web创始者）关于语义网的观点成为人们的重要关注已经很长一段时间了。事实上，它已经象大白鲸一样神乎其神了。总之，语义网关涉到机器之间的对话，它使得网络更加智能化，或者像Berners-Lee描述的那样，计算机“在网络中分析所有的数据—内容，链接以及人机之间的交易处理”。在另一个时候，Berners-Lee把它描述为“为数据设计的似网程序”，如对信息再利用的设计。<br>就象Alex在《通往语义网》中写道，语义网的核心是创建可以处理事物意义的元数据来描述数据，一旦电脑装备上语义网，它将能解决复杂的语义优化问题。<br>因此，什么时候语义网时代才会到来呢？创建语义网的组件已经出现：RDF，OWL，这些微格式只是众多组件之一.但是，Alex在他文章中指出，将需要一些时间来诠释世界的信息，然后再以某种合适的方式来捕获个人信息。一些公司，如Hakia，Powerset以及Alex自己的adaptive blue都正在积极的实现语义网，因此，未来我们将变得关系更亲密，但是我们还得等上好些年，才能看到语义网的设想实现。<br><strong>（2）人工智能</strong><br>人工智能可能会是计算机历史中的一个终极目标。从1950年，阿兰图灵提出的测试机器如人机对话能力的图灵测试开始，人工智能就成为计算机科学家们的梦想，<br>在接下来的网络发展中，人工智能使得机器更加智能化。在这个意义上来看，这和语义网在某些方面有些相同。<br>1997年5月，IBM公司研制的深蓝（DEEP BLUE）计算机战胜了国际象棋大师卡斯帕洛夫（KASPAROV）。大家或许不会注意到，在一些地方计算机帮助人进行其它原来只属于人类的工作，计算机以它的高速和准确为人类发挥着它的作用。人工智能始终是计算机科学的前沿学科，计算机编程语言和其它计算机软件都因为有了人工智能的进展而得以存在。相信以后人工智能会给人类的生活带来更大的改变，期待下一次的变革“智能时代”的到来！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、网络&quot;&gt;&lt;a href=&quot;#1、网络&quot; class=&quot;headerlink&quot; title=&quot;1、网络&quot;&gt;&lt;/a&gt;1、网络&lt;/h4&gt;&lt;p&gt;网络是由节点和连线构成，表示诸多对象及其相互联系。在数学上，网络是一种图，一般认为专指加权图。网络除了数学定义外，还有具体的物理含义，即网络是从某种相同类型的实际问题中抽象出来的模型。在计算机领域中，网络是信息传输、接收、共享的虚拟平台，通过它把各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络是人类发展史来最重要的发明，提高了科技和人类社会的发展。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统服务之端口（port）</title>
    <link href="http://yoursite.com/2018/01/15/Linux-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%AB%AF%E5%8F%A3%EF%BC%88port%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/15/Linux-系统服务之端口（port）/</id>
    <published>2018-01-15T07:50:37.000Z</published>
    <updated>2018-01-18T07:02:32.243Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、什么是-port-？"><a href="#1、什么是-port-？" class="headerlink" title="1、什么是 port ？"></a>1、什么是 port ？</h4><p>当你启动一个网络服务，这个服务会依据 TCP/IP 的相关通讯协议启动一个端口在进行监听，那就是 TCP/UDP 封包的 port (端口)了。我们知道网络联机是双向的，服务器端得要启动一个监听的端口，客户端得要随机启动一个端口来接收响应的数据才行。那么服务器端的服务是否需要启动在固定的端口？客户端的端口是否又是固定的呢？我们将与 port 有关的资料给她汇整一下，如下：<br><a id="more"></a></p><blockquote><p><strong>1、服务器端启动的监听端口所对应的服务是固定的：</strong><br>例如 WWW 服务开启在 port 80 ，FTP 服务开启在 port 21，email 传送开启在port 25 等等，都是通讯协议上面的规范！<br><strong>2、客户端启动程序时，随机启动一个大于 1024 以上的端口：</strong><br>客户端启动的 port 是随机产生的，主要是开启在大于 1024 以上的端口。这个 port 也是由某些软件所产生的，例如浏览器、Filezilla 这个 FTP 客户端程序等等。<br><strong>3、一部服务器可以同时提供多种服务：</strong><br>所谓的【监听】是某个服务程序会一直常驻在内存当中，所以该程序启动的 port 就会一直存在。只要服务器软件激活的端口不同，那就不会造成冲突。当客户端连接到此服务器时，透过不同的端口，就可以取得不同的服务数据。所以，一部主机上面当然可以同时启动很多不同的服务！<br><strong>4、共 65536 个 port：</strong><br>由 TCP/UDP 表头数据中，就知道 port 占用 16 个位，因此一般主机会有 65536 个 port，而这些 port 又分成两个部分，以 port 1024 作区隔：</p><ul><li>只有 root 才能启动的保留的 port：<br>在小于 1024 的端口，都是需要以 root 的身份才能启动的，这些 port 主要是用于一些常见的通讯服务，在 Linux 系统下，常见的协议与 port 的对应是记录在 /etc/services 里面的。</li><li>大于 1024 用于 client 端的 port：<br>在大于 1024 以上的 port 主要是作为 client 端的软件激活的 port。</li></ul><p><strong>5、是否需要三向交握：</strong><br>建立可靠的联机服务需要使用到 TCP 协议，也就需要所谓的三向交握了，如果是非面向连接的服务，例如 DNS 与视讯系统，那只要使用 UDP 协议即可。<br><strong>6、通讯协议可以启用在非正规的 port：</strong><br>我们知道浏览器默认会连接到 WWW 主机的 port 80，那么你的 WWW 是否可以启动在非 80 的其他端口？当然可以！你可以透过 WWW 软件的设定功能将该软件使用的 port 启动在非正规的端口，只是如此一来，您的客户端要连接到你的主机时，就得要在浏览器的地方额外指定你所启用的非正规的端口才行。这个启动在非正规的端口功能，常常被用在一些所谓的地下网站！另外，某些软件默认就启动在大于 1024 以上的端口，如 MySQL 数据库软件就启动在 3306。<br><strong>7、所谓的 port 的安全性：</strong><br>事实上，没有所谓的 port 的安全性！因为【Port 的启用是由服务软件所造成的】，也就是说，真正影响网络安全的并不是 port ，而是启动 port 的那个软件 (程序)！或许你偶而会听到：【没有修补过漏洞的 bind 8.x 版，很容易被黑客所入侵，请尽快升级到 bind 9.x 以后版本】，所以，对安全真正有危害的是【某些不安全的服务】而不是【开了哪些 port 】才是！因此，没有必要的服务就将他关闭吧！尤其某些网络服务还会启动一些 port ！另外，那些已启动的软件也需要持续的保持更新！</p></blockquote><p>附属：一些系统必备的软件服务说明</p><table><thead><tr><th>服务名称</th><th>服务内容</th></tr></thead><tbody><tr><td>acpid</td><td>新版的电源管理模块，通常建议开启，不过，某些笔记本电脑可能不支持此项服务，那就得关闭</td></tr><tr><td>atd</td><td>在管理单一预约命令执行的服务，应该要启动的</td></tr><tr><td>crond</td><td>在管理工作排程的重要服务，请务必要启动啊！</td></tr><tr><td>haldaemon</td><td>作系统硬件变更侦测的服务，与 USB 设备关系很大</td></tr><tr><td>iptables</td><td>Linux 内建的防火墙软件，这个也可以启动！</td></tr><tr><td>network</td><td>这个重要了吧？要网络就要有他啊！</td></tr><tr><td>postfix</td><td>系统内部邮件传递服务，不要随便关闭他！</td></tr><tr><td>rsyslog</td><td>系统的登录文件记录，很重要的，务必启动啊！</td></tr><tr><td>sshd</td><td>这是系统默认会启动的，可以让你在远程以文字型态的终端机登入！</td></tr><tr><td>xinetd</td><td>就是那个 super daemon ！所以也要启动！</td></tr></tbody></table><p>上面列出的是主机需要的重点服务，请您不要关闭他！除非你知道作了之后会有什么后果。举例来说，你如果不需要管理电源，那么将 acpid 关闭也没有关系啊！如果你不需要提供远程联机功能，那么 sshd 也可以关闭啊！那其他你不知道的服务怎办？没关系，只要不是网络服务，你都可以保留他！如果是网络服务呢？那…建议你不知道的服务就先关闭他！</p><h4 id="2、端口的观察：netstat-nmap"><a href="#2、端口的观察：netstat-nmap" class="headerlink" title="2、端口的观察：netstat, nmap"></a>2、端口的观察：netstat, nmap</h4><p>现在，我们知道 port 是什么东西了，再来就是要来了解一下，我们的主机到底是开了多少的 port 呢？由于 port 的启动与服务有关，那么【服务】跟【 port 】对应的档案是哪一个？是【 /etc/services 】！而常用来观察 port 的则有底下两个程序：</p><ul><li>1.netstat：在本机上面以自己的程序监测自己的 port；</li><li>2.nmap：透过网络的侦测软件辅助，可侦测非本机上的其他网络主机，但有违法之虞（此处略过）。<br><em>（注：为什么使用nmap会违法？由于 nmap 的功能太强大了，所以很多 cracker 会直接以他来侦测别人的主机，这个时候就可能造成违法）</em></li></ul><p>底下我们来说一说 netstat 命令：<br>在做为服务器的 Linux 系统中，开启的网络服务越少越好！因为较少的服务可以较容易除错 (debug) 与了解安全漏洞，并可避免不必要的入侵管道！所以，这个时候请了解一下您的系统当中有没有哪些服务被开启了呢？要了解自己的系统当中的服务项目，最简便的方法就是使用 netstat ！这个东西不但简单，而且功能也是很不错的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">基本语法：</span><br><span class="line">[root@www ~]# netstat -[rn] &lt;==与路由有关的参数</span><br><span class="line">[root@www ~]# netstat -[antulpc] &lt;==与网络接口有关的参数</span><br><span class="line">选项与参数：</span><br><span class="line">与路由 (route) 有关的参数说明：</span><br><span class="line">    -r ：列出路由表(route table)，功能如同 route 这个指令；</span><br><span class="line">    -n ：不使用主机名与服务名称，使用 IP 与 port number ，如同 route -n与网络接口有关的参数：</span><br><span class="line">    -a ：列出所有的联机状态，包括 tcp/udp/unix socket 等；</span><br><span class="line">    -t ：仅列出 TCP 封包的联机；</span><br><span class="line">    -u ：仅列出 UDP 封包的联机；</span><br><span class="line">    -l ：仅列出有在 Listen (监听) 的服务之网络状态；</span><br><span class="line">    -p ：列出 PID 与 Program 的檔名；</span><br><span class="line">    -c ：可以设定几秒钟后自动更新一次，例如 -c 5 每五秒更新一次网络状态的显示；</span><br><span class="line">    （netstat -rn 与 route -n 是相同的。）</span><br></pre></td></tr></table></figure></p><blockquote><p>我们先来谈一谈关于网络联机状态的输出部分，他主要是分为底下几个大项：<br><strong>Proto：</strong>该联机的封包协议，主要为 TCP/UDP 等封包；<br><strong>Recv-Q：</strong>非由用户程序连接所复制而来的总 bytes 数；<br><strong>Send-Q：</strong>由远程主机所传送而来，但不具有 ACK 标志的总 bytes 数，意指主动联机 SYN 或其他标志的封包所占的 bytes 数；<br><strong>Local Address：</strong>本地端的地址，可以是 IP (-n 参数存在时)，也可以是完整的主机名。使用的格是就是『 IP:port 』只是 IP 的格式有 IPv4 及 IPv6 的差异。 如上所示，在 port 22 的接口中，使用的 :::22 就是针对 IPv6 的显示，事实上他就相同于 0.0.0.0:22 的意思。至于 port 25 仅针对 lo 接口开放，意指 Internet 基本上是无法连接到我本机的 25 埠口啦！<br><strong>Foreign Address：</strong>远程的主机 IP 与 port number<br><strong>stat：</strong>状态栏，主要的状态含有：</p><ul><li>ESTABLISED：已建立联机的状态；</li><li>SYN_SENT：发出主动联机 (SYN 标志) 的联机封包；</li><li>SYN_RECV：接收到一个要求联机的主动联机封包；</li><li>FIN_WAIT1：该插槽服务(socket)已中断，该联机正在断线当中；</li><li>FIN_WAIT2：该联机已挂断，但正在等待对方主机响应断线确认的封包；</li><li>TIME_WAIT：该联机已挂断，但 socket 还在网络上等待结束；</li><li>LISTEN：通常用在服务的监听 port ！可使用【 -l 】参数查阅。</li></ul></blockquote><p>基本上，我们常常谈到的 netstat 的功能，就是在观察网络的联机状态了，而网络联机状态中，又以观察【我目前开了多少的 port 在等待客户端的联机】以及 【目前我的网络联机状态中，有多少联机已建立或产生问题】最常见。<br>示例：<br><strong>1.列出在监听的网络服务：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# netstat -tunl</span><br><span class="line">ctive Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State</span><br><span class="line">tcp 0 0 0.0.0.0:111 0.0.0.0:* LISTEN</span><br><span class="line">tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN</span><br><span class="line">tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN</span><br><span class="line">....(底下省略)....</span><br></pre></td></tr></table></figure></p><p>上面说明了我的主机至少有启动 port 111, 22, 25 等，而且观察各联机接口，可发现 25 为 TCP 端口，但只针对 lo 内部循环测试网络提供服务，因特网是连不到该端口的。至于 port 22 则有提供因特网的联机功能。</p><p><strong>2.列出已联机的网络联机状态：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# netstat -tun</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State</span><br><span class="line">tcp 0 52 192.168.1.100:22 192.168.1.101:2162 ESTABLISHED</span><br></pre></td></tr></table></figure></p><p>从上面的数据来看，我的本地端服务器 (Local Address, 192.168.1.100) 目前仅有一条已建立的联机，那就是与 192.168.1.101 那部主机连接的联机，并且联机方向是由对方连接到我主机的 port 22 来取用我服务器的服务！</p><p><strong>3.删除已建立或在监听当中的联机：</strong><br>如果想要将已经建立，或者是正在监听当中的网络服务关闭的话，最简单的方法当然就是找出该联机的 PID，然后将他 kill 掉即可！例如下面的范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# netstat -tunp</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State PID/P name</span><br><span class="line">tcp 0 52 192.168.1.100:22 192.168.1.101:2162 ESTABLISHED 1342/0</span><br></pre></td></tr></table></figure></p><p>如上面的范例，我们可以找出来该联机是由 sshd 这个程序来启用的，并且他的 PID 是 1342，希望你不要心急的用 killall 这个指令，否则容易删错人 (因为你的主机里面可能会有多个 sshd 存在)，应该要使用 kill 这个指令才对！<br><code>[root@www ~]# kill -9 1342</code></p><h4 id="3、端口与服务的启动-关闭及开机时状态设定"><a href="#3、端口与服务的启动-关闭及开机时状态设定" class="headerlink" title="3、端口与服务的启动/关闭及开机时状态设定"></a>3、端口与服务的启动/关闭及开机时状态设定</h4><p>其实 port 是由执行某些软件之后被软件激活的。所以要关闭某些 port 时，那就直接将某个程序给他关闭就是了！关闭的方法你当然可以使用 kill，不过这毕竟不是正统的解决之道，因为 kill 这个指令通常具有强制关闭某些程序的功能，但我们想要正常的关闭该程序！所以，就利用系统给我们的 script 来关闭就好了。一般传统的服务有哪几种类型？</p><p><strong>stand alone 与 super daemon</strong><br>    在一般正常的 Linux 系统环境下，服务的启动与管理主要有两种方式：</p><ol><li>Stand alone<br>顾名思义，stand alone 就是直接执行该服务的执行档，让该执行文件直接加载到内存当中运作，用这种方式来启动可以让该服务具有较快速响应的优点。一般来说，这种服务的启动 script 都会放置到 /etc/init.d/ 这个目录底下，所以你通常可以使用：【 /etc/init.d/sshd restart 】之类的方式来重新启动这种服务；</li><li>Super daemon<br>用一个超级服务作为总管，来统一管理某些特殊的服务。在 CentOS 6.x 里面使用的则是 xinetd 这个 super daemon ！这种方式启动的网络服务虽然在响应上速度会比较慢，不过，可以透过 super daemon 额外提供一些控管，例如控制何时启动、何时可以进行联机、那个 IP 可以连进来、是否允许同时联机等等。通常个别服务的配置文件放置在 /etc/xinetd.d/ 当中，但设定完毕后需要重新以【 /etc/init.d/xinetd restart 】重新来启动才行！</li></ol><blockquote><p>例题：<br>我们知道系统的 Telnet 服务通常是以 super daemon 来控管的，请您启动您系统的 telnet 试看看。<br>答：<br>1、要启动 telnet 首先必须要已经安装了 telnet 的服务器才行，所以请先以 rpm 查询看看是否有安装 telnet-server 呢？【rpm -qa | grep telnet-server】如果没有安装的话，请利用原版光盘来安装，或者使用【yum install telnet-server】安装一下先；<br>2、由于是 super daemon 控管，所以请编辑 /etc/xinetd.d/telnet 这个档案，将其中的【disable = yes】改成【disable = no】之后以【/etc/init.d/xinetd restart】重新启动 super daemon 吧！<br>3、利用 netstat -tnlp 察看是否有启动 port 23 呢？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、什么是-port-？&quot;&gt;&lt;a href=&quot;#1、什么是-port-？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是 port ？&quot;&gt;&lt;/a&gt;1、什么是 port ？&lt;/h4&gt;&lt;p&gt;当你启动一个网络服务，这个服务会依据 TCP/IP 的相关通讯协议启动一个端口在进行监听，那就是 TCP/UDP 封包的 port (端口)了。我们知道网络联机是双向的，服务器端得要启动一个监听的端口，客户端得要随机启动一个端口来接收响应的数据才行。那么服务器端的服务是否需要启动在固定的端口？客户端的端口是否又是固定的呢？我们将与 port 有关的资料给她汇整一下，如下：&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用网络指令</title>
    <link href="http://yoursite.com/2018/01/12/Linux-%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/01/12/Linux-常用网络指令/</id>
    <published>2018-01-12T09:41:44.000Z</published>
    <updated>2018-01-18T07:02:19.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、网络参数设定使用的指令"><a href="#一、网络参数设定使用的指令" class="headerlink" title="一、网络参数设定使用的指令"></a>一、网络参数设定使用的指令</h3><p><strong>ifconfig ：</strong>查询、设定网络卡与 IP 网域等相关参数；<br><strong>ifup, ifdown：</strong>这两个档案是 script，透过更简单的方式来启动网络接口；<br><strong>route ：</strong>查询、设定路由表 (route table)<br><strong>ip ：</strong>复合式的指令，可以直接修改上述提到的功能；<br><em>（先会使用 ifconfig, ifup , ifdown 与 route 即可，等以后有经验了之后，再继续回来玩 ip 这个好玩的指令。）</em><br><a id="more"></a></p><h4 id="1、手动-自动设定与启动-关闭-IP-参数：-ifconfig-ifup-ifdown"><a href="#1、手动-自动设定与启动-关闭-IP-参数：-ifconfig-ifup-ifdown" class="headerlink" title="1、手动/自动设定与启动/关闭 IP 参数： ifconfig, ifup, ifdown"></a>1、手动/自动设定与启动/关闭 IP 参数： ifconfig, ifup, ifdown</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法如下：</span><br><span class="line">[root@www ~]# ifconfig &#123;interface&#125; &#123;up|down&#125; &lt;== 观察与启动接口</span><br><span class="line">[root@www ~]# ifconfig interface &#123;options&#125; &lt;== 设定与修改接口</span><br><span class="line">选项与参数：</span><br><span class="line">interface：网络卡接口代号，包括 eth0, eth1, ppp0 等等</span><br><span class="line">options ：可以接的参数，包括如下：</span><br><span class="line">    up, down ：启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)</span><br><span class="line">    mtu ：可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)</span><br><span class="line">    netmask ：就是子屏蔽网络；</span><br><span class="line">    broadcast：就是广播地址啊！</span><br></pre></td></tr></table></figure><p><strong>范例一：观察所有的网络接口(直接输入 ifconfig)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr FA:16:3E:C9:BF:42  </span><br><span class="line">          inet addr:10.99.192.224  Bcast:10.99.192.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:671391959 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:629925596 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:202240418477 (188.3 GiB)  TX bytes:161760425688 (150.6 GiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:19514029692 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:19514029692 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:4097035202575 (3.7 TiB)  TX bytes:4097035202575 (3.7 TiB)</span><br></pre></td></tr></table></figure></p><blockquote><p>至于上表出现的各项数据是这样的(数据排列由上而下、由左而右)：<br><strong>eth0：</strong>就是网络卡的代号，也有 lo 这个 loopback ；<br><strong>HWaddr：</strong>就是网络卡的硬件地址，俗称的 MAC 是也；<br><strong>inet addr：</strong>IPv4 的 IP 地址，后续的 Bcast, Mask 分别代表的是 Broadcast 与 netmask！<br><strong>inet6 addr：</strong>是 IPv6 的版本的 IP ，我们没有使用，所以略过；<br><strong>MTU：</strong>最大传输单位<br><strong>RX：</strong>那一行代表的是网络由启动到目前为止的封包接收情况，packets 代表封包数、errors 代表封包发生错误的数量、dropped 代表封包由于有问题而遭丢弃的数量等等<br><strong>TX：</strong>与 RX 相反，为网络由启动到目前为止的传送情况；<br><strong>collisions：</strong>代表封包碰撞的情况，如果发生太多次，表示你的网络状况不太好；<br><strong>txqueuelen：</strong>代表用来传输数据的缓冲区的储存长度；<br><strong>RX bytes, TX bytes：</strong>总接收、发送字节总量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifup/ifdown 语法如下：</span><br><span class="line">[root@www ~]# ifup &#123;interface&#125;</span><br></pre></td></tr></table></figure><h4 id="2、路由修改：-route"><a href="#2、路由修改：-route" class="headerlink" title="2、路由修改： route"></a>2、路由修改： route</h4><p>主机之间一定要有路由才能够互通 TCP/IP 的协议，否则就无法进行联机啊！一般来说，只要有网络接口，该接口就会产生一个路由，所以我们安装的主机有一个 eth0 的接口，看起来就会是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# route [-nee]</span><br><span class="line">[root@www ~]# route add [-net|-host] [网域或主机] netmask [mask] [gw|dev]</span><br><span class="line">[root@www ~]# route del [-net|-host] [网域或主机] netmask [mask] [gw|dev]</span><br><span class="line">观察的参数：</span><br><span class="line">    -n ：不要使用通讯协议或主机名，直接使用 IP 或 port number；</span><br><span class="line">    -ee ：使用更详细的信息来显示</span><br><span class="line">增加 (add) 与删除 (del) 路由的相关参数：</span><br><span class="line">    -net ：表示后面接的路由为一个网域；</span><br><span class="line">    -host ：表示后面接的为连接到单部主机的路由；</span><br><span class="line">    netmask ：与网域有关，可以设定 netmask 决定网域的大小；</span><br><span class="line">    gw ：gateway 的简写，后续接的是 IP 的数值，与 dev 不同；</span><br><span class="line">    dev ：如果只是要指定由那一块网络卡联机出去，则使用这个设定，后面接 eth0 等</span><br></pre></td></tr></table></figure></p><p><strong>范例一：单纯的观察路由状态</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.99.192.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line">0.0.0.0         10.99.192.1     0.0.0.0         UG    0      0        0 eth0</span><br></pre></td></tr></table></figure></p><blockquote><p>上面的信息需要知道的一些参数含义：<br><strong>Destination, Genmask：</strong>这两个玩意儿就是分别是 network 与 netmask ！所以这两个咚咚就组合成为一个完整的网域！<br><strong>Gateway：</strong>该网域是通过哪个 gateway 连接出去的？如果显示 0.0.0.0 表示该路由是直接由本机传送，亦即可以透过局域网络的 MAC 直接传讯；如果有显示 IP 的话，表示该路由需要经过路由器 (通讯闸) 的帮忙才能够传送出去。<br><strong>Flags：</strong>总共有多个旗标，代表的意义如下：<br>    U (route is up)：该路由是启动的；<br>    H (target is a host)：目标是一部主机 (IP) 而非网域；<br>    G (use gateway)：需要透过外部的主机 (gateway) 来转递封包；<br>    R (reinstate route for dynamic routing)：使用动态路由时，恢复路由信息的旗标；<br>    D (dynamically installed by daemon or redirect)：已经由服务或转 port 功能设定为动态路由<br>    M (modified from routing daemon or redirect)：路由已经被修改了；<br>    ! (reject route)：这个路由将不会被接受(用来抵挡不安全的网域！)<br><strong>Iface：</strong>这个路由传递封包的接口。</p></blockquote><h4 id="3、网络参数综合指令：-ip"><a href="#3、网络参数综合指令：-ip" class="headerlink" title="3、网络参数综合指令： ip"></a>3、网络参数综合指令： ip</h4><p>他就是整合了 ifconfig 与 route 这两个指令。ifup 就是利用 ip 这个指令来达成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ip [option] [动作] [指令]</span><br><span class="line">选项与参数：</span><br><span class="line">option ：设定的参数，主要有：</span><br><span class="line">    -s ：显示出该装置的统计数据(statistics)，例如总接受封包数等；</span><br><span class="line">动作：亦即是可以针对哪些网络参数进行动作，包括有：</span><br><span class="line">    link ：关于装置 (device) 的相关设定，包括 MTU, MAC 地址等等</span><br><span class="line">    addr/address ：关于额外的 IP 协议，例如多 IP 的达成等等；</span><br><span class="line">    route ：与路由有关的相关设定</span><br></pre></td></tr></table></figure></p><p>由上面的语法我们可以知道， ip 除了可以设定一些基本的网络参数之外，还能够进行额外的 IP 协议，包括多 IP 的达成，真是太完美了！底下我们就分三个部分 (link,addr, route) 来介绍这个 ip 指令吧！</p><p><strong>（1）关于装置接口 (device) 的相关设定： ip link</strong><br>ip link 可以设定与装置 (device) 有关的相关参数，包括 MTU 以及该网络接口的 MAC 等等，当然也可以启动 (up) 或关闭 (down) 某个网络接口啦！整个语法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ip [-s] link show &lt;== 单纯的查阅该装置相关的信息</span><br><span class="line">[root@www ~]# ip link set [device] [动作与参数]</span><br><span class="line">选项与参数：</span><br><span class="line">show：仅显示出这个装置的相关内容，如果加上 -s 会显示更多统计数据；</span><br><span class="line">set ：可以开始设定项目， device 指的是 eth0, eth1 等等界面代号；</span><br><span class="line">动作与参数：包括有底下的这些动作：</span><br><span class="line">up|down ：启动 (up) 或关闭 (down) 某个接口，其他参数使用默认的以太网络；</span><br><span class="line">address ：如果这个装置可以更改 MAC 的话，用这个参数修改！</span><br><span class="line">name ：给予这个装置一个特殊的名字；</span><br><span class="line">mtu ：就是最大传输单元啊！</span><br><span class="line">（使用 ip link show 可以显示出整个装置接口的硬件相关信息，如上所示，包括网卡地址(MAC)、MTU 等等）</span><br></pre></td></tr></table></figure></p><p><strong>（2）关于额外的 IP 相关设定： ip address</strong><br>如果说 ip link 是与 OSI 七层协定 的第二层资料连阶层有关的话，那么 ip address (ip addr) 就是与第三层网络层有关的参数啦！ 主要是在设定与 IP 有关的各项参数，包括 netmask, broadcast 等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ip address show &lt;==就是查阅 IP 参数啊！</span><br><span class="line">[root@www ~]# ip address [add|del] [IP 参数] [dev 装置名] [相关参数]</span><br><span class="line">选项与参数：</span><br><span class="line">show ：单纯的显示出接口的 IP 信息啊；</span><br><span class="line">add|del ：进行相关参数的增加 (add) 或删除 (del) 设定，主要有：</span><br><span class="line">IP 参数：主要就是网域的设定，例如 192.168.100.100/24 之类的设定；</span><br><span class="line">dev ：这个 IP 参数所要设定的接口，例如 eth0, eth1 等等；</span><br><span class="line">相关参数：主要有底下这些：</span><br><span class="line">    broadcast：设定广播地址，如果设定值是 + 表示『让系统自动计算』</span><br><span class="line">    label ：亦即是这个装置的别名，例如 eth0:0 就是了！</span><br><span class="line">    scope ：这个界面的领域，通常是这几个大类：</span><br><span class="line">    global ：允许来自所有来源的联机；</span><br><span class="line">    site ：仅支持 IPv6 ，仅允许本主机的联机；</span><br><span class="line">    link ：仅允许本装置自我联机；</span><br><span class="line">    host ：仅允许本主机内部的联机；</span><br><span class="line">    所以当然是使用 global ！预设也是 global ！</span><br></pre></td></tr></table></figure></p><p><strong>（3）关于路由的相关设定： ip route</strong><br>这个项目当然就是路由的观察与设定啰！事实上， ip route 的功能几乎与 route 这个指令差不多，但是，他还可以进行额外的参数设计，例如 MTU 的规划等等，相当的强悍啊！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ip route show &lt;==单纯的显示出路由的设定而已</span><br><span class="line">[root@www ~]# ip route [add|del] [IP 或网域] [via gateway] [dev 装置]</span><br><span class="line">选项与参数：</span><br><span class="line">show ：单纯的显示出路由表，也可以使用 list ；</span><br><span class="line">add|del ：增加 (add) 或删除 (del) 路由的意思。</span><br><span class="line">IP 或网域：可使用 192.168.50.0/24 之类的网域或者是单纯的 IP ；</span><br><span class="line">via ：从那个 gateway 出去，不一定需要；</span><br><span class="line">dev ：由那个装置连出去，这就需要了！</span><br><span class="line">mtu ：可以额外的设定 MTU 的数值喔！</span><br></pre></td></tr></table></figure></p><h3 id="二、网络侦错与观察指令"><a href="#二、网络侦错与观察指令" class="headerlink" title="二、网络侦错与观察指令"></a>二、网络侦错与观察指令</h3><h4 id="1、两部主机两点沟通：-ping"><a href="#1、两部主机两点沟通：-ping" class="headerlink" title="1、两部主机两点沟通： ping"></a>1、两部主机两点沟通： ping</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ping [选项与参数] IP</span><br><span class="line">选项与参数：</span><br><span class="line">-c 数值：后面接的是执行 ping 的次数，例如 -c 5 ；</span><br><span class="line">-n ：在输出数据时不进行 IP 与主机名的反查，直接使用 IP 输出(速度较快)；</span><br><span class="line">-s 数值：发送出去的 ICMP 封包大小，预设为 56bytes，不过你可以放大此一数值；</span><br><span class="line">-t 数值：TTL 的数值，预设是 255，每经过一个节点就会少一；</span><br><span class="line">-W 数值：等待响应对方主机的秒数。</span><br><span class="line">-M [do|dont] ：主要在侦测网络的 MTU 数值大小，两个常见的项目是：</span><br><span class="line">    do ：代表传送一个 DF (Don&apos;t Fragment) 旗标，让封包不能重新拆包与打包；</span><br><span class="line">    dont：代表不要传送 DF 旗标，表示封包可以在其他主机上拆包与打包</span><br></pre></td></tr></table></figure><p><strong>范例一：侦测一下 172.24.170.43 这部 DNS 主机是否存在？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ping -c 3 172.24.170.43</span><br><span class="line">PING 172.24.170.43 (172.24.170.43) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.24.170.43: icmp_seq=0 ttl=118 time=3.59 ms</span><br><span class="line">64 bytes from 172.24.170.43: icmp_seq=1 ttl=118 time=4.41 ms</span><br><span class="line">64 bytes from 172.24.170.43: icmp_seq=2 ttl=118 time=2.48 ms</span><br><span class="line"></span><br><span class="line">--- 172.24.170.43 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</span><br><span class="line">rtt min/avg/max/mdev = 2.485/3.495/4.411/0.792 ms, pipe 2</span><br></pre></td></tr></table></figure></p><blockquote><p>ping 最简单的功能就是传送 ICMP 封包去要求对方主机回应是否存在于网络环境中，上面的响应消息当中，几个重要的项目是这样的：<br><strong>64 bytes：</strong>表示这次传送的 ICMP 封包大小为 64 bytes 这么大，这是默认值，在某些特殊场合中，例如要搜索整个网络内最大的 MTU 时，可以使用 -s 2000 之类的数值来取代；<br><strong>icmp_seq=0：</strong>ICMP 所侦测进行的次数，第一次编号为 0 ；<br><strong>ttl=118：</strong>TTL 与 IP 封包内的 TTL 是相同的，每经过一个带有 MAC 的节点 (node) 时，例如 router, bridge 时， TTL 就会减少一，预设的 TTL 为 255 ，你可以透过 -t 150 之类的方法来重新设定预设 TTL 数值；<br><strong>time=3.59 ms：</strong>响应时间，单位有 ms(0.001 秒)及 us(0.000001 秒)，一般来说，越小的响应时间，表示两部主机之间的网络联机越良好！<br><strong>（注：如果你忘记加上 -c 3 这样的规定侦测次数，那就得要使用 [ctrl]-c 将他结束掉了！）</strong></p></blockquote><p><strong>用 ping 追踪路径中的最大 MTU 数值</strong><br>现在我们知道网络卡的 MTU 修改可以透过 ifconfig 或者是 ip 等指令来达成，那么追踪整个网络传输的最大 MTU 时，又该如何查询？最简单的方法当然是透过 ping 传送一个大封包， 并且不许中继的路由器或 switch 将该封包重组，那就能够处理啦！没错！可以这样的：<br><strong>范例二：找出最大的 MTU 数值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ping -c 2 -s 1000 -M do 172.24.170.43</span><br><span class="line">PING 172.24.170.43 (172.24.170.43) 1000(1028) bytes of data.</span><br><span class="line">1008 bytes from 172.24.170.43: icmp_seq=0 ttl=118 time=2.28 ms</span><br><span class="line">1008 bytes from 172.24.170.43: icmp_seq=1 ttl=118 time=3.40 ms</span><br><span class="line"></span><br><span class="line">--- 172.24.170.43 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 2.281/2.843/3.406/0.565 ms, pipe 2</span><br><span class="line"># 如果有响应，那就是可以接受这个封包，如果无响应，那就表示这个 MTU 太大了。</span><br><span class="line">[root@www ~]# ping -c 2 -s 8000 -M do 172.24.170.43</span><br><span class="line">PING 172.24.170.43 (172.24.170.43) 8000(8028) bytes of data.</span><br><span class="line">From 10.99.192.224 icmp_seq=0 Frag needed and DF set (mtu = 1500)</span><br><span class="line">From 10.99.192.224 icmp_seq=0 Frag needed and DF set (mtu = 1500)</span><br><span class="line"></span><br><span class="line">--- 172.24.170.43 ping statistics ---</span><br><span class="line">0 packets transmitted, 0 received, +2 errors</span><br><span class="line"># 这个错误讯息是说，本地端的 MTU 才到 1500 而已，你要侦测 8000 的 MTU</span><br><span class="line"># 根本就是无法达成的！那要如何是好？用前一小节介绍的 ip link 来进行MTU 设定吧！</span><br></pre></td></tr></table></figure></p><p>不过，你需要知道的是，由于 IP 封包表头 (不含 options) 就已经占用了 20bytes ，再加上 ICMP 的表头有 8 bytes ，所以当然你在使用 -s size 的时候，那个封包的大小就得要先扣除 (20+8=28) 的大小了。 因此如果要使用 MTU 为 1500 时，就得要下达【 ping -s 1472 -M do xx.yy.zz.ip 】才行啊！</p><p>另外，由于本地端的网络卡 MTU 也会影响到侦测，所以如果想要侦测整个传输媒体的 MTU 数值，那么每个可以调整的主机就得要先使用 ifcofig 或 ip 先将 MTU 调大，然后再去进行侦测， 否则就会出现像上面提供的案例一样，可能会出现错误讯息的！</p><p>如果是要连上 Internet 的主机，注意不要随便调整 MTU ，因为我们无法知道 Internet 上面的每部机器能够支持的 MTU 到多大，因为……不是我们能够管的到的。</p><h4 id="2、两主机间各节点分析：-traceroute"><a href="#2、两主机间各节点分析：-traceroute" class="headerlink" title="2、两主机间各节点分析： traceroute"></a>2、两主机间各节点分析： traceroute</h4><p>我们前面谈到的指令大多数都是针对主机的网络参数设定所需要的，而 ping 是两部主机之间的回声与否判断， 那么有没有指令可以追踪两部主机之间通过的各个节点(node) 通讯状况的好坏呢？举例来说，如果我们联机到 yahoo 的速度比平常慢，你觉得是 (1)自己的网络环境有问题？ (2)还是外部的 Internet 有问题？如果是 (1)的话，我们当然需要检查自己的网络环境啊，看看是否又有谁中毒了？但如果是 Internet的问题呢？那只有『等等等』啊！ 判断是 (1) 还是 (2) 就得要使用 traceroute 这个指令！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# traceroute [选项与参数] IP</span><br><span class="line">选项与参数：</span><br><span class="line">-n ：可以不必进行主机的名称解析，单纯用 IP ，速度较快！</span><br><span class="line">-U ：使用 UDP 的 port 33434 来进行侦测，这是预设的侦测协议；</span><br><span class="line">-I ：使用 ICMP 的方式来进行侦测；</span><br><span class="line">-T ：使用 TCP 来进行侦测，一般使用 port 80 测试</span><br><span class="line">-w ：若对方主机在几秒钟内没有回声就宣告不治...预设是 5 秒</span><br><span class="line">-p 端号：若不想使用 UDP 与 TCP 的预设埠号来侦测，可在此改变埠号。</span><br><span class="line">-i 装置：用在比较复杂的环境，如果你的网络接口很多很复杂时，才会用到这个参数；</span><br><span class="line">    举例来说，你有两条 ADSL 可以连接到外部，那你的主机会有两个ppp，</span><br><span class="line">    你可以使用 -i 来选择是 ppp0 还是 ppp1 </span><br><span class="line">-g 路由：与 -i 的参数相仿，只是 -g 后面接的是 gateway 的 IP 就是了。</span><br></pre></td></tr></table></figure></p><p><strong>范例一：侦测本机到 yahoo 去的各节点联机状态</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# traceroute -n tw.yahoo.com</span><br><span class="line">traceroute to tw.yahoo.com (119.160.246.241), 30 hops max, 40 byte</span><br><span class="line">packets</span><br><span class="line">1 192.168.1.254 0.279 ms 0.156 ms 0.169 ms</span><br><span class="line">2 172.20.168.254 0.430 ms 0.513 ms 0.409 ms</span><br><span class="line">3 10.40.1.1 0.996 ms 0.890 ms 1.042 ms</span><br><span class="line">4 203.72.191.85 0.942 ms 0.969 ms 0.951 ms</span><br><span class="line">5 211.20.206.58 1.360 ms 1.379 ms 1.355 ms</span><br><span class="line">6 203.75.72.90 1.123 ms 0.988 ms 1.086 ms</span><br><span class="line">7 220.128.24.22 11.238 ms 11.179 ms 11.128 ms</span><br><span class="line">8 220.128.1.82 12.456 ms 12.327 ms 12.221 ms</span><br><span class="line">9 220.128.3.149 8.062 ms 8.058 ms 7.990 ms</span><br><span class="line">10 * * *</span><br><span class="line">11 119.160.240.1 10.688 ms 10.590 ms 119.160.240.3 10.047 ms</span><br><span class="line">12 * * * &lt;==可能有防火墙装置等情况发生所致</span><br></pre></td></tr></table></figure></p><p>这个 traceroute 挺有意思的，这个指令会针对欲连接的目的地之所有 node 进行 UDP 的逾时等待，例如上面的例子当中，由鸟哥的主机连接到 Yahoo 时，他会经过 12 个节点以上，traceroute 会主动的对这 12 个节点做 UDP 的回声等待，并侦测回复的时间，每节点侦测三次，最终回传像上头显示的结果。 你可以发现每个节点其实回复的时间大约在 50 ms 以内，算是还可以的 Internet 环境了。</p><p>比较特殊的算是第 10/12 个，会回传星号的，代表该 node 可能设有某些防护措施，让我们发送的封包信息被丢弃所致。 因为我们是直接透过路由器转递封包，并没有进入路由器去取得路由器的使用资源，所以某些路由器仅支持封包转递，并不会接受来自客户端的各项侦测啦！此时就会出现上述的问题。</p><h4 id="3、察看本机的网络联机与后门：-netstat"><a href="#3、察看本机的网络联机与后门：-netstat" class="headerlink" title="3、察看本机的网络联机与后门： netstat"></a>3、察看本机的网络联机与后门： netstat</h4><p>如果你觉得你的某个网络服务明明就启动了，但是就是无法造成联机的话，那么应该怎么办？首先你应该要查询一下自己的网络接口所监听的端口 (port) 来看看是否真的有启动，因为有时候屏幕上面显示的 [OK] 并不一定是 OK 啊！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# netstat -[rn] &lt;==与路由有关的参数</span><br><span class="line">[root@www ~]# netstat -[antulpc] &lt;==与网络接口有关的参数</span><br><span class="line">选项与参数：</span><br><span class="line">与路由 (route) 有关的参数说明：</span><br><span class="line">-r ：列出路由表(route table)，功能如同 route 这个指令；</span><br><span class="line">-n ：不使用主机名与服务名称，使用 IP 与 port number ，如同 route -n</span><br><span class="line">与网络接口有关的参数：</span><br><span class="line">-a ：列出所有的联机状态，包括 tcp/udp/unix socket 等；</span><br><span class="line">-t ：仅列出 TCP 封包的联机；</span><br><span class="line">-u ：仅列出 UDP 封包的联机；</span><br><span class="line">-l ：仅列出有在 Listen (监听) 的服务之网络状态；</span><br><span class="line">-p ：列出 PID 与 Program 的檔名；</span><br><span class="line">-c ：可以设定几秒钟后自动更新一次，例如 -c 5 每五秒更新一次网络状态的显示；</span><br><span class="line">（netstat -rn 与 route -n 是相同的。）</span><br></pre></td></tr></table></figure></p><blockquote><p>我们先来谈一谈关于网络联机状态的输出部分，他主要是分为底下几个大项：<br><strong>Proto：</strong>该联机的封包协议，主要为 TCP/UDP 等封包；<br><strong>Recv-Q：</strong>非由用户程序连接所复制而来的总 bytes 数；<br><strong>Send-Q：</strong>由远程主机所传送而来，但不具有 ACK 标志的总 bytes 数，意指主动联机 SYN 或其他标志的封包所占的 bytes 数；<br><strong>Local Address：</strong>本地端的地址，可以是 IP (-n 参数存在时)，也可以是完整的主机名。使用的格是就是『 IP:port 』只是 IP 的格式有 IPv4 及 IPv6 的差异。 如上所示，在 port 22 的接口中，使用的 :::22 就是针对 IPv6 的显示，事实上他就相同于 0.0.0.0:22 的意思。至于 port 25 仅针对 lo 接口开放，意指 Internet 基本上是无法连接到我本机的 25 埠口啦！<br><strong>Foreign Address：</strong>远程的主机 IP 与 port number<br><strong>stat：</strong>状态栏，主要的状态含有：<br>      ESTABLISED：已建立联机的状态；<br>      SYN_SENT：发出主动联机 (SYN 标志) 的联机封包；<br>      SYN_RECV：接收到一个要求联机的主动联机封包；<br>      FIN_WAIT1：该插槽服务(socket)已中断，该联机正在断线当中；<br>      FIN_WAIT2：该联机已挂断，但正在等待对方主机响应断线确认的封包；<br>      TIME_WAIT：该联机已挂断，但 socket 还在网络上等待结束；<br>      LISTEN：通常用在服务的监听 port ！可使用『 -l 』参数查阅。</p></blockquote><p>基本上，我们常常谈到的 netstat 的功能，就是在观察网络的联机状态了，而网络联机状态中，又以观察【我目前开了多少的 port 在等待客户端的联机】以及 【目前我的网络联机状态中，有多少联机已建立或产生问题】最常见。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、网络参数设定使用的指令&quot;&gt;&lt;a href=&quot;#一、网络参数设定使用的指令&quot; class=&quot;headerlink&quot; title=&quot;一、网络参数设定使用的指令&quot;&gt;&lt;/a&gt;一、网络参数设定使用的指令&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;ifconfig ：&lt;/strong&gt;查询、设定网络卡与 IP 网域等相关参数；&lt;br&gt;&lt;strong&gt;ifup, ifdown：&lt;/strong&gt;这两个档案是 script，透过更简单的方式来启动网络接口；&lt;br&gt;&lt;strong&gt;route ：&lt;/strong&gt;查询、设定路由表 (route table)&lt;br&gt;&lt;strong&gt;ip ：&lt;/strong&gt;复合式的指令，可以直接修改上述提到的功能；&lt;br&gt;&lt;em&gt;（先会使用 ifconfig, ifup , ifdown 与 route 即可，等以后有经验了之后，再继续回来玩 ip 这个好玩的指令。）&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>基础网络概念（二）</title>
    <link href="http://yoursite.com/2018/01/10/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/10/基础网络概念（二）/</id>
    <published>2018-01-10T10:42:25.000Z</published>
    <updated>2018-01-18T06:58:20.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、TCP-IP-的链结层相关协议"><a href="#一、TCP-IP-的链结层相关协议" class="headerlink" title="一、TCP/IP 的链结层相关协议"></a>一、TCP/IP 的链结层相关协议</h2><p>TCP/IP 最底层的链结层主要与硬件比较有关系，因此底下我们主要介绍一些 WAN 与 LAN 的硬件。同时会开始介绍那重要的 CSMA/CD 的以太网络协议，以及相关的硬件与 MAC 讯框格式等。<br><a id="more"></a></p><h3 id="（1）广域网使用的设备"><a href="#（1）广域网使用的设备" class="headerlink" title="（1）广域网使用的设备"></a>（1）广域网使用的设备</h3><p>广域网使用的设备价格较为低廉。不过广域网使用到的设备非常的多，一般用户通常会接触到的主要是 ADSL 调制解调器或者是光纤到大厦，以及第四台的 Cable 宽带等。在这里我们先介绍一些比较常见的设备，如果以后你有机会接触到其他设备，再请依据需求自行查阅相关书籍！</p><p><strong>1. 传统电话拨接：透过 ppp 协议</strong><br>早期网络大概都只能透过调制解调器加上电话线以及计算机的九针串行端口(以前接鼠标或游戏杆的插孔)，然后透过 Point-to-Point Protocol (PPP 协议)配合拨接程序来取得网络 IP 参数，这样就能够上网了。不过这样的速度非常慢，而且当电话拨接后， 就不能够讲电话了！因为 PPP 支持 TCP/IP, NetBEUI,IPX/SPX 等通讯协议，所以使用度非常广！<br><strong>2. 整合服务数字网络 (Integrated Services Digital Network, ISDN)</strong><br>也是利用现有的电话线路来达成网络联机的目的，只是联机的两端都需要有 ISDN 的调制解调器来提供联机功能。ISDN 的传输有多种通道可供使用，并且可以将多个信道整合应用，因此速度可以成倍成长。基本的 B 信道速度约为 64Kbps， 但如美国规格使用 23 个以上的通道来达成联机，此时速度可达1.5Mbps 左右。<br><strong>3. 非对称数位用路回路 (Asymmetric Digital Subscriber Line, ADSL)：透过 pppoe 协议</strong><br>也是透过电话线来拨接后取得 IP 的一个方法，只不过这个方式使用的是电话的高频部分，与一般讲电话的频率不同。 因此妳可以一边使用 ADSL 上网同时透过同一个电话号码来打电话聊天。在台湾，由于上传/下载的带宽不同， 因此才称为非对称的回路。ADSL 同样使用调制解调器，只是他透过的是 PPPoE (PPP over Ethernet) 的方法！ 将 PPP 仿真在以太网络卡上，因此你的主机需要透过一张网络卡来连接到调制解调器，并透过拨接程序来取得新的接口 (ppp0)！<br><strong>4. 电缆调制解调器 (Cable modem)</strong><br>主要透过有线电视 (台湾所谓的第四台) 使用的缆线作为网络讯号媒体，同样需要具备调制解调器来连接到 ISP，以取得网络参数来上网。 Cable modem 的带宽主要是分享型的，所以通常具有区域性，并不是你想装就能装的哩！</p><h3 id="（2）局域网络使用的设备-以太网络"><a href="#（2）局域网络使用的设备-以太网络" class="headerlink" title="（2）局域网络使用的设备-以太网络"></a>（2）局域网络使用的设备-以太网络</h3><p>在局域网络的环境中，我们最常使用的就是以太网络。当然啦，在某些超高速网络应用的环境中， 还可能会用到价格相当昂贵的光纤信道哩。只是如同前面提到的，以太网络因为已经标准化了，设备设置费用相对低廉， 所以一般你会听到什么网络线或者是网络媒体，几乎都是使用以太网络来架设的环境！ 只是这里还是要提醒您，整个网络世界并非仅有以太网络这个硬件接口！</p><h4 id="1-以太网络的速度与标准"><a href="#1-以太网络的速度与标准" class="headerlink" title="1. 以太网络的速度与标准"></a>1. 以太网络的速度与标准</h4><p>以太网络的流行主要是它成为国际公认的标准所致。早先 IEEE 所制订的以太网络标准为 802.3 的 IEEE 10BASE5 ，这个标准主要的定义是：【10 代表传输速度为10Mbps，BASE 表示采用基频信号来进行传输，至于 5 则是指每个网络节点之间最长可达 500 公尺。】由于网络的传输信息就是 0 与 1 啊，因此，数据传输的单位为每秒多少 bit ，亦即是 M bits/second, Mbps 的意思。那么为何制订成为 10Mbps 呢？ 这是因为早期的网络线压制的方法以及相关的制作方法，还有以太网络卡制作的技术并不是很好，加上当时的数据传输需求并没有像现在这么高，所以 10Mbps 已经可以符合大多数人的需求了。<br><strong>（注：我们看到的网络提供者 (Internet Services Provider, ISP) 所宣称他们的 ADSL 传输速度可以达到 下行/上行 2Mbps/128Kbps(Kbits per second) 时，那个 Kb 指的可不是 bytes 而是 bits！所以 2M/128K 在实际的档案大小传输速度上面，最大理论的传输为 256KBps/16 KBps(KBytes per second)，所以正常下载的速度约在每秒 100~200 KBytes 之间吶！同样的道理，在网络卡或者是一些网络媒体的广告上面，他们都会宣称自己的产品可以自动辨识传输速度为 10/100 Mbps ( Mega-bits per second)，该数值还是得再除以 8 才是我们一般常用的档案容量计算的单位bytes！）</strong></p><p>早期的网络线使用的是旧式的同轴电缆线，这种线路在现在几乎已经看不到了。取而代之的是类似传统电话线的双绞线 (Twisted Pair Ethernet) ，IEEE 并将这种线路的以太网络传输方法制订成为 10BASE-T 的标准。 10BASE-T 使用的是 10 Mbps 全速运作且采用无遮蔽式双绞线 (UTP) 的网络线。此外， 10BASE-T 的 UTP 网络线可以使用星形联机(star)， 也就是以一个集线器为中心来串连各网络设备的一个方法。<br>不同于早期以一条同轴电缆线链接所有的计算机的 bus 联机，透过星形联机的帮助，我们可以很简单的加装其他的设备或者是移除其他设备，而不会受到其他装置的影响，这对网络设备的扩充性与除错来说， 都是一项相当棒的设计！也因此 10BASE-T 让以太网络设备的销售额大幅提升！</p><p>后来 IEEE 更制订了 802.3u 这个支持到 100Mbps 传输速度的 100BASE-T 标准，这个标准与 10BASE-T 差异不大， 只是双绞线线材制作需要更精良，同时也已经支持使用了四对绞线的网络线了，也就是目前很常见的八蕊网络线！这种网络线我们常称为等级五 (Category 5, CAT5) 的网络线。 这种传输速度的以太网络就被称为 Fastethernet 。至于目前我们常常听到的 Gigabit 网络速度 1000 Mbps 又是什么吶？那就是 Gigabit ethernet ！只是 Gigabit ethernet 的网络线就需要更加的精良。</p><p>为什么每当传输速度增加时，网络线的要求就更严格呢？这是因为当传输速度增加时，线材的电磁效应相互干扰会增强， 因此在网络线的制作时就得需要特别注意线材的质料以及内部线蕊心之间的缠绕情况配置等，以使电子流之间的电磁干扰降到最小，才能使传输速度提升到应有的 Gigabit 。所以说，在以太网络世界当中，如果你想要提升原有的 fast ethernet 到 gigabit ethernet 的话，除了网络卡需要升级之外，主机与主机之间的网络线，以及连接主机线路的集线器/交换器等，都必须要提升到可以支持 gigabit 速度等级的设备才行！</p><h4 id="2-以太网络的网络线接头-跳线-并行线"><a href="#2-以太网络的网络线接头-跳线-并行线" class="headerlink" title="2.以太网络的网络线接头 (跳线/并行线)"></a>2.以太网络的网络线接头 (跳线/并行线)</h4><p>前面提到，网络的速度与线材是有一定程度的相关性的，那么线材的接头又是怎样呢？目前在以太网络上最常见到的接头就是 RJ-45 的网络接头，共有八蕊的接头，有点像是胖了的电话线接头， 如下所示：<br><img src="/uploads/2018/01/network_ethernet_joint.JPG" alt=""><br>而 RJ-45 接头又因为每条蕊线的对应不同而分为 568A 与 568B 接头，这两款接头内的蕊线对应如下表：<br><img src="/uploads/2018/01/network_ethernet_joint_rj45.png" alt=""><br>事实上，虽然目前的以太网络线有八蕊且两两成对，但实际使用的只有 1,2,3,6 蕊而已，其他的则是某些特殊用途的场合才会使用到。但由于主机与主机的联机以及主机与集线器的联机时，所使用的网络线脚位定义并不相同，因此由于接头的不同网络线又可分为两种：</p><ul><li>跳线：一边为 568A 一边为 568B 的接头时称为跳线，用在直接链接两部主机的网络卡。</li><li>并行线：两边接头同为 568A 或同为 568B 时称为并行线，用在链接主机网络卡与集线器之间的线材；</li></ul><h3 id="（3）以太网络的传输协议：CSMA-CD"><a href="#（3）以太网络的传输协议：CSMA-CD" class="headerlink" title="（3）以太网络的传输协议：CSMA/CD"></a>（3）以太网络的传输协议：CSMA/CD</h3><p>整个以太网络的重心就是以太网络卡！所以说，以太网络的传输主要就是网络卡对网络卡之间的数据传递而已。每张以太网络卡出厂时，就会赋予一个独一无二的卡号，那就是所谓的 MAC (Media Access Control)！理论上，网卡卡号是不能修改的，不过某些笔记本电脑的网卡卡号是能够修改的！那么以太网络的网卡之间数据是如何传输的呢？那就得要谈一下 IEEE 802.3 的标准 CSMA/CD (Carrier SenseMultiple Access with Collision Detection) 了！我们以下图来作为简介，下图内的中心点为集线器，各个主机都是联机到集线器，然后透过集线器的功能向所有主机发起联机的。<br><img src="/uploads/2018/01/network_csma_cd.JPG" alt="" title="CSMA/CD 联机示意图，由 A 发送资料给 D 时，注意箭头方向"></p><p>集线器是一种网络共享媒体，什么是网络共享媒体啊？想象一下上述的环境就像一个十字路口，而集线器就是那个路口！ 这个路口一次只允许一辆车通过，如果两辆车同时使用这个路口，那么就会发生碰撞的车祸事件啊！那就是所谓的共享媒体。 也就是说，网络共享媒体在单一时间点内， 仅能被一部主机所使用。</p><p>理解了共享媒体的意义后，再来，我们就得要讨论，那么以太网络的网卡之间是如何传输的呢？我们以上图中的 A 要发给 D 网卡为例好了，简单的说， CSMA/CD 搭配上述的环境，它的传输情况需要有以下的流程：</p><blockquote><p>1.监听媒体使用情况 (Carrier Sense)：A 主机要发送网络封包前，需要先对网络媒体进行监听，确认没有人在使用后， 才能够发送出讯框；<br>2.多点传输 (Multiple Access)：A 主机所送出的数据会被集线器复制一份，然后传送给所有连接到此集线器的主机！ 也就是说， A 所送出的数据， B, C, D 三部计算机都能够接收的到！但由于目标是 D 主机，因此 B 与 C 会将此讯框数据丢弃，而 D 则会抓下来处理；<br>3.碰撞侦测 (Collision Detection)：该讯框数据附有检测能力，若其他主机例如 B 计算机也刚好在同时间发送讯框数据时， 那么 A 与 B 送出的数据碰撞在一块 (出车祸) ，此时这些讯框就是损毁，那么 A 与 B 就会各自随机等待一个时间， 然后重新透过第一步再传送一次该讯框数据。</p></blockquote><p>了解这个程序很重要吗？我们就来谈谈：</p><ol><li><strong>网络忙碌时，集线器灯号闪个不停，但我的主机明明没有使用网络：</strong><br>透过上述的流程我们会知道，不管哪一部主机发送出讯框，所有的计算机都会接收到！因为集线器会复制一份该数据给所有计算机。 因此，虽然只有一部主机在对外联机，但是在集线器上面的所有计算机灯号就都会闪个不停！</li><li><strong>我的计算机明明没有被入侵，为何我的数据会被隔壁的计算机窃取：</strong><br>透过上述的流程，我们只要在 B 计算机上面安装一套监听软件，这套软件将原本要丢弃的讯框数据捉下来分析，并且加以重组， 就能够知道原本 A 所送出的讯息了。这也是为什么我们都建议重要数据在因特网上面得要【加密】后再传输！</li><li><strong>既然共享媒体只有一个主机可以使用，为何大家可以同时上网：</strong>这个问题就有趣了，既然共享媒体一次只能被一个主机所使用，那么万一我传输100MB 的档案，集线器就得被我使用 80 秒 (以 10Mbps 传输时)，在这期间其他人都不可以使用吗？不是的，由于标准的讯框数据在网络卡与其他以太网络媒体一次只能传输 1500bytes，因此我的 100MB 档案就得要拆成多个小数据报，然后一个一个的传送，每个数据报传送前都要经过 CSMA/CD 的机制。 所以，这个集线器的使用权是大家抢着用的！即使只有一部主机在使用网络媒体时，那么这部主机在发送每个封包间， 也都是需要等待一段时间的 (96 bit time)！</li><li><strong>讯框要多大比较好？能不能修改讯框？：</strong><br>如上所述，那么讯框的大小能不能改变呢？因为如果讯框的容量能够增大，那么小数据报的数量就会减少， 那每个讯框传送间的等待就可以减少了！是这样没错，但是以太网络标准讯框确实定义在 1500 bytes， 但近来的超高速以太网络媒体有支持 Jumbo frame (巨型讯框,注10) 的话，那么就能够将讯框大小改为9000bytes 哩！但不是很建议大家随便修改！</li></ol><h3 id="（4）MAC-的封装格式"><a href="#（4）MAC-的封装格式" class="headerlink" title="（4）MAC 的封装格式"></a>（4）MAC 的封装格式</h3><p>上面提到的 CSMA/CD 传送出去的讯框数据，其实就是 MAC 啦！MAC 其实就是我们上面一直讲到的讯框 (frame) 啰！ 只是这个讯框上面有两个很重要的数据，就是目标与来源的网卡卡号，因此我们又简称网卡卡号为 MAC 而已。 简单的说，你可以把 MAC想成是一个在网络线上面传递的包裹，而这个包裹是整个网络硬件上面传送数据的最小单位了。 也就是说，网络线可想成是一条【一次仅可通过一个人】的独木桥， 而 MAC就是在这个独木桥上面动的人啦！接下来，来看一看 MAC 这个讯框的内容吧！<br><img src="/uploads/2018/01/network_mac_frame.JPG" alt="" title="以太网络的 MAC 讯框"></p><p>上图中的目的地址与来源地址指的就是网卡卡号 (hardware address, 硬件地址)，我们前面提到，每一张网卡都有一个独一无二的卡号， 那个卡号的目的就在这个讯框的表头数据使用到啦！硬件地址最小由 00:00:00:00:00:00 到 FF:FF:FF:FF:FF:FF(16 进位法)， 这 6 bytes 当中，前 3bytes 为厂商的代码，后 3bytes 则是该厂商自行设定的装置码了。</p><p>在 Linux 当中，你可以使用 ifconfig 这个指令来查阅你的网络卡卡号喔！特别注意，在这个 MAC 的传送中，他仅在局域网络内生效，如果跨过不同的网域 (这个后面 IP 的部分时会介绍)，那么来源与目的的硬件地址就会跟着改变了。 这是因为变成不同网络卡之间的交流了嘛！所以卡号当然不同了！如下所示：<br><img src="/uploads/2018/01/network_mac_frame_trans.JPG" alt="" title="同一讯框在不同网域的主机间传送时，讯框的表头变化"></p><p>例如上面的图标，我的数据要由计算机 A 通过 B 后才送达 C ，而 B 计算机有两块网络卡，其中 MAC-2 与 A 计算机的 MAC-1 互通，至于 MAC-3 则与 C 计算机的MAC-4 互通。但是 MAC-1 不能与 MAC-3 与 MAC-4 互通，为啥？因为 MAC-1 这块网络卡并没有与 MAC-3 及 MAC-4 使用同样的 switch/hub 相接嘛！所以，数据的流通会变成：</p><blockquote><p>1.先由 MAC-1 传送到 MAC-2 ，此时来源是 MAC-1 而目的地是 MAC-2；<br>2.B 计算机接收后，察看该讯框，发现目标其实是 C 计算机，而为了与 C 计算机沟通， 所以他会将讯框内的来源 MAC 改为 MAC-3 ，而目的改为 MAC-4 ，如此就可以直接传送到 C 计算机了。</p></blockquote><p>也就是说，只要透过 B (就是路由器) 才将封包送到另一个网域去的时候，那么讯框内的硬件地址就会被改变，然后才能够在同一个网域里面直接进行讯框的流通！<br><em>（注：局域网内是mac地址寻址，网域中是通过IP寻址。）</em></p><h3 id="（5）集线器、交换器与相关机制"><a href="#（5）集线器、交换器与相关机制" class="headerlink" title="（5）集线器、交换器与相关机制"></a>（5）集线器、交换器与相关机制</h3><p>共不共享很重要，集线器还是交换器？<br>当一个很忙碌的网络在运作时，集线器 (hub) 这个网络共享媒体就可能会发生碰撞的情况， 这是因为 CSMA/CD 的缘故。那有没有办法避免这种莫名其妙的封包碰撞情况呢？有的，那就使用非共享媒体的交换器即可！</p><p>交换器 (switch) 等级非常多，我们这里仅探讨支持 OSI 第二层的交换器。交换器与集线器最大的差异，在于交换器内有一个特别的内存， 这个内存可以记录每个 switch port 与其连接的 PC 的 MAC 地址，所以，当来自 switch 两端的 PC 要互传数据时，每个讯框将直接透过交换器的内存数据而传送到目标主机上！ 所以 switch 不是共享媒体，且 switch 的每个端口 (port) 都具有独立的带宽！</p><h2 id="二、TCP-IP-的网络层相关封包与数据"><a href="#二、TCP-IP-的网络层相关封包与数据" class="headerlink" title="二、TCP/IP 的网络层相关封包与数据"></a>二、TCP/IP 的网络层相关封包与数据</h2><p>我们现在知道要有网络的话，必须要有网络相关的硬件，而目前最常见的网络硬件接口为以太网络，包括网络线、网络卡、Hub/Switch 等等。而以太网络上面的传输使用网络卡卡号为基准的 MAC 讯框，配合 CSMA/CD 的标准来传送讯框，这就是硬件部分。在软件部分，我们知道 Internet 其实就是 TCP/IP 这个通讯协议的通称，Internet 是由 InterNIC 所统一管理的， 但其实他仅是负责分配 Internet 上面的 IP 以及提供相关的 TCP/IP 技术文件而已。不过 Internet 最重要的就是 IP ！所以，这个小节就让我们来讲讲网络层的 IP 与路由！</p><h3 id="1、IP-封包的封装"><a href="#1、IP-封包的封装" class="headerlink" title="1、IP 封包的封装"></a>1、IP 封包的封装</h3><p>目前因特网社会的 IP 有两种版本，一种是目前使用最广泛的 IPv4 (Internet Protocol version 4, 因特网协定第四版)， 一种则是预期未来会热门的 IPv6 。IPv4记录的地址由于仅有 32 位，预计在 2020 年前后就会分发完毕，如此一来，新兴国家或者是新的网络公司，将没有网络可以使用。为了避免这个问题发生，因此就有 IPv6的产生。IPv6 的地址可以达到 128 位，可以多出 2 的 96 次方倍的网址数量，这样的 IP 数量几乎用不完！虽然 IPv6 具有前瞻性，但目前主流媒体大多还是使用IPv4 ，因此本文主要谈到的 IP 都指 IPv4 而言。</p><p>我们在前一小节谈到 MAC 的封装，那么 IP 封包的封装也得要来了解一下，才能知道 IP 到底是如何产生的啊！ IP 封包可以达到 65535 bytes 这么大，在比 MAC 大的情况下，我们的操作系统会对 IP 进行拆解的动作。至于 IP 封装的表头资料绘制如下：(下图第一行为每个字段的 bit 数)<br><img src="/uploads/2018/01/network_ip_01.png" alt="" title="IP 封包的表头资料"></p><p>在上面的图示中有个地方要注意，那就是【每一行所占用的位数为 32 bits】，各个表头的内容分别介绍如下：</p><blockquote><p><strong>Version(版本)</strong><br>宣告这个 IP 封包的版本，例如目前惯用的还是 IPv4 这个版本就在这里宣告。<br><strong>IHL(Internet Header Length, IP 表头的长度)</strong><br>告知这个 IP 封包的表头长度，使用的单位应该是字组 (word) ，一个字组为 4bytes 大小。<br><strong>Type of Service(服务类型)</strong><br>这个项目的内容为【PPPDTRUU】，表示这个 IP 封包的服务类型，主要分为：<br>　　PPP：表示此 IP 封包的优先度，目前很少使用；<br>　　D：若为 0 表示一般延迟(delay)，若为 1 表示为低延迟；<br>　　T：若为 0 表示为一般传输量 (throughput)，若为 1 表示为高传输量；<br>　　R：若为 0 表示为一般可靠度(reliability)，若为 1 表示高可靠度。<br>　　UU：保留尚未被使用。<br>举例来说，gigabit 以太网络的种种相关规格可以让这个 IP 封包加速且降低延迟，某些特殊的标志就是在这里说明的。<br><strong>Total Length(总长度)</strong><br>指这个 IP 封包的总容量，包括表头与内容 (Data) 部分。最大可达 65535bytes。<br><strong>Identification(辨别码)</strong><br>我们前面提到 IP 袋子必须要放在 MAC 袋子当中。不过，如果 IP 袋子太大的话，就得先要将 IP 再重组成较小的袋子然后再放到 MAC 当中。而当 IP 被重组时，每个来自同一个 IP 的小袋子就得要有个标识符以告知接收端这些小袋子其实是来自同一个 IP 封包才行。也就是说，假如 IP 封包其实是 65536 那么大 (前一个 Total Length 有规定)，那么这个 IP 就得要再被分成更小的 IP 分段后才能塞进 MAC 讯框中。那么每个小 IP 分段是否来自同一个 IP 资料，这就是该标识符的作用！<br><strong>Flags(特殊旗标)</strong><br>这个地方的内容为【0DM】，其意义为：<br>　　D：若为 0 表示可以分段，若为 1 表示不可分段<br>　　M：若为 0 表示此 IP 为最后分段，若为 1 表示非最后分段。<br><strong>Fragment Offset(分段偏移)</strong><br>表示目前这个 IP 分段在原始的 IP 封包中所占的位置。就有点像是序号，有这个序号才能将所有的小 IP 分段组合成为原本的 IP 封包大小！透过 Total Length, Identification, Flags 以及这个 Fragment Offset 就能够将小 IP 分段在收受端组合起来了！<br><strong>Time To Live(TTL, 存活时间)</strong><br>表示这个 IP 封包的存活时间，范围为 0-255。当这个 IP 封包通过一个路由器时，TTL 就会减一，当 TTL 为 0 时，这个封包将会被直接丢弃。说实在的，要让 IP 封包通过 255 个路由器，还挺难的！<br><strong>Protocol Number(协定代码)</strong><br>来自传输层与网络层本身的其他数据都是放置在 IP 封包当中的，我们可以在 IP 表头记载这个 IP 封包内的数据是啥，在这个字段就是记载每种数据封包的内容！在这个字段记载的代码与相关的封包协议名称如下所示：<br><img src="/uploads/2018/01/network_ip_frame_protocol.png" alt="" title="常见的有 TCP, UDP"><br><strong>Header Checksum(表头检查码)</strong><br>用来检查这个 IP 表头的错误检验之用。<br><strong>Source Address</strong><br>来源的 IP 地址，从这里我们也知道 IP 是 32 位。<br><strong>Destination Address</strong><br>有来源还需要有目标才能传送，这里就是目标的 IP 地址。<br><strong>Options (其他参数)</strong><br>这个是额外的功能，提供包括安全处理机制、路由纪录、时间戳、严格与宽松之来源路由等。<br><strong>Padding(补齐项目)</strong><br>由于 Options 的内容不一定有多大，但是我们知道 IP 每个数据都必须要是 32bits，所以，若 Options 的数据不足 32 bits 时，则由 padding 主动补齐。</p></blockquote><p>你只要知道 IP 表头里面含有：TTL, Protocol, 来源地址与目标地址也就够了！而这个 IP 表头的来源与目标 IP ，以及那个判断通过多少路由器的 TTL ，就能了解到这个 IP 将被如何传送到目的端的。后续各小节我们将介绍 IP 的组成与范围，还有IP 封包如何传送的机制 (路由) 等等。</p><h3 id="2、IP-地址的组成与分级"><a href="#2、IP-地址的组成与分级" class="headerlink" title="2、IP 地址的组成与分级"></a>2、IP 地址的组成与分级</h3><p>现在我们知道 IP (Internet Protocol) 其实是一种网络封包，而这个封包的表头最重要的就是那个 32 位的来源与目标地址！ 为了方便记忆，所以我们也称这个 32bits 的数值为 IP 网络地址就是了。因为网络是人类发明的，所以很多概念与邮务系统类似！ 那这个 IP 其实就类似所谓的【门牌号码】！那么这个 IP 有哪些重要的地方需要了解的呢？底下我们就来谈一谈吧！</p><p>既然 IP 的组成是 32 bits 的数值，也就是由 32 个 0 与 1 组成的一连串数字！那么当我们思考所有跟 IP 有关的参数时，你就应该要将该参数想成是 32 位的数据！不过，因为人类对于二进制实在是不怎么熟悉，所以为了顺应人们对于十进制的依赖性，因此，就将 32 bits 的 IP 分成四小段，每段含有 8 个 bits ，将 8 个 bits 计算成为十进制，并且每一段中间以小数点隔开，那就成了目前大家所熟悉的 IP 的书写模样了。如下所示：<br><img src="/uploads/2018/01/network_ip_show.png" alt=""></p><p>所以 IP 最小可以由 0.0.0.0 一直到 255.255.255.255 ！但在这一串数字中，其实还可以分为两个部分！主要分为 Net_ID (网域号码)与 Host_ID (主机号码) 两部份。我们先以 192.168.0.0 ~ 192.168.0.255 这个 Class C 的网域当作例子来说明好了：<br><img src="/uploads/2018/01/network_ip_explain.png" alt=""></p><p>在上面的范例当中，前面三组数字 (192.168.0) 就是网域号码，最后面一组数字则称为主机号码。至于同一个网域的定义是【在同一个物理网段内，主机的 IP 具有相同的 Net_ID ，并且具有独特的 Host_ID】，那么这些 IP 群就是同一个网域内的 IP 网段！<br><em>（注：什么是物理网段呢？当所有的主机都是使用同一个网络媒体串在一起，这个时候这些主机在实体装置上面其实是联机在一起的，那么就可以称为这些主机在同一个物理网段内了！同时并请注意，同一个物理网段之内，可以依据不同的 IP 的设定，而设定成多个【IP 网段】！）</em><br><strong>（请注意，同一个 Net_ID 内，不能具有相同的 Host_ID ，否则就会发生IP冲突，可能会造成两部主机都没有办法使用网络的问题！）</strong></p><p><strong>（1）IP 在同一网域的意义</strong><br>那么同一个网域该怎么设定，与将 IP 设定在同一个网域之内有什么好处呢？</p><blockquote><p><strong>1.Net_ID 与 Host_ID 的限制：</strong><br>在同一个网段内，Net_ID 是不变的，而 Host_ID 则是不可重复，此外，Host_ID在二进制的表示法当中，不可同时为 0 也不可同时为 1 ，因为全为 0 表示整个网段的地址 (Network IP)，而全为 1 则表示为广播的地址 (Broadcast IP)。<br><strong>2.在区网内透过 IP 广播传递数据</strong><br>在同物理网段的主机如果设定相同的网域 IP 范围 (不可重复)，则这些主机都可以透过 CSMA/CD 的功能直接在区网内用广播进行网络的联机，亦即可以直接网卡对网卡传递数据 (透过 MAC 讯框)；<br><strong>3.设定不同区网在同物理网段的情况</strong><br>在同一个物理网段之内，如果两部主机设定成不同的 IP 网段，则由于广播地址的不同，导致无法透过广播的方式来进行联机。 此时得要透过路由器 (router)来进行沟通才能将两个网域连结在一起。<br><strong>4.网域的大小</strong><br>当 Host_ID 所占用的位越大，亦即 Host_ID 数量越多时，表示同一个网域内可用以设定主机的 IP 数量越多。</p></blockquote><p><strong>（2）IP 的分级</strong><br>为了 IP 管理与发放注册的方便性，InterNIC 将整个 IP 网段分为五种等级， 每种等级的范围主要与 IP 那 32 bits 数值的前面几个位有关，基本定义如下：<br><img src="/uploads/2018/01/network_ip_class.png" alt=""><br>五种分级在十进制的表示：<br>Class A : 0.xx.xx.xx ~ 127.xx.xx.xx<br>Class B : 128.xx.xx.xx ~ 191.xx.xx.xx<br>Class C : 192.xx.xx.xx ~ 223.xx.xx.xx<br>Class D : 224.xx.xx.xx ~ 239.xx.xx.xx<br>Class E : 240.xx.xx.xx ~ 255.xx.xx.xx</p><p>根据上表的说明，我们可以知道，你只要知道 IP 的第一个十进制数，就能够约略了解到该 IP 属于哪一个等级，以及同网域 IP 数量有多少。这也是为啥我们上头选了 192.168.0.0 这一 IP 网段来说明时，会将巷子定义到第三个数字之故。不过，上表中你只要记忆三种等级，亦即是 Class A, B, C 即可，因为 Class D 是用来作为群播(multicast) 的特殊功能之用 (最常用在大批计算机的网络还原)，至于 Class E 则是保留没有使用的网段。因此，能够用来设定在一般系统上面的，就只有 Class A, B, C三种等级的 IP！</p><p><strong>（3）IP 的种类与取得方式</strong><br>接下来要跟大家谈一谈也是很容易造成大家困扰的一个部分，那就是 IP 的种类！很多朋友常常听到什么【真实IP, 实体 IP, 虚拟 IP, 假的 IP….】实际上，在 IPv4 里面就只有两种 IP 的类别，分别是：</p><ul><li>Public IP : 公共 IP ，经由 INTERNIC 所统一规划的 IP，有这种 IP 才可以连上 Internet ；</li><li>Private IP : 私有 IP 或保留 IP，不能直接连上 Internet 的 IP ，主要用于局域网络内的主机联机规划。</li></ul><p>早在 IPv4 规划的时候就担心 IP 会有不足的情况，而且为了应付某些企业内部的网络设定，于是就有了私有 IP (Private IP) 的产生了。私有 IP 也分别在 A, B, C 三个 Class 当中各保留一段作为私有 IP 网段，那就是：<br>　　Class A：10.0.0.0 - 10.255.255.255<br>　　Class B：172.16.0.0 - 172.31.255.255<br>　　Class C：192.168.0.0 - 192.168.255.255<br>由于这三段 Class 的 IP 是预留使用的，所以并不能直接作为 Internet 上面的连接之用，不然的话，到处就都有相同的 IP ！那怎么行！网络岂不混乱？所以，这三个 IP 网段就只做为内部私有网域的 IP 沟通之用。简单的说，他有底下的几个限制：</p><ul><li>私有 IP 的路由信息不能对外散播 (只能存在内部网络)；</li><li>使用私有 IP 作为来源或目的地址的封包，不能透过 Internet 来转送 (不然网络会混乱)；</li><li>关于私有 IP 的参考纪录(如 DNS)，只能限于内部网络使用 (一样的原理)</li></ul><p>这个私有 IP 有什么好处呢？由于他的私有路由不能对外直接提供信息，所以，你的内部网络将不会直接被 Internet 上面的 Cracker 所攻击！但是，你也就无法以私有 IP 来【直接上网】！因此相当适合一些尚未具有 Public IP 的企业内部用来规划其网络之设定！否则当你随便指定一些可能是 Public IP 的网段来规划你企业内部的网络设定时，万一哪一天真的连上 Internet 了，那么岂不是可能会造成跟 Internet上面的 Public IP 相同了吗？</p><p>此外，在没有可用的公开网络情况下，如果你想要跟同学玩联机游戏怎办？也就是说，在区网内自己玩自己的联机游戏， 此时你只要规范好所有同学在同一段私有 IP 网段中，就能够顺利的玩你的网络啦！就这么简单呢！</p><p>那么万一你又要将这些私有 IP 送上 Internet 呢？这个简单，设定一个简单的防火墙加上 NAT (Network Address Transfer) 服务，你就可以透过 IP 伪装 (不要急，这个在后面也会提到) 来使你的私有 IP 的计算机也可以连上 Internet ！</p><p><strong>特殊的 loopback IP 网段</strong><br>还有一个奇怪的 Class A 的网域，那就是 lo 这个奇怪的网域啦 (注意：是小写的 o 而不是零喔)！这个 lo 的网络是当初被用来作为测试操作系统内部循环所用的一个网域，同时也能够提供给系统内部原本就需要使用网络接口的服务 (daemon) 所使用。</p><p>简单的说，如果你没有安装网络卡在的机器上面， 但是你又希望可以测试一下在你的机器上面设定的服务器环境到底可不可以顺利运作，这个时候怎么办，就是利用这个所谓的内部循环网络啦！这个网段在 127.0.0.0/8 这个 Class A，而且默认的主机 (localhost) 的 IP 是 127.0.0.1 ！所以，当你启动了你的 WWW 服务器，然后在你的主机的 X-Window 上面执行 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 就可以直接看到你的主页！而且不需要安装网络卡！测试很方便的！</p><p><strong>IP 的取得方式</strong><br>基本上，主机的 IP 与相关网域的设定方式主要有：</p><blockquote><p>1.直接手动设定(static)： 你可以直接向你的网管询问可用的 IP 相关参数，然后直接编辑配置文件 (或使用某些软件功能) 来设定你的网络。 常见于校园网络的环境中，以及向 ISP 申请固定 IP 的联机环境；<br>2.透过拨接取得： 向你的 ISP 申请注册，取得账号密码后，直接拨接到 ISP ，你的 ISP 会透过他们自己的设定，让你的操作系统取得正确的网络参数。<br>3.自动取得网络参数 (DHCP)： 在局域网络内会有一部主机负责管理所有计算机的网络参数，你的网络启动时就会主动向该服务器要求 IP 参数， 若取得网络相关参数后，你的主机就能够自行设定好所有服务器给你的网络参数了。最常使用于企业内部、IP 分享器后端、 校园网络与宿舍环境，及缆线宽带等联机方式。</p></blockquote><p>不管是使用上面哪种方式取得的 IP ，你的 IP 都只有所谓的【 Public 与Private IP 】而已！而其他什么浮动式、固定制、 动态式等等有的没有的，就只是告诉你这个 IP 取得的方式而已。</p><h3 id="（4）Netmask-子网与-CIDR-Classless-Interdomain-Routing"><a href="#（4）Netmask-子网与-CIDR-Classless-Interdomain-Routing" class="headerlink" title="（4）Netmask, 子网与 CIDR (Classless Interdomain Routing)"></a>（4）Netmask, 子网与 CIDR (Classless Interdomain Routing)</h3><p>前面我们提到 IP 这个 32 位的数值中分为网域号码与主机号码，其中 Class C的网域号码占了 24 位，而其实我们还可以将这样的网域切的更细，就是让第一个Host_ID 被拿来作为 Net_ID ，所以，整个 Net_ID 就有 25 bits ，至于 Host_ID 则减少为 7 bits 。在这样的情况下，原来的一个 Class C 的网域就可以被切分为两个子域，而每个子域就有【 256/2 - 2 = 126 】个可用的 IP 了！这样一来，就能够将原本的一个网域切为两个较细小的网域，方便分门别类的设计。</p><p><strong>Netmask, 或称为 Subnet mask (子网掩码)</strong><br>那到底是什么参数来达成子网的切分呢？那就是 Netmask (子网掩码) 的用途！这个 Netmask 是用来定义出网域的最重要的一个参数。<br>Netmask 的表示就成为：<br><img src="/uploads/2018/01/network_ip_netmask.png" alt=""></p><h2 id="三、TCP-IP-的传输层相关封包与数据"><a href="#三、TCP-IP-的传输层相关封包与数据" class="headerlink" title="三、TCP/IP 的传输层相关封包与数据"></a>三、TCP/IP 的传输层相关封包与数据</h2><p>网络层的 IP 封包只负责将数据送到正确的目标主机去，但这个封包到底会不会被接受，或者是有没有被正确的接收，那就不是 IP 的任务啦！那是传送层的任务之一。其中连接导向的 TCP 封包与非连接导向的 UDP 封包，这两个封包很重要！资料能不能正确的被送达目的，与这两个封包有关！</p><h3 id="1、可靠联机的-TCP-协议"><a href="#1、可靠联机的-TCP-协议" class="headerlink" title="1、可靠联机的 TCP 协议"></a>1、可靠联机的 TCP 协议</h3><p>TCP 封包的表头资料：<br><img src="/uploads/2018/01/network_ip_frame_tcp.png" alt=""><br>上图就是一个 TCP 封包的表头数据，各个项目以 Source Port, Destination Port及 Code 算是比较重要的项目，底下我们就分别来谈一谈各个表头数据的内容吧！</p><blockquote><p><strong>Source Port &amp; Destination Port (来源端口 &amp; 目标端口)</strong><br>什么是端口(port)？我们知道 IP 封包的传送主要是藉由 IP 地址连接两端，但是到底这个联机的通道是连接到哪里去呢？就是连接到 port 上头！举例来说，有的网站开放 WWW 服务器，这表示主机必须要启动一个可以让 client 端连接的端口，这个端口就是 port 。同样的，客户端想要连接到 WWW 服务器时，就必须要在 client 主机上面启动一个 port ，这样这两个主机才能够利用这条【通道】来传递封包数据！这个目标与来源 port 的纪录，可以说是 TCP 封包上最重要的参数了！<br><strong>Sequence Number (封包序号)</strong><br>由于 TCP 封包必须要带入 IP 封包当中，所以如果 TCP 数据太大时(大于 IP封包的容许程度)，就得要进行分段。这个 Sequence Number 就是记录每个封包的序号，可以让收受端重新将 TCP 的数据组合起来。<br><strong>Acknowledge Number (回应序号)</strong><br>为了确认主机端确实有收到我们 client 端所送出的封包数据，我们 client 端当然希望能够收到主机方面的响应，那就是这个 Acknowledge Number 的用途了。当 client 端收到这个确认码时，就能够确定之前传递的封包已经被正确的收下了。<br><strong>Data Offset (资料补偿)</strong><br>在图中倒数第二行有个 Options 字段！那个 Options 的字段长度是非固定的，而为了要确认整个 TCP 封包的大小，就需要这个标志来说明整个封包区段的起始位置。<br><strong>Reserved (保留)</strong><br>未使用的保留字段。<br><strong>Code (Control Flag, 控制标志码)</strong><br>当我们在进行网络联机的时候，必须要说明这个联机的状态，好让接收端了解这个封包的主要动作。这可是一个非常重要的句柄！这个字段共有 6 个 bits ，分别代表 6 个句柄，若为 1 则为启动。分别说明如下：<br>　　URG(Urgent)：若为 1 则代表该封包为紧急封包，接收端应该要紧急处理，且图当中的 Urgent Pointer 字段也会被启用。<br>　　ACK(Acknowledge)：若为 1 代表这个封包为响应封包，则与上面提到的 Acknowledge Number 有关。<br>　　PSH(Push function)：若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无须等待缓冲区满了才送。<br>　　RST(Reset)：如果 RST 为 1 的时候，表示联机会被马上结束，而无需等待终止确认手续。这也就是说，这是个强制结束的联机，且发送端已断线。<br>　　SYN(Synchronous)：若为 1，表示发送端希望双方建立同步处理，也就是要求建立联机。通常带有 SYN 标志的封包表示【主动】要连接到对方的意思。<br>　　FIN(Finish)：若为 1 ，表示传送结束，所以通知对方数据传毕，是否同意断线，只是发送者还在等待对方的响应而已。<br>其实每个项目都很重要，不过我们这里仅对 ACK/SYN 有兴趣而已，这样未来在谈到防火墙的时候，你才会比较清楚为啥每个 TCP 封包都有所谓的【状态】条件！那就是因为联机方向的不同所致啊。<br><strong>Window (滑动窗口)</strong><br>主要是用来控制封包的流量的，可以告知对方目前本身有的缓冲器容量(Receive Buffer) 还可以接收封包。当 Window=0 时，代表缓冲器已经额满，所以应该要暂停传输数据。 Window 的单位是 byte。<br><strong>Checksum(确认检查码)</strong><br>当数据要由发送端送出前，会进行一个检验的动作，并将该动作的检验值标注在这个字段上；而接收者收到这个封包之后，会再次的对封包进行验证，并且比对原发送的 Checksum 值是否相符，如果相符就接受，若不符就会假设该封包已经损毁，进而要求对方重新发送此封包！<br><strong>Urgent Pointer(紧急资料)</strong><br>这个字段是在 Code 字段内的 URG = 1 时才会产生作用。可以告知紧急数据所在的位置。<br><strong>Options(任意资料)</strong><br>目前此字段仅应用于表示接收端可以接收的最大数据区段容量，若此字段不使用，表示可以使用任意数据区段的大小。这个字段较少使用。<br><strong>Padding(补足字段)</strong><br>如同 IP 封包需要有固定的 32bits 表头一样， Options 由于字段为非固定，所以也需要 Padding 字段来加以补齐才行。同样也是 32 bits 的整数。</p></blockquote><h3 id="2、通讯端口"><a href="#2、通讯端口" class="headerlink" title="2、通讯端口"></a>2、通讯端口</h3><p>谈完了 TCP 表头数据后，再来让我们了解一下这个表头里面最重要的端口信息吧！<br>在上图的 TCP 表头数据中，最重要的就属那 16 位的两个咚咚，亦即来源与目标的端口。由于是 16 位，因此目标与来源端口最大可达 65535 号 (2 的 16 次方)！那这个埠口有什么用途呢？上面稍微提到过，网络是双向的，服务器与客户端要达成联机的话，两边应该要有一个对应的端口来达成联机信道，好让数据可以透过这个信道来进行沟通。</p><p>那么这个端口怎么打开呢？就是透过程序的执行！举例来说，网站上必须要启动一个 WWW 服务器软件，这个服务器软件会主动的唤起 port 80 来等待客户端的联机。你想要看我网站上的数据，就得要利用浏览器，填入网址，然后浏览器也会启动一个端口，并将 TCP 的表头填写目标端口为 80 ，而来源端口是你主机随机启动的一个端口，然后将 TCP 封包封装到 IP 后，送出到网络上。等 WWW 网站主机接收到你这个封包后，再依据你的端口给予回应。<br><em>（注：曾经有一个朋友问过我说：【一部主机上面这么多服务，那我们跟这部主机进行联机时，该主机怎么知道我们要的数据是 WWW 还是FTP 啊？】就是透过埠口啊！因为每种 Client 软件他们所需要的数据都不相同，例如上面提到的浏览器所需要的数据是 WWW ，所以该软件默认就会向服务器的 port 80 索求数据；而如果你是使用 filezilla 来进行与服务器的 FTP 数据索求时， filezilla 当然预设就是向服务器的 FTP 相关埠口 (预设就是 port 21) 进行连接的动作啦！所以当然就可以正确无误的取得 Client 端所需要的数据了）</em></p><p><strong>特权端口 (Privileged Ports)</strong><br>Internet 上面已经有很多规范好的固定 port (well-known port)，这些 port number 通常小于 1024 ，且是提供给许多知名的网络服务软件用的。在我们的 Linux 环境下，各网络服务与 port number 的对应默认给他写在 /etc/services档案内。底下列出几个常见的 port number 与网络服务的对应：<br><img src="/uploads/2018/01/network_port_for_service.png" alt=""></p><p>另外一点比较值得注意的是，小于 1024 以下的埠口要启动时， 启动者的身份必须要是 root 才行，所以才叫做特权埠口嘛！这个限制挺重要的，大家不要忘记了！不过如果是 client 端的话，由于 client 端都是主动向 server 端要数据，所以client 端的 port number 就使用随机取一个大于 1024 以上且没有在用的 port number。</p><p><strong>Socket Pair</strong><br>由于网络是双向的，要达成联机的话得要服务器与客户端均提供了 IP 与埠口才行。因此，我们常常将这个成对的数据称之为 Socket Pair 了！</p><ul><li>来源 IP + 来源埠口 (Source Address + Source Port)</li><li>目的 IP + 目的埠口 (Destination Address + Destination Port)</li></ul><p>由于 IP 与埠口常常连在一起说明，因此网络寻址常常使用【 IP:port 】来说明，例如想要连上网站时，正确的鸟哥网站写法应该是：【 linux.vbird.org:80 】才对！</p><h3 id="3、TCP-的三向交握"><a href="#3、TCP-的三向交握" class="headerlink" title="3、TCP 的三向交握"></a>3、TCP 的三向交握</h3><p>TCP 被称为可靠的联机封包，主要是透过许多机制来达成的，其中最重要的就是三向交握的功能。我们以底下的图示来作为说明。<br><img src="/uploads/2018/01/network_tcp_connect.png" alt=""></p><p>在上面的封包连接模式当中，在建立联机之前都必须要通过三个确认的动作，所以这种联机方式也就被称为三向交握(Three-way handshake)。 那么我们将整个流程依据上面的 A, B, C, D 四个阶段来说明一下：</p><blockquote><p><strong>A:封包发起</strong><br>当客户端想要对服务器端联机时，就必须要送出一个要求联机的封包，此时客户端必须随机取用一个大于 1024 以上的端口口来做为程序沟通的接口。然后在 TCP 的表头当中，必须要带有 SYN 的主动联机(SYN=1)，并且记下发送出联机封包给服务器端的序号 (Sequence number = 10001) 。<br><strong>B:封包接收与确认封包传送</strong><br>当服务器接到这个封包，并且确定要接收这个封包后，就会开始制作一个同时带有 SYN=1, ACK=1 的封包，其中那个 acknowledge 的号码是要给 client 端确认用的，所以该数字会比(A 步骤)里面的 Sequence 号码多一号 (ack = 10001+1= 10002)， 那我们服务器也必须要确认客户端确实可以接收我们的封包才行，所以也会发送出一个 Sequence (seq=20001) 给客户端，并且开始等待客户端给我们服务器端的回应！<br><strong>C:回送确认封包</strong><br>当客户端收到来自服务器端的 ACK 数字后 (10002) 就能够确认之前那个要求封包被正确的收受了， 接下来如果客户端也同意与服务器端建立联机时，就会再次的发送一个确认封包 (ACK=1) 给服务器，亦即是 acknowledge = 20001+1 =20002 。<br><strong>D:取得最后确认</strong><br>若一切都顺利，在服务器端收到带有 ACK=1 且 ack=20002 序号的封包后，就能够建立起这次的联机了。</p></blockquote><p>也就是说，你必须要了解【网络是双向的】这个事实！所以不论是服务器端还是客户端，都必须要透过一次 SYN 与 ACK 来建立联机，所以总共会进行三次的交谈！在设定防火墙或者是追踪网络联机的问题时，这个【双向】的概念最容易被忽略， 而常常导致无法联机成功的问题啊！切记切记！</p><h2 id="四、非连接导向的-UDP-协议"><a href="#四、非连接导向的-UDP-协议" class="headerlink" title="四、非连接导向的 UDP 协议"></a>四、非连接导向的 UDP 协议</h2><p>UDP 的全名是：【User Datagram Protocol, 用户数据流协议】，UDP 与 TCP 不一样，UDP 不提供可靠的传输模式，因为他不是面向连接的一个机制，这是因为在 UDP的传送过程中，接受端在接受到封包之后，不会回复响应封包 (ACK) 给发送端，所以封包并没有像 TCP 封包有较为严密的检查机制。至于 UDP 的表头资料如下表所示：<br><img src="/uploads/2018/01/network_ip_frame_udp.png" alt=""></p><p>TCP 封包确实是比较可靠的，因为通过三向交握嘛！不过，也由于三向交握的缘故，TCP 封包的传输速度会较慢。至于 UDP 封包由于不需要确认对方是否有正确的收到数据，故表头数据较少，所以 UDP 就可以在 Data 处填入更多的数据了。同时 UDP 比较适合需要实时反应的一些数据流，例如影像实时传送软件等，就可以使用这类的封包传送。也就是说，UDP 传输协议并不考虑联机要求、联机终止与流量控制等特性，所以使用的时机是当数据的正确性不很重要的情况，例如网络摄影机！</p><p>另外，很多的软件其实是同时提供 TCP 与 UDP 的传输协议的，举例来说，查询主机名的 DNS 服务就同时提供了 UDP/TCP 协议。由于 UDP 较为快速，所以我们 client 端可以先使用 UDP 来与服务器联机。 但是当使用 UDP 联机却还是无法取得正确的数据时，便转换为较为可靠的 TCP 传输协议来进行数据的传输啰。 这样可以同时兼顾快速与可靠的传输说！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、TCP-IP-的链结层相关协议&quot;&gt;&lt;a href=&quot;#一、TCP-IP-的链结层相关协议&quot; class=&quot;headerlink&quot; title=&quot;一、TCP/IP 的链结层相关协议&quot;&gt;&lt;/a&gt;一、TCP/IP 的链结层相关协议&lt;/h2&gt;&lt;p&gt;TCP/IP 最底层的链结层主要与硬件比较有关系，因此底下我们主要介绍一些 WAN 与 LAN 的硬件。同时会开始介绍那重要的 CSMA/CD 的以太网络协议，以及相关的硬件与 MAC 讯框格式等。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>基础网络概念（一）</title>
    <link href="http://yoursite.com/2018/01/10/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/10/基础网络概念（一）/</id>
    <published>2018-01-10T10:34:11.000Z</published>
    <updated>2018-01-18T06:57:52.810Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、计算机网络组成组件"><a href="#1、计算机网络组成组件" class="headerlink" title="1、计算机网络组成组件"></a>1、计算机网络组成组件</h3><p>我们以底下这张联机示意图来解释好了：<br><img src="/uploads/2018/01/network_component.JPG" alt=""><br><a id="more"></a><br>在上图中，我们主要需要注意到的硬件有哪些呢？大致有底下这些啦：</p><ul><li><strong>节点 (node)：</strong>节点主要是具有网络地址 (IP) 的设备之称，因此上面图示中的一般PC、Linux 服务器、ADSL 调制解调器与网络打印机等，个别都可以称为一个 node！那中间那个集线器 (hub) 是不是节点呢？因为他不具有 IP ，因此 hub 不是节点。</li><li><strong>服务器主机 (server)：</strong>就网络联机的方向来说，提供数据以【响应】给用户的主机，都可以被称为是一部服务器。举例来说，Yahoo 是个 WWW 服务器，昆山的 FTP (<a href="http://ftp.ksu.edu.tw/" target="_blank" rel="noopener">http://ftp.ksu.edu.tw/</a>) 是个文件服务器等等。</li><li><strong>工作站 (workstation) 或客户端 (client)：</strong>任何可以在计算机网络输入的设备都可以是工作站，若以联机发起的方向来说，主动发起联机去【要求】数据的，就可以称为是客户端 (client)。举例来说，一般 PC 打开浏览器对 Yahoo 要求新闻数据，那一般 PC 就是客户端。</li><li><strong>网络卡 (Network Interface Card, NIC)：</strong>内建或者是外插在主机上面的一个设备，主要提供网络联机的卡片，目前大都使用具有 RJ-45 接头的以太网络卡。一般 node 上都具有一个以上的网络卡，以达成网络联机的功能。</li><li><strong>网络接口：</strong>利用软件设计出来的网络接口，主要在提供网络地址 (IP) 的任务。一张网卡至少可以搭配一个以上的网络接口；而每部主机内部其实也都拥有一个内部的网络接口，那就是 loopback (lo) 这个循环测试接口！</li><li><strong>网络形态或拓朴 (topology)：</strong>各个节点在网络上面的链接方式，一般讲的是物理连接方式。举例来说，上图中显示的是一种被称为星形联机 (star) 的方式，主要是透过一个中间连接设备，以放射状的方式连接各个节点的一种形态，这就是一种拓朴。</li><li><strong>网关 (route) 或通讯闸 (gateway)：</strong>具有两个以上的网络接口，可以连接两个以上不同的网段的设备，例如 IP 分享器就是一个常见的网关设备。那上面的 ADSL 调制解调器算不算网关呢？其实不太能算，因为调制解调器通常视为一个在主机内的网卡设备，我们可以在一般 PC 上面透过拨号软件， 将调制解调器仿真成为一张实体网卡 (ppp) ，因此他不太能算是网关设备！</li></ul><p>网络设备其实非常多也非常复杂，不过如果以小型企业角度来看，我们能够了解上述图示内各设备的角色，那应该也足够了！接下来，让我们继续来讨论一下网络范围的大小吧！</p><h3 id="2、计算机网络区域范围"><a href="#2、计算机网络区域范围" class="headerlink" title="2、计算机网络区域范围"></a>2、计算机网络区域范围</h3><p>由于各个节点的距离不同，联机的线材与方式也有所差异，由于线材的差异也导致网络速度的不同，让网络的应用方向也不一样。 根据这些差异，早期我们习惯将网络的大小范围定义如下：</p><blockquote><ol><li>局域网络 (Local Area Network, LAN)：<br>节点之间的传输距离较近，例如一栋大楼内，或一个学校的校区内。可以使用较为昂贵的联机材料， 例如光纤或是高质量网络线 (CAT 6) 等。网络速度较快，联机质量较佳且可靠，因此可应用于科学运算的丛集式系统、 分布式系统、云端负荷分担系统等。</li><li>广域网 (Wide Area Network, WAN)：<br>传输距离较远，例如城市与城市之间的距离，因此使用的联机媒体需要较为便宜的设备，例如经常使用的电话线就是一例。 由于线材质量较差，因此网络速度较慢且可靠性较低一些，网络应用方面大多为类似 email, FTP, WWW 浏览等功能。</li></ol></blockquote><p>除了这两个之外，还有所谓的都会网络 (Metropolitan Area Network, MAN)，不过近来比较少提及，因此你只要知道有 LAN 及 WAN 即可。这两个名词在很多地方你都可以看的到。改天你回家看看你家的 ADSL 调制解调器或 IP 分享器后面的插孔看看，你就能够看到有 WAN 与 LAN 的插孔，现在你就知道为啥有这两个灯号与插孔了吧。</p><h3 id="3、计算机网络协议：-OSI-七层协定"><a href="#3、计算机网络协议：-OSI-七层协定" class="headerlink" title="3、计算机网络协议： OSI 七层协定"></a>3、计算机网络协议： OSI 七层协定</h3><p>我们可以将整个网络连接过程分成数个阶层 (layer)，每个阶层都有特别的独立的功能，而且每个阶层的程序代码可以独立撰写，因为每个阶层之间的功能并不会互相干扰的。 如此一来，当某个小环节出现问题时，只要将该层级的程序代码重新撰写即可。所以程序撰写也容易，整个网络概念也就更清晰！ 那就是目前你常听到的 OSI 七层协议 (Open System Interconnection) 的概念。<br>依据定义来说，越接近硬件的阶层为底层 (layer 1)，越接近应用程序的则是高层 (layer 7) 。不论是接收端还是发送端，每个一阶层只认识对方的同一阶层数据。</p><p><img src="/uploads/2018/01/network_osi_01.JPG" alt=""><br>上图中仔细看每个数据报的部分，上层的包裹是放入下层的数据中，而数据前面则是这个数据的表头。其中比较特殊的是第二层，因为第二层 (数据链结层) 主要是位于软件封包 (packet) 以及硬件讯框 (frame) 中间的一个阶层，他必须要将软件包装的包裹放入到硬件能够处理的包裹中，因此这个阶层又分为两个子层在处理相对应的数据。因为比较特殊，所以第二层的数据格式比较不一样，尾端还出现一个检查码.<br>简单的说，每一层负责的任务如下：</p><style type="text/css">table th:first-of-type {    width: 150px;}</style><table><thead><tr><th>分层</th><th>负责任务</th></tr></thead><tbody><tr><td>Layer 1<br>物理层<br>Physical Layer</td><td>由于网络媒体只能传送 0 与 1 这种位串，因此物理层必须定义所使用的媒体设备之电压与讯号等， 同时还必须了解数据讯框转成位串的编码方式，最后连接实体媒体并传送/接收位串。</td></tr><tr><td>Layer 2<br>数据链结层<br>Data-Link Layer</td><td>这一层是比较特殊的一个阶层，因为底下是实体的定义，而上层则是软件封装的定义。因此第二层又分两个子层在进行数据的转换动作。 在偏硬件媒体部分，主要负责的是 MAC(Media Access Control) ，我们称这个数据报裹为 MAC 讯框 (frame)， MAC 是网络媒体所能处理的主要数据报裹，这也是最终被物理层编码成位串的数据。MAC 必须要经由通讯协议来取得媒体的使用权， 目前最常使用的则是 IEEE802.3 的以太网络协议。详细的 MAC 与以太网络请参考下节说明。<br>至于偏向软件的部分则是由逻辑链接层 (logical linkcontrol, LLC) 所控制，主要在多任务处理来自上层的封包数据 (packet) 并转成 MAC 的格式， 负责的工作包括讯息交换、流量控制、失误问题的处理等等。</td></tr><tr><td>Layer 3<br>网络层<br>Network Layer</td><td>这一层是我们最感兴趣的啰，因为我们提及的 IP (Internet Protocol) 就是在这一层定义的。 同时也定义出计算机之间的联机建立、终止与维持等，数据封包的传输路径选择等等，因此这个层级当中最重要的除了 IP 之外，就是封包能否到达目的地的路由 (route) 概念了！</td></tr><tr><td>Layer 4<br>传送层<br>Transport Layer</td><td>这一个分层定义了发送端与接收端的联机技术(如 TCP, UDP技术)， 同时包括该技术的封包格式，数据封包的传送、流程的控制、传输过程的侦测检查与复原重新传送等等， 以确保各个资料封包可以正确无误的到达目的端。</td></tr><tr><td>Layer 5<br>会谈层<br>Session Layer</td><td>在这个层级当中主要定义了两个地址之间的联机信道之连接与挂断，此外，亦可建立应用程序之对谈、 提供其他加强型服务如网络管理、签到签退、对谈之控制等等。如果说传送层是在判断资料封包是否可以正确的到达目标， 那么会谈层则是在确定网络服务建立联机的确认。</td></tr><tr><td>Layer 6<br>表现层<br>Presentation Layer</td><td>我们在应用程序上面所制作出来的数据格式不一定符合网络传输的标准编码格式的！ 所以，在这个层级当中，主要的动作就是：将来自本地端应用程序的数据格式转换(或者是重新编码)成为网络的标准格式， 然后再交给底下传送层等的协议来进行处理。所以，在这个层级上面主要定义的是网络服务(或程序)之间的数据格式的转换， 包括数据的加解密也是在这个分层上面处理。</td></tr><tr><td>Layer 7<br>应用层<br>Application Layer</td><td>应用层本身并不属于应用程序所有，而是在定义应用程序如何进入此层的沟通接口，以将数据接收或传送给应用程序，最终展示给用户。</td></tr></tbody></table><p>事实上，OSI 七层协议只是一个参考的模型 (model)，目前的网络社会并没有什么很知名的操作系统在使用 OSI 七层协议的联网程序代码。那…讲这么多干嘛？这是因为 OSI 所定义出来的七层协议在解释网络传输的情况来说，可以解释的非常棒，因此大家都拿 OSI 七层协议来做为网络的教学与概念的理解。至于实际的联网程序代码，那就交给 TCP/IP 了！</p><h3 id="4、计算机网络协议：-TCP-IP"><a href="#4、计算机网络协议：-TCP-IP" class="headerlink" title="4、计算机网络协议： TCP/IP"></a>4、计算机网络协议： TCP/IP</h3><p>虽然 OSI 七层协议的架构非常严谨，是学习网络的好材料。但是也就是因为太过严谨了，因此程序撰写相当不容易，所以造成它在发展上面些许的困扰。而由 ARPANET 发展而来的 TCP/IP 又如何呢？其实 TCP/IP 也是使用 OSI 七层协议的观念，所以同样具有分层的架构，只是将它简化为四层，在结构上面比较没有这么严谨，程序撰写会比较容易些。后来在 1990 年代由于 email, WWW 的流行，造成 TCP/IP 这个标准为大家所接受，这也造就目前我们的网络社会！</p><p>既然 TCP/IP 是由 OSI 七层协议简化而来，那么这两者之间有没有什么相关性呢？它们的相关性可以图示如下， 同时这里也列出目前在这架构底下常见的通讯协议、封包格式与相关标准：<br><img src="/uploads/2018/01/network_osi_tcpip.JPG" alt=""></p><p>从上图中，我们可以发现 TCP/IP 将应用、表现、会谈三层整合成一个应用层，在应用层上面可以实作的程序协议有 HTTP, SMTP, DNS 等等。 传送层则没有变，不过依据传送的可靠性又将封包格式分为连接导向的 TCP 及非连接导向的 UDP 封包格式。网络层也没有变，主要内容是提供了 IP 封包，并可选择最佳路由来到达目标 IP 地址。数据链结层与物理层则整合成为一个链结层，包括定义硬件讯号、 讯框转位串的编码等等，因此主要与硬件 (不论是区网还是广域网) 有关。</p><p>那 TCP/IP 是如何运作的呢？我们就拿妳常常连上的 Yahoo 入口网站来做个说明好了，整个联机的状态可以这样看：</p><blockquote><p>1.应用程序阶段：妳打开浏览器，在浏览器上面输入网址列，按下 [Enter]。此时网址列与相关数据会被浏览器包成一个数据， 并向下传给 TCP/IP 的应用层；<br>2.应用层：由应用层提供的 HTTP 通讯协议，将来自浏览器的数据报起来，并给予一个应用层表头，再向传送层丢去；<br>3.传送层：由于 HTTP 为可靠联机，因此将该数据丢入 TCP 封包内，并给予一个 TCP 封包的表头，向网络层丢去；<br>4.网络层：将 TCP 包裹包进 IP 封包内，再给予一个 IP 表头 (主要就是来源与目标的 IP)，向链结层丢去；<br>5.链结层：如果使用以太网络时，此时 IP 会依据 CSMA/CD 的标准，包裹到MAC 讯框中，并给予 MAC 表头，再转成位串后， 利用传输媒体传送到远程主机上。</p></blockquote><p>等到 Yahoo 收到你的包裹后，在依据相反方向拆解开来，然后交给对应的层级进行分析，最后就让 Yahoo 的 WWW 服务器软件得到你所想要的数据，该服务器软件再根据你的要求，取得正确的资料后，又依循上述的流程，一层一层的包装起来， 最后传送到你的手上！就是这样！</p><p>根据这样的流程，我们就得要知道每个分层所需要了解的基础知识，这样才算学习网络基础.所以下面一节我们会依据 TCP/IP 的链结层、网络层、传送层来进行说明，应用层的协议则在以后对应的协定再来谈！</p><h3 id="5、Linux-网络相关配置文件案"><a href="#5、Linux-网络相关配置文件案" class="headerlink" title="5、Linux 网络相关配置文件案"></a>5、Linux 网络相关配置文件案</h3><p>我们知道 TCP/IP 的重要参数主要是： IP, Netmask, Gateway, DNS IP ，而且千万不要忘记你这部主机也应该要有主机名 (hostname)！此外，我们也知道 IP 的取得有手动设定、DHCP 处理等。那么这些参数主要是写在哪些配置文件？如何对应呢？底下就让我们来处理一番！</p><table><thead><tr><th>所需网络参数</th><th>主要配置文件档名</th><th>重要参数</th></tr></thead><tbody><tr><td>IP、Netmask、DHCP 与 Gateway 等<br></td><td>/etc/sysconfig/network-scripts/ifcfg-eth0</td><td>DEVICE=网卡的代号<br>BOOTPROTO=是否使用 dhcp<br>HWADDR=是否加入网卡卡号(MAC)<br>IPADDR=就是IP 地址<br>NETMASK=指网络屏蔽<br>ONBOOT=要不要默认启动此接口<br>GATEWAY=就是通讯闸<br>NM_CONTROLLED=额外的网管软件</td></tr><tr><td>主机名</td><td>/etc/sysconfig/network</td><td>NETWORKING=要不要有网络<br>NETWORKING_IPV6=支援IPv6 否？<br>HOSTNAME=你的主机名</td></tr><tr><td>DNS IP</td><td>/etc/resolv.conf</td><td>nameserver DNS 的IP</td></tr><tr><td>私有IP对应的主机名</td><td>/etc/hosts</td><td>私有IP 主机名 别名</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、计算机网络组成组件&quot;&gt;&lt;a href=&quot;#1、计算机网络组成组件&quot; class=&quot;headerlink&quot; title=&quot;1、计算机网络组成组件&quot;&gt;&lt;/a&gt;1、计算机网络组成组件&lt;/h3&gt;&lt;p&gt;我们以底下这张联机示意图来解释好了：&lt;br&gt;&lt;img src=&quot;/uploads/2018/01/network_component.JPG&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux之定时任务详解</title>
    <link href="http://yoursite.com/2018/01/04/Linux%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/04/Linux之定时任务详解/</id>
    <published>2018-01-04T06:17:53.000Z</published>
    <updated>2018-01-18T07:01:55.911Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Linux-工作排程的种类：-at-cron"><a href="#1、Linux-工作排程的种类：-at-cron" class="headerlink" title="1、Linux 工作排程的种类： at, cron"></a>1、Linux 工作排程的种类： at, cron</h3><ol><li>at ：at 是个可以处理仅执行一次就结束排程的指令，不过要执行 at 时，必须要有 atd 这个服务的支援才行。在某些新版的 distributions 中，atd 可能预设并没有启动，那么 at 这个指令就会失效！不过我们的 CentOS 预设是启动的。</li><li>crontab ：crontab 这个指令所设定的工作将会循环的一直进行下去！可循环的时间为分钟、小时、每周、每月或每年等。crontab 除了可以使用指令执行外，亦可编辑 /etc/crontab 来支持。至于让 crontab 可以生效的服务则是 crond 这个服务。<a id="more"></a></li></ol><h3 id="2、atd-的启动与-at-运作的方式"><a href="#2、atd-的启动与-at-运作的方式" class="headerlink" title="2、atd 的启动与 at 运作的方式"></a>2、atd 的启动与 at 运作的方式</h3><p>要使用单一工作排程时，我们的 Linux 系统上面必须要有负责这个排程的服务，那就是 atd ！不过并非所有的 Linux distributions 都预设会把他打开的，所以，某些时刻我们必须要手动将他启用才行。启用的方法很简单，就是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# /etc/init.d/atd restart</span><br><span class="line">正在停止 atd: [ 确定 ]</span><br><span class="line">正在激活 atd: [ 确定 ]</span><br><span class="line"># 再设定一下开机时就启动这个服务，免得每次重新启动都得再来一次！</span><br><span class="line">[root@www ~]# chkconfig atd on</span><br></pre></td></tr></table></figure></p><h4 id="（1）at-的运作方式"><a href="#（1）at-的运作方式" class="headerlink" title="（1）at 的运作方式"></a>（1）at 的运作方式</h4><p>既然是工作排程，那么应该会有产生工作的方式，并且将这些工作排进行程表中！那么产生工作的方式是怎么进行的？事实上，我们使用 at 这个指令来产生所要运作的工作，并将这个工作以文本文件的方式写入 /var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与执行了。就这么简单。<br>不过，并不是所有的人都可以进行 at 工作排程！为什么？因为安全的理由，很多主机被所谓的【绑架】后，最常发现的就是他们的系统当中多了很多的怪客程序 (cracker program)， 这些程序非常可能运用工作排程来执行或搜集系统信息，并定时的回报给怪客团体！所以，除非是你认可的账号，否则先不要让他们使用 at ！那怎么达到使用 at 的列管呢？<br>我们可以利用 /etc/at.allow 与 /etc/at.deny 这两个档案来进行 at 的使用限制！加上这两个档案后，at 的工作情况其实是这样的：</p><ol><li>先找寻 /etc/at.allow 这个档案，写在这个档案中的使用者才能使用 at ，没有在这个档案中的使用者则不能使用 at (即使没有写在 at.deny 当中)；</li><li>如果 /etc/at.allow 不存在，就寻找 /etc/at.deny 这个档案，若写在这个 at.deny 的使用者则不能使用at ，而没有在这个 at.deny 档案中的使用者，就可以使用 at ；</li><li>如果两个档案都不存在，那么只有 root 可以使用 at 这个指令。</li></ol><p>透过这个说明，我们知道 /etc/at.allow 是管理较为严格的方式，而 /etc/at.deny 则较为松散 (因为账号没有在该档案中，就能够执行 at 了)。在一般的 distributions 当中，由于假设系统上的所有用户都是可信任的，因此系统通常会保留一个空的 /etc/at.deny 档案，意思是允讲所有人使用 at 指令的意思 (您可以自行检查一下该档案)。不过，万一你不希望有某些使用者使用 at 的话，将那个使用者的账号写入 /etc/at.deny 即可！一个账号写一行。</p><h4 id="（2）实际运作单一工作排程"><a href="#（2）实际运作单一工作排程" class="headerlink" title="（2）实际运作单一工作排程"></a>（2）实际运作单一工作排程</h4><p>基本的语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# at [-mldv] TIME</span><br><span class="line">[root@www ~]# at -c 工作号码</span><br><span class="line">选项与参数：</span><br><span class="line">-m ：当 at 的工作完成后，即使没有输出讯息，亦以 email 通知使用者该工作已完成。</span><br><span class="line">-l ：at -l 相当于 atq，列出目前系统上面的所有该用户的 at 排程；</span><br><span class="line">-d ：at -d 相当于 atrm ，可以取消一个在 at 排程中的工作；</span><br><span class="line">-v ：可以使用较明显的时间格式栏出 at 排程中的任务栏表；</span><br><span class="line">-c ：可以列出后面接的该项工作的实际指令内容。</span><br><span class="line">TIME：时间格式，这里可以定义出【什么时候要进行 at 这项工作】的时间，格式有：</span><br><span class="line">HH:MM ex&gt; 04:00</span><br><span class="line">在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此工作。</span><br><span class="line">HH:MM YYYY-MM-DD ex&gt; 04:00 2009-03-17</span><br><span class="line">强制规定在某年某月的某一天的特殊时刻进行该工作！</span><br><span class="line">HH:MM[am|pm] [Month] [Date] ex&gt; 04pm March 17</span><br><span class="line">也是一样，强制在某年某月某日的某时刻进行！</span><br><span class="line">HH:MM[am|pm] + number [minutes|hours|days|weeks]</span><br><span class="line">ex&gt; now + 5 minutes ex&gt; 04pm + 3 days</span><br><span class="line">就是说，在某个时间点【再加几个时间后】才进行。</span><br></pre></td></tr></table></figure></p><p>老实说，这个 at 指令的下达最重要的地方在于【时间】的指定了！一般使用【 now + … 】的方式来定义现在过多少时间再进行工作，但有时也需要定义特定的时间点来进行！底下的范例先看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">范例一：再过五分钟后，将 /root/.bashrc 寄给 root 自己</span><br><span class="line">[root@www ~]# at now + 5 minutes &lt;==记得单位要加 s</span><br><span class="line">at&gt; /bin/mail root -s &quot;testing at job&quot; &lt; /root/.bashrc</span><br><span class="line">at&gt; &lt;EOT&gt; &lt;==这里输入 [ctrl] + d 就会出现 &lt;EOF&gt; 的字样！代表结束！</span><br><span class="line">job 4 at 2009-03-14 15:38</span><br><span class="line"># 上面这行信息在说明，第 4 个 at 工作将在 2009/03/14 的 15:38 进行！</span><br><span class="line"># 而执行 at 会进入所谓的 at shell 环境，让你下达多重指令等待运作！</span><br><span class="line">范例二：将上述的第 4 项工作内容列出来查阅</span><br><span class="line">[root@www ~]# at -c 4</span><br><span class="line">#!/bin/sh &lt;==就是透过 bash shell </span><br><span class="line"># atrun uid=0 gid=0</span><br><span class="line"># mail root 0</span><br><span class="line">umask 22</span><br><span class="line">....(中间省略许多的环境变量项目)....</span><br><span class="line">cd /root || &#123; &lt;==可以看出，会到下达 at 时的工作目录去执行指令</span><br><span class="line">echo &apos;Execution directory inaccessible&apos; &gt;&amp;2</span><br><span class="line">exit 1</span><br><span class="line">&#125;</span><br><span class="line">/bin/mail root -s &quot;testing at job&quot; &lt; /root/.bashrc</span><br><span class="line"># 你可以看到指令执行的目录 (/root)，还有多个环境变量与实际的指令内容</span><br><span class="line">范例三：由于机房预计于 2009/03/18 停电，我想要在 2009/03/17 23:00 关机？</span><br><span class="line">[root@www ~]# at 23:00 2009-03-17</span><br><span class="line">at&gt; /bin/sync</span><br><span class="line">at&gt; /bin/sync</span><br><span class="line">at&gt; /sbin/shutdown -h now</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 5 at 2009-03-17 23:00</span><br><span class="line"># at 还可以在一个工作内输入多个指令</span><br></pre></td></tr></table></figure></p><p>事实上，当我们使用 at 时会进入一个 at shell 的环境来让用户下达工作指令，此时，建议你最好使用绝对路径来下达你的指令，比较不会有问题！由于指令的下达与 PATH 变量有关，同时与当时的工作目录也有关连(如果有牵涉到档案的话)，因此使用绝对路径来下达指令，会是比较一劳永逸的方法。</p><p>at 有另外一个很棒的优点，那就是【背景执行】的功能！由于 at 工作排程的使用上，系统会将该项 at 工作独立出你的 bash 环境中，直接交给系统的 atd 程序来接管，因此，当你下达了 at 的工作之后就可以立刻脱机了，剩下的工作就完全交给 Linux 管理即可！所以，如果有长时间的网络工作时，使用 at 可以让你免除网络断线后的困扰！</p><h3 id="3、循环执行的例行性工作排程"><a href="#3、循环执行的例行性工作排程" class="headerlink" title="3、循环执行的例行性工作排程"></a>3、循环执行的例行性工作排程</h3><p>相对于 at 是仅执行一次的工作，循环执行的例行性工作排程则是由 cron (crond) 这个系统服务来控制的。刚刚谈过 Linux 系统上面原本就有非常多的例行性工作，因此这个系统服务是默认启动的。另外，由于使用者自己也可以进行例行性工作排程，所以，Linux 也提供使用者控制例行性工作排程的指令(crontab)。底下我们分别来聊一聊：</p><h4 id="（1）使用者的设定"><a href="#（1）使用者的设定" class="headerlink" title="（1）使用者的设定"></a>（1）使用者的设定</h4><p>使用者想要建立循环型工作排程时，使用的是 crontab 这个指令。不过，为了安全性的问题，与 at 同样的，我们可以限制使用 crontab 的使用者账号！使用的限制数据有：</p><ul><li>/etc/cron.allow：将可以使用 crontab 的账号写入其中，若不在这个档案内的使用者则不可使用 crontab；</li><li>/etc/cron.deny：将不可以使用 crontab 的账号写入其中，若未记录到这个档案当中的使用者，就可以使用crontab 。</li></ul><p>与 at 很像。同样的，以优先级来说，/etc/cron.allow 比 /etc/cron.deny 要优先，而判断上面，这两个档案只选择一个来限制而已，因此，建议你只要保留一个即可，免得影响自己在设定上面的判断！一般来说，系统默认是保留 /etc/cron.deny，你可以将不想让他执行 crontab 的那个使用者写入 /etc/cron.deny 当中，一个账号一行！</p><p>当用户使用 crontab 这个指令来建立工作排程之后，该项工作就会被记录到 /var/spool/cron/ 里面去，而且是以账号来作为判别的。举例来说，dmtsai 使用 crontab 后，他的工作会被记录到 /var/spool/cron/dmtsai 里头去！但请注意，不要使用 vi 直接编辑该档案，因为可能由于输入语法错误，会导致无法执行 cron 。另外，cron 执行的每一项工作都会被记录到 /var/log/cron 这个登录档中，所以，如果你的 Linux 不知道有否被植入木马时，也可以搜寻一下 /var/log/cron 这个登录档！</p><h4 id="（2）crontab-的语法："><a href="#（2）crontab-的语法：" class="headerlink" title="（2）crontab 的语法："></a>（2）crontab 的语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# crontab [-u username] [-l|-e|-r]</span><br><span class="line">选项与参数：</span><br><span class="line">-u ：只有 root 才能进行这个任务，亦即帮其他使用者建立/移除 crontab 工作排程；</span><br><span class="line">-e ：编辑 crontab 的工作内容</span><br><span class="line">-l ：查阅 crontab 的工作内容</span><br><span class="line">-r ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。</span><br><span class="line">范例一：用 dmtsai 的身份在每天的 12:00 发信给自己</span><br><span class="line">[dmtsai@www ~]$ crontab -e</span><br><span class="line"># 此时会进入 vi 的编辑画面让您编辑工作！注意到，每项工作都是一行。</span><br><span class="line">0 12 * * * mail dmtsai -s &quot;at 12:00&quot; &lt; /home/dmtsai/.bashrc</span><br><span class="line">#分 时 日 月 周 |&lt;==============指令串========================&gt;|</span><br></pre></td></tr></table></figure><p>预设情况下，任何使用者只要不被列入 /etc/cron.deny 当中，那么他就可以直接下达【 crontab -e 】去编辑自己的例行性命令。整个过程就如同上面提到的，会进入 vi 的编辑画面，然后以一个工作一行来编辑，编辑完毕之后输入【 :wq 】储存后离开 vi 就可以了。而每项工作 (每行) 的格式都是具有六个字段，这六个字段的意义为：<br><img src="/uploads/2018/01/linux_crontab_01.png" alt=""><br>比较有趣的是那个【周】，周的数字为 0 或 7 时，都代表【星期天】的意思！另外，还有一些辅助的字符，大概有底下这些：<br><img src="/uploads/2018/01/linux_crontab_02.png" alt=""><br><strong>（注：那个 crontab 每个人都只有一个档案存在，就是在 /var/spool/cron 里面！还有建议：【指令下达时，最好使用绝对路径，这样比较不会找不到执行档。】）</strong></p><h4 id="（3）系统的配置文件：-etc-crontab"><a href="#（3）系统的配置文件：-etc-crontab" class="headerlink" title="（3）系统的配置文件： /etc/crontab"></a>（3）系统的配置文件： /etc/crontab</h4><p>如果是【系统的例行性任务】时，你只要编辑 /etc/crontab 这个档案就可以。有一点需要特别注意！那就是 crontab -e 这个 crontab 其实是 /usr/bin/crontab 这个执行档，但是 /etc/crontab 可是一个【纯文本档】。你可以 root 的身份编辑一下这个档案。<br>基本上， cron 这个服务的最低侦测限制是【分钟】，所以【 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron 里面的数据内容 】，因此，只要你编辑完 /etc/crontab 这个档案，并且将他储存之后，那么 cron 的设定就自动的会来执行了。</p><p>下面是 /etc/crontab 的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat /etc/crontab</span><br><span class="line">SHELL=/bin/bash &lt;==使用哪种 shell 接口</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin &lt;==执行文件搜寻路径</span><br><span class="line">MAILTO=root &lt;==若有额外STDOUT，以 email 将数据送给谁</span><br><span class="line">HOME=/ &lt;==默认此 shell 的家目录所在</span><br><span class="line"># run-parts</span><br><span class="line">01 * * * * root run-parts /etc/cron.hourly &lt;==每小时</span><br><span class="line">02 4 * * * root run-parts /etc/cron.daily &lt;==每天</span><br><span class="line">22 4 * * 0 root run-parts /etc/cron.weekly &lt;==每周日</span><br><span class="line">42 4 1 * * root run-parts /etc/cron.monthly &lt;==每个月 1 号</span><br><span class="line">分 时 日 月 周 执行者身份 指令串</span><br></pre></td></tr></table></figure></p><p>看到这个档案的内容你大概就了解了吧。这个档案与将刚刚我们下达 crontab -e 的内容几乎完全一模一样！只是有几个地方不太相同：</p><blockquote><p><strong>MAILTO=root：</strong><br>    这个项目是说，当 /etc/crontab 这个档案中的例行性工作的指令发生错误时，或者是该工作的执行结果有 STDOUT/STDERR 时，会将错误讯息或者是屏幕显示的讯息传给谁？默认当然是由系统直接寄发一封 mail 给 root。不过，由于 root 并无法在客户端中以 POP3 之类的软件收信，因此，通常都将这个 e-mail 改成自己的账号，好随时了解系统的状况！例如：MAILTO=dmtsai@my.host.name<br><strong>PATH=….：</strong><br>    在 BASH 当中一直提到的执行文件路径问题。这里就是输入执行文件的搜寻路径！使用默认的路径设定就已经很足够了。<br><strong>01 <em> </em> <em> </em> root run-parts /etc/cron.hourly：</strong><br>    这个 /etc/crontab 里面默认定义出四项工作任务，分别是每小时、每天、每周及每个月分别进行一次的工作！但是在五个字段后面接的并不是挃令，而是一个新的字段，那就是【执行后面那串指令的身份】为何。这不使用者的 crontab -e 不相同。由于使用者自己的 crontab 并不需要指定身份，但 /etc/crontab 里面当然要指定身份。以上表的内容来说，系统默认的例行性工作是以 root 的身份来进行的。<br>    那么后面那串指令是什么呢？你可以使用【 which run-parts 】搜寻看看，其实那是一个 bash script！如果你直接进入 /usr/bin/run-parts 去看看，会发现这支指令会将后面接的【目录】内的所有档案捉出来执行！这也就是说【如果你想让系统每小时主动帮你执行某个指令，将该指令写成 script，并将该档案放置到 /etc/cron.hourly/ 目录下即可】的意思。<br>    现在你知道系统是如何进行他默认的一堆例行性工作排程了吗？如果你下达【 ll /etc/cron.daily 】就可以看到一堆档案，那些档案就是系统提供的 script ，而这堆 scripts 将会在每天的凌晨 4:02 开始运作！这也是为啥如果你是夜猫族，就会发现奇怪的是，Linux 系统为何早上 4:02 开始会很忙碌的发出一些硬盘跑动的声音！因为他必须要进行 makewhatis,pdatedb, rpm rebuild 等等的任务。</p></blockquote><p>由于 CentOS 提供的 run-parts 这个 script 的辅助，因此 /etc/crontab 这个档案里面支持两种下达指令的方式，一种是直接下达指令，一种则是以目录来规划，例如：</p><blockquote><p><strong>指令型态</strong><br><code>01 * * * * dmtsai mail -s &quot;testing&quot; kiki &lt; /home/dmtsai/test.txt</code><br>以 dmtsai 这个使用者的身份，在每小时执行一次 mail 指令。<br><strong>目录规划</strong><br><code>*/5 * * * * root run-parts /root/runcron</code><br>建立一个 /root/runcron 的目录，将要每隔五分钟执行的【可执行文件】都写到该目录下，就可以让系统每五分钟执行一次该目录下的所有可执行文件。</p></blockquote><h3 id="4、一些注意事项："><a href="#4、一些注意事项：" class="headerlink" title="4、一些注意事项："></a>4、一些注意事项：</h3><h4 id="（1）资源分配不均的问题"><a href="#（1）资源分配不均的问题" class="headerlink" title="（1）资源分配不均的问题"></a>（1）资源分配不均的问题</h4><p>如果每个流程都在同一个时间启动的话，那么在某个时段时，我的系统会变的相当的繁忙，所以，这个时候就必须要分别设定。我可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# vi /etc/crontab</span><br><span class="line">1,6,11,16,21,26,31,36,41,46,51,56 * * * * root CMD1</span><br><span class="line">2,7,12,17,22,27,32,37,42,47,52,57 * * * * root CMD2</span><br><span class="line">3,8,13,18,23,28,33,38,43,48,53,58 * * * * root CMD3</span><br><span class="line">4,9,14,19,24,29,34,39,44,49,54,59 * * * * root CMD4</span><br></pre></td></tr></table></figure></p><p>看到了没？那个【 , 】分隔的时候，请注意，不要有空格符！（连续的意思）如此一来，则可以将每五分钟工作的流程分别在不同的时刻来工作！则可以让系统的执行较为顺畅！</p><h4 id="（2）取消不要的输出项目"><a href="#（2）取消不要的输出项目" class="headerlink" title="（2）取消不要的输出项目"></a>（2）取消不要的输出项目</h4><p>另外一个困扰发生在【 当有执行成果或者是执行的项目中有输出的数据时，该数据将会 mail 给 MAILTO 设定的账号 】，那么当有一个排程一直出错（例如 DNS 的侦测系统当中，若 DNS 上层主机挂掉，那么你就会一直收到错误讯息！）怎么办？可以使用数据流重导向直接以【命令重导向】将输出的结果输出到 /dev/null 这个垃圾桶当中就好了！</p><h4 id="（3）安全的检验"><a href="#（3）安全的检验" class="headerlink" title="（3）安全的检验"></a>（3）安全的检验</h4><p>很多时候被植入木马都是以例行命令的方式植入的，所以可以藉由检查 /var/log/cron 的内容来视察是否有【非您设定的 cron 被执行了？】这个时候就需要小心一点！</p><h4 id="（4）周与日月不可同时并存"><a href="#（4）周与日月不可同时并存" class="headerlink" title="（4）周与日月不可同时并存"></a>（4）周与日月不可同时并存</h4><p>另一个需要注意的地方在于：【你可以分别以周或者是日月为单位作为循环，但你不可使用「几月几号且为星期几」的模式工作】。这个意思是说，你不可以这样编写一个工作排程：<br>    30 12 11 9 5 root echo “just test” &lt;==这是错诨癿写法<br>本来你以为九月十一号且为星期五才会进行这项工作，无奈的是，系统可能会判定每个星期五作一次，或每年的 9 月 11 号分别进行，如此一来与你当初的规划就不一样了。所以，得要注意这个地方！上述的写法是不对的！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、Linux-工作排程的种类：-at-cron&quot;&gt;&lt;a href=&quot;#1、Linux-工作排程的种类：-at-cron&quot; class=&quot;headerlink&quot; title=&quot;1、Linux 工作排程的种类： at, cron&quot;&gt;&lt;/a&gt;1、Linux 工作排程的种类： at, cron&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;at ：at 是个可以处理仅执行一次就结束排程的指令，不过要执行 at 时，必须要有 atd 这个服务的支援才行。在某些新版的 distributions 中，atd 可能预设并没有启动，那么 at 这个指令就会失效！不过我们的 CentOS 预设是启动的。&lt;/li&gt;
&lt;li&gt;crontab ：crontab 这个指令所设定的工作将会循环的一直进行下去！可循环的时间为分钟、小时、每周、每月或每年等。crontab 除了可以使用指令执行外，亦可编辑 /etc/crontab 来支持。至于让 crontab 可以生效的服务则是 crond 这个服务。
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Crontab" scheme="http://yoursite.com/tags/Crontab/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之Shell Scripts</title>
    <link href="http://yoursite.com/2018/01/03/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8BShell-Scripts/"/>
    <id>http://yoursite.com/2018/01/03/认识与学习BASH之Shell-Scripts/</id>
    <published>2018-01-03T09:14:14.000Z</published>
    <updated>2018-01-18T07:00:39.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是Shell-Script"><a href="#一、什么是Shell-Script" class="headerlink" title="一、什么是Shell Script"></a>一、什么是Shell Script</h3><p>什么是 shell script (程序化脚本) 呢？就字面上的意义，我们将他分为两部份。在【 shell 】部分，我们在 BASH 当中已经提过了，那是一个文字接口底下让我们与系统沟通的一个工具接口。那么【 script 】是啥？字面上的意义，script 是【脚本、剧本】的意思。整句话是说，shell script 是针对 shell 所写的【剧本！】</p><p>什么东西啊？其实，shell script 是利用 shell 的功能所写的一个【程序 (program)】，这个程序是使用纯文本文件，将一些 shell 的语法与指令(含外部指令)写在里面，搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的。<br><a id="more"></a><br>所以，简单的说，shell script 就像是早期 DOS 年代的批处理文件 (.bat) ，最简单的功能就是将许多指令汇整写在一起，让使用者很轻易的就能够 one touch 的方法去处理复杂的动作 (执行一个档案”shell script” ，就能够一次执行多个指令)。而且 shell script 更提供数组、循环、条件与逻辑判断等重要功能，让用户也可以直接以 shell 来撰写程序，而不必使用类似 C 程序语言等传统程序撰写的语法。shell script 可以简单的被看成是批处理文件，也可以被说成是一个程序语言，且这个程序语言由于都是利用 shell 与相关工具指令，所以不需要编译即可执行，且拥有不错的除错 (debug) 工具，所以，他可以帮助系统管理员快速的管理好主机。</p><p>shell script 号称是程序 (program) ，但实际上，shell script 处理数据的速度上是不太够的。因为 shell script 用的是外部的指令与 bash shell 的一些默认工具，所以，他常常会去呼叫外部的函式库，因此，指令周期上面当然比不上传统的程序语言。所以，shell script 用在系统管理上面是很好的一项工具，但是用在处理大量数值运算上，就不够好了，因为 Shell scripts 的速度较慢，且使用的 CPU 资源较多，造成主机资源的分配不良。我们通常利用 shell script 来处理服务器的侦测，倒是没有进行大量运算的需求！所以不必担心。</p><h4 id="Shell执行及注意事项"><a href="#Shell执行及注意事项" class="headerlink" title="Shell执行及注意事项"></a>Shell执行及注意事项</h4><p>在 shell script 的撰写中还需要用到底下的注意事项：</p><ol><li>指令的执行是从上而下、从左而右的分析与执行；</li><li>指令的下达就是： 指令、选项与参数间的多个空白都会被忽略掉；</li><li>空白行也将被忽略掉，并且 [tab] 按键所推开的空白同样视为空格键；</li><li>如果读取到一个 Enter 符号 (CR) ，就尝试开始执行该行 (或该串) 命令；</li><li>至于如果一行的内容太多，则可以使用【 [Enter] 】来延伸至下一行；</li><li>【 # 】可做为批注！任何加在 # 后面的资料将全部被视为批注文字而被忽略！</li></ol><p>如此一来，我们在 script 内所撰写的程序，就会被一行一行的执行。现在我们假设你写的这个程序文件名是 /home/dmtsai/shell.sh 好了，那如何执行这个档案？很简单，可以有底下几个方法：</p><ul><li>直接指令下达： shell.sh 档案必须要具备可读与可执行 (rx) 的权限，然后：<ul><li>绝对路径：使用 /home/dmtsai/shell.sh 来下达指令；</li><li>相对路径：假设工作目录在 /home/dmtsai/ ，则使用 ./shell.sh 来执行</li><li>变量【PATH】功能：将 shell.sh 放在 PATH 指定的目录内，例如： ~/bin/(目录需要自行设定) 。此时，若 shell.sh 在 ~/bin 内且具有 rx 的权限，那就直接输入 shell.sh 即可执行该脚本程序！</li></ul></li><li>以 bash 程序来执行：透过【 bash shell.sh 】或【 sh shell.sh 】来执行</li></ul><p>反正重点就是要让那个 shell.sh 内的指令可以被执行的意思。</p><h3 id="二、简单的shell-script练习"><a href="#二、简单的shell-script练习" class="headerlink" title="二、简单的shell script练习"></a>二、简单的shell script练习</h3><h4 id="（1）撰写第一支-script：输出Hello-World！"><a href="#（1）撰写第一支-script：输出Hello-World！" class="headerlink" title="（1）撰写第一支 script：输出Hello World！"></a>（1）撰写第一支 script：输出Hello World！</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# mkdir scripts; cd scripts</span><br><span class="line">[root@www scripts]# vi sh01.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"># Program:</span><br><span class="line"># This program shows &quot;Hello World!&quot; in your screen.</span><br><span class="line"># History:</span><br><span class="line"># 2005/08/23 VBird First release</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line">echo -e &quot;Hello World! \a \n&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>在本章当中，请将所有撰写的 script 放置到你家目录的 ~/scripts 这个目录内，未来比较好管理。<br>上面的写法当中，主要将整个程序的撰写分成数段，大致是这样：</p><blockquote><p>1.第一行 #!/bin/bash 在宣告这个 script 使用的 shell 名称：<br>因为我们使用的是 bash ，所以，必须要以【 #!/bin/bash 】来宣告这个档案内的语法使用 bash 的语法！那么当这个程序被执行时，他就能够加载 bash 的相关环境配置文件 (一般来说就是 non-login shell 的 ~/.bashrc)， 并且执行 bash 来使我们底下的指令能够执行！这很重要！(在很多状况中，如果没有设定好这一行，那么该程序很可能会无法执行，因为系统可能无法判断该程序需要使用什么 shell 来执行！)<br>2.程序内容的说明：<br>整个 script 当中，除了第一行的【 #! 】是用来宣告 shell 的之外，其他的 # 都是【批注】用途！所以上面的程序当中，第二行以下就是用来说明整个程序的基本数据。一般来说，建议你一定要养成说明该 script 的：1. 内容与功能； 2. 版本信息； 3. 作者与联绚方式； 4. 建檔日期；5. 历史纪录 等等。这将有助于未来程序的改写与 debug。<br>3.主要环境变量的宣告：<br>建议务必要将一些重要的环境变量设定好，PATH 与 LANG (如果有使用到输出相关的信息时) 是当中最重要的！如此一来，则可让我们这支程序在进行时，可以直接下达一些外部指令，而不必写绝对路径！<br>4.主要程序部分<br>就将主要的程序写好即可！在这个例子当中，就是 echo 那一行！<br>5.执行成果告知 (定义回传值)<br>是否记得我们在讨论一个指令的执行成功与否，可以使用 $? 这个变量来观察。那么我们也可以利用 exit 这个指令来让程序中断，并且回传一个数值给系统。在我们这个例子当中，使用 exit 0 ，这代表离开 script 并且回传一个 0 给系统，所以我执行完这个 script 后，若接着下达 echo $? 则可得到 0 的值！更聪明的读者应该也知道，利用这个 exit n (n 是数字) 的功能，我们还可以自定义错误讯息，让这支程序发得更加的 smart ！接下来透过刚刚上头介绍的执行方法来执行看看结果吧。</p></blockquote><h4 id="（2）简单范例"><a href="#（2）简单范例" class="headerlink" title="（2）简单范例"></a>（2）简单范例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">（1）对谈式脚本：变量内容由用户决定</span><br><span class="line">[root@www scripts]# vi sh02.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"># Program:</span><br><span class="line"># User inputs his first name and last name. Program shows his full</span><br><span class="line">name.</span><br><span class="line"># History:</span><br><span class="line"># 2005/08/23 VBird First release</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line">read -p &quot;Please input your first name: &quot; firstname # 提示使用者输入</span><br><span class="line">read -p &quot;Please input your last name: &quot; lastname # 提示使用者输入</span><br><span class="line">echo -e &quot;\nYour full name is: $firstname $lastname&quot; # 结果由屏幕输出</span><br><span class="line"></span><br><span class="line">（2）随日期变化：利用date进行档案的建立</span><br><span class="line">[root@www scripts]# vi sh03.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"># Program:</span><br><span class="line"># Program creates three files, which named by user&apos;s input</span><br><span class="line"># and date command.</span><br><span class="line"># History:</span><br><span class="line"># 2005/08/23 VBird First release</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"># 1. 让使用者输入文件名，并取得 fileuser 这个变量；</span><br><span class="line">echo -e &quot;I will use &apos;touch&apos; command to create 3 files.&quot; # 纯粹显示信息</span><br><span class="line">read -p &quot;Please input your filename: &quot; fileuser # 提示使用者输入</span><br><span class="line"># 2. 为了避免使用者随意按 Enter ，利用变量功能分析档名是否有设定？</span><br><span class="line">filename=$&#123;fileuser:-&quot;filename&quot;&#125; # 开始判断有否配置文件名</span><br><span class="line"># 3. 开始利用 date 指令来取得所需要的档名；</span><br><span class="line">date1=$(date --date=&apos;2 days ago&apos; +%Y%m%d) # 前两天的日期</span><br><span class="line">date2=$(date --date=&apos;1 days ago&apos; +%Y%m%d) # 前一天的日期</span><br><span class="line">date3=$(date +%Y%m%d) # 今天的日期</span><br><span class="line">file1=$&#123;filename&#125;$&#123;date1&#125; # 底下三行在配置文件名</span><br><span class="line">file2=$&#123;filename&#125;$&#123;date2&#125;</span><br><span class="line">file3=$&#123;filename&#125;$&#123;date3&#125;</span><br><span class="line"># 4. 将档名建立</span><br><span class="line">touch &quot;$file1&quot; # 底下三行在建立档案</span><br><span class="line">touch &quot;$file2&quot;</span><br><span class="line">touch &quot;$file3&quot;</span><br><span class="line"></span><br><span class="line">（3）数值运算：简单的加减乘除</span><br><span class="line">[root@www scripts]# vi sh04.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"># Program:</span><br><span class="line"># User inputs 2 integer numbers; program will cross these two</span><br><span class="line">numbers.</span><br><span class="line"># History:</span><br><span class="line"># 2005/08/23 VBird First release</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line">echo -e &quot;You SHOULD input 2 numbers, I will cross them! \n&quot;</span><br><span class="line">read -p &quot;first number: &quot; firstnu</span><br><span class="line">read -p &quot;second number: &quot; secnu</span><br><span class="line">total=$(($firstnu*$secnu))</span><br><span class="line">echo -e &quot;\nThe result of $firstnu x $secnu is ==&gt; $total&quot;</span><br><span class="line"># 在数值的运算上，我们可以使用【 declare -i total=$firstnu*$secnu 】</span><br><span class="line"># 也可以使用上面的方式来进行。基本上，比较建议使用这样的方式来进行运算：</span><br><span class="line">var=$((运算内容))</span><br><span class="line"># 不但容易记忆，而且也比较方便的多，因为两个小括号内可以加上空格符！</span><br><span class="line"># 未来你可以使用这种方式来计算。至于数值运算上的处理，则有：【 +, -, *, /, % 】等等。</span><br></pre></td></tr></table></figure><h3 id="三、判断式"><a href="#三、判断式" class="headerlink" title="三、判断式"></a>三、判断式</h3><h4 id="（1）利用-test-指令的测试功能"><a href="#（1）利用-test-指令的测试功能" class="headerlink" title="（1）利用 test 指令的测试功能"></a>（1）利用 test 指令的测试功能</h4><p><img src="/uploads/2018/01/linux_shell_test_01.png" alt=""><br><img src="/uploads/2018/01/linux_shell_test_02.png" alt=""><br><img src="/uploads/2018/01/linux_shell_test_03.png" alt=""><br><img src="/uploads/2018/01/linux_shell_test_04.png" alt=""><br><img src="/uploads/2018/01/linux_shell_test_05.png" alt=""></p><p>OK！现在我们就利用 test 来帮我们写几个简单的例子。首先，判断一下，让使用者输入一个档名，我们判断：</p><ol><li>这个档案是否存在，若不存在则给予一个【Filename does not exist】的讯息，并中断程序；</li><li>若这个档案存在，则判断他是个档案或目录，结果输出【Filename is regular file】或【Filename is directory】</li><li>判断一下，执行者的身份对这个档案或目录所拥有的权限，并输出权限数据！<br><strong>（注意利用 test 与 &amp;&amp; 还有 || 等标志！）</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@www scripts]# vi sh05.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"># Program:</span><br><span class="line"># User input a filename, program will check the flowing:</span><br><span class="line"># 1.) exist? 2.) file/directory? 3.) file permissions</span><br><span class="line"># History:</span><br><span class="line"># 2005/08/25 VBird First release</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"># 1. 讥使用者输入档名，幵且刞断使用者是否真的有输入字符串？</span><br><span class="line">echo -e &quot;Please input a filename, I will check the filename&apos;s type and \</span><br><span class="line">permission. \n\n&quot;</span><br><span class="line">read -p &quot;Input a filename : &quot; filename</span><br><span class="line">test -z $filename &amp;&amp; echo &quot;You MUST input a filename.&quot; &amp;&amp; exit 0</span><br><span class="line"># 2. 刞断档案是否存在？若丌存在则显示讯息幵结束脚本</span><br><span class="line">test ! -e $filename &amp;&amp; echo &quot;The filename &apos;$filename&apos; DO NOT exist&quot; &amp;&amp;</span><br><span class="line">exit 0</span><br><span class="line"># 3. 开始刞断文件类型不属性</span><br><span class="line">test -f $filename &amp;&amp; filetype=&quot;regulare file&quot;</span><br><span class="line">test -d $filename &amp;&amp; filetype=&quot;directory&quot;</span><br><span class="line">test -r $filename &amp;&amp; perm=&quot;readable&quot;</span><br><span class="line">test -w $filename &amp;&amp; perm=&quot;$perm writable&quot;</span><br><span class="line">test -x $filename &amp;&amp; perm=&quot;$perm executable&quot;</span><br><span class="line"># 4. 开始输出信息！</span><br><span class="line">echo &quot;The filename: $filename is a $filetype&quot;</span><br><span class="line">echo &quot;And the permissions are : $perm&quot;</span><br></pre></td></tr></table></figure><h4 id="（2）利用判断符号"><a href="#（2）利用判断符号" class="headerlink" title="（2）利用判断符号 [ ]"></a>（2）利用判断符号 [ ]</h4><p>除了我们很喜欢使用的 test 之外，其实，我们还可以利用判断符号【 [ ] 】(就是中括号) 来进行数据的判断。举例来说，如果我想要知道 $HOME 这个变量是否为空的，可以这样做：<br><code>[root@www ~]# [ -z &quot;$HOME&quot; ] ; echo $?</code><br>使用中括号必须要特别注意，因为中括号用在很多地方，包括通配符与正规表示法等等，所以如果要在 bash 的语法当中使用中括号作为 shell 的判断式时，必须要注意中括号的两端需要有空格符来分隔。<br>最好要注意：</p><ul><li>在中括号 [] 内的每个组件都需要有空格键来分隔；</li><li>在中括号内的变数，最好都以双引号括号起来；</li><li>在中括号内的常数，最好都以单或双引号括号起来。</li></ul><p>举例来说，假如我设定了 <code>name=&quot;VBird Tsai&quot;</code> ，然后这样判定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# name=&quot;VBird Tsai&quot;</span><br><span class="line">[root@www ~]# [ $name == &quot;VBird&quot; ]</span><br><span class="line">bash: [: too many arguments</span><br></pre></td></tr></table></figure></p><p>怎么会发生错误？bash 还跟我说错误是由于【太多参数 (arguments)】所致。为什么呢？<br>因为 $name 如果没有使用双引号刮起来，那么上面的判定式会变成：<br>    <code>[ VBird Tsai == &quot;VBird&quot; ]</code><br>上面肯定不对了。因为一个判断式仅能有两个数据的比对，上面 VBird 与 Tsai 还有 “VBird” 就有三个资料。这不是我们要的，我们要的应该是底下这个样子：<br>    <code>[ &quot;VBird Tsai&quot; == &quot;VBird&quot; ]</code><br>这可是差很多。另外，中括号的使用方法与 test 几乎一模一样。</p><h3 id="四、条件判断式"><a href="#四、条件判断式" class="headerlink" title="四、条件判断式"></a>四、条件判断式</h3><h4 id="（1）利用if…then判断式"><a href="#（1）利用if…then判断式" class="headerlink" title="（1）利用if…then判断式"></a>（1）利用if…then判断式</h4><p>（1）单层、简单条件判断式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]; then</span><br><span class="line">当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line">fi &lt;==将 if 反过来写，就成为 fi ！结束 if 之意！</span><br><span class="line"></span><br><span class="line">括号与括号之间，则以 &amp;&amp; 或 || 来隔开，他们的意义是：</span><br><span class="line">&amp;&amp; 代表 AND ；</span><br><span class="line">|| 代表 or ；</span><br><span class="line">例如：[ &quot;$yn&quot; == &quot;Y&quot; -o &quot;$yn&quot; == &quot;y&quot; ] 可替换为：[ &quot;$yn&quot; == &quot;Y&quot; ] || [ &quot;$yn&quot; == &quot;y&quot; ]</span><br></pre></td></tr></table></figure></p><p>（2）多重、复杂条件判断式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 一个条件判断，分成功进行与失败进行 (else)</span><br><span class="line">if [ 条件判断式 ]; then</span><br><span class="line">当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line">else</span><br><span class="line">当条件判断式不成立时，可以进行的指令工作内容；</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 多个条件判断 (if ... elif ... elif ... else) 分多种不同情况执行</span><br><span class="line">if [ 条件判断式一 ]; then</span><br><span class="line">当条件判断式一成立时，可以进行的指令工作内容；</span><br><span class="line">elif [ 条件判断式二 ]; then</span><br><span class="line">当条件判断式二成立时，可以进行的指令工作内容；</span><br><span class="line">else</span><br><span class="line">当条件判断式一与二均不成立时，可以进行的指令工作内容；</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h4 id="（2）利用-case-…-esac-判断"><a href="#（2）利用-case-…-esac-判断" class="headerlink" title="（2）利用 case ….. esac 判断"></a>（2）利用 case ….. esac 判断</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case $变量名称 in &lt;==关键词为 case ，还有变数前有钱字号</span><br><span class="line">&quot;第一个变量内容&quot;) &lt;==每个变量内容建议用双引号括起来，关键词则为小括号 )</span><br><span class="line">程序段</span><br><span class="line">;; &lt;==每个类别结尾使用两个连续的分号来处理！</span><br><span class="line">&quot;第二个变量内容&quot;)</span><br><span class="line">程序段</span><br><span class="line">;;</span><br><span class="line">*) &lt;==最后一个变量内容都会用 * 来代表所有其他值，不包含第一个变量内容与第二个变量内容的其他程序执行段</span><br><span class="line">exit 1</span><br><span class="line">;;</span><br><span class="line">esac &lt;==最终的 case 结尾！【反过来写】思考一下！</span><br></pre></td></tr></table></figure><p>一般来说，使用【 case $变量 in 】这个语法中，当中的那个【 $变量 】大致有两种取得的方式：</p><ul><li>直接下达式：例如上面提到的，利用【 script.sh variable 】的方式来直接给予 $1 这个变量的内容，这也是在 /etc/init.d 目录下大多数程序的设计方式。</li><li>交互式：透过 read 这个指令来让用户输入变量的内容。</li></ul><h3 id="五、循环"><a href="#五、循环" class="headerlink" title="五、循环"></a>五、循环</h3><h4 id="（1）while-do-done-until-do-done-不定循环"><a href="#（1）while-do-done-until-do-done-不定循环" class="headerlink" title="（1）while do done, until do done (不定循环)"></a>（1）while do done, until do done (不定循环)</h4><p>一般来说，不定循环最常见的就是底下这两种状态了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ condition ] &lt;==中括号内的状态就是判断式</span><br><span class="line">do &lt;==do 是循环的开始！</span><br><span class="line">程序段落</span><br><span class="line">done &lt;==done 是循环的结束</span><br></pre></td></tr></table></figure></p><p>while 的中文是【当….时】，所以，这种方式说的是【当 condition 条件成立时，就进行循环，直到condition 的条件不成立才停止】的意思。还有另外一种不定循环的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ condition ]</span><br><span class="line">do</span><br><span class="line">程序段落</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>这种方式恰恰与 while 相反，它说的是【当 condition 条件成立时，就终止循环，否则就持续进行循环的程序段。】</p><h4 id="（2）for…do…done-固定循环"><a href="#（2）for…do…done-固定循环" class="headerlink" title="（2）for…do…done (固定循环)"></a>（2）for…do…done (固定循环)</h4><p>相对于 while, until 的循环方式是必须要【符合某个条件】的状态，for 这种语法，则是【 已经知道要进行几次循环】的状态！他的语法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in con1 con2 con3 ...</span><br><span class="line">do</span><br><span class="line">程序段</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><blockquote><p>以上面的例子来说，这个 $var 的变量内容在循环工作时：</p><pre><code>1. 第一次循环时， $var 的内容为 con1 ；2. 第二次循环时， $var 的内容为 con2 ；3. 第三次循环时， $var 的内容为 con3 ；4. ....</code></pre></blockquote><h4 id="（3）for…do…done-的数值处理"><a href="#（3）for…do…done-的数值处理" class="headerlink" title="（3）for…do…done 的数值处理"></a>（3）for…do…done 的数值处理</h4><p>除了上述的方法之外，for 循环还有另外一种写法！语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值; 限制值; 执行步阶 ))</span><br><span class="line">do</span><br><span class="line">程序段</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>这种语法适合于数值方式的运算当中，在 for 后面的括号内的三串内容意义为：</p><ul><li>初始值：某个变量在循环当中的起始值，直接以类似 i=1 设定好；</li><li>限制值：当变量的值在这个限制值的范围内，就继续进行循环。例如 i&lt;=100；</li><li>执行步阶：每作一次循环时，变量的变化量。例如 i=i+1。</li></ul><p>值得注意的是，在【执行步阶】的设定上，如果每次增加 1 ，则可以使用类似【i++】的方式，亦即是 i 每次循环都会增加一的意思。</p><h3 id="六、shell-script的追踪与debug"><a href="#六、shell-script的追踪与debug" class="headerlink" title="六、shell script的追踪与debug"></a>六、shell script的追踪与debug</h3><p>scripts 在执行之前，最怕的就是出现语法错误的问题了！那么我们如何 debug 呢？有没有办法不需要透过直接执行该 scripts 就可以来判断是否有问题呢？当然是有的，我们就直接以 bash 的相关参数来进行判断！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sh [-nvx] scripts.sh</span><br><span class="line">选项与参数：</span><br><span class="line">-n ：不要执行 script，仅查询语法的问题；</span><br><span class="line">-v ：再执行 sccript 前，先将 scripts 的内容输出到屏幕上；</span><br><span class="line">-x ：将使用到的 script 内容显示到屏幕上，这是很有用的参数！</span><br><span class="line">范例一：测试 sh16.sh 有无语法的问题？</span><br><span class="line">[root@www ~]# sh -n sh16.sh</span><br><span class="line"># 若语法没有问题，则不会显示任何信息！</span><br><span class="line">范例二：将 sh15.sh 的执行过程全部列出来～</span><br><span class="line">[root@www ~]# sh -x sh15.sh</span><br></pre></td></tr></table></figure></p><p>熟悉 sh 的用法，将可以使你在管理 Linux 的过程中得心应手！至于在 Shell scripts 的学习方法上面，需要【多看、多模仿、并加以修改成自己的样式！】是最快的学习手段了！网络上有相当多的朋友在<br>开发一些相当有用的 scripts ，若是你可以将对方的 scripts 拿来，并且改成适合自己主机的样子！那么学习的效果会是最快的！</p><p>另外，我们 Linux 系统本来就有很多的服务启动脚本，如果你想要知道每个 script 所代表的功能是什么？可以直接以 vim 进入该 script 去查阅一下，通常立刻就知道该 script 的目的了。 举例来说，我们之前一直提到的 /etc/init.d/syslog ，这个 script 是干嘛用的？ 利用 vi 去查阅最前面的几行字，他出现如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># description: Syslog is the facility by which many daemons use to log \</span><br><span class="line"># messages to various system log files. It is a good idea to always \</span><br><span class="line"># run syslog.</span><br><span class="line">### BEGIN INIT INFO</span><br><span class="line"># Provides: $syslog</span><br><span class="line">### END INIT INFO</span><br></pre></td></tr></table></figure></p><p>简单的说，这个脚本在启动一个名为 syslog 的常驻程序 (daemon)，这个常驻程序可以帮助很多系统服务记载她们的登录文件 (log file)，我们的 Linux 建议你一直启动 syslog 是个好主意！简单的看看您就知道啥是啥啦！</p><h3 id="附属：Shell-Script中的特殊变量："><a href="#附属：Shell-Script中的特殊变量：" class="headerlink" title="附属：Shell Script中的特殊变量："></a>附属：Shell Script中的特殊变量：</h3><p>Shell script 的默认变数($0, $1…)<br>一些较为特殊的变量可以在 script 内使用来呼叫这些参数：</p><ul><li>$# ：代表后接的参数【个数】，以上表为例这里显示为【 4 】；</li><li>$@ ：代表【 “$1” “$2” “$3” “$4” 】之意，每个变量是独立的(用双引号括起来)；</li><li>$* ：代表【 “$1c$2c$3c$4” 】，其中 c 为分隔字符，默认为空格键，所以本例中代表【 “$1 $2 $3 $4” 】之意。</li><li>$0 ：代表执行的脚本档名</li><li>$n ：代表对应输入的变量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、什么是Shell-Script&quot;&gt;&lt;a href=&quot;#一、什么是Shell-Script&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Shell Script&quot;&gt;&lt;/a&gt;一、什么是Shell Script&lt;/h3&gt;&lt;p&gt;什么是 shell script (程序化脚本) 呢？就字面上的意义，我们将他分为两部份。在【 shell 】部分，我们在 BASH 当中已经提过了，那是一个文字接口底下让我们与系统沟通的一个工具接口。那么【 script 】是啥？字面上的意义，script 是【脚本、剧本】的意思。整句话是说，shell script 是针对 shell 所写的【剧本！】&lt;/p&gt;
&lt;p&gt;什么东西啊？其实，shell script 是利用 shell 的功能所写的一个【程序 (program)】，这个程序是使用纯文本文件，将一些 shell 的语法与指令(含外部指令)写在里面，搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
      <category term="BASH" scheme="http://yoursite.com/tags/BASH/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之awk命令</title>
    <link href="http://yoursite.com/2017/12/29/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8Bawk%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/12/29/认识与学习BASH之awk命令/</id>
    <published>2017-12-29T09:56:49.000Z</published>
    <updated>2018-01-18T07:00:14.858Z</updated>
    
    <content type="html"><![CDATA[<h4 id="awk：好用的数据处理工具"><a href="#awk：好用的数据处理工具" class="headerlink" title="awk：好用的数据处理工具"></a>awk：好用的数据处理工具</h4><p>awk 也是一个非常棒的数据处理工具。相较于 sed 常常作用于一整个行的处理，awk 则比较倾向于一行当中分成数个【字段】来处理。因此，awk 相当的适合处理小型的数据数据处理。awk 通常运作的模式是这样的：<br><code>[root@www ~]# awk &#39;条件类型1{动作1} 条件类型2{动作2} ...&#39; filename</code></p><p>awk 后面接两个单引号并加上大括号 {} 来设定想要对数据进行的处理动作。awk 可以处理后续接的档案，也可以读取来自前个指令的 standard output 。但如前面说的，awk 主要是处理【每一行的字段内的数据】，而默认的【字段的分隔符为 “空格键” 或 “[tab]键”】。<br><a id="more"></a><br>举例来说，我们用 last 可以将登入者的数据取出来，结果如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# last -n 5 &lt;==仅取出前五行</span><br><span class="line">root pts/1 192.168.1.100 Tue Feb 10 11:21 still logged in</span><br><span class="line">root pts/1 192.168.1.100 Tue Feb 10 00:46 - 02:28 (01:41)</span><br><span class="line">root pts/1 192.168.1.100 Mon Feb 9 11:41 - 18:30 (06:48)</span><br><span class="line">dmtsai pts/1 192.168.1.100 Mon Feb 9 11:41 - 11:41 (00:00)</span><br><span class="line">root tty1 Fri Sep 5 14:09 - 14:10 (00:01)</span><br></pre></td></tr></table></figure></p><p>若我想要取出账号与登入者的 IP ，且账号与 IP 之间以 [tab] 隔开，则会变成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# last -n 5 | awk &apos;&#123;print $1 &quot;\t&quot; $3&#125;&apos;</span><br><span class="line">root 192.168.1.100</span><br><span class="line">root 192.168.1.100</span><br><span class="line">root 192.168.1.100</span><br><span class="line">dmtsai 192.168.1.100</span><br><span class="line">root Fri</span><br></pre></td></tr></table></figure></p><p>上表是 awk 最常使用的动作。透过 print 的功能将字段数据列出来，字段的分隔则以空格键或 [tab] 按键来隔开。因为不论哪一行我都要处理，因此，就不需要有 “条件类型” 的限制。我所想要的是第一栏以及第三栏，但是，第五行的内容怪怪的，这是因为数据格式的问题。所以，使用 awk 的时候，请先确认一下你的数据当中，如果是连续性的数据，请不要有空格或 [tab] 在内，否则，就会像这个例子这样，会发生误判。</p><p>另外，由上面这个例子你也会知道，在每一行的每个字段都是有变量名称的，那就是 $1, $2… 等变量名称。以上面的例子来说，root 是 $1 ，因为他是第一栏。至于 192.168.1.100 是第三栏，所以他就是 $3，后面以此类推。还有个变数，那就是 $0 ，$0 代表【一整列资料】的意思。以上面的例子来说，第一行的 $0 代表的就是【root ….】那一行。 由此可知，刚刚上面五行当中，整个 awk 的处理流程是：</p><pre><code>1. 读入第一行，并将第一行的资料填入 $0, $1, $2.... 等变数当中；2. 依据 &quot;条件类型&quot; 的限制，判断是否需要进行后面的 &quot;动作&quot;；3. 做完所有的动作与条件类型；4. 若还有后续的【行】的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。</code></pre><p>经过这样的步骤，你会晓得，awk 是【以行为一次处理的单位】，而【以字段为最小的处理单位】。那么 awk 怎么知道我到底这个数据有几行？有几栏？这就需要 awk 的内建变量的帮忙了。</p><table><thead><tr><th>变量名称</th><th>代表意义</th></tr></thead><tbody><tr><td>NF</td><td>每一行 ($0) 拥有的字段总数</td></tr><tr><td>NR</td><td>目前 awk 所处理的是【第几行】数据</td></tr><tr><td>FS</td><td>目前的分隔字符，默认是空格键</td></tr></tbody></table><p>我们继续以上面 last -n 5 的例子来做说明，如果我想要：</p><ul><li>列出每一行的账号(就是 $1)；</li><li>列出目前处理的行数(就是 awk 内的 NR 变量)</li><li>并且说明，该行有多少字段(就是 awk 内的 NF 变量)</li></ul><p><em>（注：awk 后续的所有动作是以单引号【 ‘ 】括住的，由于单引号与双引号都必须是成对的，所以，awk的格式内容如果想要以print打印时，记得非变量的文字部分，包含printf的格式中，都需要使用双引号来定义出来。因为单引号已经是 awk 的指令固定用法了！）</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# last -n 5| awk &apos;&#123;print $1 &quot;\t lines: &quot; NR &quot;\t columes: &quot; NF&#125;&apos;</span><br><span class="line">root lines: 1 columes: 10</span><br><span class="line">root lines: 2 columes: 10</span><br><span class="line">root lines: 3 columes: 10</span><br><span class="line">dmtsai lines: 4 columes: 10</span><br><span class="line">root lines: 5 columes: 9</span><br><span class="line"># 注意，在 awk 内的 NR, NF 等变量要用大写，且不需要有钱字号 $</span><br></pre></td></tr></table></figure><h4 id="awk-的逻辑运算字符"><a href="#awk-的逻辑运算字符" class="headerlink" title="awk 的逻辑运算字符"></a>awk 的逻辑运算字符</h4><p>既然有需要用到 “条件” 的类别，自然就需要一些逻辑运算。例如底下这些：<br><img src="/uploads/2017/12/linux_shell_awk_01.png" alt=""><br>值得注意的是那个【 == 】的符号，因为：    </p><ul><li>逻辑运算上面亦即所谓的大于、小于、等于等判断式上面，习惯上是以【 == 】来表示；</li><li>如果是直接给予一个值，例如变量设定时，就直接使用 = 而已。</li></ul><p>举例来说，在 /etc/passwd 当中是以冒号 “:” 来作为字段的分隔，该档案中第一字段为账号，第三字段则是UID。那假设我要查阅，第三栏小于 10 以下的数据，并且仅列出账号与第三栏，那么可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat /etc/passwd | awk &apos;&#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&apos;</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin 1</span><br><span class="line">daemon 2</span><br><span class="line">....(以下省略)....</span><br></pre></td></tr></table></figure></p><p>另外，如果要用 awk 来进行【计算功能】呢？以底下的例子来看，假设我有一个薪资数据表档名为 pay.txt ，内容是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name 1st 2nd 3th</span><br><span class="line">VBird 23000 24000 25000</span><br><span class="line">DMTsai 21000 20000 23000</span><br><span class="line">Bird2 43000 42000 41000</span><br></pre></td></tr></table></figure></p><p>如何帮我计算每个人的总额呢？而且我还想要格式化输出。我们可以这样考虑：</p><ul><li>第一行只是说明，所以第一行不要进行加总 (NR==1 时处理)；</li><li>第二行以后就会有加总的情况出现 (NR&gt;=2 以后处理)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat pay.txt | \</span><br><span class="line">&gt; awk &apos;NR==1&#123;printf</span><br><span class="line">&quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot; &#125;</span><br><span class="line">NR&gt;=2&#123;total = $2 + $3 + $4</span><br><span class="line">printf &quot;%10s %10d %10d %10d %10.2f\n&quot;, $1, $2, $3, $4, total&#125;&apos;</span><br><span class="line">Name 1st 2nd 3th Total</span><br><span class="line">VBird 23000 24000 25000 72000.00</span><br><span class="line">DMTsai 21000 20000 23000 64000.00</span><br><span class="line">Bird2 43000 42000 41000 126000.00</span><br></pre></td></tr></table></figure><p>上面的例子有几个重要事项应该要先说明的：</p><ul><li>awk 的指令间隔：所有 awk 的动作，亦即在 {} 内的动作，如果有需要多个指令辅助时，可利用分号【;】间隔，或者直接以 [Enter] 按键来隔开每个指令</li><li>逻辑运算当中，如果是【等于】的情况，则务必使用两个等号【==】！</li><li>格式化输出时，在 printf 的格式设定当中，务必加上 \n ，才能进行分行！</li><li>与 bash shell 的变量不同，在 awk 当中，变量可以直接使用，不需加上 $ 符号。</li></ul><p>利用 awk 这个玩意儿，就可以帮我们处理很多日常工作了呢！真是好用的很。此外，awk 的输出格式当中，常常会以 printf 来辅助，所以，最好你对 printf 也稍微熟悉一下比较好。另外，awk 的动作内 {} 也是支持 if (条件) 的。举例来说，上面的指令可以修订成为这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat pay.txt | \</span><br><span class="line">&gt; awk &apos;&#123;if(NR==1) printf</span><br><span class="line">&quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot;&#125;</span><br><span class="line">NR&gt;=2&#123;total = $2 + $3 + $4</span><br><span class="line">printf &quot;%10s %10d %10d %10d %10.2f\n&quot;, $1, $2, $3, $4, total&#125;&apos;</span><br></pre></td></tr></table></figure></p><h4 id="格式化打印：printf"><a href="#格式化打印：printf" class="headerlink" title="格式化打印：printf"></a>格式化打印：printf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# printf &apos;打印格式&apos; 实际内容</span><br><span class="line">选项与参数：</span><br><span class="line">关于格式方面的几个特殊样式：</span><br><span class="line">\a 警告声音输出</span><br><span class="line">\b 退格键(backspace)</span><br><span class="line">\f 清除屏幕 (form feed)</span><br><span class="line">\n 输出新的一行</span><br><span class="line">\r 亦即 Enter 按键</span><br><span class="line">\t 水平的 [tab] 按键</span><br><span class="line">\v 垂直的 [tab] 按键</span><br><span class="line">\xNN NN 为两位数的数字，可以转换数字成为字符。</span><br><span class="line">关于 C 程序语言内，常见的变数格式</span><br><span class="line">%ns 那个 n 是数字， s 代表 string ，亦即多少个字符；</span><br><span class="line">%ni 那个 n 是数字， i 代表 integer ，亦即多少整数字数；</span><br><span class="line">%N.nf 那个 n 与 N 都是数字， f 代表 floating (浮点)，如果有小数字数，假设我共要十个位数，但小数点有两位，即为 %10.2f</span><br></pre></td></tr></table></figure><p><strong>（注：printf 不是管线命令）</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;awk：好用的数据处理工具&quot;&gt;&lt;a href=&quot;#awk：好用的数据处理工具&quot; class=&quot;headerlink&quot; title=&quot;awk：好用的数据处理工具&quot;&gt;&lt;/a&gt;awk：好用的数据处理工具&lt;/h4&gt;&lt;p&gt;awk 也是一个非常棒的数据处理工具。相较于 sed 常常作用于一整个行的处理，awk 则比较倾向于一行当中分成数个【字段】来处理。因此，awk 相当的适合处理小型的数据数据处理。awk 通常运作的模式是这样的：&lt;br&gt;&lt;code&gt;[root@www ~]# awk &amp;#39;条件类型1{动作1} 条件类型2{动作2} ...&amp;#39; filename&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;awk 后面接两个单引号并加上大括号 {} 来设定想要对数据进行的处理动作。awk 可以处理后续接的档案，也可以读取来自前个指令的 standard output 。但如前面说的，awk 主要是处理【每一行的字段内的数据】，而默认的【字段的分隔符为 “空格键” 或 “[tab]键”】。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="BASH" scheme="http://yoursite.com/tags/BASH/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之sed命令</title>
    <link href="http://yoursite.com/2017/12/29/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8Bsed%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/12/29/认识与学习BASH之sed命令/</id>
    <published>2017-12-29T09:56:35.000Z</published>
    <updated>2018-01-18T07:00:30.642Z</updated>
    
    <content type="html"><![CDATA[<p>sed 本身也是一个管线命令，可以分析 standard input 的，而且 sed 还可以将数据进行取代、删除、新增、撷取特定行等等的功能。我们先来了解一下 sed 的用法，再来聊他的用途。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sed [-nefr] [动作]</span><br><span class="line">选项与参数：</span><br><span class="line">    -n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。</span><br><span class="line">         但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">    -e ：直接在指令列模式上进行 sed 的动作编辑；</span><br><span class="line">    -f ：直接将 sed 的动作写在一个档案内，-f filename 则可以执行 filename 内的 sed 动作；</span><br><span class="line">    -r ：sed 的动作支持的是延伸型正规表示法的语法。(预设是基础正规表示法语法)</span><br><span class="line">    -i ：直接修改读取的档案内容，而不是由屏幕输出。</span><br><span class="line"></span><br><span class="line">动作说明： [n1[,n2]]function</span><br><span class="line">n1, n2 ：不见得会存在，一般代表【选择进行动作的行数】，</span><br><span class="line">        举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则【 10,20[动作行为] 】</span><br><span class="line">function 有底下这些咚咚：</span><br><span class="line">    a ：新增， a 的后面可以接字符串，而这些字符串会在新的一行出现(目前的下一行)</span><br><span class="line">    c ：取代， c 的后面可以接字符串，这些字符串可以取代 n1,n2 之间的行！</span><br><span class="line">    d ：删除，因为是删除，所以 d 后面通常不接任何咚咚；</span><br><span class="line">    i ：插入， i 的后面可以接字符串，而这些字符串会在新的一行出现(目前的上一行)；</span><br><span class="line">    p ：打印，亦即将某个选择的数据打印出。通常 p 会与参数 sed -n 一起运作</span><br><span class="line">    s ：取代，可以直接进行取代的工作。通常这个 s 的动作可以搭配正规表示法。例如 1,20s/old/new/g 就是</span><br></pre></td></tr></table></figure></p><p>下面进行一些示例：</p><h4 id="1、以行为单位的新增-删除功能"><a href="#1、以行为单位的新增-删除功能" class="headerlink" title="1、以行为单位的新增/删除功能"></a>1、以行为单位的新增/删除功能</h4><h5 id="范例一：将-etc-passwd-的内容列出并且打印行号，同时，请将第-2-5-行删除"><a href="#范例一：将-etc-passwd-的内容列出并且打印行号，同时，请将第-2-5-行删除" class="headerlink" title="范例一：将 /etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删除"></a>范例一：将 /etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删除</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed &apos;2,5d&apos;</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>sed 的动作为 ‘2,5d’ ，那个 d 就是删除。因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行了。另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行。同时也要注意的是，sed 后面接的动作，请务必以 ‘’ 两个单引号括住。</p><p>如果题型变化一下，举例来说，如果只要删除第 2 行，可以使用<code>【 nl /etc/passwd | sed &#39;2d&#39; 】</code>来达成，至于若是要删除第 3 到最后一行，则是<code>【 nl /etc/passwd | sed &#39;3,$d&#39; 】</code>，那个钱字号【 $ 】代表最后一行。</p><h5 id="范例二：承上题，在第二行后-亦即是加在第三行-加上【drink-tea-】字样"><a href="#范例二：承上题，在第二行后-亦即是加在第三行-加上【drink-tea-】字样" class="headerlink" title="范例二：承上题，在第二行后(亦即是加在第三行)加上【drink tea?】字样"></a>范例二：承上题，在第二行后(亦即是加在第三行)加上【drink tea?】字样</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed &apos;2a drink tea&apos;</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2 bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">drink tea</span><br><span class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>在 a 后面加上的字符串就已将出现在第二行后面。那如果是要在第二行前呢？<code>【 nl /etc/passwd | sed &#39;2i drink tea&#39; 】</code>就对了。就是将【 a 】变成【 i 】即可。增加一行很简单，那如果是要增将两行以上呢？</p><h5 id="范例三：在第二行后面加入两行字，例如【Drink-tea-or-…-】与【drink-beer-】"><a href="#范例三：在第二行后面加入两行字，例如【Drink-tea-or-…-】与【drink-beer-】" class="headerlink" title="范例三：在第二行后面加入两行字，例如【Drink tea or …..】与【drink beer?】"></a>范例三：在第二行后面加入两行字，例如【Drink tea or …..】与【drink beer?】</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed &apos;2a Drink tea or ......\</span><br><span class="line">&gt; drink beer ?&apos;</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2 bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">Drink tea or ......</span><br><span class="line">drink beer ?</span><br><span class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>这个范例的重点是【我们可以新增不只一行，可以新增好几行】但是每一行之间都必须要以反斜杠【 \ 】来进行新行的增加。所以，上面的例子中，我们可以发现在第一行的最后面就有 \ 存在，那是一定要的。</p><h4 id="2、以行为单位的取代与显示功能"><a href="#2、以行为单位的取代与显示功能" class="headerlink" title="2、以行为单位的取代与显示功能"></a>2、以行为单位的取代与显示功能</h4><h5 id="范例四：我想将第-2-5-行的内容取代成为【No-2-5-number】"><a href="#范例四：我想将第-2-5-行的内容取代成为【No-2-5-number】" class="headerlink" title="范例四：我想将第 2-5 行的内容取代成为【No 2-5 number】"></a>范例四：我想将第 2-5 行的内容取代成为【No 2-5 number】</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed &apos;2,5c No 2-5 number&apos;</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">No 2-5 number</span><br><span class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">.....(后面省略).....</span><br></pre></td></tr></table></figure><p>透过这个方法我们就能够将数据整行取代了，非常容易吧，sed 还有更好用的。我们以前想要列出第 11~20 行，得要透过<code>【head -n 20 | tail -n 10】</code>之类的方法来处理，很麻烦。sed 则可以简单的直接取出你想要的那几行，是透过行号来的。看看底下的范例：</p><h5 id="范例五：仅列出-etc-passwd-档案内的第-5-7-行"><a href="#范例五：仅列出-etc-passwd-档案内的第-5-7-行" class="headerlink" title="范例五：仅列出 /etc/passwd 档案内的第 5-7 行"></a>范例五：仅列出 /etc/passwd 档案内的第 5-7 行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed -n &apos;5,7p&apos;</span><br><span class="line">5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br></pre></td></tr></table></figure><p>上述的指令中有个重要的选项【 -n 】，按照说明文件，这个 -n 代表的是【安静模式】。那么为什么要使用安静模式呢？你可以自行下达 sed ‘5,7p’ 就知道了 (5-7 行会重复输出)。有没有加上 -n 的参数时，输出的数据可是差很多的。你可以透过这个 sed 的以行为单位的显示功能，就能够将某一个档案内的某些行号捉出来查阅。很棒的功能！</p><h4 id="3、部分数据的搜寻并取代的功能"><a href="#3、部分数据的搜寻并取代的功能" class="headerlink" title="3、部分数据的搜寻并取代的功能"></a>3、部分数据的搜寻并取代的功能</h4><p>除了整行的处理模式之外，sed 还可以用行为单位进行部分数据的搜寻并取代的功能。基本上 sed 的搜寻与取代的与 vi 相当的类似！他有点像这样：<br><code>sed &#39;s/要被取代的字符串/新的字符串/g&#39;</code></p><p>我们使用底下这个取得 ifconfig 中 IP 数据的范例来了解一下什么是咱们所谓的搜寻并取代：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">步骤一：先观察原始讯息，利用 /sbin/ifconfig 查询 IP 为何？</span><br><span class="line">[root@www ~]# /sbin/ifconfig eth0</span><br><span class="line">eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84</span><br><span class="line">inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line">inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:Link</span><br><span class="line">UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line">.....(以下省略).....</span><br><span class="line"># 我们的重点在第二行，也就是 192.168.1.100 这一行。先利用关键词捉出那一行！</span><br><span class="line"></span><br><span class="line">步骤二：利用关键词配合 grep 撷取出关键的一行数据</span><br><span class="line">[root@www ~]# /sbin/ifconfig eth0 | grep &apos;inet addr&apos;</span><br><span class="line">inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line"># 当场仅剩下一行，接下来，我们要将开始到 addr: 通通删除，就是像底下这样：</span><br><span class="line"># inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line"># 上面的删除关键在于【 ^.*inet addr: 】。正规表示法出现！</span><br><span class="line"></span><br><span class="line">步骤三：将 IP 前面的部分予以删除</span><br><span class="line">[root@www ~]# /sbin/ifconfig eth0 | grep &apos;inet addr&apos; | \</span><br><span class="line">&gt; sed &apos;s/^.*addr://g&apos;</span><br><span class="line">192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line"># 仔细与上个步骤比较一下，前面的部分不见了！接下来则是删除后续的部分，亦即：</span><br><span class="line"># 192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</span><br><span class="line"># 此时所需的正规表示法为：【 Bcast.*$ 】</span><br><span class="line"></span><br><span class="line">步骤四：将 IP 后面的部分予以删除</span><br><span class="line">[root@www ~]# /sbin/ifconfig eth0 | grep &apos;inet addr&apos; | \</span><br><span class="line">&gt; sed &apos;s/^.*addr://g&apos; | sed &apos;s/Bcast.*$//g&apos;</span><br><span class="line">192.168.1.100</span><br></pre></td></tr></table></figure></p><h4 id="4、直接修改档案内容-危险动作"><a href="#4、直接修改档案内容-危险动作" class="headerlink" title="4、直接修改档案内容(危险动作)"></a>4、直接修改档案内容(危险动作)</h4><p>sed 甚至可以直接修改档案的内容。而不必使用管线命令或数据流重导向。不过，由于这个动作会直接修改到原始的档案，所以千万不要随便拿系统配置文件来测试，可以使用测试档案 regular_express.txt 来测试看看。</p><h5 id="范例六：利用-sed-将-regular-express-txt-内每一行结尾若为-则换成"><a href="#范例六：利用-sed-将-regular-express-txt-内每一行结尾若为-则换成" class="headerlink" title="范例六：利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !"></a>范例六：利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sed -i &apos;s/\.$/\!/g&apos; regular_express.txt</span><br><span class="line"># 上头的 -i 选项可以让你的 sed 直接去修改后面接的档案内容而不是由屏幕输出</span><br><span class="line"># 这个范例是用在取代，可自行 cat 该档案去查阅结果</span><br></pre></td></tr></table></figure><h5 id="范例七：利用-sed-直接在-regular-express-txt-最后一行加入【-This-is-a-test】"><a href="#范例七：利用-sed-直接在-regular-express-txt-最后一行加入【-This-is-a-test】" class="headerlink" title="范例七：利用 sed 直接在 regular_express.txt 最后一行加入【# This is a test】"></a>范例七：利用 sed 直接在 regular_express.txt 最后一行加入【# This is a test】</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sed -i &apos;$a # This is a test&apos; regular_express.txt</span><br><span class="line"># 由于 $ 代表的是最后一行，而 a 的动作是新增，因此该档案是最后新增</span><br></pre></td></tr></table></figure><p>sed 的【 -i 】选项可以直接修改档案内容，这功能非常有帮助。举例来说，如果你有一个 100 万行的档案，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为档案太大了！那怎办？就利用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修订。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sed 本身也是一个管线命令，可以分析 standard input 的，而且 sed 还可以将数据进行取代、删除、新增、撷取特定行等等的功能。我们先来了解一下 sed 的用法，再来聊他的用途。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="BASH" scheme="http://yoursite.com/tags/BASH/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之正规表示法与延伸正规表示法</title>
    <link href="http://yoursite.com/2017/12/29/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8B%E6%AD%A3%E8%A7%84%E8%A1%A8%E7%A4%BA%E6%B3%95%E4%B8%8E%E5%BB%B6%E4%BC%B8%E6%AD%A3%E8%A7%84%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/29/认识与学习BASH之正规表示法与延伸正规表示法/</id>
    <published>2017-12-29T07:55:29.000Z</published>
    <updated>2018-01-18T07:00:04.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、正规表示法"><a href="#一、正规表示法" class="headerlink" title="一、正规表示法"></a>一、正规表示法</h2><p>正规表示法 (Regular Expression, RE, 或称为常规表示法)是透过一些特殊字符的排列，用以【搜寻/取代/删除】一列或多列文字字符串，简单的说，正规表示法就是用在字符串的处理上面的一项【表示式】。正规表示法并不是一个工具程序，而是一个字符串处理的标准依据，如果您想要以正规表示法的方式处理字符串，就得要使用支持正规表示法的工具程序才行，这类的工具程序很多，例如 vi, sed, awk 等等。</p><h3 id="1、什么是正规表示法"><a href="#1、什么是正规表示法" class="headerlink" title="1、什么是正规表示法"></a>1、什么是正规表示法</h3><p>简单的说，正规表示法就是处理字符串的方法，他是以行为单位来进行字符串的处理行为，正规表示法透过一些特殊符号的辅助，可以让使用者轻易的达到【搜寻/删除/取代】某特定字符串的处理程序。<br><a id="more"></a><br>举个系统常见的例子，假如你发现系统在开机的时候，出现一个关于 mail 程序的错误，而开机过程的相关程序都是在 /etc/init.d/ 底下，也就是说，在该目录底下的某个档案内具有 mail 这个关键词，你想要将该档案捉出来进行查询修改的动作。此时你怎么找出来含有这个关键词的档案？你当然可以一个档案一个档案的开启，然后去搜寻 mail 这个关键词，只是…..该目录底下的档案可能不止100 个。如果了解正规表示法的相关技巧，那么只要一行指令就找出来：<code>【grep &#39;mail&#39; /etc/init.d/*】</code>那个 grep 就是支持正规表示法的工具程序之一。</p><p>谈到这里就得要进一步说明，正规表示法基本上是一种【表示法】，只要工具程序支持这种表示法，那么该工具程序就可以用来作为正规表示法的字符串处理之用。例如 vi, grep, awk ,sed 等等工具，因为她们有支持正规表示法，所以，这些工具就可以使用正规表示法的特殊字符来进行字符串的处理。但例如 cp, ls 等指令并未支持正规表示法，所以就只能使用 bash 自己本身的通配符而已。</p><h3 id="2、正规表示法与Shell在Linux当中的角色定位："><a href="#2、正规表示法与Shell在Linux当中的角色定位：" class="headerlink" title="2、正规表示法与Shell在Linux当中的角色定位："></a>2、正规表示法与Shell在Linux当中的角色定位：</h3><p>我们谈到的这个正规表示法，就有点像是数学的九九表一样，是 Linux 基础当中的基础，虽然也是最难的部分，不过，如果学成了之后，一定是【大大的有帮助】的。这就好像是金庸小说里面的学武难关：任督二脉！ 打通任督二脉之后，武功立刻成倍成长！所以，不论是对于系统的认识与系统的管理部分，他都有很棒的辅助。</p><h3 id="3、延伸的正规表示法："><a href="#3、延伸的正规表示法：" class="headerlink" title="3、延伸的正规表示法："></a>3、延伸的正规表示法：</h3><p>正规表示法的字符串表示方式依照不同的严谨度而分为： 基础正规表示法与延伸正规表示法。延伸型正规表示法除了简单的一组字符串处理之外，还可以作群组的字符串处理，例如进行搜寻VBird 或 netman 或 lman 的搜寻，注意，是【或(or)】而不是【和(and)】的处理，此时就需要延伸正规表示法的帮助，藉由特殊的【 ( 】与【 | 】等字符的协助，就能够达到这样的目的。不过，我们在这里主要介绍最基础的基础正规表示法。<br><strong>（注：有一点要向大家报告说明清楚，那就是：【正规表示法与通配符是完全不一样的东西！】这很重要。因为【通配符 (wildcard) 代表的是 bash 操作接口的一个功能】，但正规表示法则是一种字符串处理的表示方式，这两者要分的很清楚才行。)</strong></p><h3 id="4、通过grep实例演示来学习正规表示法："><a href="#4、通过grep实例演示来学习正规表示法：" class="headerlink" title="4、通过grep实例演示来学习正规表示法："></a>4、通过grep实例演示来学习正规表示法：</h3><p>新建regular_express.txt文档及测试内容：</p><blockquote><p>“Open Source” is a good mechanism to develop programs.<br>apple is my favorite food.<br>Football game is not use feet only.<br>this dress doesn’t fit me.<br>However, this dress is about $ 3183 dollars.<br>GNU is free air not free beer.<br>Her hair is very beauty.<br>I can’t finish the test.<br>Oh! The soup taste good.<br>motorcycle is cheap than car.<br>This window is clear.<br>the symbol ‘*’ is represented as start.<br>Oh!    My god!<br>The gd software is a library for drafting programs.<br>You are the best is mean you are the no. 1.<br>The world <happy> is the same with “glad”.<br>I like dog.<br>google is the best tools for search keyword.<br>goooooogle yes!<br>go! go! Let’s go.<br># I am VBird</happy></p></blockquote><p>共有22行，最底下一行为空白行！现在开始我们一个案例一个案例的来介绍。</p><h4 id="例题一：搜寻特定字符串"><a href="#例题一：搜寻特定字符串" class="headerlink" title="例题一：搜寻特定字符串"></a>例题一：搜寻特定字符串</h4><p>假设我们要从刚刚的档案当中取得 the 这个特定字符串，最简单的方式就是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;the&apos; regular_express.txt</span><br><span class="line">8:I can&apos;t finish the test.</span><br><span class="line">12:the symbol &apos;*&apos; is represented as start.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br><span class="line">16:The world &lt;Happy&gt; is the same with &quot;glad&quot;.</span><br><span class="line">18:google is the best tools for search keyword.</span><br></pre></td></tr></table></figure></p><p>那如果想要【反向选择】呢？也就是说，当该行没有 ‘the’ 这个字符串时才显示在屏幕上，那就直接使用：<br><code>[root@www ~]# grep -vn &#39;the&#39; regular_express.txt</code></p><p>接下来，如果你想要取得不论大小写的 the 这个字符串，则：<br><code>[root@www ~]# grep -in &#39;the&#39; regular_express.txt</code></p><h4 id="例题二、利用中括号-来搜寻集合字符"><a href="#例题二、利用中括号-来搜寻集合字符" class="headerlink" title="例题二、利用中括号 [] 来搜寻集合字符"></a>例题二、利用中括号 [] 来搜寻集合字符</h4><p>如果我想要搜寻 test 或 taste 这两个单字时，可以发现到，其实她们有共通的 ‘t?st’ 存在。这个时候，我可以这样来搜寻：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;t[ae]st&apos; regular_express.txt</span><br><span class="line">8:I can&apos;t finish the test.</span><br><span class="line">9:Oh! The soup taste good.</span><br></pre></td></tr></table></figure></p><p>其实 [] 里面不论有几个字符，他都谨代表某【一个】字符，所以，上面的例子说明了，我需要的字符串是【tast】或【test】两个字符串而已。</p><p>而如果想要搜寻到有 oo 的字符时，则使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;oo&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure></p><p>但是，如果我不想要 oo 前面有 g 的话呢？此时，可以利用在集合字符的反向选择 [^] 来达成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;[^g]oo&apos; regular_express.txt</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure></p><p>假设我 oo 前面不想要有小写字符，所以，我可以这样写 [^abcd….z]oo ，但是这样似乎不怎么方便，由于小写字符的 ASCII 上编码的顺序是连续的，因此，我们可以将之简化为底下这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;[^a-z]oo&apos; regular_express.txt</span><br><span class="line">3:Football game is not use feet only.</span><br></pre></td></tr></table></figure></p><p>也就是说，当我们在一组集合字符中，如果该字符组是连续的，例如大写英文/小写英文/数字等等，就可以使用<code>[a-z],[A-Z],[0-9]</code>等方式来书写，那么如果我们的要求字符串是数字与英文呢？就将他全部写在一起，变成：<code>[a-zA-Z0-9]</code>。</p><h4 id="例题三、行首与行尾字符"><a href="#例题三、行首与行尾字符" class="headerlink" title="例题三、行首与行尾字符 ^ $"></a>例题三、行首与行尾字符 ^ $</h4><p>我们在例题一当中，可以查询到一行字符串里面有 the 的，那如果我想要让 the 只在行首列出呢？这个时候就得要使用制表符了。我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;^the&apos; regular_express.txt</span><br><span class="line">12:the symbol &apos;*&apos; is represented as start.</span><br></pre></td></tr></table></figure></p><p>那如果我不想要开头是英文字母，则可以是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;^[^a-zA-Z]&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">21:# I am VBird</span><br></pre></td></tr></table></figure></p><p>注意到了吧？那个 ^ 符号，在字符集合符号(括号[])之内与之外是不同的！在 [] 内代表【反向选择】，在 [] 之外则代表定位在行首的意义！</p><p>如果我想要找出来，行尾结束为小数点 (.) 的那一行，该如何处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;\.$&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">4:this dress doesn&apos;t fit me.</span><br><span class="line">10:motorcycle is cheap than car.</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>特别注意到，因为小数点具有其他意义(底下会介绍)，所以必须要使用跳脱字符<code>(\)</code>来加以解除其特殊意义！</p><p>那么如果我想要找出来，哪一行是【空白行】，也就是说，该行并没有输入任何数据，该如何搜寻？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;^$&apos; regular_express.txt</span><br><span class="line">22:</span><br></pre></td></tr></table></figure></p><p>因为只有行首跟行尾 (^$)，所以，这样就可以找出空白行了。</p><p>假设你已经知道在一个程序脚本(shell script)或者是配置文件当中，空白行与开头为 # 的那一行是批注，因此如果你要将资料列出给别人参考时，可以将这些数据省略掉以节省保贵的纸张，那么你可以怎么作呢？我们以<code>/etc/syslog.conf</code> 这个档案来作范例，你可以自行参考一下输出的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat -n /etc/syslog.conf</span><br><span class="line"># 在 CentOS 中，结果可以发现有 26 行的输出，很多空白行与 # 开头</span><br><span class="line">[root@www ~]# grep -v &apos;^$&apos; /etc/syslog.conf | grep -v &apos;^#&apos;</span><br><span class="line"># 结果仅有 7 行，其中第一个【 -v &apos;^$&apos; 】代表【不要空白行】，</span><br><span class="line"># 第二个【 -v &apos;^#&apos; 】代表【不要开头是 # 的那行】</span><br></pre></td></tr></table></figure></p><h4 id="例题四、任意一个字符-与重复字符"><a href="#例题四、任意一个字符-与重复字符" class="headerlink" title="例题四、任意一个字符 . 与重复字符 *"></a>例题四、任意一个字符 . 与重复字符 *</h4><p>我们知道通配符 * 可以用来代表任意(0 或多个)字符，但是正规表示法并不是通配符，两者之间是不相同的。至于正规表示法当中的【 . 】则代表【绝对有一个任意字符】的意思。这两个符号在正规表示法的意义如下：</p><pre><code>. (小数点)：代表【一定有一个任意字符】的意思；* (星星号)：代表【重复前一个 0 到无穷多次】的意思，为组合形态</code></pre><p>我们直接做个练习吧。假设我需要找出 g??d 的字符串，亦即共有四个字符，起头是 g 而结束是 d ，我可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;g..d&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">16:The world &lt;Happy&gt; is the same with &quot;glad&quot;.</span><br></pre></td></tr></table></figure></p><p>因为 * 代表的是【重复 0 个或多个前面的 RE 字符】的意义，因此，【o*】代表的是：【拥有空字符或一个 o 以上的字符】，特别注意，因为允许空字符(就是有没有字符都可以的意思)，因此，<code>【 grep -n &#39;o*&#39; regular_express.txt 】</code>将会把所有的数据都打印出到屏幕上。因此，当我们需要【至少两个 o 以上的字符串】时，就需要 ooo* ，亦即是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;ooo*&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure></p><h4 id="例题五、限定连续-RE-字符范围"><a href="#例题五、限定连续-RE-字符范围" class="headerlink" title="例题五、限定连续 RE 字符范围 {}"></a>例题五、限定连续 RE 字符范围 {}</h4><p>在上个例题当中，我们可以利用 . 与 RE 字符及 * 来设定 0 个到无限多个重复字符，那如果我想要限制一个范围区间内的重复字符数呢？举例来说，我想要找出两个到五个 o 的连续字符串，该如何作？这时候就得要使用到限定范围的字符 {} 了。但因为 { 与 } 的符号在 shell 是有特殊意义的，因此，我们必须要使用跳脱字符 \ 来让他失去特殊意义才行。至于 {} 的语法是这样的，假设我要找到两个 o 的字符串，可以是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;o\&#123;2\&#125;&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure></p><p>这样看似乎与 ooo* 的字符没有什么差异？因为第 19 行有多个 o 依旧也出现了。那么换个搜寻的字符串，假设我们要找出 g 后面接 2 到 5 个 o ，然后再接一个 g 的字符串，他会是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;go\&#123;2,5\&#125;g&apos; regular_express.txt</span><br><span class="line">18:google is the best tools for search keyword.</span><br></pre></td></tr></table></figure></p><h3 id="5、基础正规表示法字符汇整-characters"><a href="#5、基础正规表示法字符汇整-characters" class="headerlink" title="5、基础正规表示法字符汇整 (characters)"></a>5、基础正规表示法字符汇整 (characters)</h3><p>经过了上面的几个简单的范例，我们可以将基础的正规表示法特殊字符汇整如下：</p><style>table th:first-of-type {    width: 100px;}</style><table><thead><tr><th>RE字符</th><th>意义与范例</th></tr></thead><tbody><tr><td>^word</td><td>意义：待搜寻的字符串(word)在行首！<br> 范例：搜寻行首为 # 开始的那一行，并列出行号 <br> <code>grep -n &#39;^#&#39; regular_express.txt</code></td></tr><tr><td>word$</td><td>意义：待搜寻的字符串(word)在行尾！ <br> 范例：将行尾为 ! 的那一行打印出来，并列出行号 <br> <code>grep -n &#39;!$&#39; regular_express.txt</code></td></tr><tr><td> .</td><td>意义：代表【一定有一个任意字符】的字符！ <br> 范例：搜寻的字符串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间【一定】仅有一个字符，而空格符也是字符！ <br> <code>grep -n &#39;e.e&#39; regular_express.txt</code></td></tr><tr><td> \</td><td>意义：跳脱字符，将特殊符号的特殊意义去除！ <br> 范例：搜寻含有单引号 ‘ 的那一行！ <br> <code>grep -n \&#39; regular_express.txt</code></td></tr><tr><td>  *</td><td>意义：重复零个到无穷多个的前一个 RE 字符 <br> 范例：找出含有 (es) (ess) (esss) 等等的字符串，注意，因为 <em> 可以是 0 个，所以 es 也是符合带搜寻字符串。另外，因为 </em> 为重复【前一个 RE 字符】的符号，因此，在 <em> 之前必须要紧接着一个 RE 字符。例如任意字符则为【.</em>】！ <br> <code>grep -n &#39;ess*&#39; regular_express.txt</code></td></tr><tr><td>[list]</td><td>意义：字符集合的 RE 字符，里面列出想要撷取的字符！ <br> 范例：搜寻含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在 [] 当中【谨代表一个待搜寻的字符】，例如【 a[afl]y 】代表搜寻的字符串可以是 aay, afy, aly 即[afl] 代表 a 或 f 或 l 的意思！ <br> <code>grep -n &#39;g[ld]&#39; regular_express.txt</code></td></tr><tr><td>[n1-n2]</td><td>意义：字符集合的 RE 字符，里面列出想要撷取的字符范围！ <br> 范例：搜寻含有任意数字的那一行！需特别留意，在字符集合 [] 中的减号 - 是有特殊意义的，他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码有关，因此，你的编码需要设定正确(在 bash 当中，需要确定 LANG 与 LANGUAGE 的变量是否正确！) 例如所有大写字符则为 [A-Z] <br> <code>grep -n &#39;[0-9]&#39; regular_express.txt</code></td></tr><tr><td>[^list]</td><td>意义：字符集合的 RE 字符，里面列出不要的字符串或范围！ <br> 范例：搜寻的字符串可以是 (oog) (ood) 但不能是 (oot) ，那个 ^ 在 [] 内时，代表的意义是【反向选择】的意思。 例如，我不要大写字符，则为 [^A-Z]。但是，需要特别注意的是，如果以 <code>grep -n [^A-Z] regular_express.txt</code>来搜寻，即发现该档案内的所有行都被列出，为什么？因为这个 [^A-Z] 是【非大写字符】的意思，因为每一行均有非大写字符，例如第一行的 “Open Source” 就有 p,e,n,o….等等的小写字 <br> <code>grep -n &#39;oo[^t]&#39; regular_express.txt</code></td></tr><tr><td>\{n,m\}</td><td>意义：连续 n 到 m 个的【前一个 RE 字符】 <br> 意义：若为 \{n\} 则是连续 n 个的前一个 RE 字符， <br> 意义：若是 \{n,\} 则是连续 n 个以上的前一个 RE 字符！ 范例：在 g 与 g 之间有2 个到 3 个的 o 存在的字符串，亦即 (goog)(gooog) <br> <code>grep -n &#39;go\\{2,3\\}g&#39; regular_express.txt</code></td></tr></tbody></table><p>再次强调：【正规表示法的特殊字符】与一般在指令列输入指令的【通配符】并不相同，例如，在通配符当中的 * 代表的是【 0 ~ 无限多个字符】的意思，但是在正规表示法当中， * 则是【重复 0 到无穷多个的前一个 RE 字符】的意思。使用的意义并不相同，不要搞混了。</p><h2 id="二、延伸正规表示法"><a href="#二、延伸正规表示法" class="headerlink" title="二、延伸正规表示法"></a>二、延伸正规表示法</h2><p>事实上，一般读者只要了解基础型的正规表示法大概就已经相当足够了，不过，某些时刻为了要简化整个指令操作，了解一下使用范围更广的延伸型正规表示法的表示式会更方便。举个简单的例子，我们要去除空白行与行首为 # 的行列，使用的是<br><code>grep -v &#39;^$&#39; regular_express.txt | grep -v &#39;^#&#39;</code><br>需要使用到管线命令来搜寻两次！那么如果使用延伸型的正规表示法，我们可以简化为：<br><code>egrep -v &#39;^$|^#&#39; regular_express.txt</code><br>延伸型正规表示法可以透过群组功能【 | 】来进行一次搜寻！那个在单引号内的管线意义为【或 or】。此外，grep 预设仅支持基础正规表示法，如果要使用延伸型正规表示法，你可以使用 grep -E ，不过更建议直接使用 egrep ！直接区分指令比较好记忆！其实 egrep 与 grep -E 是类似命令别名的关系。</p><table><thead><tr><th>RE字符</th><th>意义与范例</th></tr></thead><tbody><tr><td> +</td><td>意义：重复【一个或一个以上】的前一个 RE 字符 <br> 范例：搜寻 (god) (good) (goood)… 等等的字符串。那个 o+ 代表【一个以上的 o 】所以，底下的执行成果会将第 1, 9, 13 行列出来。 <br> <code>egrep -n &#39;go+d&#39; regular_express.txt</code></td></tr><tr><td> ?</td><td>意义：【零个或一个】的前一个 RE 字符 <br> 范例：搜寻 (gd) (god) 这两个字符串。 那个 o? 代表【空的或 1 个 o 】所以，上面的执行成果会将第 13, 14 行列出来。有没有发现到，这两个案例( ‘go+d’ 与 ‘go?d’ )的结果集合与 ‘go*d’ 相同？想想看，这是为什么！ <br> <code>egrep -n &#39;go?d&#39; regular_express.txt</code></td></tr><tr><td>  &#124;</td><td>意义：用或( or )的方式找出数个字符串 <br> 范例：搜寻 gd 或 good 这两个字符串，注意，是【或】！ 所以，第 1,9,14 这三行都可以被打印出来。那如果还想要找出 dog 呢？ <br> <code>egrep -n &#39;gd&amp;#124;good&#39; regular_express.txt</code> <br> <code>egrep -n &#39;gd&amp;#124;good&amp;#124;dog&#39; regular_express.txt</code></td></tr><tr><td> ()</td><td>意义：找出【群组】字符串 <br> 范例：搜寻 (glad) 或 (good) 这两个字符串，因为 g 与 d 是重复的，所以，我就可以将 la 与 oo 列于 ( ) 当中，并以 &#124; 来分隔开来，就可以。 <br> <code>egrep -n &#39;g(la&amp;#124;oo)d&#39; regular_express.txt</code></td></tr><tr><td> ()+</td><td>意义：多个重复群组的判别 <br> 范例：将【AxyzxyzxyzxyzC】用 echo 叫出，然后再使用如下的方法搜寻一下！ <br> echo ‘AxyzxyzxyzxyzC’ &#124; egrep ‘A(xyz)+C’ <br> 上面的例子意思是说，我要找开头是 A 结尾是 C ，中间有一个以上的 “xyz” 字符串的意思</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、正规表示法&quot;&gt;&lt;a href=&quot;#一、正规表示法&quot; class=&quot;headerlink&quot; title=&quot;一、正规表示法&quot;&gt;&lt;/a&gt;一、正规表示法&lt;/h2&gt;&lt;p&gt;正规表示法 (Regular Expression, RE, 或称为常规表示法)是透过一些特殊字符的排列，用以【搜寻/取代/删除】一列或多列文字字符串，简单的说，正规表示法就是用在字符串的处理上面的一项【表示式】。正规表示法并不是一个工具程序，而是一个字符串处理的标准依据，如果您想要以正规表示法的方式处理字符串，就得要使用支持正规表示法的工具程序才行，这类的工具程序很多，例如 vi, sed, awk 等等。&lt;/p&gt;
&lt;h3 id=&quot;1、什么是正规表示法&quot;&gt;&lt;a href=&quot;#1、什么是正规表示法&quot; class=&quot;headerlink&quot; title=&quot;1、什么是正规表示法&quot;&gt;&lt;/a&gt;1、什么是正规表示法&lt;/h3&gt;&lt;p&gt;简单的说，正规表示法就是处理字符串的方法，他是以行为单位来进行字符串的处理行为，正规表示法透过一些特殊符号的辅助，可以让使用者轻易的达到【搜寻/删除/取代】某特定字符串的处理程序。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="BASH" scheme="http://yoursite.com/tags/BASH/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之管线命令</title>
    <link href="http://yoursite.com/2017/12/28/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8B%E7%AE%A1%E7%BA%BF%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/12/28/认识与学习BASH之管线命令/</id>
    <published>2017-12-28T11:11:21.000Z</published>
    <updated>2018-01-18T07:00:09.895Z</updated>
    
    <content type="html"><![CDATA[<p>就如同《数据流导向》所说的，bash 命令执行的时候有输出的数据会出现，那么如果这群数据必需要经过几道手续之后才能得到我们所想要的格式，应该如何来设定？这就牵涉到管线命令的问题(pipe) ，管线命令使用的是【 | 】这个界定符号。另外，管线命令与【连续下达命令】是不一样的。这点底下我们会再说明。底下我们先举一个例子来说明一下简单的管线命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：显示/etc/地下有多少个档案，并且利用less指令来分页显示</span><br><span class="line">[root@www ~]# ls -al /etc | less</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>其实这个管线命令【 | 】仅能处理经由前面一个指令传来的正确信息，也就是 standard output 的信息，对于 stdandard error 并没有直接处理的能力。那么整体的管线命令可以使用下图表示：<br><img src="/uploads/2017/12/linux_pipe_command.JPG" alt=""></p><p><font color="red">在每个管线后面接的第一个数据必定是【指令】(管线指令)。</font>而且这个指令必须要能够接收 standard input 的数据才行，这样的指令才可以是为【管线命令】，例如 less, more, head, tail 等都是可以接收 standard input 的管线命令。至于例如 ls, cp, mv 等就不是管线命令。因为 ls, cp, mv 并不会接收来自 stdin的数据。也就是说，管线命令主要有两个比较需要注意的地方：</p><blockquote><p>1.管线命令仅会处理 standard output，对于 standard error output 会予以忽略<br>2.管线命令必须要能够接收来自前一个指令的数据成为 standard input 继续处理才行。</p></blockquote><h3 id="1、撷取命令：-cut-grep"><a href="#1、撷取命令：-cut-grep" class="headerlink" title="1、撷取命令： cut, grep"></a>1、撷取命令： cut, grep</h3><p>什么是撷取命令？就是将一段数据经过分析后，取出我们所想要的。或者是经由分析关键词，取得我们所想要的那一行。不过，要注意的是，一般来说，撷取讯息通常是针对【一行一行】来分析的，并不是整篇讯息分析的，底下我们介绍两个很常用的讯息撷取命令：</p><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>这个指令可以将一段讯息的某一段给他【切】出来，处理的讯息是以【行】为单位，底下我们就来谈一谈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cut -d&apos;分隔字符&apos; -f fields &lt;==用于有特定分隔字符</span><br><span class="line">[root@www ~]# cut -c 字符区间 &lt;==用于排列整齐的讯息</span><br><span class="line">选项与参数：</span><br><span class="line">    -d ：后面接分隔字符。与 -f 一起使用；</span><br><span class="line">    -f ：依据 -d 的分隔字符将一段讯息分割成为数段，用 -f 取出第几段的意思；</span><br><span class="line">    -c ：以字符 (characters) 的单位取出固定字符区间；</span><br><span class="line">范例一：将 PATH 变量取出，我要找出第五个路径。</span><br><span class="line">[root@www ~]# echo $PATH</span><br><span class="line">/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games:</span><br><span class="line"># 1 | 2 | 3 | 4 | 5 | 6 | 7</span><br><span class="line"></span><br><span class="line">[root@www ~]# echo $PATH | cut -d &apos;:&apos; -f 5</span><br><span class="line"># 如同上面的数字显示，我们是以【 : 】作为分隔，因此会出现 /usr/local/bin</span><br><span class="line"># 那么如果想要列出第 3 与第 5 呢？，就是这样：</span><br><span class="line">[root@www ~]# echo $PATH | cut -d &apos;:&apos; -f 3,5</span><br><span class="line">范例二：将 export 输出癿讯息，取得第 12 字符以后的所有字符串</span><br><span class="line">[root@www ~]# export</span><br><span class="line">declare -x HISTSIZE=&quot;1000&quot;</span><br><span class="line">declare -x INPUTRC=&quot;/etc/inputrc&quot;</span><br><span class="line">declare -x KDEDIR=&quot;/usr&quot;</span><br><span class="line">declare -x LANG=&quot;zh_TW.big5&quot;</span><br><span class="line">.....(其他省略).....</span><br><span class="line"># 注意看，每个数据都是排列整齐的输出！如果我们不想要【declare -x】时，就得这么做：</span><br><span class="line">[root@www ~]# export | cut -c 12-</span><br><span class="line">HISTSIZE=&quot;1000&quot;</span><br><span class="line">INPUTRC=&quot;/etc/inputrc&quot;</span><br><span class="line">KDEDIR=&quot;/usr&quot;</span><br><span class="line">LANG=&quot;zh_TW.big5&quot;</span><br><span class="line">.....(其他省略).....</span><br><span class="line"># 知道怎么回事了吧？用 -c 可以处理比较具有格式的输出数据！</span><br><span class="line"># 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等等！</span><br></pre></td></tr></table></figure></p><p><em>cut 主要的用途在于将【同一行里面的数据进行分解！】最常使用在分析一些数据或文字数据的时候！这是因为有时候我们会以某些字符当作分割的参数，然后来将数据加以切割，以取得我们所需要的数据。</em></p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>刚刚的 cut 是将一行讯息当中，取出某部分我们想要的，而 grep 则是分析一行讯息，若当中有我们所需要的信息，就将该行拿出来，简单的语法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# grep [-acinv] [--color=auto] &apos;搜寻字符串&apos; filename</span><br><span class="line">选项与参数：</span><br><span class="line">    -a ：将 binary 档案以 text 档案的方式搜寻数据</span><br><span class="line">    -c ：计算找到 &apos;搜寻字符串&apos; 的次数</span><br><span class="line">    -i ：忽略大小写的不同，所以大小写视为相同</span><br><span class="line">    -n ：顺便输出行号</span><br><span class="line">    -v ：反向选择，亦即显示出没有 &apos;搜寻字符串&apos; 内容的那一行！</span><br><span class="line">    --color=auto ：可以将找到的关键词部分加上颜色的显示。</span><br><span class="line"></span><br><span class="line">范例一：将 last 当中，有出现 root 的那一行就取出来；</span><br><span class="line">[root@www ~]# last | grep &apos;root&apos;</span><br><span class="line">范例二：与范例一相反，只要没有 root 的就取出！</span><br><span class="line">[root@www ~]# last | grep -v &apos;root&apos;</span><br><span class="line">范例三：在 last 的输出讯息中，只要有 root 就取出，并且仅取第一栏</span><br><span class="line">[root@www ~]# last | grep &apos;root&apos; |cut -d &apos; &apos; -f1</span><br><span class="line">范例四：取出 /etc/man.config 内含 MANPATH 的那几行</span><br><span class="line">[root@www ~]# grep --color=auto &apos;MANPATH&apos; /etc/man.config</span><br><span class="line">....(前面省略)....</span><br><span class="line">MANPATH_MAP /usr/X11R6/bin /usr/X11R6/man</span><br><span class="line">MANPATH_MAP /usr/bin/X11 /usr/X11R6/man</span><br><span class="line">MANPATH_MAP /usr/bin/mh /usr/share/man</span><br><span class="line">（如果加上 --color=auto 的选项，找到的关键词部分会用特殊颜色显示。）</span><br></pre></td></tr></table></figure></p><h3 id="2、排序命令：-sort-wc-uniq"><a href="#2、排序命令：-sort-wc-uniq" class="headerlink" title="2、排序命令： sort, wc, uniq"></a>2、排序命令： sort, wc, uniq</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>他可以帮我们进行排序，而且可以依据不同的数据型态来排序。例如数字与文字的排序就不一样。此外，排序的字符与语系的编码有关，因此，如果您需要排序时，建议使用LANG=C来让语系统一，数据排序会比较好一些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sort [-fbMnrtuk] [file or stdin]</span><br><span class="line">选项与参数：</span><br><span class="line">    -f ：忽略大小写的差异，例如 A 与 a 规为编码相同；</span><br><span class="line">    -b ：忽略最前面的空格符部分；</span><br><span class="line">    -M ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；</span><br><span class="line">    -n ：使用【纯数字】进行排序(默认是以文字型态来排序的)；</span><br><span class="line">    -r ：反向排序；</span><br><span class="line">    -u ：就是 uniq ，相同的数据中，仅出现一行代表；</span><br><span class="line">    -t ：分隔符，预设是用 [tab] 键来分隔；</span><br><span class="line">    -k ：以那个区间 (field) 来进行排序的意思</span><br><span class="line"></span><br><span class="line">范例一：个人账号都记录在 /etc/passwd 下，请将账号进行排序。</span><br><span class="line">[root@www ~]# cat /etc/passwd | sort</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">apache:x:48:48:Apache:/var/www:/sbin/nologin</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">#由上面的数据看起来，sort 是预设【以第一个】数据来排序，而且默认是以【文字】型态来排序的。所以由a开始排到最后。</span><br><span class="line">范例二：/etc/passwd 内容是以 : 来分割的，我想以第三栏来排序，该如何？</span><br><span class="line">[root@www ~]# cat /etc/passwd | sort -t &apos;:&apos; -k 3</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line"># 如果是以文字型态来排序的，就是会这样，想要使用数字排序：</span><br><span class="line"># cat /etc/passwd | sort -t &apos;:&apos; -k 3 -n</span><br><span class="line"># 这样才行。用那个 -n 来告知 sort 以数字来排序。</span><br></pre></td></tr></table></figure></p><h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>如果我排序完成了，想要将重复的资料仅列出一个显示，可以怎么做呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# uniq [-ic]</span><br><span class="line">选项与参数：</span><br><span class="line">    -i ：忽略大小写字符的不同；</span><br><span class="line">    -c ：进行计数</span><br><span class="line">范例一：使用 last 将账号列出，仅取出账号栏，进行排序后仅取出一位；</span><br><span class="line">[root@www ~]# last | cut -d &apos; &apos; -f1 | sort | uniq</span><br><span class="line">范例二：承上题，如果我还想要知道每个人的登入总次数</span><br><span class="line">[root@www ~]# last | cut -d &apos; &apos; -f1 | sort | uniq -c</span><br><span class="line">1</span><br><span class="line">12 reboot</span><br><span class="line">41 root</span><br><span class="line">1 wtmp</span><br><span class="line"># 从上面的结果可以发现 reboot 有 12 次， root 登入则有 41 次。wtmp与第一行的空白都是last的默认字符，那两个可以忽略。</span><br></pre></td></tr></table></figure></p><p><em>这个指令用来将【重复的行删除掉只显示一个】，举个例子来说，你要知道这个月份登入你主机的用户有谁，而不在乎他的登入次数，那么就使用上面的范例，(1)先将所有的数据列出；(2)再将人名独立出来；(3)经过排序；(4)只显示一个！由于这个指令是在将重复的东西减少，所以当然需要【配合排序过的档案】来处理。</em></p><h3 id="3、统计命令：wc"><a href="#3、统计命令：wc" class="headerlink" title="3、统计命令：wc"></a>3、统计命令：wc</h3><p>如果我想要知道 /etc/man.config这个档案里面有多少字？多少行？多少字符的话，可以利用wc这个指令来达成，他可以帮我们计算输出的讯息的整体数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# wc [-lwm]</span><br><span class="line">选项与参数：</span><br><span class="line">    -l ：仅列出行；</span><br><span class="line">    -w ：仅列出多少字(英文单字)；</span><br><span class="line">    -m ：多少字符；</span><br></pre></td></tr></table></figure></p><p><em>当你要知道目前你的账号档案中有多少个账号时，就使用这个方法：【cat /etc/passwd | wc -l】。因为/etc/passwd里头一行代表一个使用者。所以知道行数就晓得有多少账号在里头。而如果要计算一个档案里头有多少个字符时，就使用 wc -c 这个选项。</em></p><h3 id="4、字符转换命令：-tr-col-join-paste-expand"><a href="#4、字符转换命令：-tr-col-join-paste-expand" class="headerlink" title="4、字符转换命令： tr, col, join, paste, expand"></a>4、字符转换命令： tr, col, join, paste, expand</h3><p>我们在 vim 程序编辑器当中，提到过 DOS 断行字符与 Unix 断行字符的不同，并且可以使用 dos2unix 与 unix2dos 来完成转换。当然，还有其他的替代方案，底下我们就来介绍一下这些字符转换命令在管线当中的使用方法：</p><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# tr [-ds] SET1 ...</span><br><span class="line">选项与参数：</span><br><span class="line">    -d ：删除讯息当中的 SET1 这个字符串；</span><br><span class="line">    -s ：取代掉重复的字符！</span><br><span class="line">范例一：将 last 输出的讯息中，所有的小写变成大写字符：</span><br><span class="line">[root@www ~]# last | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;</span><br><span class="line"># 事实上，没有加上单引号也是可以执行的，如：【 last | tr [a-z] [A-Z] 】</span><br><span class="line">范例二：将 /etc/passwd 输出的讯息中，将冒号 (:) 删除</span><br><span class="line">[root@www ~]# cat /etc/passwd | tr -d &apos;:&apos;</span><br></pre></td></tr></table></figure></p><p>相信处理 Linux &amp; Windows 系统中的人们最麻烦的一件事就是 DOS 底下会自动的在每行行尾加入^M 这个断行符号。使用 tr 将 ^M 可以使用 \r 来代替就可以去除 DOS 档案留下来的 ^M 这个断行的符号。这东西相当的有用！</p><h4 id="col"><a href="#col" class="headerlink" title="col"></a>col</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# col [-xb]</span><br><span class="line">选项与参数：</span><br><span class="line">    -x ：将 tab 键转换成对等的空格键</span><br><span class="line">    -b ：在文字内有反斜杠 (/) 时，仅保留反斜杠最后接的那个字符</span><br></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>join 看字面上的意义 (加入/参加) 就可以知道，他是在处理两个档案之间的数据，而且，主要是在处理【两个档案当中，有”相同数据”的那一行，才将他加在一起】的意思。我们利用底下的简单例子来说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# join [-ti12] file1 file2</span><br><span class="line">选项与参数：</span><br><span class="line">    -t ：join 默认以空格符分隔数据，并且比对【第一个字段】的数据，如果两个档案相同，则将两笔数据联成一行，且第一个字段放在第一个</span><br><span class="line">    -i ：忽略大小写的差异；</span><br><span class="line">    -1 ：这个是数字的 1 ，代表【第一个档案要用那个字段来分析】的意思；</span><br><span class="line">    -2 ：代表【第二个档案要用那个字段来分析】的意思。</span><br><span class="line"></span><br><span class="line">范例一：用 root 的身份，将 /etc/passwd 与 /etc/shadow 相关数据整合成一栏</span><br><span class="line">[root@www ~]# join -t &apos;:&apos; /etc/passwd /etc/shadow</span><br><span class="line"># 透过上面这个动作，我们可以将两个档案第一字段相同者整合成一行。第二个档案的相同字段并不会显示</span><br><span class="line">范例二：我们知道 /etc/passwd 第四个字段是 GID ，那个 GID 记录在 /etc/group 当中的第三个字段</span><br><span class="line">[root@www ~]# join -t &apos;:&apos; -1 4 /etc/passwd -2 3 /etc/group</span><br><span class="line"># 同样的，相同的字段部分被移动到最前面了。所以第二个档案的内容就没再显示</span><br></pre></td></tr></table></figure></p><h4 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h4><p>这个 paste 就要比 join 简单多了。相对于 join 必须要比对两个档案的数据相关性，paste 就直接【将两行贴在一起，且中间以 [tab] 键隔开】而已。简单的使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# paste [-d] file1 file2</span><br><span class="line">选项与参数：</span><br><span class="line">    -d ：后面可以接分隔字符。预设是以 [tab] 来分隔的</span><br><span class="line">    - ：如果 file 部分写成 - ，表示来自 standard input 的资料的意思。</span><br></pre></td></tr></table></figure></p><h4 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h4><p>将 [tab] 按键转成空格键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# expand [-t] file</span><br><span class="line">选项与参数：</span><br><span class="line">    -t ：后面可以接数字。一般来说，一个 tab 按键可以用 8 个空格键取代。我们也可以自行定义一个 [tab] 按键代表多少个字符</span><br></pre></td></tr></table></figure></p><h3 id="5、分割命令：-split"><a href="#5、分割命令：-split" class="headerlink" title="5、分割命令： split"></a>5、分割命令： split</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# split [-bl] file PREFIX</span><br><span class="line">选项与参数：</span><br><span class="line">    -b ：后面可接欲分割成的档案大小，可加单位，例如 b, k, m 等；</span><br><span class="line">    -l ：以行数来进行分割。</span><br><span class="line">    PREFIX ：代表前导符的意思，可作为分割档案的前导文字。</span><br></pre></td></tr></table></figure><h3 id="6、参数代换：-xargs"><a href="#6、参数代换：-xargs" class="headerlink" title="6、参数代换： xargs"></a>6、参数代换： xargs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# xargs [-0epn] command</span><br><span class="line">选项与参数：</span><br><span class="line">    -0 ：如果输入的 stdin 含有特殊字符，例如 `, \, 空格键等等字符时，这个 -0 参数可以将他还原成一般字符。这个参数可以用于特殊状态</span><br><span class="line">    -e ：这个是 EOF (end of file) 的意思。后面可以接一个字符串，当 xargs 分析到这个字符串时，就会停止继续工作</span><br><span class="line">    -p ：在执行每个指令的 argument 时，都会询问使用者的意思；</span><br><span class="line">    -n ：后面接次数，每次 command 指令执行时，要使用几个参数的意思。</span><br><span class="line">当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就如同《数据流导向》所说的，bash 命令执行的时候有输出的数据会出现，那么如果这群数据必需要经过几道手续之后才能得到我们所想要的格式，应该如何来设定？这就牵涉到管线命令的问题(pipe) ，管线命令使用的是【 | 】这个界定符号。另外，管线命令与【连续下达命令】是不一样的。这点底下我们会再说明。底下我们先举一个例子来说明一下简单的管线命令。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：显示/etc/地下有多少个档案，并且利用less指令来分页显示&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@www ~]# ls -al /etc | less&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="BASH" scheme="http://yoursite.com/tags/BASH/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之数据流重导向</title>
    <link href="http://yoursite.com/2017/12/28/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AF%BC%E5%90%91/"/>
    <id>http://yoursite.com/2017/12/28/认识与学习BASH之数据流重导向/</id>
    <published>2017-12-28T11:11:09.000Z</published>
    <updated>2018-01-18T06:59:45.012Z</updated>
    
    <content type="html"><![CDATA[<p>数据流重导向就是将某个指令执行后应该要出现在屏幕上的数据，给他传输到其他的地方，例如档案或者是装置(例如打印机之类的)。</p><h3 id="1、什么是数据流导向？"><a href="#1、什么是数据流导向？" class="headerlink" title="1、什么是数据流导向？"></a>1、什么是数据流导向？</h3><p>这得要由指令的执行结果谈起。一般来说，如果你要执行一个指令，通常他会是这样的：<br><img src="/uploads/2017/12/linux_standard_input_output_error.JPG" alt=""><br><a id="more"></a><br>我们执行一个指令的时候，这个指令可能会由档案读入资料，经过处理之后，再将数据输出到屏幕上。在上图当中，standard output 与 standard error output 分别代表【标准输出】与【标准错误输出】，这两个默认都是输出到屏幕上面。那么什么是标准输出与标准错误输出呢？</p><h3 id="2、standard-output-与-standard-error-output"><a href="#2、standard-output-与-standard-error-output" class="headerlink" title="2、standard output 与 standard error output"></a>2、standard output 与 standard error output</h3><p>简单的说，标准输出指的是【指令执行所回传的正确的讯息】，而标准错误输出可理解为【指令执行失败后，所回传的错误讯息】。不管正确或错误的数据都是默认输出到屏幕上，所以屏幕当然是乱的。那能不能透过某些机制将这两股数据分开呢？答案是可以的。那就是数据流重导向的功能，数据流重导向可以将 standard output(简称 stdout) 与 standard error output (简称 stderr)分别传送到其他的档案或装置去，而分别传送所用的特殊字符则如下所示：</p><pre><code>1. 标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；2. 标准输出 (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；3. 标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；</code></pre><p><strong>（注：一个’&lt;’符号表示覆盖，两个’&lt;&lt;’表示追加。）</strong></p><h3 id="3、-dev-null-垃圾桶黑洞装置与特殊写法"><a href="#3、-dev-null-垃圾桶黑洞装置与特殊写法" class="headerlink" title="3、/dev/null 垃圾桶黑洞装置与特殊写法"></a>3、/dev/null 垃圾桶黑洞装置与特殊写法</h3><p>如果我知道错误讯息会发生，所以要将错误讯息忽略掉而不显示或储存，这个时候黑洞装置 /dev/null 就很重要了。这个 /dev/null 可以吃掉任何导向这个装置的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">[dmtsai@www ~]$ find /home -name .bashrc 2&gt; /dev/null</span><br><span class="line">/home/dmtsai/.bashrc &lt;==只有 stdout 会显示到屏幕上， stderr 被丢弃了</span><br></pre></td></tr></table></figure></p><p>如果我要将正确与错误数据通通写入同一个档案去，这个时候就得要使用特殊的写法了。我们同样用底下的案例来说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：将指令的数据全部写入名为 list 的档案中</span><br><span class="line">[dmtsai@www ~]$ find /home -name .bashrc &gt; list 2&gt; list &lt;==错误</span><br><span class="line">[dmtsai@www ~]$ find /home -name .bashrc &gt; list 2&gt;&amp;1 &lt;==正确</span><br><span class="line">[dmtsai@www ~]$ find /home -name .bashrc &amp;&gt; list &lt;==正确</span><br></pre></td></tr></table></figure></p><p>上述表格第一行错误的原因是，由于两股数据同时写入一个档案，又没有使用特殊的语法，此时两股数据可能会交叉写入该档案内，造成次序的错乱。所以虽然最终 list 档案还是会产生，但是里面的数据排列是乱的，而不是原本屏幕上的输出排序。至于写入同一个档案的特殊语法如上所示，你可以使用 2&gt;&amp;1 也可以使用 &amp;&gt; 。一般来说，比较常见的是 2&gt;&amp;1 的语法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据流重导向就是将某个指令执行后应该要出现在屏幕上的数据，给他传输到其他的地方，例如档案或者是装置(例如打印机之类的)。&lt;/p&gt;
&lt;h3 id=&quot;1、什么是数据流导向？&quot;&gt;&lt;a href=&quot;#1、什么是数据流导向？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是数据流导向？&quot;&gt;&lt;/a&gt;1、什么是数据流导向？&lt;/h3&gt;&lt;p&gt;这得要由指令的执行结果谈起。一般来说，如果你要执行一个指令，通常他会是这样的：&lt;br&gt;&lt;img src=&quot;/uploads/2017/12/linux_standard_input_output_error.JPG&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="BASH" scheme="http://yoursite.com/tags/BASH/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之变量</title>
    <link href="http://yoursite.com/2017/12/28/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8B%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2017/12/28/认识与学习BASH之变量/</id>
    <published>2017-12-28T11:10:43.000Z</published>
    <updated>2018-01-18T06:59:54.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Shell-的变量"><a href="#1、Shell-的变量" class="headerlink" title="1、Shell 的变量"></a>1、Shell 的变量</h3><p>变量是 bash 环境中非常重要的一个知识点，我们知道 Linux 是多人多任务的环境，每个人登入系统都能取得一个 bash ，每个人都能够使用 bash 下达 mail 这个指令来收取【自己】的邮件，问题是，bash 是如何得知你的邮件信箱是哪个档案？这就需要【变量】的帮助。底下我们将介绍重要的环境变量、变量的取用与设定等数据。<br><a id="more"></a></p><h3 id="2、什么是变量"><a href="#2、什么是变量" class="headerlink" title="2、什么是变量"></a>2、什么是变量</h3><p>简单的说，就是让某一个特定字符串代表不固定的内容。<br><strong>（1）环境变量</strong><br>当我们登录到Linux之后，就会有一个bash的执行程序用来跟Linux沟通，而在进入 shell 之前，由于系统需要一些变量来提供其他数据的存取 (或者是一些环境的设定参数值，例如是否要显示彩色等等)，所以就有一些所谓的【环境变量】需要来读入系统中。这些环境变量例如 PATH、HOME、MAIL、SHELL 等等，都是很重要的，为了区别与自定义变量的不同，环境变量通常以大写字符来表示。</p><p><strong>（2）变量的取用与设定：echo, 取消变量设定规则：unset</strong><br>可以利用 echo 这个指令来取用变量，但是，变量在被取用时，前面必须要加上钱字号【$】才行，举例来说，要知道 PATH 的内容，该如何是好？</p><ol><li><p>变量的取用：</p><blockquote><p>[root@www ~]# echo $PATH<br>/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin<br>变量的取用就如同上面的范例，利用 ehco 就能够读出，只是需要在变量名称前面加上 $，或者是以${变量}的方式来取用都可以。</p></blockquote></li><li><p>变量的设定规则：</p><blockquote><p>1.变量与变量内容以一个等号【=】来连结，如下所示：<br>　　【myname=ben】<br>2.等号两边不能直接接空格符，如下所示为错误：<br>　　【myname = ben】或【myname=ben Tsai】<br>3.变量名称只能是英文字母与数字，但是开头字符不能是数字，如下为错误：<br>　　【2myname=ben】<br>4.变量内容若有空格符可使用双引号【”】或单引号【’】将变量内容结合起来，但双引号能够识别变量，单引号原样输出。<br>5.可用跳脱字符【\】将特殊符号(如 [Enter], $, \, 空格符, ‘等)变成一般字符；<br>6.在一串指令中，还需要藉由其他的指令提供的信息，可以使用反单引号【<code>指令</code>】或【$(指令)】。<br>　　【version=$(uname -r)】再【echo $version】可得【2.6.32_1-16-0-0_virtio】<br>7.若该变量为扩增变量内容时，则可用 “$变量名称” 或 ${变量} 累加内容，如下所示：<br>　　【PATH=”$PATH”:/home/bin】<br>8.若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境发量：<br>　　【export PATH】<br>9.通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断；<br>10.取消变量的方法为使用 unset ：【unset 变量名称】例如取消 version 的设定：<br>　　【unset version】</p></blockquote></li></ol><p><strong>（3）其它</strong></p><ol><li>什么是【子程序】呢？就是说，在我目前这个 shell 的情况下，去启用另一个新的 shell ，新的那个shell 就是子程序。在一般的状态下，父程序的自定义变量是无法在子程序内使用的。但是透过export 将变量变成环境发量后，就能够在子程序底下应用了。</li><li>在指令下达的过程中，反单引号( ` )这个符号代表的意义为何？<br>在一串指令中，在 ` 之内的指令将会被先执行，而其执行出来的结果将做为外部的输入信息。</li></ol><h3 id="3、环境变量的功能"><a href="#3、环境变量的功能" class="headerlink" title="3、环境变量的功能"></a>3、环境变量的功能</h3><p>用 env 观察环境变量与常见环境变量说明。env 是 environment (环境) 的简写，是列出来所有的环境变量的命令（此处就不贴出 env 命令显示数据）。<br>底下我们对一些常见变量来做一个说明：</p><blockquote><p>HOME<br>    代表用户的家目录。还记得我们可以使用 cd ~ 去到自己的家目录吗？或者利用 cd 就可以直接回到用户家目录了。那就是取用这个变量。有很多程序都可能会取用到这个变量的值。</p><p>SHELL<br>    告知我们，目前这个环境使用的 SHELL 是哪支程序？ Linux 预设使用 /bin/bash 。</p><p>HISTSIZE<br>    这个与【历史命令】有关，亦即是，我们曾经下达过的指令可以被系统记录下来，而记录的【笔数】则是由这个值来设定的。</p><p>MAIL<br>    当我们使用 mail 这个指令在收信时，系统会去读取的邮件信箱档案 (mailbox)。</p><p>PATH<br>    就是执行文件搜寻的路径，目录与目录中间以冒号(:)分隔，由于档案的搜寻是依序由 PATH 的变量内的目录来查询，所以目录的顺序也是重要的。</p><p>LANG<br>    这个重要。就是语系数据。很多讯息都会用到他，举例来说，当我们在启动某些 perl 的程序语言档案时，他会主动的去分析语系数据文件，如果发现有他无法解析的编码语系，可能会产生错误。一般来说，我们中文编码通常是 zh_TW.Big5 或者是 zh_TW.UTF-8，这两个编码偏偏不容易被解译出来，所以，有的时候，可能需要修订一下语系数据。</p><p>RANDOM<br>    这个就是【随机随机数】的变量。目前大多数的 distributions 都会有随机数生成器，那就是 /dev/random 这个档案。 我们可以透过这个随机数档案相关的变量 ($RANDOM) 来随机取得随机数值。在 BASH 的环境下，这个 RANDOM 变量的内容，介于 0~32767 之间，所以，你只要 echo $RANDOM 时，系统就会主动的随机取出一个介于 0~32767 的数值。万一我想要使用 0~9 之间的数值，利用 declare 宣告数值类型，然后这样做就可以了：<br>        <code>declare -i number=$RANDOM*10/32768 ; echo $number ##此时会随机取出 0~9 之间的数值</code></p></blockquote><h3 id="4、变量键盘的读取、数组与宣告"><a href="#4、变量键盘的读取、数组与宣告" class="headerlink" title="4、变量键盘的读取、数组与宣告"></a>4、变量键盘的读取、数组与宣告</h3><p>（1）要读取来自键盘输入的变量，就是用 read 这个指令。这个指令最常被用在 shell script 的撰写当中，想要跟使用者对谈？用这个指令就对了。</p><pre><code>语法：read [-pt] variable选项与参数：    -p ：后面可以接提示字符；    -t ：后面可以接等待的【秒数！】这个比较有趣。不会一直等待使用者</code></pre><p>read 之后不加任何参数，直接加上变量名称，那么底下就会主动出现一个空白行等待你的输入。如果加上 -t 后面接秒数，那么 t 秒之内没有任何动作时，该指令就会自动略过。如果是加上 -p ，在输入的光标前就会有比较多可以用的提示字符给我们参考。在指令的下达里面，比较美观。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">[root@www ~]# echo $atest</span><br><span class="line">This is a test &lt;==你刚刚输入的数据已经变成一个变量内容</span><br><span class="line">[root@www ~]# read -p &quot;Please keyin your name: &quot; -t 30 named</span><br><span class="line">Please keyin your name: VBird Tsai &lt;==提示使用者 30 秒内输入自己的大名，将该输入字符串作为名为 named的变量内容</span><br></pre></td></tr></table></figure></p><p>（2）declare 或 typeset 是一样的功能，就是在【宣告变量的类型】。如果使用 declare 后面并没有接任何参数，那么 bash 就会主动的将所有的变量名称与内容通通叫出来，就好像使用 set 一样。<br>declare / typeset</p><pre><code>语法：declare [-aixr] variable选项与参数：    -a ：将后面名为 variable 的变量定义成为数组 (array) 类型    -i ：将后面名为 variable 的变量定义成为整数数字 (integer) 类型    -x ：用法与 export 一样，就是将后面的 variable 变成环境变量；取消的话将[-x]变为[+x]即为取消。    -r ：将变量设定成为 readonly 类型，该变量不可被更改内容，也不能 unset</code></pre><h3 id="5、变量内容的删除、取代与替换"><a href="#5、变量内容的删除、取代与替换" class="headerlink" title="5、变量内容的删除、取代与替换"></a>5、变量内容的删除、取代与替换</h3><p><img src="/uploads/2017/12/linux_shell_variable_01.png" alt=""></p><h3 id="6、用户登入-shell-后读取的两个配置文件："><a href="#6、用户登入-shell-后读取的两个配置文件：" class="headerlink" title="6、用户登入 shell 后读取的两个配置文件："></a>6、用户登入 shell 后读取的两个配置文件：</h3><ol><li>/etc/profile：这是系统整体的设定，你最好不要修改这个档案；</li><li>~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于使用者个人设定，你要改自己的数据，就写入这里。</li></ol><h3 id="7、常见的一些特殊变量"><a href="#7、常见的一些特殊变量" class="headerlink" title="7、常见的一些特殊变量"></a>7、常见的一些特殊变量</h3><style type="text/css">    table th:first-of-type {        width: 100px;    }</style><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td>$#</td><td>传递到脚本的参数个数</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td></tr><tr><td>$@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td>$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、Shell-的变量&quot;&gt;&lt;a href=&quot;#1、Shell-的变量&quot; class=&quot;headerlink&quot; title=&quot;1、Shell 的变量&quot;&gt;&lt;/a&gt;1、Shell 的变量&lt;/h3&gt;&lt;p&gt;变量是 bash 环境中非常重要的一个知识点，我们知道 Linux 是多人多任务的环境，每个人登入系统都能取得一个 bash ，每个人都能够使用 bash 下达 mail 这个指令来收取【自己】的邮件，问题是，bash 是如何得知你的邮件信箱是哪个档案？这就需要【变量】的帮助。底下我们将介绍重要的环境变量、变量的取用与设定等数据。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="BASH" scheme="http://yoursite.com/tags/BASH/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之BASH概述</title>
    <link href="http://yoursite.com/2017/12/28/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8BBASH%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/12/28/认识与学习BASH之BASH概述/</id>
    <published>2017-12-28T11:10:35.000Z</published>
    <updated>2018-01-18T07:00:21.842Z</updated>
    
    <content type="html"><![CDATA[<p>为什么BASH叫做壳程序？ 理解这个就理解了BASH与操作系统的关系，以及BASH是什么，有什么用。</p><h3 id="1、认识BASH这个Shell"><a href="#1、认识BASH这个Shell" class="headerlink" title="1、认识BASH这个Shell"></a>1、认识BASH这个Shell</h3><p>管理整个计算机硬件的其实是操作系统的核心 (kernel)，这个核心是需要被保护的。所以我们一般使用者就只能透过 shell 来跟核心沟通，以让核心达到我们所想要达到的工作。那么系统有多少 shell 可用呢？为什么我们要使用 bash啊？底下分别来谈一谈。<br><a id="more"></a></p><h3 id="2、硬件、核心-与-Shell"><a href="#2、硬件、核心-与-Shell" class="headerlink" title="2、硬件、核心 与 Shell"></a>2、硬件、核心 与 Shell</h3><p>在认识 Shell 之前，我们先来了解一下计算机的运作状况吧。举个例子来说：当你要计算机传输出来【音乐】的时候，你的计算机需要什么东西呢？</p><pre><code>1. 硬件：当然就是需要你的硬件有【声卡芯片】这个配备，否则怎么会有声音；2. 核心管理：操作系统的核心可以支持这个芯片组，当然还需要提供芯片的驱动程序；3. 应用程序：需要使用者 (就是你) 输入发生声音的指令。</code></pre><p>这就是基本的一个输出声音所需要的步骤。也就是说，你必须要【输入】一个指令之后，【硬件】才会透过你下达的指令来工作。那么硬件如何知道你下达的指令呢？那就是 kernel (核心) 的控制工作了，也就是说，我们必须要透过【Shell】将我们输入的指令与 Kernel 沟通，好让 Kernel 可以控制硬件来正确无误的工作。</p><p>曾经提到过，操作系统其实是一组软件，由于这组软件在控制整个硬件与管理系统的活动监测，如果这组软件能被用户随意的操作，若使用者应用不当，将会使得整个系统崩溃！因为操作系统管理的就是整个硬件功能，所以当然不能够随便被一些没有管理能力的终端用户随意使用。但是我们总是需要让用户操作系统的，所以就有了在操作系统上面发展的应用程序。用户可以透过应用程序来指挥核心，让核心达成我们所需要的硬件任务！</p><p>我们可以发现应用程序其实是在最外局，就如同鸡蛋的外壳一样，因此这个咚咚也就被称呼为<font color="red">壳程序 (shell)</font>。其实壳程序的功能只是提供用户操作系统的一个接口，因此这个壳程序需要可以呼叫其他软件才好。我们知道有很多指令，例如 man, chmod, chown, vi, fdisk, mkfs 等指令，这些指令都是独立的应用程序，但是我们可以透过壳程序 (就是指令列模式)来操作这些应用程序，让这些应用程序呼叫核心来运作所需的工作。这样对于壳程序是否有了一定的概念了。</p><blockquote><p>也就是说，只要能够操作应用程序的接口都能够称为壳程序。狭义的壳程序指的是指令列方面的软件，包括本章要介绍的 bash 等。广义的壳程序则包括图形接口的软件，因为图形接口其实也能够操作各种应用程序来呼叫核心工作。</p></blockquote><h3 id="3、系统合法的shell与-etc-shells功能"><a href="#3、系统合法的shell与-etc-shells功能" class="headerlink" title="3、系统合法的shell与/etc/shells功能"></a>3、系统合法的shell与/etc/shells功能</h3><p>知道什么是 Shell 之后，那么我们来了解一下 Linux 使用的是哪一个 shell 。由于早年的 Unix 年代，发展者众，所以由于 shell 依据发展者的不同就有很多的版本，例如常听到的 Bourne SHell (sh) 、在 Sun 里头预设的 C SHell、 商业上常用的 K SHell、还有 TCSH 等等，每一种 Shell 都各有其特点。至于 Linux 使用的这一种版本就称为【Bourne Again SHell (简称 bash) 】，这个 Shell 是 Bourne Shell 的增强版本，也是基准于GNU 的架构下发展出来的。</p><p>在介绍 shell 的优点之前，先来说一说 shell 的简单历史：第一个流行的 shell 是由 Steven Bourne 发展出来的，为了纪念他所以就称为 Bourne shell ，或直接简称为 sh 。而后来另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计依附于 BSD 版的 Unix 系统中的 shell ，这个 shell 的语法有点类似 C 语言，所以才得名为 C shell ，简称为 csh 。由于在学术界 Sun 主机势力相当的庞大，而Sun 主要是 BSD 的分支之一，所以 C shell 也是另一个很重要而且流传很广的 shell 之一 。</p><blockquote><p>由于 Linux 为 C 程序语言撰写的，很多程序设计师使用 C 来开发软件，因此 C shell相对的就很热门了。Sun 公司的创始人就是 Bill Joy，而 BSD 最早就是 Bill Joy 发展出来的。</p></blockquote><p>那么目前我们的 Linux 有多少我们可以使用的 shells 呢？ 你可以检查一下/etc/shells 这个档案，至少就有底下这几个可以用的 shells：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh (已经被 /bin/bash 所取代)</span><br><span class="line">/bin/bash (就是 Linux 预设的 shell)</span><br><span class="line">/bin/ksh (Kornshell 由 AT&amp;T Bell lab. 发展出来的，兼容于 bash)</span><br><span class="line">/bin/tcsh (整合 C Shell ，提供更多的功能)</span><br><span class="line">/bin/csh (已经被 /bin/tcsh 所取代)</span><br><span class="line">/bin/zsh (基于 ksh 发展出来的，功能更强大的 shell)</span><br></pre></td></tr></table></figure></p><p>虽然各家 shell 的功能都差不多，但是在某些语法的下达方面则有所不同，因此建议你还是选择某一种 shell 来熟悉一下较佳。 Linux 预设就是使用 bash ，所以最初你只要学会 bash 就ok了。为什么我们系统上合法的 shell 要写入 /etc/shells 这个档案呢？ 这是因为系统某些服务在运作过程中，会去检查使用者能够使用的 shells ，而这些 shell 的查询就是藉由 /etc/shells 这个档案。</p><p>那么，我这个使用者取得shell工作后，预设会取得哪一个 shell 呢？当我登入的时候，系统就会给我一个 shell 让我来工作了。而这个登入取得的 shell 就记录在 /etc/passwd 这个档案内。这个档案的内容是啥？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">.....(底下省略).....</span><br></pre></td></tr></table></figure></p><p>如上所示，在每一行的最后一个数据，就是你登入后取得预设的 shell 。</p><h3 id="4、Bash-shell-的功能"><a href="#4、Bash-shell-的功能" class="headerlink" title="4、Bash shell 的功能"></a>4、Bash shell 的功能</h3><p>既然 /bin/bash 是 Linux 预设的 shell，那么总是得了解一下这个玩意儿。bash 是 GNU 计划中重要的工具软件之一，目前也是 Linux distributions 的标准 shell 。 bash 主要兼容于 sh ，并且依据一些使用者的需求，而加强的 shell 版本。不论你使用的是那个 distribution ，你都难逃需要学习 bash 的宿命。那么这个 shell 有什么好处，干嘛 Linux 要使用他作为预设的 shell 呢？ bash 主要的优点有底下几个：</p><p><strong>（1）命令编修能力 (history)：</strong><br>就是记忆使用过的指令，只要在指令列按【上下键】就可以找到前/后一个输入的指令。而在很多 distribution 里头，默认的指令记忆功能可以多达 1000 个。也就是说，你曾经下达过的指令几乎都被记录下来了。</p><p>这么多的指令记录在哪里呢？在你的家目录内的 .bash_history。不过，需要留意的是，~/.bash_history 记录的是前一次登入以前所执行过的指令，而至于这一次登入所执行的指令都被暂存在内存中，当你成功的注销系统后，该指令记忆才会记录到 .bash_history 当中。</p><p><strong>（2）命令与档案补全功能： ([tab] 按键的好处)</strong><br>常常在 bash 环境中使用 [tab] 是个很棒的习惯。因为至少可以让你 1)少打很多字； 2)确定输入的数据是正确的。使用 [tab] 按键的时机依据 [tab] 接在指令后或参数后而有所不同。<br>如下所示：</p><pre><code>1. [Tab] 接在一串指令的第一个字的后面，则为命令补全；2. [Tab] 接在一串指令的第二个字以后时，则为【档案补齐】。</code></pre><p>所以说，如果我想要知道我的环境中，所有可以执行的指令有几个？就直接在 bash 的提示字符后面连续按两次 [tab] 按键就能够显示所有的可执行指令了。 那如果想要知道系统当中所有以 c 为开头的指令呢？就按下【c[tab][tab]】就好了。</p><p><strong>（3）命令别名设定功能： (alias)</strong><br>假如我需要知道这个目录底下的所有档案 (包含隐藏档) 及所有的文件属性，那么我就必须要下达【ls -al】这样的指令串。如果使用命令别名，就可以自定义命令来取代长指令串命令，也就是说使用 alias 即可。你可以在指令列输入 alias 就可以知道目前的命令别名有哪些了。也可以直接下达命令来设定别名：<br>    <code>alias lm=&#39;ls -al&#39;</code></p><p><strong>（4）工作控制、前景背景控制： (job control, foreground, background)</strong><br>使用前、背景的控制可以让工作进行的更为顺利。至于工作控制(jobs)的用途则更广，可以让我们随时将工作丢到背景中执行。而不怕不小心使用了[Ctrl] + c 来停掉该程序。此外，也可以在单一登录的环境中，达到多任务的目的。</p><p><strong>（5）程序化脚本： (shell scripts)</strong><br>在 Linux 底下的 shell scripts 可以将你平时管理系统常需要下达的连续指令写成一个档案，该档案并且可以透过对谈交互式的方式来进行主机的侦测工作。也可以藉由 shell 提供的环境变量及相关指令来进行设计，整个设计下来几乎就是一个小型的程序语言。（该部分会单独详解）</p><p><strong>（6）通配符： (Wildcard)</strong><br>除了完整的字符串之外，bash 还支持很多的通配符来帮助用户查询与指令下达。举例来说，想要知道/usr/bin 底下有多少以 X 为开头的档案，使用：【ls -l /usr/bin/X*】就能够知道。</p><h3 id="5、Bash-shell-的内建命令：-type"><a href="#5、Bash-shell-的内建命令：-type" class="headerlink" title="5、Bash shell 的内建命令： type"></a>5、Bash shell 的内建命令： type</h3><p>如何知道这个指令是来自于外部指令(指的是其他非 bash 所提供的指令) 或是内建在 bash 当中的，利用 type 这个指令来观察即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：`type [-tpa] name`</span><br><span class="line">选项与参数：</span><br><span class="line">   ：不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内建指令</span><br><span class="line">-t ：当加入 -t 参数时，type 会将 name 以底下这些字眼显示出他的意义：</span><br><span class="line">file ：表示为外部指令；</span><br><span class="line">alias ：表示该指令为命令别名所设定的名称；</span><br><span class="line">builtin ：表示该指令为 bash 内建的指令功能；</span><br><span class="line">-p ：如果后面接的 name 为外部指令时，才会显示完整文件名；</span><br><span class="line">-a ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含alias</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么BASH叫做壳程序？ 理解这个就理解了BASH与操作系统的关系，以及BASH是什么，有什么用。&lt;/p&gt;
&lt;h3 id=&quot;1、认识BASH这个Shell&quot;&gt;&lt;a href=&quot;#1、认识BASH这个Shell&quot; class=&quot;headerlink&quot; title=&quot;1、认识BASH这个Shell&quot;&gt;&lt;/a&gt;1、认识BASH这个Shell&lt;/h3&gt;&lt;p&gt;管理整个计算机硬件的其实是操作系统的核心 (kernel)，这个核心是需要被保护的。所以我们一般使用者就只能透过 shell 来跟核心沟通，以让核心达到我们所想要达到的工作。那么系统有多少 shell 可用呢？为什么我们要使用 bash啊？底下分别来谈一谈。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="BASH" scheme="http://yoursite.com/tags/BASH/"/>
    
  </entry>
  
  <entry>
    <title>vim程序编辑器</title>
    <link href="http://yoursite.com/2017/12/27/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://yoursite.com/2017/12/27/vim程序编辑器/</id>
    <published>2017-12-27T07:07:51.000Z</published>
    <updated>2018-01-18T07:04:46.313Z</updated>
    
    <content type="html"><![CDATA[<p>vi：文本编辑器<br>vim：程序编辑器</p><p>为什么要学vi？<br>因为所有的UNIX Like系统都会内建vi文本编辑器，其它的文本编辑器则不一定会存在。</p><p>vi与vim的区别？<br>其实你可以将 vim 规作 vi 的进阶版本，vim 可以用颜色或底线等方式来显示一些特殊的信息。举例来说，当你使用 vim 去编辑一个 C 程序语言的档案，或者是我们后续会谈到的shell script 程序时，vim 会依据档案的扩展名或者是档案内的开头信息，判断该档案的内容而自动的呼叫该程序的语法判断式，再以颜色来显示程序代码与一般信息。也就是说，这个 vim 是个【程序编辑器】。甚至一些 Linux 基础配置文件内的语法，都能够用 vim 来检查。<br><a id="more"></a><br>首先，先简单的对vi做个介绍，然后再说一下vim的额外功能与用法。</p><h2 id="vi的使用："><a href="#vi的使用：" class="headerlink" title="vi的使用："></a>vi的使用：</h2><p>基本上 vi 共分为三种模式，分别是【一般模式】、【编辑模式】与【指令列命令模式】。 这三种模式的作用分别是：</p><h3 id="一般模式："><a href="#一般模式：" class="headerlink" title="一般模式："></a>一般模式：</h3><p>以 vi 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用【上下左右】按键来移动光标，你可以使用【删除字符】或【删除整行】来处理档案内容，也可以使用【复制、粘贴】来处理你的文件数据。</p><h3 id="编辑模式："><a href="#编辑模式：" class="headerlink" title="编辑模式："></a>编辑模式：</h3><p>在一般模式中可以进行删除、复制、粘贴等等的动作，但是却无法编辑文件内容。要等到你按下【i, I, o, O, a, A, r, R】等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现【INSERT 或 REPLACE】的字样，此时才可以进行编辑。而如果要回到一般模式时，则必须要按下【Esc】这个按键即可退出编辑模式。</p><h3 id="指令列命令模式："><a href="#指令列命令模式：" class="headerlink" title="指令列命令模式："></a>指令列命令模式：</h3><p>在一般模式当中，输入【: / ?】三个中的任何一个按钮，就可以将光标移动到最底下那一行。在这个模式当中，可以提供你【搜寻资料】的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等等的动作则是在此模式中达成的。</p><p>简单的说，我们可以将这三个模式想成底下的图标来表示：<br><img src="/uploads/2017/12/linux_vi_01.JPG" alt=""><br>注意到上面的图标，你会发现一般模式可与编辑模式及指令列模式切换，但编辑模式与指令列模式之间不可互相切换。</p><h2 id="按键说明："><a href="#按键说明：" class="headerlink" title="按键说明："></a>按键说明：</h2><h3 id="第一部份：一般模式可用的按钮说明，光标移动、复制粘贴、搜寻取代等"><a href="#第一部份：一般模式可用的按钮说明，光标移动、复制粘贴、搜寻取代等" class="headerlink" title="第一部份：一般模式可用的按钮说明，光标移动、复制粘贴、搜寻取代等"></a>第一部份：一般模式可用的按钮说明，光标移动、复制粘贴、搜寻取代等</h3><p><img src="/uploads/2017/12/linux_vi_01.png" alt=""><br><img src="/uploads/2017/12/linux_vi_02.png" alt=""><br><img src="/uploads/2017/12/linux_vi_03.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">替换语法总结：</span><br><span class="line">基础语法：:[range]substitute/old/new/[flags]</span><br><span class="line">（注：substitute 常用缩写形式“:s”。）</span><br><span class="line">range:</span><br><span class="line">  . : 当前行</span><br><span class="line">  n : 对应行数</span><br><span class="line">  % : 所有行</span><br><span class="line">  $ : 最后一行</span><br><span class="line">flags:</span><br><span class="line">  空: 将光标所在行第一个 old 替换为 new</span><br><span class="line">  g : 将光标所在行所有 old 替换为 new</span><br><span class="line">  c : 表示进行确认</span><br><span class="line">  i : 不区分大小写</span><br></pre></td></tr></table></figure></p><p><img src="/uploads/2017/12/linux_vi_04.png" alt=""><br><img src="/uploads/2017/12/linux_vi_05.png" alt=""></p><h3 id="第二部份：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部份：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部份：一般模式切换到编辑模式的可用的按钮说明"></a>第二部份：一般模式切换到编辑模式的可用的按钮说明</h3><p><img src="/uploads/2017/12/linux_vi_06.png" alt=""></p><h3 id="第三部份：一般模式切换到指令列模式的可用的按钮说明"><a href="#第三部份：一般模式切换到指令列模式的可用的按钮说明" class="headerlink" title="第三部份：一般模式切换到指令列模式的可用的按钮说明"></a>第三部份：一般模式切换到指令列模式的可用的按钮说明</h3><p><img src="/uploads/2017/12/linux_vi_07.png" alt=""></p><h2 id="vim的暂存档、救援恢复与开启时的警告讯息"><a href="#vim的暂存档、救援恢复与开启时的警告讯息" class="headerlink" title="vim的暂存档、救援恢复与开启时的警告讯息"></a>vim的暂存档、救援恢复与开启时的警告讯息</h2><h3 id="什么是暂存档？"><a href="#什么是暂存档？" class="headerlink" title="什么是暂存档？"></a>什么是暂存档？</h3><p>当我们在使用 vim 编辑时， vim 会在不被编辑的档案的目录下，再建立一个名为 .filename.swp 的档案。当然，前提是由于各种原因导致的不正常的中断，才会产生该暂存档文件。如果对文件没有修改或正确存储则不会生成该暂存档文件。该暂存档文件的作用就是保留文件修改内容，防止文件因为系统或网络原因等导致丢失。</p><h3 id="警告讯息"><a href="#警告讯息" class="headerlink" title="警告讯息"></a>警告讯息</h3><p>团队工作中，有可能会有多人同时操作同一个文件的情况，这种情况就会产生警告讯息。至于这个发现暂存盘警告讯息的画面中，有出现六个可用按钮，各按钮的说明如下：</p><ul><li>[O]pen Read-Only：打开此档案成为只读档，可以用在你只是想要查阅该档案内容并不想要进行编辑行为时。一般来说，在上课时，如果你是登入到同学的计算机去看他的配置文件，结果发现其实同学他自己也在编辑时，可以使用这个模式；</li><li>(E)dit anyway：还是用正常的方式打开你要编辑的那个档案，并不会载入暂存盘的内容。不过很容易出现两个使用者互相改变对方的档案等问题！不好不好！</li><li>(R)ecover：就是加载暂存盘的内容，用在你要救回之前未储存的工作。不过当你救回来并且储存离开 vim 后，还是要手动自行删除那个暂存档。</li><li>(D)elete it：你确定那个暂存档是无用的。那么开启档案前会先将这个暂存盘删除！这个动作其实是比较常做的！因为你可能不确定这个暂存档是怎么来的，所以就删除掉他吧！</li><li>(Q)uit：按下 q 就离开 vim ，不会进行任何动作回到命令提示字符。</li><li>(A)bort：忽略这个编辑行为，感觉上与 quit 非常类似，也会送你回到命令提示字符。</li></ul><h2 id="vim的额外功能："><a href="#vim的额外功能：" class="headerlink" title="vim的额外功能："></a>vim的额外功能：</h2><p>查看vi是否被vim替代：alias<br>    <code>alias vi=&#39;vim&#39; &lt;==重点在这行</code><br>这表示当你使用 vi 这个指令时，其实就是执行 vim。如果你没有这一行，那么你就必须要使用 vimfilename 来启动 vim 。基本上， vim 的一般用法与 vi 完全一模一样。</p><h4 id="1、区块选择-Visual-Block"><a href="#1、区块选择-Visual-Block" class="headerlink" title="1、区块选择(Visual Block)"></a>1、区块选择(Visual Block)</h4><p>刚刚我们提到的简单的 vi 操作过程中，几乎提到的都是以行为单位的操作。那么如果我想要搞定的是一个区块范围呢？<br>那就使用区块选择 (Visual Block) 吧！当我们按下 v 或者 V 或者 [Ctrl]+v 时，这个时候光标移动过的地方就会开始反白，这三个按键的意义分别是：<br><img src="/uploads/2017/12/linux_vi_vb.png" alt=""><br>透过上述的功能，你可以复制一个区块，并且是贴在某个【区块的范围】内，而不是以行为单位来处理你的整份文件。</p><h4 id="2、多档案编辑"><a href="#2、多档案编辑" class="headerlink" title="2、多档案编辑"></a>2、多档案编辑</h4><p>如果我想要将 A 档案内的十条消息『移动』到 B 档案去，通常要开两个 vim 窗口来复制，偏偏每个 vim 都是独立的，因此并没有办法在 A 档案下达【nyy】再跑到 B 档案去【p】。 在这种情况下最常用的方法就是透过鼠标圈选， 复制后粘贴。不过这样一来还是有问题，因为用 [Tab] 按键进行编排对齐动作，透过鼠标却会将 [Tab] 转成空格键，这样内容就不一样了。此时这个多档案编辑就派上用场了！</p><p>我们可以使用 vim 后面同时接好几个档案来同时开启。相关的按键有：<br><img src="/uploads/2017/12/linux_vi_multifiles.png" alt=""></p><p>示例：将hosts 内的前四行 IP 资料复制到你的/etc/hosts 档案内，那可以怎么进行呢？可以这样：</p><pre><code>1. 透过【vim hosts /etc/hosts】指令来使用一个 vim 开启两个档案；2. 在 vim 中先使用【:files】察看一下编辑的档案数据有啥？结果如下所示。至于下图的最后一行显示的是【按下任意键】就会回到 vim 的一般模式中；3. 在第一行输入【4yy】复制前四行；4. 在 vim 的环境下输入【:n】会来到第二个编辑的档案，亦即 /etc/hosts 内；5. 在 /etc/hosts 下按【G】到最后一行，再输入【p】粘贴；6. 按下多次的【u】来还原原本的档案数据；7. 最终按下【:q】来离开 vim 的多档案编辑。</code></pre><h4 id="3、多窗口功能"><a href="#3、多窗口功能" class="headerlink" title="3、多窗口功能"></a>3、多窗口功能</h4><p>在开始这个小节前，先来想象两个情况：</p><ul><li>当我有一个档案非常的大，我查阅到后面的数据时，想要【对照】前面的数据，是否需要使用[ctrl]+f 与 [ctrl]+b (或 pageup, pagedown 功能键) 来跑前跑后查阅？</li><li>我有两个需要对照着看的档案，不想使用前一小节提到的多档案编辑功能；</li></ul><p>在一般窗口接口下的编辑软件大多有【分割窗口】或者是【冻结窗口】的功能来将一个档案分割成多个窗口的展现，那么 vim 能不能达到这个功能？可以啊。在指令列模式输入【:sp {filename}】即可！那个 filename 可有可无，如果想要在新窗口启动另一个档案，就加入档名，否则仅输入 :sp 时，出现的则是同一个档案在两个窗口。<br>下面是一些常用命令的说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:sp [filename] &lt;=&gt;  :split [filename]   #横向切分窗口</span><br><span class="line">:vsp [filename] &lt;=&gt;  :vsplit [filename]   #竖向切分窗口</span><br><span class="line">:clo  &lt;=&gt;  :close   #关闭当前窗口</span><br><span class="line">:on   &lt;=&gt;  :only    #仅保留当前窗口，其它窗口都关闭</span><br><span class="line">:ctrl + w + [h/j/k/l]   #切换窗口</span><br></pre></td></tr></table></figure></p><p>这样的话，复制啊、查阅啊等等的，就变的很简单。分割窗口的相关指令功能有很多，不过只要记得这几个就好了：<br><img src="/uploads/2017/12/linux_vi_multiwindows.png" alt=""></p><h4 id="4、vim-环境设定与记录：-vimrc-viminfo"><a href="#4、vim-环境设定与记录：-vimrc-viminfo" class="headerlink" title="4、vim 环境设定与记录： ~/.vimrc, ~/.viminfo"></a>4、vim 环境设定与记录： ~/.vimrc, ~/.viminfo</h4><p>有没有发现，如果我们以 vim 软件来搜寻一个档案内部的某个字符串时，这个字符串会被反白，而下次我们再次以 vim 编辑这个档案时，该搜寻的字符串反白情况还是存在呢！甚至于在编辑其他档案时，如果其他档案内也存在这个字符串，竟然还是主动反白。另外，当我们重复编辑同一个档案时，当第二次进入该档案时，光标竟然就在上次离开的那一行上头，真是好方便。但是，怎么会这样呢？</p><p>这是因为我们的 vim 会主动的将你曾经做过的行为登录下来，好让你下次可以轻松的作业。那个记录动作的档案就是： ~/.viminfo ！如果你曾经使用过 vim，那你的家目录应该会存在这个档案才对。这个档案是自动产生的，你不必自行建立。而你在 vim 里头所做过的动作，就可以在这个档案内部查询到。</p><p>此外，每个 distributions 对 vim 的预设环境都不太相同，举例来说，某些版本在搜寻到关键词时并不会高亮度反白，有些版本则会主动的帮你进行缩排的行为。但这些其实都可以自行设定的，那就是vim 癿环境设定。vim 的环境设定参数有很多，如果你想要知道目前的设定值，可以在一般模式时输入【:set all】 来查阅，不过…..设定项目实在太多了。所以，在这里仅列出一些平时比较常用的一些简单的设定值，提供参考。<br><img src="/uploads/2017/12/linux_vi_environment_set_01.png" alt=""><br><img src="/uploads/2017/12/linux_vi_environment_set_02.png" alt=""></p><p>总之，这些设定值很有用处的。但是……我是否每次使用 vim 都要重新设定一次各个参数值？这不太合理吧。所以，我们可以透过配置文件来直接规定我们习惯的 vim 操作环境。整体 vim 的设定值一般是放置在 /etc/vimrc 这个档案，不过，不建议你修改该文件，你可以修改 ~/.vimrc 这个档案(预设不存在，可以自行手动建立！)，将你所希望的设定值写入！举例来说，可以是这样的一个档案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# vim ~/.vimrc</span><br><span class="line">&quot;这个档案的双引号 (&quot;) 是批注</span><br><span class="line">set hlsearch &quot;高亮度反白</span><br><span class="line">set backspace=2 &quot;可随时用退格键删除</span><br><span class="line">set autoindent &quot;自动缩排</span><br><span class="line">set ruler &quot;可显示最后一行的状态</span><br><span class="line">set showmode &quot;左下角那一行的状态</span><br><span class="line">set nu &quot;可以在每一行的最前面显示行号</span><br><span class="line">set bg=dark &quot;显示不同的底色色调</span><br><span class="line">syntax on &quot;进行语法检验，颜色显示。</span><br></pre></td></tr></table></figure></p><p>在这个档案中，使用【set hlsearch】或【:set hlsearch】，亦即最前面有没有冒号【:】效果都是一样的！至于双引号则是批注符号，不要用错批注符号，否则每次使用 vim 时都会发生警告讯息。建立好这个档案后，当你下次重新以 vim 编辑某个档案时，该档案的预设环境设定就是上头写的。这样，是否很方便你的操作，多多利用 vim 的环境设定功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vi：文本编辑器&lt;br&gt;vim：程序编辑器&lt;/p&gt;
&lt;p&gt;为什么要学vi？&lt;br&gt;因为所有的UNIX Like系统都会内建vi文本编辑器，其它的文本编辑器则不一定会存在。&lt;/p&gt;
&lt;p&gt;vi与vim的区别？&lt;br&gt;其实你可以将 vim 规作 vi 的进阶版本，vim 可以用颜色或底线等方式来显示一些特殊的信息。举例来说，当你使用 vim 去编辑一个 C 程序语言的档案，或者是我们后续会谈到的shell script 程序时，vim 会依据档案的扩展名或者是档案内的开头信息，判断该档案的内容而自动的呼叫该程序的语法判断式，再以颜色来显示程序代码与一般信息。也就是说，这个 vim 是个【程序编辑器】。甚至一些 Linux 基础配置文件内的语法，都能够用 vim 来检查。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>文件系统的压缩详解</title>
    <link href="http://yoursite.com/2017/12/27/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/12/27/文件系统的压缩详解/</id>
    <published>2017-12-27T05:58:23.000Z</published>
    <updated>2018-01-18T06:58:25.380Z</updated>
    
    <content type="html"><![CDATA[<p>何为压缩？<br>何为压缩比？<br>为什么要压缩，压缩有什么好处？<br>带着这几个问题我们来学习一下。<br><a id="more"></a></p><h3 id="1、为什么要压缩："><a href="#1、为什么要压缩：" class="headerlink" title="1、为什么要压缩："></a>1、为什么要压缩：</h3><p>如果一个软件档案很多，或者文件档案太大，都会耗掉很多的磁盘空间，如果是网络传输也会耗掉很多带宽和时间，同时也不利于复制与携带。此时就需要【文件压缩】技术了。</p><h3 id="2、压缩的好处："><a href="#2、压缩的好处：" class="headerlink" title="2、压缩的好处："></a>2、压缩的好处：</h3><p>透过文件压缩的技术，最大的好处就是压缩过的档案容量变小了， 所以你的硬盘容量无形之中就可以容纳更多的资料。此外，在一些网络数据的传输中，也会由于数据量的降低，好让网络带宽可以用来作更多的工作。目前很多的 WWW 网站也是利用文件压缩的技术来进行数据的传送，好让网站带宽的可利用率上升。</p><h3 id="3、压缩的原理："><a href="#3、压缩的原理：" class="headerlink" title="3、压缩的原理："></a>3、压缩的原理：</h3><p>目前我们使用的计算机系统中都是使用所谓的 bytes（字节） 单位来计量的。不过，事实上，计算机最小的计量单位应该是 bits（比特） 才对。此外，我们也知道 1 byte = 8 bits 。但是如果今天我们只是记忆一个数字，亦即是 1 这个数字？他会如何记录？假设一个 byte 可以看成底下的模样：<br>　　　□□□□□□□□<br><em>（由于 1 byte = 8 bits ，所以每个 byte 当中会有 8 个空格，而每个空格可以是 0,1）</em></p><p>由于我们记录数字是 1 ，考虑计算机所谓的二进制，如此一来， 1 会在最右边占据 1 个 bit ，而其他的 7 个 bits 将会自动的被填上 0 。你看看，其实在这样的例子中，那 7 个 bits 应该是【空的】才对。不过，为了要满足目前我们的操作系统数据的存取（按字存取或按字节存取两种），所以就会将该数据转为 byte 的型态来记录。而一些聪明的计算机工程师就利用一些复杂的计算方式，将这些没有使用到的空间【丢】出去，以让档案占用的空间变小。这就是压缩的技术。</p><p>另外一种压缩技术也很有趣，他是将重复的数据进行统计记录的。举例来说，如果你的数据为【111….】共有100 个1 时， 那么压缩技术会记录为【100 个1】而不是真的有100 个1 的位存在！这样也能够精简档案记录的容量。</p><p>简单的说，你可以将他想成，其实档案里面有相当多的【空间】存在，并不是完全填满的， 而【压缩】的技术就是将这些【空间】填满，以让整个档案占用的容量下降。不过，这些【压缩过的档案】并无法直接被我们的操作系统所使用，因此， 若要使用这些被压缩过的档案数据，则必项将他【还原】回来未压缩前的模样， 那就是所谓的【解压缩】。而至于压缩前与压缩后的档案所占用的磁盘空间大小，就可以被称为是【压缩比】。</p><h3 id="4、压缩文件扩展名："><a href="#4、压缩文件扩展名：" class="headerlink" title="4、压缩文件扩展名："></a>4、压缩文件扩展名：</h3><p>在Linux中，文件的扩展名是没什么作用的，但是为什么不同的压缩文件有不同的扩展名呢？原因就是，因为 Linux 支持的压缩指令非常多，且不同的指令所用的压缩技术并不相同，当然彼此之间可能就无法互通压缩/解压缩文件。所以，当你下载到某个压缩文件时，自然就需要知道该档案是由哪种压缩指令所制作出来的，好用来对照着解压缩。也就是说，虽然 Linux 档案的属性基本上是与文件名没有绝对关系的，但是为了帮助我们人类小小的脑袋瓜子，所以适当的扩展名还是必要的。<br>底下我们就列出几个常见的压缩文件扩展名吧：</p><pre><code>*.Z compress 程序压缩的档案；*.gz gzip 程序压缩的档案；*.bz2 bzip2 程序压缩的档案；*.tar tar 程序打包的数据，并没有压缩过；*.tar.gz tar 程序打包的档案，其中并且经过 gzip 的压缩*.tar.bz2 tar 程序打包的档案，其中并且经过 bzip2 的压缩</code></pre><h3 id="5、常用压缩命令"><a href="#5、常用压缩命令" class="headerlink" title="5、常用压缩命令"></a>5、常用压缩命令</h3><h5 id="1-tar-命令："><a href="#1-tar-命令：" class="headerlink" title="1. tar 命令："></a>1. tar 命令：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">语法：语法：tar [主选项+辅选项] 文件或者目录</span><br><span class="line">参  数：</span><br><span class="line">-c: 建立压缩档案</span><br><span class="line">-x：解压</span><br><span class="line">-t：查看内容</span><br><span class="line">-r：向压缩归档文件末尾追加文件 (注：压缩后的档案再次追加文件会导致失败)</span><br><span class="line">-u：更新原压缩包中的文件（注：压缩后的档案再次更新会导致失败）</span><br><span class="line">这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。</span><br><span class="line">下面的参数是根据需要在压缩或解压档案时可选的。</span><br><span class="line">-z：有gzip属性的</span><br><span class="line">-j：有bz2属性的</span><br><span class="line">-Z：有compress属性的</span><br><span class="line">-v：显示所有过程</span><br><span class="line">-O：将文件解开到标准输出</span><br><span class="line">-f：使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。（必须）</span><br><span class="line">-C：解压到指定目录</span><br><span class="line">特殊使用：</span><br><span class="line">① # tar -rf all.tar *.gif</span><br><span class="line">这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</span><br><span class="line">② # tar -uf all.tar logo.gif</span><br><span class="line">这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</span><br><span class="line">③ # tar -tf all.tar</span><br><span class="line">这条命令是列出all.tar包中所有文件，-t是列出文件的意思</span><br><span class="line">压缩：</span><br><span class="line">① tar -cvf jpg.tar *.jpg //仅打包，不压缩！</span><br><span class="line">② tar -zcvf jpg.tar.gz *.jpg   //打包后，以 gzip 压缩</span><br><span class="line">③ tar -jcvf jpg.tar.bz2 *.jpg //打包后，以 bzip2 压缩</span><br><span class="line">解压：</span><br><span class="line">① tar -xvf file.tar //解压 tar包</span><br><span class="line">② tar -zxvf file.tar.gz //解压tar.gz</span><br><span class="line">③ tar -jxvf file.tar.bz2   //解压 tar.bz2</span><br><span class="line">④ tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下</span><br></pre></td></tr></table></figure><h5 id="2-zip-命令："><a href="#2-zip-命令：" class="headerlink" title="2. zip 命令："></a>2. zip 命令：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">语　　法：zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b &lt;工 作目录&gt;][-ll][-n &lt;字 尾字符串&gt;]\</span><br><span class="line">[-t &lt;日 期时间&gt;][-&lt;压 缩效率&gt;][压 缩文件][文件...][-i &lt;范本样式&gt;][-x &lt;范本样式&gt;]</span><br><span class="line">参　　数：</span><br><span class="line">-r   递归处理，将指定目录下的所有文件和子目录一并处理。</span><br><span class="line">-d   从压缩文件内删除指定的文件。</span><br><span class="line">-D   压缩文件内不建立目录名称。</span><br><span class="line">-m   将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。</span><br><span class="line">-x&lt;范本样式&gt;   压缩时排除符合条件的文件。</span><br><span class="line">-q   不显示指令执行过程。</span><br><span class="line">压缩文件：</span><br><span class="line">①  将当前目录下的所有文件和文件夹全部压缩成test.zip文件,-r表示递归压缩子目录下所有文件</span><br><span class="line"># zip -r test.zip ./*</span><br><span class="line">② 删除压缩文件test1.zip中test.MYI文件</span><br><span class="line"># zip -d test1.zip test.MYI</span><br><span class="line">③ 向压缩文件中test1.zip中添加test. MYI文件</span><br><span class="line"># zip -m test1.zip test. MYI</span><br><span class="line">④ 压缩文件时排除某个文件</span><br><span class="line"># zip test3.zip tests/* -x tests/ln.log</span><br><span class="line">unzip 命令：</span><br><span class="line">语　　法：unzip [-cflptuvz][-agCjLMnoqsVX][-P &lt;密 码&gt;][.zip文 件][文件][-d &lt;目录&gt;][-x &lt;文件&gt;] 或 unzip [-Z]</span><br><span class="line">-v   执 行是时显示详细的信息。或查看压缩文件目录，但不解压。</span><br><span class="line">-n   解 压缩时不要覆盖原有的文件。</span><br><span class="line">-o   不 必先询问用户，unzip执 行后覆盖原有文件。</span><br><span class="line">-q   执 行时不显示任何信息。</span><br><span class="line">-d&lt;目录&gt;   指 定文件解压缩后所要存储的目录。</span><br><span class="line">解压文件：</span><br><span class="line">① 将压缩文件text.zip在当前目录下解压缩。</span><br><span class="line"># unzip test.zip </span><br><span class="line">② 将压缩文件text.zip在指定目录/tmp下解压缩，如果已有相同的文件存在，要求unzip命令不覆盖原先的文件。</span><br><span class="line"># unzip -n test.zip -d /tmp</span><br><span class="line">③ 查看压缩文件目录，但不解压。</span><br><span class="line"># unzip -v test.zip</span><br><span class="line">④ 将压缩文件test.zip在指定目录tmp下解压缩，如果已有相同的文件存在，要求unzip命令覆盖原先的文件。</span><br><span class="line"># unzip -o test.zip -d tmp/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;何为压缩？&lt;br&gt;何为压缩比？&lt;br&gt;为什么要压缩，压缩有什么好处？&lt;br&gt;带着这几个问题我们来学习一下。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="计算机系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之shutdown</title>
    <link href="http://yoursite.com/2017/12/26/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bshutdown/"/>
    <id>http://yoursite.com/2017/12/26/Linux命令之shutdown/</id>
    <published>2017-12-26T10:28:35.000Z</published>
    <updated>2017-12-26T10:41:21.671Z</updated>
    
    <content type="html"><![CDATA[<p>　　正常情况下，windows在令你不爽的时候，按着电源开关4秒就关机了，或者简单粗暴的方法，直接拔电源。但是在Linux下非常不建议这么做。在 Linux 底下，由于每个程序 (或者说是服务) 都是在背景下执行的，因此，在你看不到的屏幕背后其实可能有相当多人同时在你的主机上面工作，若不正常关机，则可能造成文件系统的毁损 （因为来不及将数据回写到档案中，所以有些服务的档案会有问题！）。<br><a id="more"></a><br>惯用的关机指令：shutdown</p><blockquote><p>shutdown 可以达成如下的工作：</p><ul><li>可以自由选择关机模式：是要关机、重新启动或进入单人操作模式均可；</li><li>可以设定关机时间: 可以设定成现在立刻关机, 也可以设定某一个特定的时间才关机。</li><li>可以自定义关机讯息：在关机之前，可以将自己设定的讯息传送给在线 user 。</li><li>可以仅发出警告讯息：有时有可能你要进行一些测试，而不想让其他的使用者干扰， 或者是明白的告诉使用者某段时间要注意一下！这个时候可以使用 shutdown 来吓一吓使用者，但不是真的要关机！</li><li>可以选择是否要 fsck 检查文件系统 。</li></ul></blockquote><p>简单的语法规则为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# /sbin/shutdown [-t 秒] [-arkhncfF] 时间 [警告讯息]</span><br><span class="line">选项不参数：</span><br><span class="line">-t sec ： -t 后面加秒数，亦即【过几秒后关机】的意思</span><br><span class="line">-k ： 不要真的关机，只是发送警告讯息出去！</span><br><span class="line">-r ： 在将系统的服务停掉之后就重新启动 (常用)</span><br><span class="line">-h ： 将系统的服务停掉后，立即关机。 (常用)</span><br><span class="line">-n ： 不经过 init 程序，直接以 shutdown 的功能来关机</span><br><span class="line">-f ： 关机并开机之后，强制略过 fsck 的磁盘检查</span><br><span class="line">-F ： 系统重新启动之后，强制进行 fsck 的磁盘检查</span><br><span class="line">-c ： 取消已经在进行的 shutdown 指令内容。</span><br><span class="line">时间 ： 这是一定要加入的参数！指定系统关机的时间！时间的范例底下会说明。</span><br></pre></td></tr></table></figure></p><p>示例：<br><code>[root@www ~]# /sbin/shutdown -h 10 &#39;I will shutdown after 10 mins&#39;</code><br>告诉大家，这部机器会在十分钟后关机！并且“警告讯息”会显示在目前登入者的屏幕前方！<br><code>[root@www ~]# shutdown -h now</code><br>立刻关机，其中 now 相当于时间为 0 的状态<br><code>[root@www ~]# shutdown -h 20:25</code><br>系统在今天的 20:25 分会关机，若在21:25 才下达此指令，则明天才关机<br><code>[root@www ~]# shutdown -h +10</code><br>系统再过十分钟后自动关机<br><code>[root@www ~]# shutdown -r now</code><br>系统立刻重新启动<br><code>[root@www ~]# shutdown -r +30 &#39;The system will reboot&#39;</code><br>再过三十分钟系统会重新启动，并显示后面的讯息给所有在在线的使用者<br><code>[root@www ~]# shutdown -k now &#39;This system will reboot&#39;</code><br>仅发出警告信件的参数！系统并不会关机！吓唬人！</p><p><strong>重新启动命令：reboot, halt, poweroff</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　正常情况下，windows在令你不爽的时候，按着电源开关4秒就关机了，或者简单粗暴的方法，直接拔电源。但是在Linux下非常不建议这么做。在 Linux 底下，由于每个程序 (或者说是服务) 都是在背景下执行的，因此，在你看不到的屏幕背后其实可能有相当多人同时在你的主机上面工作，若不正常关机，则可能造成文件系统的毁损 （因为来不及将数据回写到档案中，所以有些服务的档案会有问题！）。&lt;br&gt;
    
    </summary>
    
      <category term="每日一个Linux命令" scheme="http://yoursite.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
