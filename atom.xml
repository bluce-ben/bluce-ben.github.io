<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-13T09:36:44.384Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP的几种运行模式</title>
    <link href="http://yoursite.com/2017/12/13/PHP%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/13/PHP的几种运行模式/</id>
    <published>2017-12-13T09:29:42.000Z</published>
    <updated>2017-12-13T09:36:44.384Z</updated>
    
    <content type="html"><![CDATA[<p>首先，我们来看看PHP的架构图：<br><img src="/uploads/2017/12/php_core_framework.jpg" alt=""><br><a id="more"></a><br>　　<strong>SAPI（Server Application Programming Interface服务端应用编程端口）提供了一个和外部通信的接口，使得PHP可以和其他应用进行交互数据。</strong> php默认提供了很多种SAPI，常见的给apache的mod_php，CGI，FastCGI，还有Shell的CLI。</p><h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p>　　以CGI的方式运行，CGI英文叫做公共网关接口，就是Apache在遇到PHP脚本的时候会将PHP程序提交给CGI应用程序（php-cgi.exe）解释，CGI方式在遇到连接请求（用户 请求）先要创建cgi的子进程，激活一个CGI进程（解析器会解析php.ini文件，初始化执行环境），然后处理请求，处理完后再以CGI规定的格式返回处理后的结果给Apache，结束这个子进程。之后Apache再将结果响应给请求的用户。这就是fork-and-execute模式。所以用cgi 方式的服务器有多少连接请求就会有多少cgi子进程，子进程反复加载是cgi性能低下的主要原因。都会当用户请求数量非常多时，会大量挤占系统的资源如内 存，CPU时间等，造成效能低下。</p><font color="red">（注：php-cgi 是PHP的解释器。）</font><h2 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h2><p>　　以FastCGI的方式运行，目的是提高CGI程序性能。这种形式是CGI的加强版本，CGI是单进程，多线程的运行方式，程序执行完成之后就会销毁，所以每次都需要加载配置和环境变量fork-and-execute（创建-执行）。而FastCGI则不同，FastCGI 像是一个常驻 (long-live) 型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 fork 一次。PHP使用PHP-FPM(FastCGI Process Manager)，全称PHP FastCGI进程管理器进行管理。<br>　　Web Server启动时载入FastCGI进程管理器(IIS ISAPI或Apache Module)。FastCGI进程管理器自身初始化，启动多个CGI解释器进程 (在任务管理器中可见多个php-cgi.exe)并等待来自Web Server的连接。<br>　　当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。<br>　　FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</p><h2 id="APACHE2HANDLER（mod-php）"><a href="#APACHE2HANDLER（mod-php）" class="headerlink" title="APACHE2HANDLER（mod_php）"></a>APACHE2HANDLER（mod_php）</h2><p>　　PHP作为Apache模块，Apache服务器在系统启动后，预先生成多个进程副本驻留在内存中，一旦有请求出 现，就立即使用这些空余的子进程进行处理，这样就不存在生成子进程造成的延迟了。这些服务器副本在处理完一次HTTP请求之后并不立即退出，而是停留在计算机中等待下次请求。对于客户浏览器的请求反应更快，性能较高。<br><em>注：实现FastCGI协议的还有 PHP-FPM（Nginx）、Spawn-FCGI（Lighttp）。</em></p><h2 id="CLI（Command-Line-Interface，即命令行接口）"><a href="#CLI（Command-Line-Interface，即命令行接口）" class="headerlink" title="CLI（Command Line Interface，即命令行接口）"></a>CLI（Command Line Interface，即命令行接口）</h2><p>　　cli是php的命令行运行模式，大家经常会使用它，但是可能并没有注意到（例如：我们在linux下经常使用 “php -m”查找PHP安装了那些扩展就是PHP命令行运行模式；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，我们来看看PHP的架构图：&lt;br&gt;&lt;img src=&quot;/uploads/2017/12/php_core_framework.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="PHP原理" scheme="http://yoursite.com/categories/PHP%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP原理" scheme="http://yoursite.com/tags/PHP%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>茅台投资者：最烦被说一夜暴富 这一天我等了十年【转】</title>
    <link href="http://yoursite.com/2017/12/13/%E8%8C%85%E5%8F%B0%E6%8A%95%E8%B5%84%E8%80%85%EF%BC%9A%E6%9C%80%E7%83%A6%E8%A2%AB%E8%AF%B4%E4%B8%80%E5%A4%9C%E6%9A%B4%E5%AF%8C-%E8%BF%99%E4%B8%80%E5%A4%A9%E6%88%91%E7%AD%89%E4%BA%86%E5%8D%81%E5%B9%B4%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>http://yoursite.com/2017/12/13/茅台投资者：最烦被说一夜暴富-这一天我等了十年【转】/</id>
    <published>2017-12-13T03:35:40.000Z</published>
    <updated>2017-12-13T05:27:10.220Z</updated>
    
    <content type="html"><![CDATA[<p><em>随记…</em><br><a id="more"></a><br><img src="/uploads/2017/12/essaies_01.JPEG" alt=""><br><img src="/uploads/2017/12/essaies_02.JPEG" alt=""><br>吴东勤参加茅台股东大会时的自拍。</p><p>茅台股票的异常波动造就了一个经济新名词“茅房困境”：我手里有钱，是拿来买房子，还是拿来买茅台？</p><p>这确实是个问题。</p><p>11月16日，“贵州茅台”以719.11元的收盘价，成为A股有史以来第一只突破700元的股票。当天，其总市值冲破9000亿元。</p><p>茅台自己倒是被吓到了。11月16日晚间茅台公司发布风险提示公告：希望广大投资者和消费者理性看待，审慎决策。</p><p>紧接着20日，上交所会员部出了份通报函，批评个别券商对茅台的评估报告客观依据不足，风险揭示不全面、不充分。</p><p>此后茅台股票一路走跌。11月28日，贵州茅台以648.23元收盘，上涨4.34%。</p><p>从年初的每股334.56元到此后一路走高，不到一年时间，贵州茅台股价累计上涨超100%。转眼又连续下跌，短短几个交易日，市值蒸发千亿。</p><p>股市从没有新事物，只有贪婪和恐惧的交替。那些投资茅台的人，他们有着怎样的故事呢？</p><p>给儿子留十套茅台生肖</p><p>茅台风波迭起的这几天，浙江舟山投资者吴东勤显得相当淡定，依旧保持着每天晚上喝一点的习惯，不多，两盅，茅台。</p><p>在吴东勤15平方米的办公室里有一面堆了将近50箱还没拆封的茅台生肖酒，旁边的架子上还陈列着限量的茅台酒和特供酒，都是近两年陆续收藏的。</p><p>他正在装修的新房子里甚至专门为茅台酒留了一间房，做陈列和收藏用。</p><p>“我以十年为一个周期做资产配置，每年有15%收益率就已经很开心了，茅台今年涨了多少！我不希望它（涨得）太快。”吴东勤会计学出身，喜欢讨论复利：每年15%收益率，意味着差不多5年以后他的投资就能够翻倍。</p><p>事实上，茅台的增长速度远远高于他的预期。“我从150元/股的价格开始买起，最低买到过118元/股，满仓以后就没有再交易。”即使不算分红收益，从开始重仓茅台，一年多时间吴东勤的账户资金已经翻了两番不止。</p><p>而他收藏的茅台生肖酒比买入时已经涨了3倍多。</p><p>这算暴利吗？“暴利？小票（指小市值股票）才赚得更多。”他说，“创业板我买过乐视，第一家上A股的网络视频公司，两个月不到赚了一倍。现在看呢？我曾问过自己一个问题，‘这家公司5年后会怎么样’，答案是‘不知道’，所以我抛掉了。”</p><p>当时的股市几乎是一匹脱缰的野马。“什么时候见顶，谁知道？我不够聪明，所以这个钱你们赚吧，我不赚了。”从那波断崖式下跌的行情里全身而退，吴东勤庆幸自己比较“傻”。“说到底股票投资赚的是三笔钱：一笔是价格低于价值，被低估的钱；一笔是企业发展，市值提高，增值的钱；还有一笔就是价值被高估，泡沫化的钱。我能赚到前两笔就足够满足了。”赚第一笔靠智商，赚到第二笔要耐心，而泡沫化的钱，迟早都要还回去。</p><p>“我自己是做实业的，知道实业企业一年能有10%~15%的净利润有多么难。用实业的思维去看一家公司的时候，我们在投资回报上的要求会非常理性。”吴东勤希望可以通过投资实现家庭致富，但这是一个漫长的过程，他并不急，他的计划是20年。“以后给儿子留十套茅台生肖酒，他人生的第一桶金就有了。”</p><p>一夜暴富？这一天我等了十年</p><p>仲阳和吴东勤同在一个茅粉群里，加群的门槛之一是至少持有5000股茅台。</p><p>一开始只是一起讨论股票的网友，投资理念相合，约着喝了顿酒，就成了朋友。他持有茅台的时间比吴东勤更长。</p><p>“最烦别人说茅台‘一夜暴富’，这一天我等了十年。”他买入时是2007年春，现在已是2017年冬，“当时茅台股价已经在100元附近徘徊，也是高价股了。”</p><p>以当时的“高价”买入，原本就存了长期持有的打算。“给儿子结婚准备的”，对好奇他十年不卖的朋友，仲阳总是这么解释，虽然他儿子今年初中还没毕业。</p><p>“我不会说自己锁仓十年都是那么快乐，我是凡人，2008年大熊市的惊涛骇浪，2012年秋后白酒板块的大溃退，都很彷徨。”仲阳说，其实最近这几天他也有点纠结要不要减仓：一方面作为十几年的资深“茅粉”，很清楚这家公司的经营状况并没有出现问题，并且正在进入一轮快速发展周期；另一方面他又多少有点担心历史重演，“我经历过两次股价60%以上的回撤，不想再坐一次电梯。”</p><p>他说，股票市场短期看是一台投票器，长期看一定是称重仪。“买股票就是做股东买企业，我要用足够的时间把企业的成长转化为我的财富。”这让他在茅台股价超过400元时决定继续做一个茅台的守望者，他很文艺地说，因为“几乎所有包括投资在内的伟大事业都是一场孤独的旅行”，最好不多看、不多说，也不胡思乱想。</p><p>话虽如此，实际很难做到，尤其是茅台股价在极短时间内冲破700元。“机构也好、基金也好都有短期业绩指标，他们不可能像我一样有耐心去等待一家企业成长，（他们）收一茬韭菜就走，能让他们兴奋的只有收益率。”仲阳说起来就生气，直言中国资本市场出现的很多问题每个参与者都有责任，不要抱怨我们没有伟大的公司，因为在他们成为“伟大”之前就已经被一轮轮收割。他忍不住骂了一句，“那些短视的公募基金！”</p><p>他决定还是再看看，作为小股东分享了一家企业十年成长的红利，很难说抛就抛。“有感情了。”为了分析这只股票，他甚至专门去研究茅台的历史，了解其酿造过程、搞清楚了每种茅台酒的区别，甚至身边朋友买茅台酒他都要叫人家去茅台电商买，除了“保真”以外，因为这样茅台股份能稍多一部分营收。尽管那几箱酒的买卖影响也未必多大，但他觉得这是投资者应尽之责。</p><p>700元以上可能会考虑减持茅台</p><p>跟仲阳碰面当天，茅台还没有破700元，另一位投资者“西湖边的男2015”在其个人微博上表态，“以股价700为界，本人在未来6个月内也将择机减持茅台股票；并使本人所持有的茅台仓位降到占全部持仓市值的6~7成。”</p><p>“西湖边的男2015”姓许，也是资深茅粉，微博网友习惯称呼他“西湖兄”。两人相识，用仲阳的话说，都是“经历过上甘岭的人”。圈内把在2012年秋后白酒板块的大溃退中坚持下来戏称为“守住上甘岭”。</p><p>“西湖边的男2015”手里的茅台股票是圈里比较多的，“按目前的市值来算早已过亿”，所以在圈里人看来适度减仓很正常。</p><p>11月14日，发微博当天，他说对茅台股价现状的看法是，“不再便宜，但也谈不上极端高估”。</p><p>11月16日，茅台股价破700元。</p><p>原本想约“西湖边的男2015”见面聊聊，结果他人正在大洋彼岸。“我这人散淡惯了。”他说。</p><p>一周之后，他发微博又谈起茅台，当然说的也不仅仅是茅台。谈及减持茅台的初衷，除了仓位原因，他说，“700元以上的茅台股价作为参照，去找寻在未来一个时期投资收益高于茅台的投资标的，是可能的。”当然，他口中的“未来一个时期”是5年，或者10年。大多数希望短期获利的人没有这份耐心。</p><p>他想要完成茅台的调仓，实际上并未完成。“这次市场并没有在700元以上给我提供充裕的调仓时间。好在，我善于等待，我不急。”</p><p>不要抱怨我们没有伟大的公司，因为在他们成为“伟大”之前就已经被一轮轮收割。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;随记…&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随记" scheme="http://yoursite.com/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="随记" scheme="http://yoursite.com/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Apache-多站点伪静态配置</title>
    <link href="http://yoursite.com/2017/12/13/Apache-%E5%A4%9A%E7%AB%99%E7%82%B9%E4%BC%AA%E9%9D%99%E6%80%81%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/12/13/Apache-多站点伪静态配置/</id>
    <published>2017-12-13T03:07:22.000Z</published>
    <updated>2017-12-13T03:14:58.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Apache伪静态配置"><a href="#一、Apache伪静态配置" class="headerlink" title="一、Apache伪静态配置"></a>一、Apache伪静态配置</h2><p>1、开启http.conf中的rewrite模块<br>LoadModule rewrite_module modules/mod_rewrite.so  #前的注释去掉即可<br>检测：可使用phpinfo() 查看mod_rewrite模块是否加载<br>2、允许指定目录使用.htaccess<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DocumentRoot &quot;D:/xampp/htdocs&quot;</span><br><span class="line">&lt;Directory &quot;D:/xampp/htdocs&quot;&gt;</span><br><span class="line">Options Indexes FollowSymLinks Includes ExecCGI</span><br><span class="line">AllowOverride All</span><br><span class="line">Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p><p>3、上面两步操作完之后，后面即可在 /htdocs目录下使用.htaccess文件<br><a id="more"></a></p><h2 id="二、多站点伪静态配置"><a href="#二、多站点伪静态配置" class="headerlink" title="二、多站点伪静态配置"></a>二、多站点伪静态配置</h2><blockquote><p>前提：根目录下有多个站点，且http.conf 配置文件中的网站根目录不能开启.htaccess文件识别。（否则，根目录开启.htaccess文件识别，那根目录下的子目录都会生效。）此处指的多站点配置伪静态是指对根目录下的某些站点配置。</p></blockquote><p>因此多站点配置可分为两种方式：</p><ol><li>根目录开启识别.htaccess文件</li><li>根目录下各子站开启识别.htaccess文件</li></ol><p>多站点配置伪静态，首先需要有多站点配置。此处不予说明，前提配置与上面相同，直接上代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerAdmin webmaster@admin.com</span><br><span class="line">    DocumentRoot &quot;D:/xampp/htdocs/CI&quot;</span><br><span class="line">    ServerName myblog.com</span><br><span class="line">    ServerAlias www.myblog.com</span><br><span class="line">    &lt;Directory &quot;D:/xampp/htdocs/CI&quot;&gt;</span><br><span class="line">        Options Indexes FollowSymLinks Includes ExecCGI</span><br><span class="line">        AllowOverride All</span><br><span class="line">        Require all granted</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">    ErrorLog &quot;logs/myblog.com-error.log&quot;</span><br><span class="line">    CustomLog &quot;logs/myblog-access.log&quot; common</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>此处的<directory>节点必须要写，否则站点下的.htaccess文件不生效。</directory></li><li>有几个站点可以配置几个站点，都是同理。</li></ul><h2 id="三、遇到的问题及操作记录"><a href="#三、遇到的问题及操作记录" class="headerlink" title="三、遇到的问题及操作记录"></a>三、遇到的问题及操作记录</h2><p>1、启动Apache报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">15:10:01  [Apache] Error: Apache shutdown unexpectedly.</span><br><span class="line">15:10:01  [Apache] This may be due to a blocked port, missing dependencies, </span><br><span class="line">15:10:01  [Apache] improper privileges, a crash, or a shutdown by another method.</span><br><span class="line">15:10:01  [Apache] Press the Logs button to view error logs and check</span><br><span class="line">15:10:01  [Apache] the Windows Event Viewer for more clues</span><br><span class="line">15:10:01  [Apache] If you need more help, copy and post this</span><br><span class="line">15:10:01  [Apache] entire log window on the forums</span><br></pre></td></tr></table></figure></p><p>解决办法：</p><ol><li>有错误可知最可能的原因就是端口被占用，因此可围绕端口占用查找<br>windows下查看端口情况及被占用情况命令：<br>列出所有端口的情况： netstat -ano<br>查找指定端口的情况： netstat -ano | findstr “80”<br>还可使用xampp管理界面直接查看使用端口情况，或者使用任务管理器查看进程，比对pid。</li><li>此处，经查我的错误不是端口被占用，可<strong>在命令行下面执行httpd.exe</strong>，查看输出结果。<br>提示错误：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\xampp\apache\bin&gt;httpd.exe</span><br><span class="line">AH00526: Syntax error on line 47 of D:/xampp/apache/conf/extra/httpd-vhosts.conf:</span><br><span class="line">ServerName takes one argument, The hostname and port of the server</span><br></pre></td></tr></table></figure></li></ol><p>可知是由于httpd-vhosts.conf配置文件修改错误，更改后重启成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Apache伪静态配置&quot;&gt;&lt;a href=&quot;#一、Apache伪静态配置&quot; class=&quot;headerlink&quot; title=&quot;一、Apache伪静态配置&quot;&gt;&lt;/a&gt;一、Apache伪静态配置&lt;/h2&gt;&lt;p&gt;1、开启http.conf中的rewrite模块&lt;br&gt;LoadModule rewrite_module modules/mod_rewrite.so  #前的注释去掉即可&lt;br&gt;检测：可使用phpinfo() 查看mod_rewrite模块是否加载&lt;br&gt;2、允许指定目录使用.htaccess&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DocumentRoot &amp;quot;D:/xampp/htdocs&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Directory &amp;quot;D:/xampp/htdocs&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Options Indexes FollowSymLinks Includes ExecCGI&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AllowOverride All&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Require all granted&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/Directory&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3、上面两步操作完之后，后面即可在 /htdocs目录下使用.htaccess文件&lt;br&gt;
    
    </summary>
    
      <category term="Apache" scheme="http://yoursite.com/categories/Apache/"/>
    
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Apache" scheme="http://yoursite.com/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之grep</title>
    <link href="http://yoursite.com/2017/12/12/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bgrep/"/>
    <id>http://yoursite.com/2017/12/12/Linux命令之grep/</id>
    <published>2017-12-12T10:27:29.000Z</published>
    <updated>2017-12-12T10:28:26.894Z</updated>
    
    <content type="html"><![CDATA[<p>　grep命令文件过滤分割与合并 grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。<br><a id="more"></a><br><strong>常用选项：</strong><br>-n    在显示符合范本样式的那一列之前，标示出该列的编号。<br>-v    反转查找。<br>-i    忽略字符大小写的差别。</p><p><strong>常见用法：</strong><br>1、在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：<br>grep match_pattern file_name<br>grep “match_pattern” file_name</p><p>2、在多个文件中查找：<br>grep “match_pattern” file_1 file_2 file_3 …<br>grep “match_pattern” ./*.php</p><p>3、输出除之外的所有行 -v 选项：<br>grep -v “match_pattern” file_name</p><p>4、输出包含匹配字符串的行数 -n 选项：<br>grep “text” -n file_name<br>或<br>cat file_name | grep “text” -n </p><p>#多个文件<br>grep “text” -n file_1 file_2</p><p>5、忽略匹配样式中的字符大小写：<br>echo “hello world” | grep -i “HELLO”<br>hello</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　grep命令文件过滤分割与合并 grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>CGI、FastCGI、PHP-CGI、PHP-FPM详解</title>
    <link href="http://yoursite.com/2017/12/12/CGI%E3%80%81FastCGI%E3%80%81PHP-CGI%E3%80%81PHP-FPM%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/12/12/CGI、FastCGI、PHP-CGI、PHP-FPM详解/</id>
    <published>2017-12-12T07:05:11.000Z</published>
    <updated>2017-12-12T10:48:31.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p>　CGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。<br>　CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等<br><a id="more"></a><br><img src="/uploads/2017/12/cgi_01.jpg" alt=""></p><h2 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h2><p>　FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute 模式)。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。<br>　FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail-Over特性等等。<br>　FastCGI也可以称为是一种协议标准，比如下面要说的php-fpm就是支持解析php的一个fastCGI进程管理器/引擎。<br><img src="/uploads/2017/12/fastcgi_01.jpg" alt=""></p><blockquote><p><strong>FastCGI特点</strong></p><ol><li>FastCGI具有语言无关性.</li><li>FastCGI在进程中的应用程序，独立于核心web服务器运行，提供了一个比API更安全的环境。APIs把应用程序的代码与核心的web服务器链接在一起，这意味着在一个错误的API的应用程序可能会损坏其他应用程序或核心服务器。 恶意的API的应用程序代码甚至可以窃取另一个应用程序或核心服务器的密钥。</li><li>FastCGI技术目前支持语言有：C/C++、Java、Perl、Tcl、Python、SmallTalk、Ruby等。相关模块在Apache, ISS, Lighttpd等流行的服务器上也是可用的。</li><li>FastCGI的不依赖于任何Web服务器的内部架构，因此即使服务器技术的变化, FastCGI依然稳定不变。</li></ol><p><strong>FastCGI的工作原理</strong></p><ol><li>Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module)</li><li>FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。</li><li>当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</li><li>FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</li></ol></blockquote><p>　在上述情况中，你可以想象CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展并重初始化全部数据结构。使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。</p><blockquote><p><strong>FastCGI的不足</strong><br>　因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。<br>　Nginx 0.8.46+PHP 5.2.14(FastCGI)服务器在3万并发连接下，开启的10个Nginx进程消耗150M内存（15M<em>10=150M），开启的64个php-cgi进程消耗1280M内存（20M</em>64=1280M），加上系统自身消耗的内存，总共消耗不到2GB内存。如果服务器内存较小，完全可以只开启25个php-cgi进程，这样php-cgi消耗的总内存数才500M。<br>上面的数据摘自Nginx 0.8.x + PHP 5.2.13(FastCGI)搭建胜过Apache十倍的Web服务器(第6版)</p></blockquote><h2 id="php-cgi"><a href="#php-cgi" class="headerlink" title="php-cgi"></a>php-cgi</h2><p>　php-cgi是php提供给web serve也就是http前端服务器的cgi协议接口程序，当每次接到http前端服务器的请求都会开启一个php-cgi进程进行处理，而且开启的php-cgi的过程中会先要重载配置，数据结构以及初始化运行环境，如果更新了php配置，那么就需要重启php-cgi才能生效，例如phpstudy就是这种情况。</p><h2 id="PHP-CGI"><a href="#PHP-CGI" class="headerlink" title="PHP-CGI"></a>PHP-CGI</h2><p>PHP-CGI是PHP自带的FastCGI管理器。</p><blockquote><p><strong>PHP-CGI的不足：</strong></p><ol><li>php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启。</li><li>直接杀死php-cgi进程，php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题，守护进程会平滑从新生成新的子进程。）</li></ol></blockquote><h2 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h2><p>PHP-FPM是一个PHP FastCGI管理器（FastCGI Process Manager），是只用于PHP的，可以在<a href="http://php-fpm.org/download下载得到。" target="_blank" rel="noopener">http://php-fpm.org/download下载得到。</a><br>PHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。<br>PHP5.3.3已经集成php-fpm了，不再是第三方的包了。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多有点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。</p><h2 id="Spawn-FCGI"><a href="#Spawn-FCGI" class="headerlink" title="Spawn-FCGI"></a>Spawn-FCGI</h2><p>Spawn-FCGI是一个通用的FastCGI管理服务器，它是lighttpd中的一部份，很多人都用Lighttpd的Spawn-FCGI进行FastCGI模式下的管理工作。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>　　fastCGI是nginx和php之间的一个通信接口，该接口实际处理过程通过启动php-fpm进程来解析php脚本，即php-fpm相当于一个动态应用服务器，从而实现nginx动态解析php。因此，如果nginx服务器需要支持php解析，需要在nginx.conf中增加php的配置：将php脚本转发到fastCGI进程监听的IP地址和端口（php-fpm.conf中指定）。同时，php安装的时候，需要开启支持fastCGI选项，并且编译安装php-fpm补丁/扩展，同时，需要启动php-fpm进程，才可以解析nginx通过fastCGI转发过来的php脚本。</p><blockquote><p>php-fpm是一个完全独立的程序,不依赖php-cgi,也不依赖php.因为php-fpm是一个内置了php解释器的FastCGI服务,启动时能够自行读取php.ini配置和php-fpm.conf配置.</p><p>附:PHP FastCGI进程管理器PHP-FPM的架构<br>一个master进程,支持多个pool,每个pool由master进程监听不同的端口,pool中有多个worker进程.<br>每个worker进程都内置PHP解释器,并且进程常驻后台,支持prefork动态增加.<br>每个worker进程支持在运行时编译脚本并在内存中缓存生成的opcode来提升性能.<br>每个worker进程支持配置响应指定请求数后自动重启,master进程会重启挂掉的worker进程.<br>每个worker进程能保持一个到MySQL/Memcached/Redis的持久连接,实现”连接池”,避免重复建立连接,对程序透明.<br>master进程采用epoll模型异步接收和分发请求,listen监听端口,epoll_wait等待连接,<br>然后分发给对应pool里的worker进程,worker进程accpet请求后poll处理连接,<br>如果worker进程不够用,master进程会prefork更多进程,<br>如果prefork达到了pm.max_children上限,worker进程又全都繁忙,<br>这时master进程会把请求挂起到连接队列backlog里(默认值是511).</p></blockquote><p>　web server（比如说nginx）只是内容的分发者。比如，如果请求/index.html，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。好了，如果现在请求的是/index.php，根据配置文件，nginx知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP解析器。Nginx会传哪些数据给PHP解析器呢？url要有吧，查询字符串也得有吧，POST数据也要有，HTTP header不能少吧，好的，CGI就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。仔细想想，你在PHP代码中使用的用户从哪里来的。</p><p>　当web server收到/index.php这个请求后，会启动对应的CGI程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程。web server再把结果返回给浏览器。</p><p>　好了，CGI是个协议，跟进程什么的没关系。那fastcgi又是什么呢？Fastcgi是用来提高CGI程序性能的。</p><p>　提高性能，那么CGI程序的性能问题在哪呢？”PHP解析器会解析php.ini文件，初始化执行环境”，就是这里了。标准的CGI对每个请求都会执行这些步骤（不闲累啊！启动进程很累的说！），所以处理每个时间的时间会比较长。这明显不合理嘛！那么Fastcgi是怎么做的呢？首先，Fastcgi会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是fastcgi的对进程的管理。</p><p>　那PHP-FPM又是什么呢？是一个实现了Fastcgi的程序，被PHP官方收了。</p><p>　大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理（皇上，臣妾真的做不到啊！）所以就出现了一些能够调度php-cgi进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。好了PHP-FPM也是这么个东东，在长时间的发展后，逐渐得到了大家的认可（要知道，前几年大家可是抱怨PHP-FPM稳定性太差的），也越来越流行。</p><p>　fastcgi是一个协议，php-fpm实现了这个协议</p><p>　php-fpm的 管理对象 是php-cgi。但不能说php-fpm是fastcgi进程的管理器，因为前面说了fastcgi是个协议，</p><p>　以前php-fpm没有包含在PHP内核里面，要使用这个功能，需要找到与源码版本相同的php-fpm对内核打补丁，然后再编译。</p><p>　后来PHP内核集成了PHP-FPM之后就方便多了，使用–enalbe-fpm这个编译参数即可。</p><p>　有的说，修改了php.ini配置文件后，没办法 平滑重启，所以就诞生了php-fpm</p><p>　是的，修改php.ini之后，php-cgi进程的确是没办法平滑重启的。php-fpm对此的处理机制是新的worker用新的配置，已经存在的worker处理完手上的活就可以歇着了，通过这种机制来平滑过度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CGI&quot;&gt;&lt;a href=&quot;#CGI&quot; class=&quot;headerlink&quot; title=&quot;CGI&quot;&gt;&lt;/a&gt;CGI&lt;/h2&gt;&lt;p&gt;　CGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。&lt;br&gt;　CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP原理" scheme="http://yoursite.com/tags/PHP%E5%8E%9F%E7%90%86/"/>
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>PHP底层的运行机制与原理【摘】</title>
    <link href="http://yoursite.com/2017/12/11/PHP%E5%BA%95%E5%B1%82%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E3%80%90%E6%91%98%E3%80%91/"/>
    <id>http://yoursite.com/2017/12/11/PHP底层的运行机制与原理【摘】/</id>
    <published>2017-12-11T08:27:41.000Z</published>
    <updated>2017-12-13T09:30:28.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHP简单运行过程："><a href="#PHP简单运行过程：" class="headerlink" title="PHP简单运行过程："></a>PHP简单运行过程：</h2><p>　我们从未手动开启过PHP的相关进程，它是随着Apache的启动而运行的；<br>　PHP通过mod_php5.so模块和Apache相连（具体说来是SAPI，即服务器应用程序编程接口）；<br>　PHP总共有三个模块：内核、Zend引擎、以及扩展层；<br>　PHP内核用来处理请求、文件流、错误处理等相关操作；<br>　Zend引擎（ZE）用以将源文件转换成机器语言，然后在虚拟机上运行它；<br>　扩展层是一组函数、类库和流，PHP使用它们来执行一些特定的操作。比如，我们需要mysql扩展来连接MySQL数据库；<br>　当ZE执行程序时可能会需要连接若干扩展，这时ZE将控制权交给扩展，等处理完特定任务后再返还；<br>　最后，ZE将程序运行结果返回给PHP内核，它再将结果传送给SAPI层，最终输出到浏览器上。<br><a id="more"></a></p><h2 id="PHP的执行流程-amp-opcode"><a href="#PHP的执行流程-amp-opcode" class="headerlink" title="PHP的执行流程&amp;opcode"></a>PHP的执行流程&amp;opcode</h2><p>　我们先来看看PHP代码的执行所经过的流程。<br><img src="/uploads/2017/12/php_opcode.jpg" alt=""><br>　从图上可以看到，PHP实现了一个典型的动态语言执行过程：拿到一段代码后，经过词法解析、语法解析等阶段后，源程序会被翻译成一个个指令(opcodes)，然后ZEND虚拟机顺次执行这些指令完成操作。PHP本身是用C实现的，因此最终调用的也都是C的函数，实际上，我们可以把PHP看做是一个C开发的软件。<br>　PHP的执行的核心是翻译出来的一条一条指令，也即opcode。<br>　Opcode是PHP程序执行的最基本单位。一个opcode由两个参数(op1,op2)、返回值和处理函数组成。PHP程序最终被翻译为一组opcode处理函数的顺序执行。</p><h2 id="PHP的四层体系"><a href="#PHP的四层体系" class="headerlink" title="PHP的四层体系"></a>PHP的四层体系</h2><p>PHP的核心架构如下图：<br><img src="/uploads/2017/12/php_core_framework.jpg" alt=""></p><p>从图上可以看出，PHP从下到上是一个4层体系：</p><ul><li>Zend引擎：Zend整体用纯C实现，是PHP的内核部分，它将PHP代码翻译（词法、语法解析等一系列编译过程）为可执行opcode的处理并实现相应的处理方法、实现了基本的数据结构（如hashtable、oo）、内存分配及管理、提供了相应的api方法供外部调用，是一切的核心，所有的外围功能均围绕Zend实现。</li><li>Extensions：围绕着Zend引擎，extensions通过组件式的方式提供各种基础服务，我们常见的各种内置函数（如array系列）、标准库等都是通过extension来实现，用户也可以根据需要实现自己的extension以达到功能扩展、性能优化等目的（如贴吧正在使用的PHP中间层、富文本解析就是extension的典型应用）。</li><li>Sapi：Sapi全称是Server Application Programming Interface，也就是服务端应用编程接口，Sapi通过一系列钩子函数，使得PHP可以和外围交互数据，这是PHP非常优雅和成功的一个设计，通过sapi成功的将PHP本身和上层应用解耦隔离，PHP可以不再考虑如何针对不同应用进行兼容，而应用本身也可以针对自己的特点实现不同的处理方式。</li><li>上层应用：这就是我们平时编写的PHP程序，通过不同的sapi方式得到各种各样的应用模式，如通过webserver实现web应用、在命令行下以脚本方式运行等等。</li></ul><p><strong>构架思想：</strong><br>引擎(Zend)+组件(ext)的模式降低内部耦合<br>中间层(sapi)隔绝web server和PHP</p><hr><p>如果php是一辆车，那么</p><p>车的框架就是php本身</p><p>Zend是车的引擎（发动机）</p><p>Ext下面的各种组件就是车的轮子</p><p>Sapi可以看做是公路，车可以跑在不同类型的公路上</p><p>而一次php程序的执行就是汽车跑在公路上。</p><p>因此，我们需要：性能优异的引擎+合适的车轮+正确的跑道</p><h2 id="Sapi"><a href="#Sapi" class="headerlink" title="Sapi"></a>Sapi</h2><p>　如前所述，Sapi通过通过一系列的接口，使得外部应用可以和PHP交换数据并可以根据不同应用特点实现特定的处理方法，我们常见的一些sapi有：</p><ul><li>apache2handler：这是以apache作为webserver，采用mod_PHP模式运行时候的处理方式，也是现在应用最广泛的一种。</li><li>cgi：这是webserver和PHP直接的另一种交互方式，也就是大名鼎鼎的fastcgi协议，在最近今年fastcgi+PHP得到越来越多的应用，也是异步webserver所唯一支持的方式。</li><li>cli：命令行调用的应用模式</li></ul><h2 id="LAMP架构"><a href="#LAMP架构" class="headerlink" title="LAMP架构"></a>LAMP架构</h2><p><img src="/uploads/2017/12/php_lamp_01.png" alt=""><br>从下往上四层：</p><ol><li>liunx 属于操作系统的底层</li><li>apache服务器，属于次服务器，沟通linux和PHP</li><li>php:属于服务端编程语言，通过php_module 模块 和apache关联</li><li>mysql和其他web服务：属于应用服务，通过PHP的Extensions外 挂模块和mysql关联</li></ol><p><strong>参考文章：</strong><br><a href="https://www.cnblogs.com/hongfei/archive/2012/06/12/2547119.html" target="_blank" rel="noopener">PHP的执行原理/执行流程</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/102" target="_blank" rel="noopener">PHP底层的运行机制与原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PHP简单运行过程：&quot;&gt;&lt;a href=&quot;#PHP简单运行过程：&quot; class=&quot;headerlink&quot; title=&quot;PHP简单运行过程：&quot;&gt;&lt;/a&gt;PHP简单运行过程：&lt;/h2&gt;&lt;p&gt;　我们从未手动开启过PHP的相关进程，它是随着Apache的启动而运行的；&lt;br&gt;　PHP通过mod_php5.so模块和Apache相连（具体说来是SAPI，即服务器应用程序编程接口）；&lt;br&gt;　PHP总共有三个模块：内核、Zend引擎、以及扩展层；&lt;br&gt;　PHP内核用来处理请求、文件流、错误处理等相关操作；&lt;br&gt;　Zend引擎（ZE）用以将源文件转换成机器语言，然后在虚拟机上运行它；&lt;br&gt;　扩展层是一组函数、类库和流，PHP使用它们来执行一些特定的操作。比如，我们需要mysql扩展来连接MySQL数据库；&lt;br&gt;　当ZE执行程序时可能会需要连接若干扩展，这时ZE将控制权交给扩展，等处理完特定任务后再返还；&lt;br&gt;　最后，ZE将程序运行结果返回给PHP内核，它再将结果传送给SAPI层，最终输出到浏览器上。&lt;br&gt;
    
    </summary>
    
      <category term="PHP原理" scheme="http://yoursite.com/categories/PHP%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP原理" scheme="http://yoursite.com/tags/PHP%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库导入导出命令</title>
    <link href="http://yoursite.com/2017/12/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/12/11/MySQL数据库导入导出命令/</id>
    <published>2017-12-11T07:26:44.000Z</published>
    <updated>2017-12-11T07:37:51.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导出（mysqldump）"><a href="#导出（mysqldump）" class="headerlink" title="导出（mysqldump）"></a>导出（mysqldump）</h2><p>1、只导出结构，不导出数据</p><p>#mysqldump 数据库名 -u root -p  -d &gt; xxx.sql </p><p>2、只导出数据，不导出结构</p><p>#mysqldump 数据库名 -uroot -p  -t　&gt;　xxx.sql　<br><a id="more"></a><br>3、既导出数据，也导出结构</p><p>#mysqldump　数据库名　-uroot　-p　&gt;　xxx.sql　</p><p>4、导出指定表</p><p>#mysqldump　-uroot　-p　数据库名　–table　表名　&gt;　xxx.sql　</p><p>5、导出数据库，忽略其中的某些表</p><p>#mysqldump -uroot -p  数据库名 –ignore-table 数据库名.表名1  –ignore-table 数据库名.表名2….  &gt; xxx.sql</p><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><p>由于mysqldump导出的是完整的SQL语句，所以用mysql客户程序很容易就能把数据导入了：</p><p>#mysql -hlocalhost -P3306 -uroot -p　数据库名　&lt;　文件名 </p><p>#source　/tmp/xxx.sql　</p><h2 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h2><p>#mysqldump　数据库名　&gt;数据库备份名 </p><p>#mysqldump　-A　-u用户名　-p密码　数据库名&gt;数据库备份名 </p><p>#mysqldump　-d　-A　–add-drop-table　-uroot　-p　&gt;xxx.sql </p><h2 id="Mysqldump参数大全（参数来源于mysql5-5-19源码）"><a href="#Mysqldump参数大全（参数来源于mysql5-5-19源码）" class="headerlink" title="Mysqldump参数大全（参数来源于mysql5.5.19源码）"></a>Mysqldump参数大全（参数来源于mysql5.5.19源码）</h2><p>参数<br>参数说明</p><p><strong>–all-databases  , -A</strong></p><p>导出全部数据库。</p><p>mysqldump  -uroot -p –all-databases</p><p><strong>–all-tablespaces  , -Y</strong></p><p>导出全部表空间。</p><p>mysqldump  -uroot -p –all-databases –all-tablespaces</p><p><strong>–no-tablespaces  , -y</strong></p><p>不导出任何表空间信息。</p><p>mysqldump  -uroot -p –all-databases –no-tablespaces</p><p><strong>–add-drop-database</strong></p><p>每个数据库创建之前添加drop数据库语句。</p><p>mysqldump  -uroot -p –all-databases –add-drop-database</p><p><strong>–add-drop-table</strong></p><p>每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用–skip-add-drop-table取消选项)</p><p>mysqldump  -uroot -p –all-databases  (默认添加drop语句)</p><p>mysqldump  -uroot -p –all-databases –skip-add-drop-table  (取消drop语句)</p><p><strong>–add-locks</strong></p><p>在每个表导出之前增加LOCK TABLES并且之后UNLOCK  TABLE。(默认为打开状态，使用–skip-add-locks取消选项)</p><p>mysqldump  -uroot -p –all-databases  (默认添加LOCK语句)</p><p>mysqldump  -uroot -p –all-databases –skip-add-locks   (取消LOCK语句)</p><p><strong>–allow-keywords</strong></p><p>允许创建是关键词的列名字。这由表名前缀于每个列名做到。</p><p>mysqldump  -uroot -p –all-databases –allow-keywords</p><p><strong>–apply-slave-statements</strong></p><p>在’CHANGE MASTER’前添加’STOP SLAVE’，并且在导出的最后添加’START SLAVE’。</p><p>mysqldump  -uroot -p –all-databases –apply-slave-statements</p><p><strong>–character-sets-dir</strong></p><p>字符集文件的目录</p><p>mysqldump  -uroot -p –all-databases  –character-sets-dir=/usr/local/mysql/share/mysql/charsets</p><p><strong>–comments</strong></p><p>附加注释信息。默认为打开，可以用–skip-comments取消</p><p>mysqldump  -uroot -p –all-databases  (默认记录注释)</p><p>mysqldump  -uroot -p –all-databases –skip-comments   (取消注释)</p><p><strong>–compatible</strong></p><p>导出的数据将和其它数据库或旧版本的MySQL 相兼容。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options等，</p><p>要使用几个值，用逗号将它们隔开。它并不保证能完全兼容，而是尽量兼容。</p><p>mysqldump  -uroot -p –all-databases –compatible=ansi</p><p><strong>–compact</strong></p><p>导出更少的输出信息(用于调试)。去掉注释和头尾等结构。可以使用选项：–skip-add-drop-table  –skip-add-locks –skip-comments –skip-disable-keys</p><p>mysqldump  -uroot -p –all-databases –compact</p><p><strong>–complete-insert,  -c</strong></p><p>使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败。</p><p>mysqldump  -uroot -p –all-databases –complete-insert</p><p><strong>–compress, -C</strong></p><p>在客户端和服务器之间启用压缩传递所有信息</p><p>mysqldump  -uroot -p –all-databases –compress</p><p><strong>–create-options,  -a</strong></p><p>在CREATE TABLE语句中包括所有MySQL特性选项。(默认为打开状态)</p><p>mysqldump  -uroot -p –all-databases</p><p><strong>–databases,  -B</strong></p><p>导出几个数据库。参数后面所有名字参量都被看作数据库名。</p><p>mysqldump  -uroot -p –databases test mysql</p><p><strong>–debug</strong></p><p>输出debug信息，用于调试。默认值为：d:t:o,/tmp/mysqldump.trace</p><p>mysqldump  -uroot -p –all-databases –debug</p><p>mysqldump  -uroot -p –all-databases –debug=” d:t:o,/tmp/debug.trace”</p><p><strong>–debug-check</strong></p><p>检查内存和打开文件使用说明并退出。</p><p>mysqldump  -uroot -p –all-databases –debug-check</p><p><strong>–debug-info</strong></p><p>输出调试信息并退出</p><p>mysqldump  -uroot -p –all-databases –debug-info</p><p><strong>–default-character-set</strong></p><p>设置默认字符集，默认值为utf8</p><p>mysqldump  -uroot -p –all-databases –default-character-set=latin1</p><p><strong>–delayed-insert</strong></p><p>采用延时插入方式（INSERT DELAYED）导出数据</p><p>mysqldump  -uroot -p –all-databases –delayed-insert</p><p><strong>–delete-master-logs</strong></p><p>master备份后删除日志. 这个参数将自动激活–master-data。</p><p>mysqldump  -uroot -p –all-databases –delete-master-logs</p><p><strong>–disable-keys</strong></p><p>对于每个表，用/<em>!40000 ALTER TABLE tbl_name DISABLE KEYS </em>/;和/<em>!40000 ALTER TABLE tbl_name ENABLE KEYS </em>/;语句引用INSERT语句。这样可以更快地导入dump出来的文件，因为它是在插入所有行后创建索引的。该选项只适合MyISAM表，默认为打开状态。</p><p>mysqldump  -uroot -p –all-databases </p><p><strong>–dump-slave</strong></p><p>该选项将导致主的binlog位置和文件名追加到导出数据的文件中。设置为1时，将会以CHANGE MASTER命令输出到数据文件；设置为2时，在命令前增加说明信息。该选项将会打开–lock-all-tables，除非–single-transaction被指定。该选项会自动关闭–lock-tables选项。默认值为0。</p><p>mysqldump  -uroot -p –all-databases –dump-slave=1</p><p>mysqldump  -uroot -p –all-databases –dump-slave=2</p><p><strong>–events, -E</strong></p><p>导出事件。</p><p>mysqldump  -uroot -p –all-databases –events</p><p><strong>–extended-insert,  -e</strong></p><p>使用具有多个VALUES列的INSERT语法。这样使导出文件更小，并加速导入时的速度。默认为打开状态，使用–skip-extended-insert取消选项。</p><p>mysqldump  -uroot -p –all-databases</p><p>mysqldump  -uroot -p –all-databases–skip-extended-insert   (取消选项)</p><p><strong>–fields-terminated-by</strong></p><p>导出文件中忽略给定字段。与–tab选项一起使用，不能用于–databases和–all-databases选项</p><p>mysqldump  -uroot -p test test –tab=”/home/mysql” –fields-terminated-by=”#”</p><p><strong>–fields-enclosed-by</strong></p><p>输出文件中的各个字段用给定字符包裹。与–tab选项一起使用，不能用于–databases和–all-databases选项</p><p>mysqldump  -uroot -p test test –tab=”/home/mysql” –fields-enclosed-by=”#”</p><p><strong>–fields-optionally-enclosed-by</strong></p><p>输出文件中的各个字段用给定字符选择性包裹。与–tab选项一起使用，不能用于–databases和–all-databases选项</p><p>mysqldump  -uroot -p test test –tab=”/home/mysql”  –fields-enclosed-by=”#” –fields-optionally-enclosed-by  =”#”</p><p><strong>–fields-escaped-by</strong></p><p>输出文件中的各个字段忽略给定字符。与–tab选项一起使用，不能用于–databases和–all-databases选项</p><p>mysqldump  -uroot -p mysql user –tab=”/home/mysql” –fields-escaped-by=”#”</p><p><strong>–flush-logs</strong></p><p>开始导出之前刷新日志。</p><p>请注意：假如一次导出多个数据库(使用选项–databases或者–all-databases)，将会逐个数据库刷新日志。除使用–lock-all-tables或者–master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用–lock-all-tables 或者–master-data 和–flush-logs。</p><p>mysqldump  -uroot -p –all-databases –flush-logs</p><p><strong>–flush-privileges</strong></p><p>在导出mysql数据库之后，发出一条FLUSH  PRIVILEGES 语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。</p><p>mysqldump  -uroot -p –all-databases –flush-privileges</p><p><strong>–force</strong></p><p>在导出过程中忽略出现的SQL错误。</p><p>mysqldump  -uroot -p –all-databases –force</p><p><strong>–help</strong></p><p>显示帮助信息并退出。</p><p>mysqldump  –help</p><p><strong>–hex-blob</strong></p><p>使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。</p><p>mysqldump  -uroot -p –all-databases –hex-blob</p><p><strong>–host, -h</strong></p><p>需要导出的主机信息</p><p>mysqldump  -uroot -p –host=localhost –all-databases</p><p><strong>–ignore-table</strong></p><p>不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：–ignore-table=database.table1 –ignore-table=database.table2 ……</p><p>mysqldump  -uroot -p –host=localhost –all-databases –ignore-table=mysql.user</p><p><strong>–include-master-host-port</strong></p><p>在–dump-slave产生的’CHANGE  MASTER TO..’语句中增加’MASTER_HOST=<host>，MASTER_PORT=<port>‘  </port></host></p><p>mysqldump  -uroot -p –host=localhost –all-databases –include-master-host-port</p><p><strong>–insert-ignore</strong></p><p>在插入行时使用INSERT IGNORE语句.</p><p>mysqldump  -uroot -p –host=localhost –all-databases –insert-ignore</p><p><strong>–lines-terminated-by</strong></p><p>输出文件的每行用给定字符串划分。与–tab选项一起使用，不能用于–databases和–all-databases选项。</p><p>mysqldump  -uroot -p –host=localhost test test –tab=”/tmp/mysql”  –lines-terminated-by=”##”</p><p><strong>–lock-all-tables,  -x</strong></p><p>提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭–single-transaction 和–lock-tables 选项。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –lock-all-tables</p><p><strong>–lock-tables,  -l</strong></p><p>开始导出前，锁定所有表。用READ  LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，–single-transaction是一个更好的选择，因为它根本不需要锁定表。</p><p>请注意当导出多个数据库时，–lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –lock-tables</p><p><strong>–log-error</strong></p><p>附加警告和错误信息到给定文件</p><p>mysqldump  -uroot -p –host=localhost –all-databases  –log-error=/tmp/mysqldump_error_log.err</p><p><strong>–master-data</strong></p><p>该选项将binlog的位置和文件名追加到输出文件中。如果为1，将会输出CHANGE MASTER 命令；如果为2，输出的CHANGE  MASTER命令前添加注释信息。该选项将打开–lock-all-tables 选项，除非–single-transaction也被指定（在这种情况下，全局读锁在开始导出时获得很短的时间；其他内容参考下面的–single-transaction选项）。该选项自动关闭–lock-tables选项。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –master-data=1;</p><p>mysqldump  -uroot -p –host=localhost –all-databases –master-data=2;</p><p><strong>–max_allowed_packet</strong></p><p>服务器发送和接受的最大包长度。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –max_allowed_packet=10240</p><p><strong>–net_buffer_length</strong></p><p>TCP/IP和socket连接的缓存大小。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –net_buffer_length=1024</p><p><strong>–no-autocommit</strong></p><p>使用autocommit/commit 语句包裹表。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –no-autocommit</p><p><strong>–no-create-db,  -n</strong></p><p>只导出数据，而不添加CREATE DATABASE 语句。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –no-create-db</p><p><strong>–no-create-info,  -t</strong></p><p>只导出数据，而不添加CREATE TABLE 语句。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –no-create-info</p><p><strong>–no-data, -d</strong></p><p>不导出任何数据，只导出数据库表结构。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –no-data</p><p><strong>–no-set-names,  -N</strong></p><p>等同于–skip-set-charset</p><p>mysqldump  -uroot -p –host=localhost –all-databases –no-set-names</p><p><strong>–opt</strong></p><p>等同于–add-drop-table,  –add-locks, –create-options, –quick, –extended-insert, –lock-tables,  –set-charset, –disable-keys 该选项默认开启,  可以用–skip-opt禁用.</p><p>mysqldump  -uroot -p –host=localhost –all-databases –opt</p><p><strong>–order-by-primary</strong></p><p>如果存在主键，或者第一个唯一键，对每个表的记录进行排序。在导出MyISAM表到InnoDB表时有效，但会使得导出工作花费很长时间。 </p><p>mysqldump  -uroot -p –host=localhost –all-databases –order-by-primary</p><p><strong>–password, -p</strong></p><p>连接数据库密码</p><p><strong>–pipe(windows系统可用)</strong></p><p>使用命名管道连接mysql</p><p>mysqldump  -uroot -p –host=localhost –all-databases –pipe</p><p><strong>–port, -P</strong></p><p>连接数据库端口号</p><p><strong>–protocol</strong></p><p>使用的连接协议，包括：tcp, socket, pipe, memory.</p><p>mysqldump  -uroot -p –host=localhost –all-databases –protocol=tcp</p><p><strong>–quick, -q</strong></p><p>不缓冲查询，直接导出到标准输出。默认为打开状态，使用–skip-quick取消该选项。</p><p>mysqldump  -uroot -p –host=localhost –all-databases </p><p>mysqldump  -uroot -p –host=localhost –all-databases –skip-quick</p><p><strong>–quote-names,-Q</strong></p><p>使用（`）引起表和列名。默认为打开状态，使用–skip-quote-names取消该选项。</p><p>mysqldump  -uroot -p –host=localhost –all-databases</p><p>mysqldump  -uroot -p –host=localhost –all-databases –skip-quote-names</p><p><strong>–replace</strong></p><p>使用REPLACE INTO 取代INSERT INTO.</p><p>mysqldump  -uroot -p –host=localhost –all-databases –replace</p><p><strong>–result-file,  -r</strong></p><p>直接输出到指定文件中。该选项应该用在使用回车换行对（\r\n）换行的系统上（例如：DOS，Windows）。该选项确保只有一行被使用。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –result-file=/tmp/mysqldump_result_file.txt</p><p><strong>–routines, -R</strong></p><p>导出存储过程以及自定义函数。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –routines</p><p><strong>–set-charset</strong></p><p>添加’SET NAMES  default_character_set’到输出文件。默认为打开状态，使用–skip-set-charset关闭选项。</p><p>mysqldump  -uroot -p –host=localhost –all-databases </p><p>mysqldump  -uroot -p –host=localhost –all-databases –skip-set-charset</p><p><strong>–single-transaction</strong></p><p>该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于多版本存储引擎，仅InnoDB。本选项和–lock-tables 选项是互斥的，因为LOCK  TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用–quick 选项。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –single-transaction</p><p><strong>–dump-date</strong></p><p>将导出时间添加到输出文件中。默认为打开状态，使用–skip-dump-date关闭选项。</p><p>mysqldump  -uroot -p –host=localhost –all-databases</p><p>mysqldump  -uroot -p –host=localhost –all-databases –skip-dump-date</p><p><strong>–skip-opt</strong></p><p>禁用–opt选项.</p><p>mysqldump  -uroot -p –host=localhost –all-databases –skip-opt</p><p><strong>–socket,-S</strong></p><p>指定连接mysql的socket文件位置，默认路径/tmp/mysql.sock</p><p>mysqldump  -uroot -p –host=localhost –all-databases –socket=/tmp/mysqld.sock</p><p><strong>–tab,-T</strong></p><p>为每个表在给定路径创建tab分割的文本文件。注意：仅仅用于mysqldump和mysqld服务器运行在相同机器上。</p><p>mysqldump  -uroot -p –host=localhost test test –tab=”/home/mysql”</p><p><strong>–tables</strong></p><p>覆盖–databases (-B)参数，指定需要导出的表名。</p><p>mysqldump  -uroot -p –host=localhost –databases test –tables test</p><p><strong>–triggers</strong></p><p>导出触发器。该选项默认启用，用–skip-triggers禁用它。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –triggers</p><p><strong>–tz-utc</strong></p><p>在导出顶部设置时区TIME_ZONE=’+00:00’ ，以保证在不同时区导出的TIMESTAMP 数据或者数据被移动其他时区时的正确性。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –tz-utc</p><p><strong>–user, -u</strong></p><p>指定连接的用户名。</p><p><strong>–verbose, –v</strong></p><p>输出多种平台信息。</p><p><strong>–version, -V</strong></p><p>输出mysqldump版本信息并退出</p><p><strong>–where, -w</strong></p><p>只转储给定的WHERE条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –where=” user=’root’”</p><p><strong>–xml, -X</strong></p><p>导出XML格式.</p><p>mysqldump  -uroot -p –host=localhost –all-databases –xml</p><p><strong>–plugin_dir</strong></p><p>客户端插件的目录，用于兼容不同的插件版本。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –plugin_dir=”/usr/local/lib/plugin”</p><p><strong>–default_auth</strong></p><p>客户端插件默认使用权限。</p><p>mysqldump  -uroot -p –host=localhost –all-databases –default-auth=”/usr/local/lib/plugin/<plugin>”</plugin></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导出（mysqldump）&quot;&gt;&lt;a href=&quot;#导出（mysqldump）&quot; class=&quot;headerlink&quot; title=&quot;导出（mysqldump）&quot;&gt;&lt;/a&gt;导出（mysqldump）&lt;/h2&gt;&lt;p&gt;1、只导出结构，不导出数据&lt;/p&gt;
&lt;p&gt;#mysqldump 数据库名 -u root -p  -d &amp;gt; xxx.sql &lt;/p&gt;
&lt;p&gt;2、只导出数据，不导出结构&lt;/p&gt;
&lt;p&gt;#mysqldump 数据库名 -uroot -p  -t　&amp;gt;　xxx.sql　&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Shell基础知识手册</title>
    <link href="http://yoursite.com/2017/12/11/Shell%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2017/12/11/Shell基础知识手册/</id>
    <published>2017-12-11T02:31:18.000Z</published>
    <updated>2017-12-11T03:35:11.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>1、变量命名</strong></p><pre><code>1. 只能使用数字、字母和下划线，且不能以数字开头2. 变量名区分大小写3. 建议命令要通俗易懂</code></pre><font color="red"><strong>注意：</strong></font><ul><li>变量不需要声明，初始化不需要指定类型</li><li><p>变量赋值是通过等号（=）进行赋值，在变量、等号和值之间不能出现空格</p><a id="more"></a><p><strong>2、变量分类</strong></p><ol><li><p>本地变量</p><ul><li>只对当前shell进程有效的，对当前进程的子进程和其它shell进程无效。</li><li>定义：VAR_NAME=VALUE</li><li>变量引用：${VAR_NAME} 或者 $VAR_NAME</li><li>取消变量：unset VAR_NAME</li><li>相当于java中的私有变量(private)，只能当前类使用，子类和其他类都无法使用。</li></ul></li><li><p>环境变量</p><ul><li>自定义的环境变量对当前shell进程及其子shell进程有效，对其它的shell进程无效</li><li>定义：export VAR_NAME=VALUE</li><li>对所有shell进程都有效需要配置到配置文件中：/etc/profile</li><li>相当于java中的protected修饰符,对当前类，子孙类，以及同一个包下面可以共用。<br><em>（和windows中的环境变量比较类似）</em></li></ul></li><li><p>局部变量</p><ul><li>在函数中调用，函数执行结束，变量就会消失</li><li>对shell脚本中某代码片段有效</li><li>定义：local VAR_NAME=VALUE</li><li>相当于java代码中某一个方法中定义的局部变量，只对这个方法有效。</li></ul></li><li><p>位置变量<br> 比如脚本中的参数：</p><pre><code>$0：脚本自身$1：脚本的第一个参数$2：脚本的第二个参数</code></pre><p> 相当于java中main函数中的args参数，可以获取外部参数。</p></li><li><p>特殊变量<br> $?：接收上一条命令的返回状态码<br> <em>（返回状态码在0-255之间）</em><br> $#：参数个数<br> $*：或者$@：所有的参数<br> $$：获取当前shell的进程号（PID）(可以实现脚本自杀)(或者使用exit命令直接退出也可以使用exit [num])</p></li></ol></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>1、算术运算符</strong></p><pre><code>格式：let varName=算术表达式varName=$[算术表达式]varName=$((算术表达式))varName=\`expr $num1 + $num2\`</code></pre><font color="red">（使用这种格式要注意两个数字和+号中间要有空格。）</font><p><strong>2、逻辑运算符</strong><br>　if [ 条件A &amp;&amp; 条件B ] 在shell中怎么写?<br>　if [ 条件A &amp;&amp; 条件B ];then    是不对的<br>（1）需要用到shell中的逻辑操作符<br>　-a 与<br>　-o 或<br>　！ 非<br>　如if [ 条件A -a 条件B ]<br>（2）if [ 条件A ] &amp;&amp; [条件B ]<br>（3）if((A&amp;&amp;B))<br>（4）if [[ A&amp;&amp;B ]]</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p><img src="/uploads/2017/12/shell_string_01.png" alt=""></p><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><p><strong>定义：</strong></p><pre><code>declare -a：表示定义普通数组</code></pre><p><strong>特点：</strong></p><pre><code>1. 支持稀疏格式2. 仅支持一维数组</code></pre><p><strong>数组赋值方式：</strong></p><pre><code>1. 一次对一个元素赋值a[0]=$RANDOM2. 一次对多个元素赋值a=(a b c d)3. 按索引进行赋值a=([0]=a [3]=b [1]=c)</code></pre><p><strong>数组操作</strong></p><pre><code>1. 使用read命令read -a ARRAY_NAME查看元素　${ARRAY[index]}：查看数组指定角标的元素  　${ARRAY}：查看数组的第一个元素  　${ARRAY[*]}或者${ARRAY[@]}：查看数组的所有元素  2. 获取数组的长度：　${#ARRAY[*]}  　${#ARRAY[@]} 3. 获取数组内元素的长度：　${#ARRAY[0]}4. 从数组中获取某一片段之内的元素（操作类似于字符串操作）　格式：    ${ARRAY[@]:offset:length}  　注释：　　offset：偏移的元素个数　　length：取出的元素的个数　　${ARRAY[@]:offset:length}：取出偏移量后的指定个数的元素　　${ARRAY[@]:offset}：取出数组中偏移量后的所有元素5. 数组删除元素：　unset ARRAY[index] </code></pre><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p><strong>if判断</strong></p><pre><code>单分支： if 测试条件;then     选择分支 fi双分支： if 测试条件  then   选择分支1   else   选择分支2 fi 多分支： if 条件1; then           分支1 elif 条件2; then           分支2 elif 条件3; then           分支3          ... else           分支n fi</code></pre><p><strong>Case判断</strong><br><em>（有多个测试条件时，case语句会使得语法结构更清晰）</em></p><pre><code>格式：case 变量引用 in    PATTERN1)        分支1        ;;    PATTERN2)        分支2        ;;    ...    *)        分支n        ;;esac注释：PATTERN :类同于文件名通配机制，但支持使用|表示或者a|b：a或者b*：匹配任意长度的任意字符?：匹配任意单个字符[a-z]：指定范围内的任意单个字符</code></pre><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><p><strong>for循环</strong><br>　通过使用一个变量去遍历给定列表中的每个元素，在每次变量赋值时执行一次循环体，直至赋值完成所有元素退出循环<br><em>（注意：for i in {0..9} 等于for i in {0..9..1} , 第三个参数为跨步。）</em></p><pre><code>格式1：for ((i=0;i&lt;10;i++))do  ...Done格式2：for i in 0 1 2 3 4 5 6 7 8 9do...Done格式3：for i in {0..9}do  ...done</code></pre><p><strong>while循环</strong><br>　适用于循环次数未知，或不便用for直接生成较大的列表时</p><pre><code>格式：while 测试条件do循环体done</code></pre><p><strong>循环控制命令</strong></p><pre><code>循环控制命令——breakbreak命令是在处理过程中跳出循环的一种简单方法，可以使用break命令退出任何类型的循环，包括while循环和for循环循环控制命令——continuecontinue命令是一种提前停止循环内命令，而不完全终止循环的方法，这就需要在循环内设置shell不执行命令的条件</code></pre><p><strong>条件</strong><br>　bash条件测试</p><pre><code>格式：    test EXPR    [ EXPR ]：注意中括号和表达式之间的空格整型测试：    -gt：大于：    -lt：小于    -ge：大于等于    -le：小于等于    -eq：等于    -ne：不等于例如[ $num1 -gt $num2 ]或者test $num1 -gt $num2字符串测试：    =：等于，例如判断变量是否为空 [ &quot;$str&quot; =  &quot;&quot; ] 或者[ -z $str ]    !=：不等于</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>格式：function 函数名(){...}1. 引用自定义函数文件时，使用source  func.sh2. 有利于代码的重用性3. 函数传递参数（可以使用类似于Java中的args，args[1]代表Shell中的$1）4. 函数的返回值，只能是数字5. 函数的调用： 函数名</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1、变量命名&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 只能使用数字、字母和下划线，且不能以数字开头
2. 变量名区分大小写
3. 建议命令要通俗易懂
&lt;/code&gt;&lt;/pre&gt;&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/font&gt;

&lt;ul&gt;
&lt;li&gt;变量不需要声明，初始化不需要指定类型&lt;/li&gt;
&lt;li&gt;&lt;p&gt;变量赋值是通过等号（=）进行赋值，在变量、等号和值之间不能出现空格&lt;/p&gt;
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Git Error: Failed to connect to github.com port 443: Timed out</title>
    <link href="http://yoursite.com/2017/12/08/Git-Error-Failed-to-connect-to-github-com-port-443-Timed-out/"/>
    <id>http://yoursite.com/2017/12/08/Git-Error-Failed-to-connect-to-github-com-port-443-Timed-out/</id>
    <published>2017-12-08T06:39:58.000Z</published>
    <updated>2017-12-08T06:46:51.686Z</updated>
    
    <content type="html"><![CDATA[<h3 id="错误信息："><a href="#错误信息：" class="headerlink" title="错误信息："></a>错误信息：</h3><blockquote><p>fatal: unable to access ‘<a href="https://github.com/bluce-ben/bluce-ben.github.io.git/" target="_blank" rel="noopener">https://github.com/bluce-ben/bluce-ben.github.io.git/</a>‘: Failed to connect to github.com port 443: Timed out<br>FATAL Something’s wrong. Maybe you can find the solution here: <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">http://hexo.io/docs/troubleshooting.html</a><br>Error: fatal: unable to access ‘<a href="https://github.com/bluce-ben/bluce-ben.github.io.git/" target="_blank" rel="noopener">https://github.com/bluce-ben/bluce-ben.github.io.git/</a>‘: Failed to connect to github.com port 443: Timed out<br><a id="more"></a><br>　依据错误可清晰知道是因为无法连接Git导致的超时错误。而我配置的Hexo+GitHub Pages中使用的Git仓库就是 HTTPS 协议的，所以是使用443端口，也由此我 hexo deploy 部署Git失败。</p></blockquote><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p><em>在百度搜索到一个解决方案，现整理如下。</em><br><strong>1、测试git是否成功连接GitHub，使用：</strong><br>　<code>ssh -T git@github.com</code></p><blockquote><p>连接失败：ssh: connect to host github.com port 22: Connection timed out<br>连接成功：Hi bluce-ben! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p><strong>2、修改Git配置文件，首先找到git的安装目录，找到/etc/ssh/ssh_config文件</strong><br>　打开该文件并将下列配置添加末尾：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User git</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure></p><p>　保存修改。<br><em>（注：如果保存失败提示没有权限，可用 Notepad++打开会提示使用管理员权限，点击确定即可。）</em></p><p><strong>3、再次测试是否成功连接GitHub。成功后再次 hexo deploy 部署GitHub即可。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;错误信息：&quot;&gt;&lt;a href=&quot;#错误信息：&quot; class=&quot;headerlink&quot; title=&quot;错误信息：&quot;&gt;&lt;/a&gt;错误信息：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;fatal: unable to access ‘&lt;a href=&quot;https://github.com/bluce-ben/bluce-ben.github.io.git/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/bluce-ben/bluce-ben.github.io.git/&lt;/a&gt;‘: Failed to connect to github.com port 443: Timed out&lt;br&gt;FATAL Something’s wrong. Maybe you can find the solution here: &lt;a href=&quot;http://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hexo.io/docs/troubleshooting.html&lt;/a&gt;&lt;br&gt;Error: fatal: unable to access ‘&lt;a href=&quot;https://github.com/bluce-ben/bluce-ben.github.io.git/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/bluce-ben/bluce-ben.github.io.git/&lt;/a&gt;‘: Failed to connect to github.com port 443: Timed out&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="Git问题" scheme="http://yoursite.com/categories/Git/Git%E9%97%AE%E9%A2%98/"/>
    
      <category term="Hexo问题" scheme="http://yoursite.com/categories/Hexo/Hexo%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Git问题" scheme="http://yoursite.com/tags/Git%E9%97%AE%E9%A2%98/"/>
    
      <category term="Hexo问题" scheme="http://yoursite.com/tags/Hexo%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>总结-MySQL数据库设计</title>
    <link href="http://yoursite.com/2017/12/08/%E6%80%BB%E7%BB%93-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2017/12/08/总结-MySQL数据库设计/</id>
    <published>2017-12-08T05:13:28.000Z</published>
    <updated>2017-12-08T05:28:56.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是数据库设计"><a href="#一、什么是数据库设计" class="headerlink" title="一、什么是数据库设计"></a>一、什么是数据库设计</h2><p><strong>１、数据库设计概念</strong><br>　数据库设计就是根据业务系统的具体需求，结合所选择的DBMS，为这个业务系统构造出最优的数据存储模型。并建立好数据库中表的结构，以及表与表之间的关联关系的过程。使之能有效的对应用系统中的数据进行存储，并可以高效的对已经存储的数据进行查询访问。<br><strong>２、设计对比</strong></p><table><thead><tr><th>优良的设计</th><th>槽糕的设计</th></tr></thead><tbody><tr><td>减少数据冗余</td><td>存在大量的数据冗余</td></tr><tr><td>避免数据维护异常</td><td>存在数据插入、更新、删除异常</td></tr><tr><td>节约存储空间(偶尔会用空间换时间)</td><td>浪费大量存储空间</td></tr><tr><td>高效的访问</td><td>访问数据低效</td></tr></tbody></table><a id="more"></a><h2 id="二、数据库设计的步骤"><a href="#二、数据库设计的步骤" class="headerlink" title="二、数据库设计的步骤"></a>二、数据库设计的步骤</h2><p><strong>1). 需求分析</strong><br>　需求分析主要完成的内容：业务系统中有哪些数据？这些数据又有哪些属性？数据和属性的各自特点有哪些？<br><strong>2). 逻辑设计</strong><br>　使用ER图设计工具对数据库进行ER图逻辑建模：首先将需求转化为数据库的逻辑模型，其次，通过ER图形式将逻辑模型描述展示出来，最后这个逻辑设计与所选择的DBMS无关，也就是说这个逻辑设计应该适合所有的DBMS。<br><strong>3). 物理设计</strong><br>　这个阶段是进入到与DBMS相关的阶段，因此首先需要选择DBMS，并且将第二步的逻辑模型转为物理模型。<br>　这个阶段会涉及到数据库中建表，选择字段类型的问题。在MySQL中遵循以下原则：<br>　列的数据类型一方面影响相应数据的存储空间的开销，另一方面也会影响数据查询性能。当一个列可以选择多种数据类型时，应该优先考虑数字类型，其次是日期或二进制，最后是字符串类型。对于相同级别的数据类型，在满足业务的情况下，应该优先选择占用空间小的数据类型。<br>　mysql中部分字段空间占用情况：<br><img src="/uploads/2017/12/mysql_database_01.jpg" alt=""><br><em>额外注意几点：</em></p><ul><li>在对数据进行比较(where、join 、order by)操作时，同样的数据，字符串处理比数字处理更慢。</li><li>在MySql中，UTF-8占用3个字节。</li></ul><p><strong>4). 维护优化</strong></p><ul><li>针对新的需求建立新的数据库表(这里补充说明下，在进行数据库最初的设计过程中，不建议在表中预留不确定的字段，这并不能实现数据库良好的扩展性问题，它的代价与后期新加一个字段一样，甚至更大)</li><li>索引优化</li><li>大表拆分：拆分又分为两种方式 <ul><li>水平拆分：控制表的长度，即数据的行数。会将每个表中的数据量减少。</li><li>垂直拆分：数据库中的存储是以页为单位的，当每一行的宽度比较小时(列数比较少时)，每页中存储的内容就多，IO效率就高(数据中的数据是存放在磁盘上，每次IO的内容越多越好)。因此常常对于非常宽的表，进行表的垂直拆分。拆表后的数据量不应该发生变化，但是表的数量增加，每张表的宽度减少。</li></ul></li></ul><h2 id="三、数据库中的几大范式"><a href="#三、数据库中的几大范式" class="headerlink" title="三、数据库中的几大范式"></a>三、数据库中的几大范式</h2><p><strong>第一范式(1NF)</strong></p><blockquote><p>概念：数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。<br>作用：确保每列保持原子性 （每个表中的字段不可再拆分）<br>举例：本来正常情况下，设计地址，只需要一个字段，但是若在实际业务系统中需要访问其中的国家、省、市时，此时就应该将地址这个字段进行拆分才符合1NF。</p></blockquote><p><strong>第二范式(2NF)</strong></p><blockquote><p>概念：基于1NF基础之上，第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。此外：所有单关键字段的表都符合第二范式。<br>作用：确保表中的每列都和主键相关（一个表中只能有一个主键）</p></blockquote><p><strong>第三范式(3NF)</strong></p><blockquote><p>概念：基于2NF基础上的，如果数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。<br>作用：确保每列都和主键列直接相关,而不是间接相关 （表中字段都与主键直接相关）</p></blockquote><h2 id="四、高手的境界都是无招胜有招"><a href="#四、高手的境界都是无招胜有招" class="headerlink" title="四、高手的境界都是无招胜有招"></a>四、高手的境界都是无招胜有招</h2><p>　为了设计出优良的数据库，我们需要遵循数据库的范式，但是有时候如果你设计的数据库完全遵循了这些范式，反而会降低你的某些性能。这里提几点： </p><ul><li>数据库连接会带来一部分性能损失，因此有时候为了减少冗余，将数据存放在多张表中，往往会降低查询性能，而互联网的世界，读写比例大概是3:1甚至4:1 </li><li>减少表与表之间的关联数量(减少了对磁盘的IO)，增加数据的读取效率。 </li><li>反范式化一定要适度。凡事过度适得其反。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是数据库设计&quot;&gt;&lt;a href=&quot;#一、什么是数据库设计&quot; class=&quot;headerlink&quot; title=&quot;一、什么是数据库设计&quot;&gt;&lt;/a&gt;一、什么是数据库设计&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;１、数据库设计概念&lt;/strong&gt;&lt;br&gt;　数据库设计就是根据业务系统的具体需求，结合所选择的DBMS，为这个业务系统构造出最优的数据存储模型。并建立好数据库中表的结构，以及表与表之间的关联关系的过程。使之能有效的对应用系统中的数据进行存储，并可以高效的对已经存储的数据进行查询访问。&lt;br&gt;&lt;strong&gt;２、设计对比&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;优良的设计&lt;/th&gt;
&lt;th&gt;槽糕的设计&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;减少数据冗余&lt;/td&gt;
&lt;td&gt;存在大量的数据冗余&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;避免数据维护异常&lt;/td&gt;
&lt;td&gt;存在数据插入、更新、删除异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;节约存储空间(偶尔会用空间换时间)&lt;/td&gt;
&lt;td&gt;浪费大量存储空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;高效的访问&lt;/td&gt;
&lt;td&gt;访问数据低效&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>总结-MySQL常用函数</title>
    <link href="http://yoursite.com/2017/12/08/%E6%80%BB%E7%BB%93-MySQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/12/08/总结-MySQL常用函数/</id>
    <published>2017-12-08T03:59:00.000Z</published>
    <updated>2017-12-08T04:44:06.451Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、聚合函数-常用于GROUP-BY从句的SELECT查询中"><a href="#一、聚合函数-常用于GROUP-BY从句的SELECT查询中" class="headerlink" title="一、聚合函数(常用于GROUP BY从句的SELECT查询中)"></a>一、聚合函数(常用于GROUP BY从句的SELECT查询中)</h3><p>　下面五个函数会忽略值为NULL的行</p><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>AVG(col)</td><td>返回指定列的平均值</td></tr><tr><td>COUNT(col)</td><td>返回指定列中非NULL值/行的个数（当函数参数为星号*时不会忽略）</td></tr><tr><td>MIN(col)</td><td>返回指定列的最小值</td></tr><tr><td>MAX(col)</td><td>返回指定列的最大值</td></tr><tr><td>SUM(col)</td><td>返回指定列的所有值之和</td></tr><tr><td>GROUP_CONCAT(col)</td><td>返回由属于一组的列值连接组合而成的结果</td></tr></tbody></table><a id="more"></a><h3 id="二、数学函数"><a href="#二、数学函数" class="headerlink" title="二、数学函数"></a>二、数学函数</h3><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回x的绝对值</td></tr><tr><td>BIN(x)</td><td>返回x的二进制（OCT返回八进制，HEX返回十六进制）</td></tr><tr><td>EXP(x)</td><td>返回值e（自然对数的底）的x次方</td></tr><tr><td>GREATEST(x1,x2,…,xn)</td><td>返回集合中最大的值</td></tr><tr><td>LEAST(x1,x2,…,xn)</td><td>返回集合中最小的值</td></tr><tr><td>LN(x)</td><td>返回x的自然对数</td></tr><tr><td>LOG(x,y)</td><td>返回x的以y为底的对数</td></tr><tr><td>MOD(x,y)</td><td>返回x/y的模（余数）</td></tr><tr><td>PI()</td><td>返回pi的值（圆周率）</td></tr><tr><td>RAND()</td><td>返回0到1内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。</td></tr><tr><td>FLOOR(x)</td><td>返回小于x的最大整数值，（去掉小数取整）</td></tr><tr><td>CEILING(x)</td><td>返回大于x的最小整数值，（进一取整）</td></tr><tr><td>ROUND(x,y)</td><td>返回参数x的四舍五入的有y位小数的值，（四舍五入）</td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数字x截短为y位小数的结果</td></tr><tr><td>SIGN(x)</td><td>返回代表数字x的符号的值（正数返回1，负数返回-1，0返回0）</td></tr><tr><td>SQRT(x)</td><td>返回一个数的平方根</td></tr></tbody></table><h3 id="三、字符串函数"><a href="#三、字符串函数" class="headerlink" title="三、字符串函数"></a>三、字符串函数</h3><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>ASCII(char)</td><td>返回字符的ASCII码值</td></tr><tr><td>BIT_LENGTH(str)</td><td>返回字符串的比特长度</td></tr><tr><td>CONCAT(s1,s2…,sn)</td><td>将s1,s2…,sn连接成字符串</td></tr><tr><td>CONCAT_WS(sep,s1,s2…,sn)</td><td>将s1,s2…,sn连接成字符串，并用sep字符间隔</td></tr><tr><td>INSERT(str,x,y,instr)</td><td>将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果</td></tr><tr><td>FIND_IN_SET(str,list)</td><td>分析逗号分隔的list列表，如果发现str，返回str在list中的位置</td></tr><tr><td>LCASE(str)或LOWER(str)</td><td>返回将字符串str中所有字符改变为小写后的结果</td></tr><tr><td>UCASE(str)或UPPER(str)</td><td>返回将字符串str中所有字符转变为大写后的结果</td></tr><tr><td>LEFT(str,x)</td><td>返回字符串str中最左边的x个字符</td></tr><tr><td>RIGHT(str,x)</td><td>返回字符串str中最右边的x个字符</td></tr><tr><td>LENGTH(str)</td><td>返回字符串str中的字符数</td></tr><tr><td>POSITION(substr,str)</td><td>返回子串substr在字符串str中第一次出现的位置</td></tr><tr><td>QUOTE(str)</td><td>用反斜杠转义str中的单引号</td></tr><tr><td>REPEAT(str,srchstr,rplcstr)</td><td>返回字符串str重复x次的结果</td></tr><tr><td>REVERSE(str)</td><td>返回颠倒字符串str的结果</td></tr><tr><td>LTRIM(str)</td><td>去掉字符串str开头的空格</td></tr><tr><td>RTRIM(str)</td><td>去掉字符串str尾部的空格</td></tr><tr><td>TRIM(str)</td><td>去除字符串首部和尾部的所有空格</td></tr></tbody></table><h3 id="四、日期和时间函数"><a href="#四、日期和时间函数" class="headerlink" title="四、日期和时间函数"></a>四、日期和时间函数</h3><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>DATE_ADD(date,INTERVAL int keyword)</td><td>返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化),如：SELECTDATE_ADD(CURRENT_DATE,INTERVAL 6 MONTH);</td></tr><tr><td>DATE_SUB(date,INTERVAL int keyword)</td><td>返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化),如：SELECTDATE_SUB(CURRENT_DATE,INTERVAL 6 MONTH);</td></tr><tr><td>DATE_FORMAT(date,fmt)</td><td>依照指定的fmt格式格式化日期date值</td></tr><tr><td>FROM_UNIXTIME(ts,fmt)</td><td>根据指定的fmt格式，格式化UNIX时间戳ts</td></tr><tr><td>MONTHNAME(date)</td><td>返回date的月份名(英语月份，如October)</td></tr><tr><td>DAYNAME(date)</td><td>返回date的星期名(英语星期几，如Saturday)</td></tr><tr><td>NOW()</td><td>返回当前的日期和时间 如：2016-10-08 18:57:39</td></tr><tr><td>CURDATE()或CURRENT_DATE()</td><td>返回当前的日期</td></tr><tr><td>CURTIME()或CURRENT_TIME()</td><td>返回当前的时间</td></tr><tr><td>QUARTER(date)</td><td>返回date在一年中的季度(1~4)</td></tr><tr><td>WEEK(date)</td><td>返回日期date为一年中第几周(0~53)</td></tr><tr><td>DAYOFYEAR(date)</td><td>返回date是一年的第几天(1~366)</td></tr><tr><td>DAYOFMONTH(date)</td><td>返回date是一个月的第几天(1~31)</td></tr><tr><td>DAYOFWEEK(date)</td><td>返回date所代表的一星期中的第几天(1~7)</td></tr><tr><td>YEAR(date)</td><td>返回日期date的年份(1000~9999)</td></tr><tr><td>MONTH(date)</td><td>返回date的月份值(1~12)</td></tr><tr><td>DAY(date)</td><td>返回date的天数部分</td></tr><tr><td>HOUR(time)</td><td>返回time的小时值(0~23)</td></tr><tr><td>MINUTE(time)</td><td>返回time的分钟值(0~59)</td></tr><tr><td>SECOND(time)</td><td>返回time的秒值（0-59）</td></tr><tr><td>DATE(datetime)</td><td>返回datetime的日期值</td></tr><tr><td>TIME(datetime)</td><td>返回datetime的时间值</td></tr></tbody></table><h3 id="五、加密函数"><a href="#五、加密函数" class="headerlink" title="五、加密函数"></a>五、加密函数</h3><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>AES_ENCRYPT(str,key)</td><td>返回用密钥key对字符串str利用高级加密标准算法加密后的结果，调用AES_ENCRYPT的结果是一个二进制字符串，以BLOB类型存储</td></tr><tr><td>AES_DECRYPT(str,key)</td><td>返回用密钥key对字符串str利用高级加密标准算法解密后的结果</td></tr><tr><td>DECODE(str,key)</td><td>使用key作为密钥解密加密字符串str</td></tr><tr><td>ENCRYPT(str,salt)</td><td>使用UNIXcrypt()函数，用关键词salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串str</td></tr><tr><td>ENCODE(str,key)</td><td>使用key作为密钥加密字符串str，调用ENCODE()的结果是一个二进制字符串，它以BLOB类型存储</td></tr><tr><td>MD5()</td><td>计算字符串str的MD5校验和</td></tr><tr><td>PASSWORD(str)</td><td>返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。</td></tr><tr><td>SHA()</td><td>计算字符串str的安全散列算法(SHA)校验和</td></tr></tbody></table><h3 id="六、格式化函数"><a href="#六、格式化函数" class="headerlink" title="六、格式化函数"></a>六、格式化函数</h3><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>DATE_FORMAT(date,fmt)</td><td>依照字符串fmt格式化日期date值</td></tr><tr><td>FORMAT(x,y)</td><td>把x格式化为以逗号隔开的数字序列，y是结果的小数位数</td></tr><tr><td>INET_ATON(ip)</td><td>返回IP地址的数字表示</td></tr><tr><td>INET_NTOA(num)</td><td>返回数字所代表的IP地址</td></tr><tr><td>TIME_FORMAT(time,fmt)</td><td>依照字符串fmt格式化时间time值,其中最简单的是FORMAT()函数，它可以把大的数值格式化为以逗号间隔的易读的序列。</td></tr></tbody></table><h3 id="七、数据类型转换函数"><a href="#七、数据类型转换函数" class="headerlink" title="七、数据类型转换函数"></a>七、数据类型转换函数</h3><p>　CAST()函数，将一个值转换为指定的数据类型（类型有：BINARY,CHAR,DATE,TIME,DATETIME,SIGNED,UNSIGNED）<br><code>SELECT CAST(NOW() AS SIGNED INTEGER),CURDATE()+0;</code></p><h3 id="八、系统信息函数"><a href="#八、系统信息函数" class="headerlink" title="八、系统信息函数"></a>八、系统信息函数</h3><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>DATABASE()</td><td>返回当前数据库名</td></tr><tr><td>BENCHMARK(count,expr)</td><td>将表达式expr重复运行count次</td></tr><tr><td>CONNECTION_ID()</td><td>返回当前客户的连接ID</td></tr><tr><td>FOUND_ROWS()</td><td>返回最后一个SELECT查询进行检索的总行数</td></tr><tr><td>USER()或SYSTEM_USER()</td><td>返回当前登陆用户名</td></tr><tr><td>VERSION()</td><td>返回MySQL服务器的版本</td></tr></tbody></table><h3 id="九、条件判断函数"><a href="#九、条件判断函数" class="headerlink" title="九、条件判断函数"></a>九、条件判断函数</h3><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>isnull(expr)</td><td>如expr为null，那么isnull()的返回值为1，否则返回值为0。</td></tr><tr><td>ifnull(expr1,expr2)</td><td>假如expr1不为NULL，则IFNULL()的返回值为expr1; 否则其返回值为expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。</td></tr><tr><td>nullif(expr1,expr2)</td><td>如果expr1=expr2成立，那么返回值为NULL，否则返回值为expr1。</td></tr><tr><td>IF(expr1,expr2,expr3)</td><td>如果 expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、聚合函数-常用于GROUP-BY从句的SELECT查询中&quot;&gt;&lt;a href=&quot;#一、聚合函数-常用于GROUP-BY从句的SELECT查询中&quot; class=&quot;headerlink&quot; title=&quot;一、聚合函数(常用于GROUP BY从句的SELECT查询中)&quot;&gt;&lt;/a&gt;一、聚合函数(常用于GROUP BY从句的SELECT查询中)&lt;/h3&gt;&lt;p&gt;　下面五个函数会忽略值为NULL的行&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AVG(col)&lt;/td&gt;
&lt;td&gt;返回指定列的平均值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COUNT(col)&lt;/td&gt;
&lt;td&gt;返回指定列中非NULL值/行的个数（当函数参数为星号*时不会忽略）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MIN(col)&lt;/td&gt;
&lt;td&gt;返回指定列的最小值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MAX(col)&lt;/td&gt;
&lt;td&gt;返回指定列的最大值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SUM(col)&lt;/td&gt;
&lt;td&gt;返回指定列的所有值之和&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GROUP_CONCAT(col)&lt;/td&gt;
&lt;td&gt;返回由属于一组的列值连接组合而成的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>总结-MySQL主从复制、读写分离配置详解</title>
    <link href="http://yoursite.com/2017/12/08/%E6%80%BB%E7%BB%93-MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E3%80%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/12/08/总结-MySQL主从复制、读写分离配置详解/</id>
    <published>2017-12-08T03:23:55.000Z</published>
    <updated>2017-12-08T06:48:14.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL主从同步的机制："><a href="#MySQL主从同步的机制：" class="headerlink" title="MySQL主从同步的机制："></a>MySQL主从同步的机制：</h2><p><img src="/uploads/2017/12/mysql_master_slave_01.jpg" alt=""><br><a id="more"></a></p><blockquote><ol><li>Slave 上面的IO线程连接上 Master，并请求从指定日志文件的指定位置(或者从最开始的日志)之后的日志内容;</li><li>Master 接收到来自 Slave 的 IO 线程的请求后，通过负责复制的 IO线程根据请求信息读取指定日志指定位置之后的日志信息，返回给 Slave 端的 IO线程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息在 Master 端的 Binary Log 文件的名称以及在 BinaryLog 中的位置;</li><li>Slave 的 IO 线程接收到信息后，将接收到的日志内容依次写入到 Slave 端的RelayLog文件(MySQL-relay-bin.xxxxxx)的最末端，并将读取到的Master端的bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的高速Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”</li><li>Slave 的 SQL 线程检测到 Relay Log 中新增加了内容后，会马上解析该 Log 文件中的内容成为在 Master端真实执行时候的那些可执行的 Query 语句，并在自身执行这些 Query。这样，实际上就是在 Master 端和 Slave端执行了同样的 Query，所以两端的数据是完全一样的。</li></ol></blockquote><h2 id="MySQL主从同步的作用"><a href="#MySQL主从同步的作用" class="headerlink" title="MySQL主从同步的作用"></a>MySQL主从同步的作用</h2><p>Ø  可以作为一种备份机制，相当于热备份<br>Ø  可以用来做读写分离，均衡数据库负载</p><h2 id="MySQL主从同步的步骤"><a href="#MySQL主从同步的步骤" class="headerlink" title="MySQL主从同步的步骤"></a>MySQL主从同步的步骤</h2><p>1、在Master MySQL上创建一个用户‘repl’，并允许其他Slave服务器可以通过远程访问Master，通过该用户读取二进制日志，实现数据同步。</p><blockquote><p>mysql&gt;create user repl; //创建新用户<br>//repl用户必须具有REPLICATION SLAVE权限，除此之外没有必要添加不必要的权限，密码为mysql。说明一下192.168.0.%，这个配置是指明repl用户所在服务器，这里%是通配符，表示192.168.0.0-192.168.0.255的Server都可以以repl用户登陆主服务器。当然你也可以指定固定Ip。<br>mysql&gt; GRANT REPLICATION SLAVE ON <em>.</em> TO ‘repl’@’192.168.0.%’ IDENTIFIED BY ‘mysql’;</p></blockquote><p>2、主数据库服务器配置<br>　进入主数据库服务器安装目录,打开my.ini,在文件末尾增加如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#数据库ID号， 为1时表示为Master,其中master_id必须为1到232–1之间的一个正整数值;   </span><br><span class="line">server-id = 1  </span><br><span class="line">#启用二进制日志；  </span><br><span class="line">log-bin=mysql-bin  </span><br><span class="line">#需要同步的二进制数据库名；  </span><br><span class="line">binlog-do-db=minishop  </span><br><span class="line">#不同步的二进制数据库名,如果不设置可以将其注释掉;  </span><br><span class="line">binlog-ignore-db=information_schema  </span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line">binlog-ignore-db=personalsite  </span><br><span class="line">binlog-ignore-db=test  </span><br><span class="line">#设定生成的log文件名；  </span><br><span class="line">log-bin=&quot;D:/Database/materlog&quot;  </span><br><span class="line">#把更新的记录写到二进制文件中； （注：此处不限制，是对所有操作进行记录日志）</span><br><span class="line">#log-slave-updates</span><br></pre></td></tr></table></figure></p><p>　保存文件。重启Mysql服务。</p><font color="red">注：主数据库配置文件命令详解：</font><table><thead><tr><th>log-bin=mysql-bin</th><th>启动二进制日志系统</th></tr></thead><tbody><tr><td>binlog-do-db=test</td><td>二进制需要同步的数据库名</td></tr><tr><td>server-id = 1</td><td>本机数据库ID 标示为主，该部分还应有一个server-id=Master_id选项，其中master_id必须为1到232–1之间的一个正整数值</td></tr><tr><td>log-bin=/var/log/mysql/updatelog</td><td>设定生成log文件名，这里的路径没有mysql目录要手动创建并给于它mysql用户的权限。</td></tr><tr><td>binlog-ignore-db=mysql</td><td>避免同步mysql用户配置，以免不必要的麻烦</td></tr></tbody></table><p>查看日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW MASTER STATUS;</span><br><span class="line">+-------------------+----------+--------------+------------------+</span><br><span class="line">| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class="line">+-------------------+----------+--------------+------------------+</span><br><span class="line">| master-bin.000001 | 0| | |</span><br><span class="line">+-------------------+----------+--------------+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p><em>（注：此处的日志文件File、Position下面需要用到）</em><br>3、从数据库服务器配置<br>　进入从数据库服务器安装目录,打开my.ini,在文件末尾增加如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#如果需要增加Slave库则，此id往后顺延；  </span><br><span class="line">server-id = 2    </span><br><span class="line">log-bin=mysql-bin  </span><br><span class="line">#如果发现主服务器断线，重新连接的时间差；  </span><br><span class="line">master-connect-retry=60  </span><br><span class="line">#不需要备份的数据库；   </span><br><span class="line">replicate-ignore-db=mysql  </span><br><span class="line">#需要备份的数据库  </span><br><span class="line">replicate-do-db=minishop  </span><br><span class="line">#log-slave-update</span><br></pre></td></tr></table></figure></p><p>　保存文件。重启Mysql服务。<br>4、连接Master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;change master to </span><br><span class="line">-&gt;master_host=&apos;192.168.0.104&apos;, //Master 服务器Ip</span><br><span class="line">-&gt;master_port=3306,</span><br><span class="line">-&gt;master_user=&apos;repl&apos;,</span><br><span class="line">-&gt;master_password=&apos;mysql&apos;, </span><br><span class="line">-&gt;master_log_file=&apos;master-bin.000001&apos;,//Master服务器产生的日志</span><br><span class="line">-&gt;master_log_pos=0;</span><br></pre></td></tr></table></figure></p><font color="red">从服务器配置命令详解：</font><table><thead><tr><th>server-id = 2</th><th>从服务器ID号，不要和主ID相同 ，如果设置多个从服务器，每个从服务器必须有一个唯一的server-id值，必须与主服务器的以及其它从服务器的不相同。可以认为server-id值类似于IP地址：这些ID值能唯一识别复制服务器群集中的每个服务器实例。</th></tr></thead><tbody><tr><td>master-host = 172.31.70.51</td><td>指定主服务器IP地址</td></tr><tr><td>master-user = replication</td><td>指定在主服务器上可以进行同步的用户名</td></tr><tr><td>master-password = 123456</td><td>密码</td></tr><tr><td>master-port = 3306</td><td>同步所用的端口</td></tr><tr><td>master-connect-retry=60</td><td>断点重新连接时间</td></tr><tr><td>replicate-ignore-db=mysql</td><td>屏蔽对mysql库的同步，以免有麻烦</td></tr><tr><td>replicate-do-db=test</td><td>同步数据库名称</td></tr></tbody></table><p>5、启动Slave<br><code>start slave;</code><br>查看从服务器状态<br><code>mysql&gt; show slave status \G;</code><br><img src="/uploads/2017/12/mysql_master_slave_02.png" alt=""><br>OK所有配置都完成了。</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>　完成MySQL的主从配置，实现数据的实时同步，采用架构的方式实现MySQL的读写分离。<br>　统一认证平台完成数据的增删改的操作，保存数据到MySQL的Master的数据库中，Salve数据库从Master数据库中实时同步数据，应用系统从Salve数据库中读取书据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL主从同步的机制：&quot;&gt;&lt;a href=&quot;#MySQL主从同步的机制：&quot; class=&quot;headerlink&quot; title=&quot;MySQL主从同步的机制：&quot;&gt;&lt;/a&gt;MySQL主从同步的机制：&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/uploads/2017/12/mysql_master_slave_01.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
      <category term="架构" scheme="http://yoursite.com/categories/MySQL/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>总结-MySQL分库分表理论详解</title>
    <link href="http://yoursite.com/2017/12/08/%E6%80%BB%E7%BB%93-MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%90%86%E8%AE%BA%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/12/08/总结-MySQL分库分表理论详解/</id>
    <published>2017-12-08T03:05:56.000Z</published>
    <updated>2017-12-08T06:48:04.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要分库-分表？"><a href="#为什么要分库-分表？" class="headerlink" title="为什么要分库/分表？"></a>为什么要分库/分表？</h3><p>　当一张的数据达到几百万时，你查询一次所花的时间会变多，如果有联合查询的话，我想有可能会死在那儿了。分表的目的就在于此，减小数据库的负担，缩短查询时间。<br>　mysql中有一种机制是表锁定和行锁定，为什么要出现这种机制，是为了保证数据的完整 性，我举个例子来说吧，如果有二个sql都要修改同一张表的同一条数据，这个时候怎么办呢，是不是二个sql都可以同时修改这条数据呢？很显然mysql 对这种情况的处理是，一种是表锁定（myisam存储引擎），一个是行锁定（innodb存储引擎）。表锁定表示你们都不能对这张表进行操作，必须等我对 表操作完才行。行锁定也一样，别的sql必须等我对这条数据操作完了，才能对这条数据进行操作。如果数据太多，一次执行的时间太长，等待的时间就越长，这 也是我们为什么要分库/分表的原因。<br><a id="more"></a></p><h3 id="怎么分库-分表？"><a href="#怎么分库-分表？" class="headerlink" title="怎么分库/分表？"></a>怎么分库/分表？</h3><p><strong>分库：</strong><br>（1）mysql集群与主从复制、读写分离：</p><blockquote><p>   　主从复制、读写分离只是一种策略。<br>   　读写分离策略，最大限度提高了应用中读取数据的速度和并发量。（原理是，由于MySQL中有一种机制是表锁定和行锁定，所以写操作会锁定，而且写操作比读操作更费时，因为不仅要写入数据，还要更新索引。因此，把读写分离，可极大提高数据库的性能。）<br>   　主从复制策略，可以降低单台机器的负载，同时最大限度的降低宕机造成的损失。<br>   　集群：解决了数据库宕机带来的单点数据库不能访问的问题。</p></blockquote><p>（2）垂直分库：一般根据业务逻辑来分，例如按照用户、商品、日志等。<br>（3）水平分库：就是对业务进行主从复制、读写分离的操作。当一主一从不能满足时，就需要一主多从的形式满足读操作。<br><strong>分表：</strong><br>（1）垂直分表：根据字段的使用情况来进行划分，把一些常使用的字段放在一个表中。不经常使用（读和写）的放在一个表中，可通过一个外键关联。（使用外键时要注意该表是否读大于写，如果不能使用外键，直接将主表搜索ID放到附表即可一样关联。）<br>（2）水平分表：水平分表方式多样，例如：</p><blockquote><ol><li>按时间分表<br>　这种分表方式有一定的局限性，当数据有较强的实效性，如微博发送记录、微信消息记录等，这种数据很少有用户会查询几个月前的数据，如就可以按月分表。</li><li>按数据迁移的方式<br>　当一些很久之前的数据，很少再查询。比如员工工资表，我们可以只存今年的工资情况。而历史数据我们可以迁移到一张salary_old表中,保证数据不会丢失。但也可以用来查询。每天定期把今年中的最早一天的记录归入旧表中。这样一方面可以解决性能问题，最多也只需要读2张表就完成了。</li><li>按热度拆分<br>　典型的像贴吧这种有高点击率的词条，也有低点击率的词条，如果一个词条一张表，那得多少表啊，所以一般这种情况就会对高点击率的词条生成 一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，比如1W条，再把低热度的表单独拆分成一张表。</li></ol></blockquote><p>（3）分表实现技术方式：</p><pre><code>1. 分两张表的情况，可使用对2取余判断奇偶2. 分10张表以内的，可使用对10或10以内数字取模来实现3. 数据量大的，可根据MD5哈希取位数来实现（位数越大，表数越大）4. 利用merge存储引擎来实现分表</code></pre><h3 id="实际工作中如何分库-分表？"><a href="#实际工作中如何分库-分表？" class="headerlink" title="实际工作中如何分库/分表？"></a>实际工作中如何分库/分表？</h3><p>　做什么事都有一个度，超过这个度就会变得很差，不能一味的做数据库服务器集群，硬件是要花钱买的，也不要一味的分表，分出来1000 表，mysql的存储归根到底还以文件的形势存在硬盘上面，一张表对应三个文件，1000个分表就是对应3000个文件，这样检索起来也会变的很慢 。<br>　建议是：硬件与软件一起使用。</p><h3 id="分库-分表后产生的问题？"><a href="#分库-分表后产生的问题？" class="headerlink" title="分库/分表后产生的问题？"></a>分库/分表后产生的问题？</h3><p>（1）分库分表维度的问题<br>　假如用户购买了商品,需要将交易记录保存取来，如果按照用户的纬度分表，则每个用户的交易记录都保存在同一表中，所以很快很方便的查找到某用户的购买情况，但是某商品被购买的情况则很有可能分布在多张表中，查找起来比较麻烦。反之，按照商品维度分表，可以很方便的查找到此商品的购买情况，但要查找到购买人的交易记录比较麻烦。<br>　所以常见的解决方式有： </p><pre><code>1. 通过扫表的方式解决，此方法基本不可能，效率太低了。 2. 记录两份数据，一份按照用户纬度分表，一份按照商品维度分表。 3. 通过搜索引擎解决，但如果实时性要求很高，又得关系到实时搜索。 </code></pre><p>（2）联合查询的问题<br>　联合查询基本不可能，因为关联的表有可能不在同一数据库中。<br>（3）避免跨库事务<br>　避免在一个事务中修改db0中的表的时候同时修改db1中的表，一个是操作起来更复杂，效率也会有一定影响。<br>（4）尽量把同一组数据放到同一DB服务器上<br>　如将卖家a的商品和交易信息都放到db0中，当db1挂了的时候，卖家a相关的东西可以正常使用。也就是说避免数据库中的数据依赖另一数据库中的数据。</p><h3 id="分库时需要注意的问题："><a href="#分库时需要注意的问题：" class="headerlink" title="分库时需要注意的问题："></a>分库时需要注意的问题：</h3><p>（1）联结不能跨库操作<br>（2）InnoDB引擎的外键不能跨库<br>（3）避免跨库事务操作<br>（4）尽量把同一组数据放到同一个数据库上</p><p><strong>参考博文：</strong><br><em><a href="https://yq.aliyun.com/articles/42644" target="_blank" rel="noopener">mysql 分库分表的方法</a></em><br><em><a href="http://www.cnblogs.com/zhongxinWang/p/4262650.html" target="_blank" rel="noopener">数据库水平切分的实现原理解析——分库，分表，主从，集群，负载均衡器</a></em><br><em><a href="http://blog.csdn.net/lzf4712/article/details/47780303" target="_blank" rel="noopener">数据库读写分离和垂直分库、水平分表</a></em><br><em><a href="http://blog.51yip.com/mysql/399.html" target="_blank" rel="noopener">linux mysql proxy 的安装，配置，以及读写分离</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么要分库-分表？&quot;&gt;&lt;a href=&quot;#为什么要分库-分表？&quot; class=&quot;headerlink&quot; title=&quot;为什么要分库/分表？&quot;&gt;&lt;/a&gt;为什么要分库/分表？&lt;/h3&gt;&lt;p&gt;　当一张的数据达到几百万时，你查询一次所花的时间会变多，如果有联合查询的话，我想有可能会死在那儿了。分表的目的就在于此，减小数据库的负担，缩短查询时间。&lt;br&gt;　mysql中有一种机制是表锁定和行锁定，为什么要出现这种机制，是为了保证数据的完整 性，我举个例子来说吧，如果有二个sql都要修改同一张表的同一条数据，这个时候怎么办呢，是不是二个sql都可以同时修改这条数据呢？很显然mysql 对这种情况的处理是，一种是表锁定（myisam存储引擎），一个是行锁定（innodb存储引擎）。表锁定表示你们都不能对这张表进行操作，必须等我对 表操作完才行。行锁定也一样，别的sql必须等我对这条数据操作完了，才能对这条数据进行操作。如果数据太多，一次执行的时间太长，等待的时间就越长，这 也是我们为什么要分库/分表的原因。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
      <category term="架构" scheme="http://yoursite.com/categories/MySQL/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MySQL单机到集群的架构变迁【摘】</title>
    <link href="http://yoursite.com/2017/12/08/MySQL%E5%8D%95%E6%9C%BA%E5%88%B0%E9%9B%86%E7%BE%A4%E7%9A%84%E6%9E%B6%E6%9E%84%E5%8F%98%E8%BF%81/"/>
    <id>http://yoursite.com/2017/12/08/MySQL单机到集群的架构变迁/</id>
    <published>2017-12-08T02:27:55.000Z</published>
    <updated>2017-12-08T06:47:44.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、业务上线初期，web服务规模较小，一般具备以下特点："><a href="#1、业务上线初期，web服务规模较小，一般具备以下特点：" class="headerlink" title="1、业务上线初期，web服务规模较小，一般具备以下特点："></a>1、业务上线初期，web服务规模较小，一般具备以下特点：</h3><ol><li>服务原型时期,用户基数小,多种业务公用资源,日均写入百万级别,读取千万级别</li><li>数据规模小，单机性能能够满足需求</li><li>用户规模小，开发重心偏向迭代速度</li><li>考虑到上述小型业务特点，为节约资源成本及开发成本，可以采用多个业务混合部署形式<br><img src="/uploads/2017/12/mysql_read_write_01.jpg" alt=""><a id="more"></a><h3 id="2、当用户增多，数据量、访问量升高-2倍以下-，数据库压力较大，怎样在有限程度提高MySQL吞吐量呢？"><a href="#2、当用户增多，数据量、访问量升高-2倍以下-，数据库压力较大，怎样在有限程度提高MySQL吞吐量呢？" class="headerlink" title="2、当用户增多，数据量、访问量升高(2倍以下)，数据库压力较大，怎样在有限程度提高MySQL吞吐量呢？"></a>2、当用户增多，数据量、访问量升高(2倍以下)，数据库压力较大，怎样在有限程度提高MySQL吞吐量呢？</h3></li><li>SQL优化</li><li>硬件升级<br>　压力还在有限的范围内增长，通过简单、低成本优化，可以一定成都上提高有限的服务性能</li></ol><h3 id="3、业务持续发展，读取性能出现瓶颈-amp-amp-各业务互相影响，多个业务出-现资源抢占，如何快速解决业务抢占问题以提高服务性能？"><a href="#3、业务持续发展，读取性能出现瓶颈-amp-amp-各业务互相影响，多个业务出-现资源抢占，如何快速解决业务抢占问题以提高服务性能？" class="headerlink" title="3、业务持续发展，读取性能出现瓶颈&amp;&amp;各业务互相影响，多个业务出 现资源抢占，如何快速解决业务抢占问题以提高服务性能？"></a>3、业务持续发展，读取性能出现瓶颈&amp;&amp;各业务互相影响，多个业务出 现资源抢占，如何快速解决业务抢占问题以提高服务性能？</h3><p>　垂直拆分——按业务进行数据拆分<br><img src="/uploads/2017/12/mysql_read_write_02.jpg" alt=""></p><h3 id="4、随着业务的继续发展，读取性能出现瓶颈-读写互相影响，如何确保读请求量的增加，不要影响写入性能？相反写入请求量增加如何确保不影响读取性能？-写入性能出现问题会造成数据丢失"><a href="#4、随着业务的继续发展，读取性能出现瓶颈-读写互相影响，如何确保读请求量的增加，不要影响写入性能？相反写入请求量增加如何确保不影响读取性能？-写入性能出现问题会造成数据丢失" class="headerlink" title="4、随着业务的继续发展，读取性能出现瓶颈,读写互相影响，如何确保读请求量的增加，不要影响写入性能？相反写入请求量增加如何确保不影响读取性能？(写入性能出现问题会造成数据丢失)"></a>4、随着业务的继续发展，读取性能出现瓶颈,读写互相影响，如何确保读请求量的增加，不要影响写入性能？相反写入请求量增加如何确保不影响读取性能？(写入性能出现问题会造成数据丢失)</h3><p>　读写分离，写入仅写master，master与slave自动同步；读取仅以slave作为来源<br><img src="/uploads/2017/12/mysql_read_write_03.jpg" alt=""><br>　读写分离后，slave仅专注于承担读请求，读取性能得到优化；同里独立的master服务的写入性能也得到优化。</p><h3 id="5、一台-一对M-S服务器性能终归是很有限的，当单实例服务性能无法承载线上的请求量时，如何进行优化？"><a href="#5、一台-一对M-S服务器性能终归是很有限的，当单实例服务性能无法承载线上的请求量时，如何进行优化？" class="headerlink" title="5、一台/一对M-S服务器性能终归是很有限的，当单实例服务性能无法承载线上的请求量时，如何进行优化？"></a>5、一台/一对M-S服务器性能终归是很有限的，当单实例服务性能无法承载线上的请求量时，如何进行优化？</h3><ol><li>升级为一主多从架构</li><li>一个master承载所有写入请求，理论上master性能不变</li><li>多个slave分担读取请求，读取性能提升n倍<br><img src="/uploads/2017/12/mysql_read_write_04.jpg" alt=""></li></ol><h3 id="6、随着业务量的增长，服务出现如下变化："><a href="#6、随着业务量的增长，服务出现如下变化：" class="headerlink" title="6、随着业务量的增长，服务出现如下变化："></a>6、随着业务量的增长，服务出现如下变化：</h3><p>　数据量增长，意味着原本的存储空间不足<br>　写入量增长，意味着master写入性能存在瓶颈<br>　读取量增长，意味着slave读取性能也存在瓶颈，但通过扩充slave是有限制的：一方面M-Sreplication性能有风险；另一方面扩充slave的成本较高<br><strong>水平拆分</strong><br><img src="/uploads/2017/12/mysql_read_write_05.jpg" alt=""><br>　业务经历数据量的增长、读写请求量的增长，数据库服务已经演进为分布式架构，一个业务的数据，怎样合理的分布到上述复杂的分布式数据库是下一个需要解决的问题</p><h3 id="7、如何基于上述演进到最后的架构进行数据库设计呢？"><a href="#7、如何基于上述演进到最后的架构进行数据库设计呢？" class="headerlink" title="7、如何基于上述演进到最后的架构进行数据库设计呢？"></a>7、如何基于上述演进到最后的架构进行数据库设计呢？</h3><ol><li>分布式数据库设计</li><li>hash拆分方式，既按hash规则，将数据读写请求分散到多个实例上，见上述水平拆分示意图</li><li>时间拆分方式，基于确定好的时间划分规则，将数据按时间段分散存储再多个实例中<br><img src="/uploads/2017/12/mysql_read_write_06.jpg" alt=""></li></ol><h3 id="8、当一台服务器宕机怎么办？"><a href="#8、当一台服务器宕机怎么办？" class="headerlink" title="8、当一台服务器宕机怎么办？"></a>8、当一台服务器宕机怎么办？</h3><p>（1）Slave(一主多从)宕机？</p><pre><code>1. 剩余健康Slave无风险，则无需紧急操作，例行修复2. 切换流量到容灾机房(如果具备容灾机房)3. 紧急扩容[优先]、重启、替换4. 有损降级部分请求</code></pre><p>（2）Master宕机？<br>　由于master数据的唯一性，致使master出现异常会直接造成数据写入失败</p><pre><code>1. 快速下线master2. 下线一台salve的读服务(如果slave性能有风险，则同时快速扩容)3. 提升slave为master4. 生效新master与slave的同步机制</code></pre><h3 id="9、注意事项"><a href="#9、注意事项" class="headerlink" title="9、注意事项"></a>9、注意事项</h3><p>（1）MySQL设计应该注意的问题</p><pre><code>1. 表字符集选择UTF82. 存储引擎使用InnoDB3. 使用Varchar/Varbinary存储变长字符串4. 不在数据库中存储图片、文件等5. 每张表数据量控制在20000W以下6. 提前对业务做好垂直拆分</code></pre><p>（2）MySQL查询应该遇到的问题</p><pre><code>1. 避免使用存储过程、触发器、函数等　让数据库做最擅长的事　降低业务耦合度避开服务端BUG2. 避免使用大表的JOIN　MySQL最擅长的是单表的主键/索引查询　JOIN消耗较多内存,产生临时表3. 避免在数据库中进行数学运算　MySQL不擅长数学运算　无法使用索引4. 减少与数据库的交互次数　select条件查询要利用索引　同一字段的条件判定要用in而不要用or</code></pre><p><em>摘抄博客：</em><br><strong><a href="https://weibo.com/p/1001643874615465508614" target="_blank" rel="noopener">新兵训练营系列课程——海量数据存储基础</a></strong><br><em>分享一篇博客：</em><br><strong><a href="http://blog.csdn.net/czbing308722240/article/details/52350219" target="_blank" rel="noopener">QPS从0到4000请求每秒，谈达达后台架构演化之路</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、业务上线初期，web服务规模较小，一般具备以下特点：&quot;&gt;&lt;a href=&quot;#1、业务上线初期，web服务规模较小，一般具备以下特点：&quot; class=&quot;headerlink&quot; title=&quot;1、业务上线初期，web服务规模较小，一般具备以下特点：&quot;&gt;&lt;/a&gt;1、业务上线初期，web服务规模较小，一般具备以下特点：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;服务原型时期,用户基数小,多种业务公用资源,日均写入百万级别,读取千万级别&lt;/li&gt;
&lt;li&gt;数据规模小，单机性能能够满足需求&lt;/li&gt;
&lt;li&gt;用户规模小，开发重心偏向迭代速度&lt;/li&gt;
&lt;li&gt;考虑到上述小型业务特点，为节约资源成本及开发成本，可以采用多个业务混合部署形式&lt;br&gt;&lt;img src=&quot;/uploads/2017/12/mysql_read_write_01.jpg&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
      <category term="架构" scheme="http://yoursite.com/categories/MySQL/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MySQL调优三部曲</title>
    <link href="http://yoursite.com/2017/12/07/MySQL%E8%B0%83%E4%BC%98%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
    <id>http://yoursite.com/2017/12/07/MySQL调优三部曲/</id>
    <published>2017-12-07T10:04:34.000Z</published>
    <updated>2017-12-08T06:48:42.389Z</updated>
    
    <content type="html"><![CDATA[<p>1、慢查询 （分析出现出问题的sql）<br>2、Explain （显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句）<br>3、Profile（查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等.）<br><a id="more"></a></p><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>　MySQL通过慢查询日志定位那些执行效率较低的SQL 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 会写一个包含所有执行时间超过long_query_time 秒的SQL语句的日志文件，通过查看这个日志文件定位效率较低的SQL 。下面介绍MySQL中如何查询慢的SQL语句：</p><h4 id="配置开启"><a href="#配置开启" class="headerlink" title="配置开启"></a>配置开启</h4><p><strong>配置选项：</strong></p><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td>long_query_time</td><td>设定慢查询的阀值，超出次设定值的SQL即被记录到慢查询日志，缺省值为10s  </td></tr><tr><td>slow_query_log</td><td>指定是否开启慢查询日志  </td></tr><tr><td>log_slow_queries</td><td>指定是否开启慢查询日志(该参数要被slow_query_log取代，做兼容性保留)  </td></tr><tr><td>slow_query_log_file</td><td>指定慢日志文件存放位置，可以为空，系统会给一个缺省的文件host_name-slow.log  </td></tr><tr><td>min_examined_row_limit</td><td>查询检查返回少于该参数指定行的SQL不被记录到慢查询日志  </td></tr><tr><td>log_queries_not_using_indexes</td><td>不使用索引的慢查询日志是否记录到索引</td></tr></tbody></table><p><strong>开启配置</strong><br>查询慢查询是否开启：<br><code>show variables like &#39;%slow%&#39;;</code><br>开启慢查询日志：<br><code>set global log_slow_queries=1;</code><br>查询慢查询时间：<br><code>show variables like &#39;%long_query_time%&#39;;</code></p><h4 id="查看方式"><a href="#查看方式" class="headerlink" title="查看方式"></a>查看方式</h4><p>利用MySQL自带的慢查询日志分析工具mysqldumpslow分析日志。</p><pre><code>perlmysqldumpslow –s c –t 10 slow-query.log具体参数设置如下：-s 表示按何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时间、返回的记录数来排序，ac、at、al、ar，表示相应的倒叙；-t 表示top的意思，后面跟着的数据表示返回前面多少条；-g 后面可以写正则表达式匹配，大小写不敏感。</code></pre><p>例子：<br><code>mysqldumpslow -s c -t 20 host-slow.log</code>     #访问次数最多的20个sql语句<br><code>mysqldumpslow -t 10 -s t -g “left join” host-slow.log</code>     #按照时间返回前10条里面含有左连接的sql语句</p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。<br>使用方法，在select语句前加上explain就可以了：<br>例如：<br>explain select surname,first_name form a,b where a.id=b.id<br><strong>显示结果分析：</strong></p><pre><code>id | select_type | table |  type | possible_keys | key | key_len | ref | rows | Extra EXPLAIN列的解释table显示这一行的数据是关于哪张表的type这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALLpossible_keys显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句key实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句 中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引key_len使用的索引的长度。在不损失精确性的情况下，长度越短越好ref显示索引的哪一列被使用了，如果可能的话，是一个常数rowsMYSQL认为必须检查的用来返回请求数据的行数Extra关于MYSQL如何解析查询的额外信息。这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢</code></pre><p><strong>Extra列返回的描述的意义：</strong></p><pre><code>Distinct一旦MYSQL找到了与行相联合匹配的行，就不再搜索了Not existsMYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了Range checked for each Record（index map:#）没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一Using filesort看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行Using index列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候Using temporary看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上Where used使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）</code></pre><p><strong>Type列不同连接类型的解释：（按照效率高低的顺序排序）</strong></p><pre><code>system 表只有一行：system表。这是const连接类型的特殊情况 const 表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待 eq_ref 在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用 ref 这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好 range 这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西时发生的情况 index 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据） ALL 这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免</code></pre><h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p>　Query Profiler是MYSQL自带的一种query诊断分析工具，通过它可以分析出一条SQL语句的性能瓶颈在什么地方。通常我们是使用的explain,以及slow query log都无法做到精确分析，但是Query Profiler却可以定位出一条SQL语句执行的各种资源消耗情况，比如CPU，IO等，以及该SQL执行所耗费的时间等。<br>　Show profiles是5.0.37之后添加的，要想使用此功能，要确保版本在5.0.37之后。<br>　查看数据库版本方法：<code>show variables like &quot;%version%&quot;;</code>  或者  <code>select version();</code></p><p>1、确定支持show profile 后，查看profile是否开启，数据库默认是不开启的。变量profiling是用户变量，每次都得重新启用。<br>查看方法： <code>show variables like &quot;%pro%&quot;;</code><br>2、开启和关闭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling=1;</span><br><span class="line">mysql&gt; set profiling=0;</span><br></pre></td></tr></table></figure></p><p>　information_schema 的 database 会建立一个PROFILING 的 table 记录.<br>3、执行一些语句（自定义语句）<br><code>mysql&gt;select * from navigation_sub where navPId&lt;6 and navSName=&#39;公司介绍&#39;;</code><br>4、查询语句执行时间<br><code>mysql&gt;show profiles;</code><br>5、查询语句详细执行时间<br><code>mysql&gt;show profile for query 2;</code><br><strong>（注：此处的 2 表示再 <code>show profiles</code> 查询后获取的 Query_ID字段。）</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、慢查询 （分析出现出问题的sql）&lt;br&gt;2、Explain （显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句）&lt;br&gt;3、Profile（查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等.）&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>总结-MySQL索引</title>
    <link href="http://yoursite.com/2017/12/07/%E6%80%BB%E7%BB%93-MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2017/12/07/总结-MySQL索引/</id>
    <published>2017-12-07T08:25:02.000Z</published>
    <updated>2017-12-07T10:00:36.552Z</updated>
    
    <content type="html"><![CDATA[<p>关于MySQL索引的好处，如果正确合理设计并且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。对于没有索引的表，单表查询可能几十万数据就是瓶颈，而通常大型网站单日就可能会产生几十万甚至几百万的数据，没有索引查询会变的非常缓慢。</p><blockquote><p>   一个简单的对比测试：<br>   　以我去年测试的数据作为一个简单示例，20多条数据源随机生成200万条数据，平均每条数据源都重复大概10万次，表结构比较简单，仅包含一个自增ID，一个char类型，一个text类型和一个int类型，单表2G大小，使用MyIASM引擎。开始测试未添加任何索引。<br>   执行下面的SQL语句：<br>   　mysql&gt; SELECT id,FROM_UNIXTIME(time) FROM article WHERE a.title=’测试标题’<br>   查询需要的时间非常恐怖的，如果加上联合查询和其他一些约束条件，数据库会疯狂的消耗内存，并且会影响前端程序的执行。这时给title字段添加一个BTREE索引：<br>   　mysql&gt; ALTER TABLE article ADD INDEX index_article_title ON title(200);<br>   再次执行上述查询语句，其对比非常明显。</p></blockquote><a id="more"></a><h3 id="MySQL索引的概念"><a href="#MySQL索引的概念" class="headerlink" title="MySQL索引的概念"></a>MySQL索引的概念</h3><p>　索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。上述SQL语句，在没有索引的情况下，数据库会遍历全部200条数据后选择符合条件的；而有了相应的索引之后，数据库会直接在索引中查找符合条件的选项。如果我们把SQL语句换成<code>“SELECT * FROM article WHERE id=2000000”</code>，那么你是希望数据库按照顺序读取完200万行数据以后给你结果还是直接在索引中定位呢？上面的两个图片鲜明的用时对比已经给出了答案<em>（注：一般数据库默认都会为主键生成索引）</em>。<br>　索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。</p><blockquote><p>   　聚簇索引与非聚簇索引的区别：在《数据库原理》一书中是这么解释聚簇索引和非聚簇索引的区别的：聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。比较MyISAM和InnoDB两种存储引擎说一下，MyISAM引擎的索引文件(.MYI)和数据文件(.MYD)是相互独立的，而InnoDB的数据和索引文件都保存在(.ibd)中。MySQL索引采用的是B+Tree，对于MyISAM引擎来说叶子节点存储的是索引文件，而InnoDB引擎叶子节点存储的既有数据又有索引。当创建数据表时对于InnoDB主键生成的索引为聚簇索引，而MyISAM主键生成的索引为非聚簇索引。对于一个数据表来说只能由一个聚簇索引。<br><em>（参考文章：<br><a href="https://www.cnblogs.com/T8881/p/5940338.html" target="_blank" rel="noopener">MYSQL性能调优: 对聚簇索引和非聚簇索引的认识</a><br><a href="http://blog.csdn.net/lijiaz5033/article/details/50129723" target="_blank" rel="noopener">MySQL聚簇索引和非聚簇索引的原理及使用</a>）</em></p></blockquote><h3 id="MySQL索引的类型"><a href="#MySQL索引的类型" class="headerlink" title="MySQL索引的类型"></a>MySQL索引的类型</h3><h4 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1. 普通索引"></a>1. 普通索引</h4><p>　这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。</p><pre><code>–直接创建索引　CREATE INDEX index_name ON table(column(length))–修改表结构的方式添加索引　ALTER TABLE table_name ADD INDEX index_name ON (column(length))–创建表的时候同时创建索引　CREATE TABLE `table` (　`id` int(11) NOT NULL AUTO_INCREMENT ,　`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,　`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,　`time` int(10) NULL DEFAULT NULL ,　PRIMARY KEY (`id`),　INDEX index_name (title(length))　)–删除索引　DROP INDEX index_name ON table</code></pre><h4 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2. 唯一索引"></a>2. 唯一索引</h4><p>　与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。</p><pre><code>–创建唯一索引　CREATE UNIQUE INDEX indexName ON table(column(length))–修改表结构　ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))–创建表的时候直接指定　CREATE TABLE `table` (　`id` int(11) NOT NULL AUTO_INCREMENT ,　`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,　`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,　`time` int(10) NULL DEFAULT NULL ,　PRIMARY KEY (`id`),　UNIQUE indexName (title(length))　);</code></pre><h4 id="3-全文索引（FULLTEXT）"><a href="#3-全文索引（FULLTEXT）" class="headerlink" title="3. 全文索引（FULLTEXT）"></a>3. 全文索引（FULLTEXT）</h4><p>　MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引仅可用于 MyISAM 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。////对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。</p><pre><code>–创建表的适合添加全文索引　CREATE TABLE `table` (　`id` int(11) NOT NULL AUTO_INCREMENT ,　`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,　`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,　`time` int(10) NULL DEFAULT NULL ,　PRIMARY KEY (`id`),　FULLTEXT (content)　);–修改表结构添加全文索引　ALTER TABLE article ADD FULLTEXT index_content(content)–直接创建索引　CREATE FULLTEXT INDEX index_content ON article(content)</code></pre><h4 id="4-单列索引、多列索引"><a href="#4-单列索引、多列索引" class="headerlink" title="4. 单列索引、多列索引"></a>4. 单列索引、多列索引</h4><p><font color="red">多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。</font></p><h4 id="5-组合索引（最左前缀）"><a href="#5-组合索引（最左前缀）" class="headerlink" title="5. 组合索引（最左前缀）"></a>5. 组合索引（最左前缀）</h4><p>　平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。例如上表中针对title和time建立一个组合索引：<code>ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))</code>。建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title,time</span><br><span class="line">title</span><br></pre></td></tr></table></figure></p><p>　为什么没有time这样的组合索引呢？这是因为MySQL组合索引<strong>“最左前缀”</strong>的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这两列的查询都会用到该组合索引，如下面的几个SQL所示：</p><pre><code>–使用到上面的索引　SELECT * FROM article WHREE title=&apos;测试&apos; AND time=1234567890;　SELECT * FROM article WHREE utitle=&apos;测试&apos;;–不使用上面的索引　SELECT * FROM article WHREE time=1234567890;</code></pre><h4 id="6、主键索引"><a href="#6、主键索引" class="headerlink" title="6、主键索引"></a>6、主键索引</h4><p>　它是一种特殊的唯一索引，不允许有空值。<br>　主键索引与唯一索引区别：唯一索引除了key值允许存在NULL外，其余的和主键索引没有本质性区别。</p><pre><code>总结：主键一定是唯一性索引，唯一性索引并不一定就是主键。一个表中可以有多个唯一性索引，但只能有一个主键。主键列不允许空值，而唯一性索引列允许空值。主键可以被其他字段作外键引用，而索引不能作为外键引用。</code></pre><h4 id="7、外键索引"><a href="#7、外键索引" class="headerlink" title="7、外键索引"></a>7、外键索引</h4><p><em>（注：InnoDB支持外键，而MyISAM不支持外键。）</em><br>　是用于建立和加强两个表数据之间的链接的一列或多列。外键约束主要用来维护两个表之间数据的一致性。简言之，表的外键就是另一表的主键，外键将两表联系起来。一般情况下，要删除一张表中的主键必须首先要确保其它表中的没有相同外键（即该表中的主键没有一个外键和它相关联）。</p><h4 id="8、索引区别"><a href="#8、索引区别" class="headerlink" title="8、索引区别"></a>8、索引区别</h4><pre><code>普通索引：最基本的索引，没有任何限制唯一索引：与&quot;普通索引&quot;类似，不同的就是：索引列的值必须唯一，但允许有空值。主键索引：它是一种特殊的唯一索引，不允许有空值。 全文索引：针对较大的数据，生成全文索引很耗时好空间。组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。</code></pre><h3 id="MySQL索引的优化"><a href="#MySQL索引的优化" class="headerlink" title="MySQL索引的优化"></a>MySQL索引的优化</h3><p>　上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。<br>　下面是一些总结以及收藏的MySQL索引的注意事项和优化方法。</p><blockquote><ol><li>何时使用聚集索引或非聚集索引？</li></ol></blockquote><table><thead><tr><th>动作描述</th><th>使用聚集索引</th><th>使用非聚集索引</th></tr></thead><tbody><tr><td>列经常被分组排序</td><td>使用</td><td>使用</td></tr><tr><td>返回某范围内的数据</td><td>使用</td><td>不使用</td></tr><tr><td>一个或极少不同值</td><td>不使用</td><td>不使用</td></tr><tr><td>小数目的不同值</td><td>使用</td><td>不使用</td></tr><tr><td>大数目的不同值</td><td>不使用</td><td>使用</td></tr><tr><td>频繁更新的列</td><td>不使用</td><td>使用</td></tr><tr><td>外键列</td><td>使用</td><td>使用</td></tr><tr><td>主键列</td><td>使用</td><td>使用</td></tr><tr><td>频繁修改索引列</td><td>不使用</td><td>使用</td></tr></tbody></table><blockquote><ol><li>索引不会包含有NULL值的列<br>　只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时<strong>不要让字段的默认值为NULL。</strong></li><li>使用短索引<br>　对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。（因为索引页存储的数据更多了）</li><li>索引列排序<br>　<strong>MySQL查询只使用一个索引</strong>，因此如果where子句中已经使用了索引的话，那么order by中的列或者OR条件的另一列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建<strong>复合索引</strong>。</li><li>like语句操作<br>　一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</li><li>不要在列上进行运算<br>避免在where子句中对字段进行表达式操作或函数操作，这将导致引擎放弃使用索引而进行全表扫描。<br>　例如：<code>select * from users where YEAR(adddate)&lt;2007</code>，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：<code>select * from users where adddate&lt;’2007-01-01′</code>。</li><li>不要在WHERE子句中使用参数<br>如果在 where 子句中使用参数，也会导致全表扫描。可改为强制查询使用索引。 <code>select * from t with(index(索引名)) where num=@num</code></li><li>任何地方都不要使用 <code>select * from t</code> ，用<strong>具体的字段列表</strong>代替“*”，不要返回用不到的任何字段。</li></ol></blockquote><p>　最后总结一下，MySQL只对一下操作符才使用索引：&lt;,&lt;=,=,&gt;,&gt;=,between,in,以及某些时候的like(不以通配符%或_开头的情形)；而对负向查询（not  , not in, not like, &lt;&gt;, != ,!&gt;,!&lt;  ） 不会使用索引。理论上每张表里面最多可创建16个索引，不过除非是数据量真的很多，否则过多的使用索引也不是那么好玩的，比如我刚才针对text类型的字段创建索引的时候，系统差点就卡死了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于MySQL索引的好处，如果正确合理设计并且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。对于没有索引的表，单表查询可能几十万数据就是瓶颈，而通常大型网站单日就可能会产生几十万甚至几百万的数据，没有索引查询会变的非常缓慢。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;   一个简单的对比测试：&lt;br&gt;   　以我去年测试的数据作为一个简单示例，20多条数据源随机生成200万条数据，平均每条数据源都重复大概10万次，表结构比较简单，仅包含一个自增ID，一个char类型，一个text类型和一个int类型，单表2G大小，使用MyIASM引擎。开始测试未添加任何索引。&lt;br&gt;   执行下面的SQL语句：&lt;br&gt;   　mysql&amp;gt; SELECT id,FROM_UNIXTIME(time) FROM article WHERE a.title=’测试标题’&lt;br&gt;   查询需要的时间非常恐怖的，如果加上联合查询和其他一些约束条件，数据库会疯狂的消耗内存，并且会影响前端程序的执行。这时给title字段添加一个BTREE索引：&lt;br&gt;   　mysql&amp;gt; ALTER TABLE article ADD INDEX index_article_title ON title(200);&lt;br&gt;   再次执行上述查询语句，其对比非常明显。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>总结-MySQL语句的语法</title>
    <link href="http://yoursite.com/2017/12/07/%E6%80%BB%E7%BB%93-MySQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/07/总结-MySQL语句的语法/</id>
    <published>2017-12-07T08:05:45.000Z</published>
    <updated>2017-12-08T06:49:55.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL语句的语法："><a href="#MySQL语句的语法：" class="headerlink" title="MySQL语句的语法："></a>MySQL语句的语法：</h2><p>1、<code>ALTER TABLE</code> 更新已存在的表的模式。<br>2、<code>COMMIT</code>  用来将事务处理写到数据库。<br>3、<code>CREATE INDEX</code>   用于在一个或多个列上创建索引。<br>4、<code>CREATE PROCEDURE</code>  用于创建存储过程。<br>5、<code>CREATE TABLE</code>   用于创建数据库表。<br><a id="more"></a><br>6、<code>CREATE USER</code>   用于向系统中添加新的用户账号。<br>7、<code>CREATE VIEW</code>   用来创建一个或多个表上的新视图。<br>8、<code>DELETE</code>    从表中删除一行或多行。<br>9、<code>DROP</code>   永久地删除数据库对象（表、视图、索引等）。<br>10、<code>INSERT</code>   给表增加一行。<br>11、<code>INSERT SELECT</code>   插入SELECT的结果到一个表。<br>12、<code>ROLLBACK</code>   用于撤销一个事务处理块。<br>13、<code>SAVEPOINT</code>    为使用ROLLBACK语句设立保留点。<br>14、<code>SELECT</code>    用于从一个或多个表（视图）中检索数据。<br>15、<code>START TRANSACTION</code>   表示一个新的事务处理块的开始。<br>16、<code>UPDATE</code>    更新表中的一行或多行。</p><h2 id="详解："><a href="#详解：" class="headerlink" title="详解："></a>详解：</h2><p>1、ALTER TABLE     更新已存在的表的模式。</p><pre><code>1. 删除列　ALTER TABLE 【表名字】 DROP 【列名称】2. 增加列　ALTER TABLE 【表名字】 ADD 【列名称】 【列类型】  COMMENT &apos;注释说明&apos;3. 修改列的类型信息　ALTER TABLE 【表名字】 MODIFY 【列名称】【列类型】4. 重命名列　ALTER TABLE 【表名字】 CHANGE 【列名称】【新列名称】【新列类型】5. 重命名表　ALTER TABLE 【表名字】 RENAME 【表新名字】6. 更改表存储引擎　ALTER TABLE ENGINE=InnoDB;7. 删除表中主键　Alter TABLE 【表名字】 DROP PRIMARY KEY　（注：该主键不能为自增，否则会报错。）8. 添加主键　ALTER TABLE 【表名字】 ADD PRIMARY KEY (`resid`,`resfromid`);　（注：如果表中有数据，直接添加主键会报错。需要①字段新建普通索引②字段增加自增属性③字段新建主键④删除字段的普通索引。）9. 添加索引　ALTER TABLE 【表名字】 ADD INDEX index_name (name);10. 添加唯一索引　ALTER TABLE 【表名字】 ADD UNIQUE emp_name2(cardnumber);11. 删除索引　ALTER TABLE 【表名字】 DROP INDEX emp_name;12. 添加外键索引　ALTER TABLE 【表名字】 ADD FOREIGN KEY index_name(name) REFERENCES foreign_table(name);　（注：添加外键需要两个表的存储引擎都是InnoDB型。）13. 删除外键索引　ALTER TABLE 【表名字】 DROP FOREIGN KEY index_name;</code></pre><p>2、CREATE TABLE   创建数据库表<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] `tbl_name`(</span><br><span class="line">`col_name` type [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT]</span><br><span class="line">PRIMARY KEY (`index_col_name`,...)</span><br><span class="line">or KEY [index_name] (`index_col_name`,...)</span><br><span class="line">or INDEX [index_name] (`index_col_name`,...)</span><br><span class="line">or UNIQUE [INDEX] [index_name] (`index_col_name`,...)</span><br><span class="line">or FOREIGN KEY index_name (`index_col_name`,...）</span><br><span class="line">)ENGINE=MyISAM DEFAULT CHARSET=UTF8;</span><br></pre></td></tr></table></figure></p><p>3、CREATE USER    创建用户</p><pre><code>1. 创建用户　CREATE USER user01@&apos;localhost/%&apos; IDENTIFIED BY &apos;password1&apos;;2. 修改密码　SET PASSWORD FOR &apos;user01&apos;@&apos;localhost/%&apos; = PASSWORD(&apos;password2&apos;);</code></pre><p>4、GRANT    赋予权限</p><pre><code>1. 设置权限　grant 权限 on 数据库对象 to 用户2. 取消权限　revoke 权限 on 数据库对象 from 用户3. 查看权限　show grants for dba@localhost;</code></pre><p>5、CREATE VIEW     创建视图</p><pre><code>1. 创建视图　CREATE VIEW  view_name AS SQL;2. 删除视图　DROP VIEW [IF EXISTS] view_name;　（注：视图不能修改，只能删除，然后重建。）</code></pre><p>6、DROP      删除（表、视图、存储过程）<br>    <code>DROP TABLE/VIEW/PROCEDURE [IF EXISTS] name;</code></p><p>7、CREATE PROCEDURE     创建存储过程</p><pre><code>1. 创建存储过程　CREATE PROCEDURE procedure_name(　IN  id int,　OUT price DECIMAL(8,2) 　)　BEGIN　SQL;　END;2. 调用存储过程　CALL  procedure_name();</code></pre><p>8、触发器</p><pre><code>1. 创建触发器　CREATE TRIGGER trigger_name [AFTER/BEFORE] [INSERT/UPDATE/DELETE] ON table_name　FOR EACH ROW 操作;　（在对表操作之前或之后，执行操作，EACH ROW表示每行变动都需要执行操作）2. 删除触发器　DROP TRIGGER trigger_name;3. 如何使用触发器　此处不需要人为操作触发器，当对表操作的时候自动执行。</code></pre><p>9、事务处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">操作格式：</span><br><span class="line">START TRANSACTION;</span><br><span class="line">SQL;</span><br><span class="line">COMMIT;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure></p><h2 id="数据表的基本操作："><a href="#数据表的基本操作：" class="headerlink" title="数据表的基本操作："></a>数据表的基本操作：</h2><p>1、SELECT<br><code>select [ALL/DISTINCE] 字段表达式子句 [from子句] [where子句] [group by子句] [having子句] [order by子句] [limit子句];</code></p><p>2、UPDATE<br><code>UPDATE tbl_name SET col_name1=expr1 [, col_name2=expr2 ...][WHERE子句] [ORDER BY子句] [LIMIT子句];</code></p><p>3、DELETE<br><code>DELETE FROM tbl_name [WHERE子句] [ORDER BY子句] [LIMIT子句];</code></p><p>4、INSERT<br><code>INSERT INTO tbl_name(col_name1,col_name2...) VALUES(col_vallue1,col_value2...);</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL语句的语法：&quot;&gt;&lt;a href=&quot;#MySQL语句的语法：&quot; class=&quot;headerlink&quot; title=&quot;MySQL语句的语法：&quot;&gt;&lt;/a&gt;MySQL语句的语法：&lt;/h2&gt;&lt;p&gt;1、&lt;code&gt;ALTER TABLE&lt;/code&gt; 更新已存在的表的模式。&lt;br&gt;2、&lt;code&gt;COMMIT&lt;/code&gt;  用来将事务处理写到数据库。&lt;br&gt;3、&lt;code&gt;CREATE INDEX&lt;/code&gt;   用于在一个或多个列上创建索引。&lt;br&gt;4、&lt;code&gt;CREATE PROCEDURE&lt;/code&gt;  用于创建存储过程。&lt;br&gt;5、&lt;code&gt;CREATE TABLE&lt;/code&gt;   用于创建数据库表。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>总结-MySQL数据类型</title>
    <link href="http://yoursite.com/2017/12/07/%E6%80%BB%E7%BB%93-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/12/07/总结-MySQL数据类型/</id>
    <published>2017-12-07T07:41:50.000Z</published>
    <updated>2017-12-07T08:03:18.995Z</updated>
    
    <content type="html"><![CDATA[<p>数据类型是定义列中可以存储什么数据以及该数据实际怎样存储的基本规则。<br>数据类型用于以下目的：</p><ul><li>数据类型允许限制可存储在列中的数据。例如，数值数据类型列只能接受数值。</li><li>数据类型允许在内部更有效地存储数据。 可以用一种比文本串更简洁的格式存储数值和日期时间值。</li><li>数据类型允许变换排序顺序。如果所有数据都作为串处理，则1位于10之前，而10又位于2之前（串以字典顺序排序，从左边开始比较，一次一个字符）。作为数值数据类型，数值才能正确排序。</li></ul><p>在设计表时，应该特别重视所用的数据类型。使用错误的数据类型可能会严重地影响应用程序的功能和性能。更改包含数据的列不是一件小事（而且这样做可能会导致数据丢失）。<br><a id="more"></a></p><h2 id="1、串数据类型"><a href="#1、串数据类型" class="headerlink" title="1、串数据类型"></a>1、串数据类型</h2><p>　最常用的数据类型是串数据类型。有两种基本的串类型，分别为定长串和变长串。<br>　定长串接受长度固定的字符串，其长度是在创建表时指定的。<br>　变长串存储可变长度的文本。<br>　<em>（注：MySQL处理定长列远比处理变长列快的多，性能好得多。而且，MySQL不允许对变长列（或一个列的可变部分）进行索引。这也会极大地影响性能。）</em><br><strong>串数据类型</strong></p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>CHAR</td><td>1~255个字符的定长串。它的长度必须在创建时指定，否则MySQL假定为CHAR(1)</td></tr><tr><td>VARCHAR</td><td>长度可变，最多不超过255字节。</td></tr><tr><td>TINYTEXT</td><td>与TEXT相同，但最大长度为255字节</td></tr><tr><td>TEXT</td><td>最大长度为64K的变长文本</td></tr><tr><td>MEDIUMTEXT</td><td>与TEXT相同，但最大长度为16K</td></tr><tr><td>LONGTEXT</td><td>与TEXT相同，但最大长度为4GB</td></tr><tr><td>ENUM</td><td>接受最多64K个串组成的一个预定义集合的某个串</td></tr><tr><td>SET</td><td>接受最多64个串组成的一个预定义集合的零个或多个串</td></tr></tbody></table><p><em>（注：不管使用何种形式的串数据类型，串值都必须括在引号内（通常单引号更好）。）</em><br><strong>特殊说明：</strong></p><pre><code>`ENUM`  枚举类型  只能由一个枚举字符串值（最大值是65535）如果默认值为not null，那么允许列表中的第一个值为默认值`SET`   集合类型  字符串对象可以有零个或多个SET成员（最多64个成员）</code></pre><p>　当数值不是数值时：你可能会认为电话号码和邮政编码应该存储在数值字段中（数值字段只存储数值数据），但是，这样做却是不可取的。如果在数值字段中存储邮政编码01234，则保存的将是数值1234，实际上丢失了一位数字。需要遵守的基本规则是：如果数值时计算（求和、平均等）中使用的数值，则应该存储在数值数据类型列中。如果作为字符串（可能只包含数字）使用，则应该保存在串数据类型列中。</p><h2 id="2、数值数据类型"><a href="#2、数值数据类型" class="headerlink" title="2、数值数据类型"></a>2、数值数据类型</h2><p>　数值数据类型存储数值。MySQL支持多种数值数据类型，每种存储的数值具有不同的取值范围。<br>　<em>（注：有符号或无符号：所有数值数据类型（除BIT和BOOLEAN外）都可以有符号或无符号。有符号数值列可以存储正或负的数值，无符号数值列只能存储正数。默认情况为有符号，但如果你知道自己不需要存储负值，可以使用UNSIGNED关键字，这样做将允许你存倍大小的值。）</em><br><strong>数值数据类型</strong></p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>BOOLEAN(或BOOL)</td><td>布尔标志，或者为0或者为1，主要用于开/关(on/off)标志</td></tr><tr><td>TINYINT</td><td>整数值，1个字节，支持-128~127（如果为UNSIGNED，为0~255）的数</td></tr><tr><td>SMALLINT</td><td>整数值，2个字节，支持-32768-32767（如果是UNSIGNED，为0-65535）的数</td></tr><tr><td>MEDIUMINT</td><td>整数值，3个字节，支持-8388608~8388607（如果是UNSIGNED，为0~16777215）的数</td></tr><tr><td>INT(或INTEGER)</td><td>整数值，4个字节，支持-2147483648~2147483647</td></tr><tr><td>BIGINT</td><td>整数值，8个字节，支持+-9.22*10的18次方</td></tr><tr><td>FLOAT</td><td>单精度浮点值，8位精度（4字节）</td></tr><tr><td>DOUBLE</td><td>双精度浮点值，16位精度（8字节）</td></tr><tr><td>DECIMAL(或DEC)</td><td>精度可变的浮点值</td></tr><tr><td>REAL</td><td>4字节的浮点值</td></tr><tr><td>BIT</td><td>位字段，1~64位。（在MySQL5之前，BIT功能等价于TINYINT）</td></tr></tbody></table><p><em>（注：与串不一样，数值不应该括在引号内。）</em></p><h2 id="3、日期和时间数据类型"><a href="#3、日期和时间数据类型" class="headerlink" title="3、日期和时间数据类型"></a>3、日期和时间数据类型</h2><p>　MySQL使用专门的数据类型来存储日期和时间值。<br><strong>日期和时间数据类型</strong></p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>DATE</td><td>表示1000-01-01~9999-12-31的日期，格式为YYYY-MM-DD</td></tr><tr><td>TIME</td><td>格式为HH:MM:SS</td></tr><tr><td>DATETIME</td><td>DATE和TIME的组合</td></tr><tr><td>TIMESTAMP</td><td>功能和DATETIME相同（但范围较小）</td></tr><tr><td>YEAR</td><td>用2位数字表示，范围是70(1970年)~69(2069年)，用4位数字表示，范围是1901年~2155年  </td></tr></tbody></table><h2 id="4、二进制数据类型"><a href="#4、二进制数据类型" class="headerlink" title="4、二进制数据类型"></a>4、二进制数据类型</h2><p>　二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等。<br><strong>二进制数据类型</strong></p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>BLOB</td><td>Blob最大长度为64KB</td></tr><tr><td>MEDIUMBLOB</td><td>Blob最大长度为16MB</td></tr><tr><td>LONGBLOB</td><td>Blob最大长度为4GB</td></tr><tr><td>TINYBLOB</td><td>Blob最大长度为255字节</td></tr></tbody></table><p><strong>注：数据类型的属性</strong></p><table><thead><tr><th>MySQL关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许包含NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET name</td><td>指定一个字符集</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据类型是定义列中可以存储什么数据以及该数据实际怎样存储的基本规则。&lt;br&gt;数据类型用于以下目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据类型允许限制可存储在列中的数据。例如，数值数据类型列只能接受数值。&lt;/li&gt;
&lt;li&gt;数据类型允许在内部更有效地存储数据。 可以用一种比文本串更简洁的格式存储数值和日期时间值。&lt;/li&gt;
&lt;li&gt;数据类型允许变换排序顺序。如果所有数据都作为串处理，则1位于10之前，而10又位于2之前（串以字典顺序排序，从左边开始比较，一次一个字符）。作为数值数据类型，数值才能正确排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在设计表时，应该特别重视所用的数据类型。使用错误的数据类型可能会严重地影响应用程序的功能和性能。更改包含数据的列不是一件小事（而且这样做可能会导致数据丢失）。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《MySQL必知必会》-高级知识</title>
    <link href="http://yoursite.com/2017/12/07/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B-%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2017/12/07/《MySQL必知必会》-高级知识/</id>
    <published>2017-12-07T05:09:00.000Z</published>
    <updated>2017-12-08T06:50:24.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二十二、使用视图"><a href="#二十二、使用视图" class="headerlink" title="二十二、使用视图"></a>二十二、使用视图</h2><p>1、视图是什么？<br><em>（注：MySQL 5添加了对视图的支持，因此，使用视图需要版本在MySQL 5及以后的版本。）</em><br>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。<br>例如：<br>　　<code>SELECT cust_name,cust_contact FROM customers,orders,orderitems WHERE customers.cust_id = orders.cust_id AND orderitems.order_num = oders.order_num AND prod_id = &#39;TNT2&#39;;</code><br>此查询用来检索订购了某个特定产品的用户。<br>假如可以把整个查询包装成一个名为productcustomers的虚拟表，则可以如下轻松地检索出相同的数据：<br>　　<code>SELECT cust_name,cust_contact FROM productcustomers WERE prod_id = &#39;TNT2&#39;;</code><br>这就是视图的作用。productcustomers是一个试图，作为视图，它不包含表中应该有的任何列或数据，它包含的是一个SQL查询（与上面用以正确联结表的相同的查询）。<br><a id="more"></a><br>1.2、为什么使用视图？<br>下面是视图的一些常见应用：</p><pre><code>1. 重用SQL语句2. 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。3. 使用表的组成部分而不是整个表。4. 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。5. 更改数据格式和标识。视图可返回与底层表的表示和格式不同的数据。</code></pre><p>　　在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据（添加和更新数据存在某些限制。）。<br>　　需要知道的是：视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。<br><em>（性能问题：因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。）</em></p><p>1.3、视图的规则和限制<br>下面是关于视图创建和使用的一些最常见的规则和限制：</p><pre><code>1. 与表一样，视图必须唯一命名（不能给视图取与别的视图或者表相同的名字）。2. 对于可以创建的视图数目没有限制。3. 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。4. 视图可以嵌套，既可以利用从其它视图中检索数据的查询来构造一个试图。5. ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。6. 视图不能索引，也不能有关联的触发器或默认值。7. 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。</code></pre><p>2、视图是怎样工作的？<br>　2.1视图的创建：</p><pre><code>1. 视图用CREATE VIEW语句来创建。2. 使用SHOW CREATE VIEW viewname;来查看创建视图的语句。3. 用DROP删除视图，其语法为DROP VIEW viewname;。4. 更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。</code></pre><p>　如果要更新的视图不存在，则第2条更新语句会创建一个试图；如果更新的视图存在，则第2条更新语句会替换原有视图。<br>　2.2 常用的视图应用</p><pre><code>1. 隐藏复杂的SQL，这通常都会涉及联结。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW productcustomers AS </span><br><span class="line">SELECT cust_name,cust_contact,prod_id </span><br><span class="line">FROM customers,orders,orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id </span><br><span class="line">  AND orderitems.order_num = orders.order_num;</span><br></pre></td></tr></table></figure>这条语句创建一个名为productcustomers的视图，联结了3个表，以返回已订购了任意产品的所有客户的列表。为检索订购了产品的TNT2的客户，可如下进行：　`SELECT cust_name,cust_contact FROM productcustomers WHERE prod_id=&apos;TNT2&apos;;`（注：创建可重用的视图：创建不受特定数据限制的视图是一种好办法。）2. 用视图重新格式化检索出的数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(RTrim(vend_name), &apos;(&apos;, RTrim(vend_country), &apos;)&apos;) </span><br><span class="line">       AS vend_title </span><br><span class="line">FROM vendors ORDER BY vend_name;</span><br></pre></td></tr></table></figure>假如经常需要这个格式的结果，可创建一个试图，每次需要时使用它。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW vendorlocations AS</span><br><span class="line">SELECT Concat(RTrim(vend_name), &apos;(&apos;, RTrim(vend_country), &apos;)&apos;)</span><br><span class="line">       AS vend_title</span><br><span class="line">FROM vendors ORDER BY vend_name;</span><br></pre></td></tr></table></figure>3. 用视图过滤不想要的数据视图对于应用普通的WHERE子句也很有用。例如，可以定义customeremaillist视图，它过滤没有电子邮件地址的客户。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW customeremaillist </span><br><span class="line">SELECT cust_id,cust_name,cust_email FROM customers </span><br><span class="line">WHERE cust_email IS NOT NULL;</span><br></pre></td></tr></table></figure>（注：WHERE子句与WHERE子句：如果从视图检索数据时使用了一条WHERE子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。）4. 使用视图与计算字段视图对于简化计算字段的使用特别有用。下面是它检索某个特定订单中的物品，计算每种物品的总价格：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW orderitemsexpanded AS </span><br><span class="line">SELECT order_num,prod_id,quantity,item_price,</span><br><span class="line">       quantity*item_price AS expanded_price </span><br><span class="line">FROM orderitems;</span><br></pre></td></tr></table></figure>为检索订单20005的详细内容可如下操作：`SELECT * FROM orderitemsexpanded WHERE order_num = 20005;`</code></pre><p>　2.3 更新视图<br>　通常，视图是可更新的（即可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。<br>　但是，并非所有视图都是可更新的。基本上如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p><pre><code>1. 分组（使用GROUP BY和HAVING）2. 联结3. 子查询4. 并5. 聚集涵涵素（Min()、Count()、Sum()等）6. DISTINCT7. 导出（计算）列。因此，一般应该将视图用于检索（SELECT语句）而不用于更新（INSERT、UPDATE和DELETE）。</code></pre><h2 id="二十三、使用存储过程"><a href="#二十三、使用存储过程" class="headerlink" title="二十三、使用存储过程"></a>二十三、使用存储过程</h2><p>1、什么是存储过程？<br><em>（注：MySQL 5添加了对存储过程的支持，因此需要MySQL 5及以后的版本。）</em><br>　迄今为止，使用的大多数SQL语句都是针对一个或多个表的单条语句。并非所有操作都这么简单，经常会有一个完整的操作需要多条语句才能完成。例如下面的情形：</p><pre><code>1. 为了处理订单，需要核对以保证库存中有相应的物品。2. 如果库存有物品，这些物品需要预定以便不将它们再卖给别人，并且要减少可用的物品数量以反映正确的库存量。3. 库存中没有的物品需要订购，这需要与供应商进行某种交互。4. 关于哪些物品入库（并且可以立即发货）和哪些物品退订，需要通知相应的客户。</code></pre><p>　这显然不是一个完整的例子，执行这个处理需要针对许多表的多条MySQL语句。此外，需要执行的具体语句及其次序也不是固定的，它们可能会（和将）根据哪些物品在库存中哪些不在而变化。<br>　可以创建存储过程。存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。</p><p>2、为什么要使用存储过程？<br>　下面列出一些主要的理由：</p><pre><code>1. 通过把处理封装在容易使用的单元中，简化复杂的操作。2. 由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的。    这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。3. 简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。    这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。4. 提高性能。因为使用存储过程比使用单独的SQL语句更快。5. 存在一些只能用在单个请求中的MySQL元素和特性，存储过程以使用它们来编写功能更强更灵活的代码。</code></pre><p>　换句话说，使用存储过程有3个主要的好处，即简单、安全、高性能。<br>　不过，在将SQL代码转换为存储过程前，也必须知道它的一些缺陷：</p><pre><code>1. 一般来说，存储过程的编写比基本的SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验2. 你可能没有创建存储过程的安全访问权限。许多数据库管理员限制存储过程的创建权限，允许用户使用存储过程，但不允许他们创建存储过程。</code></pre><p>3、如何使用存储过程？<br>　存储过程的执行远比其定义更经常遇到，因此，我们将从执行存储过程开始介绍。然后再介绍创建和使用存储过程。<br>　3.1 执行存储过程<br>　MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL。CALL接受存储过程的名字以及需要传递给它的任意参数。<br>　例如：<br>    <figure class="highlight plain"><figcaption><span>productpricing(@pricelow,</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@pricehigh,</span><br><span class="line">@priceaverage);</span><br></pre></td></tr></table></figure></p><p>　其中，执行名为productpricing的存储过程，它计算并返回产品的最低、最高和平均价格。<br>　3.2 创建存储过程<br>　例子：一个返回产品平均价格的存储过程：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT Avg(prod_price) AS priceaverage FROM products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p><p>　此存储过程名为productpricing，用CREATE PROCUDURE productpricing()语句定义。<br>　如果存储过程接受参数，它们将在()中列举出来。此存储过程没有参数，但后跟的()仍然需要。BEGIN和END语句用来限定存储过程体，过程体本身仅是一个简单的SELECT语句。<br>　在MySQL处理这段代码时，它创建一个新的存储过程productpricing。没有返回数据，因为这段代码并未调用存储过程，这里只是为以后使用而创建它。</p><p>　（注：mysql命令行客户机的分隔符，如果你使用的是mysql命令行实用程序，请往下看：默认的MySQL语句分隔符;（正如你已经在迄今为止所使用的MySQL语句中所看到的那样）。mysql命令行实用程序也使用;作为语句分隔符。如果命令行使用程序要解释存储过程自身内的;字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。解决办法是临时更改命令行使用程序的语句分隔符，如下所示：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">  SELECT Avg(prod_price) AS priceaverage FROM products;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></p><p>其中，<code>DELIMITER //</code> 告诉命令行实用程序使用//作为新的语句结束分隔符，可以看到标志存储过程结束的END定义为END//而不是END;。这样，存储过程体内的;仍然保持不动，并且正确地传递给数据库引擎。最后，为恢复为原来的语句分隔符，可使用DELIMITER ;。除\符号外，任何字符都可以用作语句分隔符。如果你使用的是mysql命令行实用程序，在阅读本章时请记住这里的内容。）</p><p>　3.3 使用存储过程<br>　　<code>CALL productpricing();</code><br>　执行刚创建的存储过程并显示返回的结果。因为存储过程实际上是一种函数，所以存储过程名后需要有()符号（即使不传递参数也需要）。</p><p>　3.4 删除存储过程<br>　　<code>DROP PROCEDURE productpricing;</code><br>　请注意没有使用后面的()，只给出存储过程名。<br>　<em>（注：如果指定的过程不存在，则DROP PROCEDURE将产生一个错误。当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROP PROCEDURE IF EXISTS。）</em></p><p>　3.4 使用参数<br>　以下是productpricing的修改版本(如果不先删除此存储过程，则不能再次创建它)：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE productpricing(</span><br><span class="line">    OUT pl DECIMAL(8, 2),</span><br><span class="line">    OUT ph DECIMAL(8, 2),</span><br><span class="line">    OUT pa DECIMAL(8, 2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT Min(prod_price) INTO pl FROM products;</span><br><span class="line">    SELECT Max(prod_price) INTO ph FROM products;</span><br><span class="line">    SELECT Avg(prod_price) INTO pa FROM products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p><p>　此存储过程接受3个参数：pl存储产品的最低价格，ph存储产品的最高价格，pa存储产品的平均价格。每个参数必须具有指定的类型，这里使用十进制值。<br>　关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。<br>　MySQL支持IN（传递给存储过程）、OUT（从存储过程传出）和INOUT（对存储过程传入和传出）类型的参数。<br>　<em>（注：存储过程的参数允许的数据类型与表中使用的数据类型相同。）</em><br>　调用此修改过的存储过程，必须指定3个变量名。<br>　　<code>CALL productpricing(@pricelow, @pricehigh, @priceaverage);</code><br>　<em>（注：所有MySQL变量都必须以@开始。）</em><br>　为了显示检索出的值，可以使用以下语句：<br>　　<code>SELECT @pricehigh, @pricelow, @priceaverage;</code></p><p>　3.5 建立智能存储过程<br>　只有在存储过程内包含业务规则和智能处理时，它们的威力才真正显现出来。<br>　考虑这个场景。你需要获得与以前一样的订单合计，但需要对合计增加营业税，不过只针对某些顾客。那么，你需要做下面几件事情：</p><pre><code>1. 获得合计（与以前一样）；2. 把营业税有条件地添加到合计；3. 返回合计（带或不带税）。</code></pre><p>　存储过程的完整工作如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-- Name: ordertotal</span><br><span class="line">-- Parameters: onumber = order number</span><br><span class="line">--             taxable = 0 if not taxable,1 if taxable</span><br><span class="line">--             ototal  = order total variable</span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">    IN onumber INT,</span><br><span class="line">    IN taxable BOOLEAN,</span><br><span class="line">    OUT ototal DECIMAL(8,2)</span><br><span class="line">) COMMENT &apos;Obtain order total, optionally adding tax&apos;</span><br><span class="line">BEGIN</span><br><span class="line">    -- Declare variable for total</span><br><span class="line">    DECLARE total DECIMAL(8,2);</span><br><span class="line">    -- Declare tax percentage</span><br><span class="line">    DECLARE taxrate INT DEFAULT 6;</span><br><span class="line"></span><br><span class="line">    -- Get the order total</span><br><span class="line">    SELECT Sum(item_price*quantity) FROM orderitems</span><br><span class="line">    WHERE order_num = onumber</span><br><span class="line">    INTO total;</span><br><span class="line"></span><br><span class="line">    -- Is this taxable?</span><br><span class="line">    IF taxable THEN</span><br><span class="line">        -- Yes, so add taxrate to the total</span><br><span class="line">        SELECT total+(total/100*taxrate) INTO total;</span><br><span class="line">    END IF;</span><br><span class="line">  </span><br><span class="line">    -- AND finally, save to out variable</span><br><span class="line">    SELECT total INTO ototal;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p><p>　此存储过程有很大的变动。首先，增加了注释（前面放置–）。添加了另外一个参数taxable，它是一个布尔值。在存储过程体中，用DECLARE语句定义了两个局部变量。DECLARE要求指定变量名和数据类型，它也支持可选的默认值（这个例子中的taxable的默认值被设置为6%）。SELECT语句已经改变，因此其结果存储到total（局部变量）而不ototal。IF语句检查taxable是否为真，如果为真，则用另一SELECT语句增加营业税到局部变量total。最后，用另一SELECT语句将total（它增加或许不增加营业税）保存到ototal。<br>　<em>（注：COMMENT关键字：它不是必需的，但如果给出，将在SHOW PROCEDURE STATUS的结果中显示。）</em><br>　<em>（注：IF语句：IF语句还支持ELSEIF和ELSE子句（前者还使用THEN子句，后者不使用）。）</em></p><p>　3.6 检查存储过程<br>　为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATE PROCEDURE语句：<br>　　<code>SHOW CREATE PROCEDURE ordertotal;</code><br>　为了获得包括何时、由谁创建等详细信息的存储过程列表，使用SHOW PROCUDURE STATUS语句：<br>　　<code>SHOW PROCEDURE STATUS LIKE &#39;ordertotal&#39;;</code><br>　<em>（注：SHOW PROCEDURE STATUS列出所有存储过程，为了限制其输出，可使用LIKE指定一个过滤模式。）</em></p><h2 id="二十四、使用游标"><a href="#二十四、使用游标" class="headerlink" title="二十四、使用游标"></a>二十四、使用游标</h2><p>1、什么是游标？<br><em>（注：MySQL 5添加了对游标的支持）</em><br>　使用简单的SELECT语句，没有办法得到第一行、下一行或前10行，也不存在每次一行地处理所有行的简单方法。有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。<br>　游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。<br>　游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。<br><em>（注：MySQL游标只能用于存储过程（和函数）。）</em></p><p>2、如何使用游标？<br>　2.1使用游标涉及几个明确的步骤：</p><pre><code>1. 在能够使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句。2. 一旦声明后，必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来。3. 对于填有数据的游标，根据需要取出（检索）各行。4. 在结束游标使用时，必须关闭游标。</code></pre><p>　2.2 创建游标<br>　游标用DECLARE语句创建。DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其它子句。<br>　例如：下面语句定义了名为ordernumbers的游标：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE ordernumbers CURSOR</span><br><span class="line">    FOR</span><br><span class="line">    SELECT order_num FROM orders;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p><p>　2.3 打开和关闭游标<br>　在定义游标之后，可以打开它。<br>　游标用OPEN CURSOR语句来打开：<br>　　<code>OPEN ordernumbers;</code><br>　游标处理完成后，应当使用如下语句关闭游标：<br>　　<code>CLOSE ordernumbers;</code><br>　在一个游标关闭后，如果没有重新打开，则不能使用它。但是，使用声明过的游标不需要再次声明，用OPEN语句打开它就可以了。<br>　2.4 使用游标数据<br>　在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）。<br>　下面给出游标存储过程对取出的数据进行某种实际的处理：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">    -- Declare local variables</span><br><span class="line">    DECLARE done BOOLEAN DEFAULT 0;</span><br><span class="line">    DECLARE o INT;</span><br><span class="line">    DECLARE t DECIMAL(8,2);</span><br><span class="line"></span><br><span class="line">    -- Declare the cursor</span><br><span class="line">    DECLARE ordernumbers CURSOR </span><br><span class="line">    FOR</span><br><span class="line">    SELECT order_num FROM orders;</span><br><span class="line">    </span><br><span class="line">    -- Declare continue handler</span><br><span class="line">    DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done=1;</span><br><span class="line"></span><br><span class="line">    -- Create a table to store the results</span><br><span class="line">    CREATE TABLE IF NOT EXISTS ordertotals</span><br><span class="line">        (order_num INT, total DECIMAL(8,2));</span><br><span class="line"></span><br><span class="line">    -- Open the cursor</span><br><span class="line">    OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line">    -- Loop through all rows</span><br><span class="line">    REPEAT</span><br><span class="line">      </span><br><span class="line">        -- Get order number</span><br><span class="line">        FETCH ordernumbers INTO o;</span><br><span class="line">        -- Get the total for this order</span><br><span class="line">        CALL ordertotal(o, 1, t);</span><br><span class="line">        -- Insert order and total into ordertotals</span><br><span class="line">        INSERT INTO ordertotals(order_num, total) VALUES(o, t);</span><br><span class="line">    -- End of loop</span><br><span class="line">    UNTIL done END REPEAT;</span><br><span class="line"> </span><br><span class="line">    -- Close the cursor</span><br><span class="line">    CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p><p>　此例子中，FETCH是在REPEAT内，因此它反复执行直到done为真（由UNTIL done END REPEAT;规定）。为使它起作用，用一个DEFAULT 0(假，不结束)定义变量done。<br>　而done是通过以下语句设置结束条件：<br>　　<code>DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;02000&#39; SET done=1;</code><br>　这条语句定义了一个CONTINUE HANDLER，它是在条件出现时被执行的代码。这里，它指出当SQLSTATE ‘02000’出现时，SET done=1。SQLSTATE ‘02000’是一个未找到条件，当REPEAT由于没有更多的行供循环而不能继续时，出现这个条件。<br>　<em>（注：DECLARE语句的次序：用DECLARE语句定义的局部变量必须在定义任意游标或句柄之前定义，而句柄必须在游标之后定义。不遵守此顺序将产生错误信息。）</em><br>　<em>（注：重复或循环：除这里使用的REPEAT语句外，MySQL还支持循环语句，它可用来重复执行代码，直到使用LEAVE语句手动退出位置。通常REPEAT语句的语法使它更适合于对游标进行循环。）</em></p><h2 id="二十五、触发器"><a href="#二十五、触发器" class="headerlink" title="二十五、触发器"></a>二十五、触发器</h2><p><em>（注：MySQL 5增加了对触发器的支持。）</em><br>1、什么是触发器？<br>　MySQL语句在需要时被执行，存储过程也是如此。但是，如果你想要某条语句（或某些语句）在事件发生时自动执行。例如：</p><pre><code>1. 每当增加一个顾客到某个数据表时，都检查其电话号码格式是否正确等；2. 每当订购一个产品时，都从库存数量中减去订购的数量；3. 无论何时删除一行，都在某个存档表中保留一个副本。</code></pre><p>　所有这些例子的共同之处是它们都需要在某个表发生更改时自动处理。这确切地说就是触发器。触发器是MySQL相应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：<br>　　<code>DELETE、INSERT、UPDATE</code><br>　其它MySQL语句不支持触发器。</p><p>2、为什么要使用触发器？<br>　2.1 创建触发器<br>　在创建触发器时，需要给出4条信息：</p><pre><code>1. 唯一的触发器名；（保持每个数据库的触发器名唯一）2. 触发器关联的表；3. 触发器应该响应的活动（DELETE、INSERT或UPDATE）；4. 触发器何时执行（处理之前或之后）。</code></pre><p>　触发器用CREATE TRIGGER语句创建。下面是一个例子：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT &apos;Product added&apos;;</span><br></pre></td></tr></table></figure></p><p>　在这个例子中，文本Product added将对每个插入的行显示一次。<br>　<em>（注：只有表才支持触发器，视图不支持（临时表也不支持）。）</em><br>　触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条INSERT、UPDATE和DELETE的之前和之后）。单一触发器不能与多个时间或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。<br>　<em>（注：如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）。）</em><br>　2.2 删除触发器<br>　使用 DROP TRIGGER语句，如下所示：<br>　　<code>DROP TRIGGER newproduct;</code><br>　触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。</p><p>3、如何使用触发器？<br>　查看已有触发器： <code>show triggers;</code><br>　3.1 INSERT触发器<br>　INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点：</p><pre><code>1. 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；2. 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）；3. 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。</code></pre><p>　示例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER neworder AFTER INSERT ON orders</span><br><span class="line">FOR EACH ROW SELECT NEW.order_num;</span><br></pre></td></tr></table></figure></p><p>　此代码创建一个名为neworder的触发器，它按照AFTER INSERT ON orders执行。在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。触发器从NEW.order_num取得这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。<br>　<em>（注：通常，将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）。本提示也适用于UPDATE触发器。）</em><br>　3.2 DELETE触发器<br>　DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两点：</p><pre><code>1. 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；2. OLD中的值全都是只读的，不能更新。</code></pre><p>　示例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    INSERT INTO archive_orders(order_num, order_date, cust_id) </span><br><span class="line">    VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p><p>　在任意订单被删除前将执行此触发器。它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中。<br>　使用BEFORE DELETE触发器的优点（相对于AFTER DELETE触发器来说）为，如果由于某种原因，订单不能存档，DELETE本身将被放弃。<br>　<em>（注：多语句触发器。触发器deleteorder使用BEGIN和END语句标记触发器体。使用BEGIN END块的好处是触发器能容纳多条SQL语句。）</em><br>　3.3 UPDATE触发器<br>　UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：</p><pre><code>1. 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值。2. 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；3. OLD中的值全都是只读的，不能更新。</code></pre><p>　下面的例子保证州名缩写总是大写（不管UPDATE语句中给出的是大写还是小写）：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors</span><br><span class="line">FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state);</span><br></pre></td></tr></table></figure></p><p>　显然，任何数据净化都需要在UPDATE语句之前进行，就像这个例子中一样。每次更新一个行时，NEW.vend_state中的值（将用来更新表行的值）都用Upper(NEW.vend_state)替换。<br>4、关于触发器的进一步介绍<br>　再介绍一些使用触发器时需要记住的重点：</p><pre><code>1. 与其他DBMS相比，MySQL 5中支持的触发器相当初级。未来会有一些改进和增强触发器支持的计划。2. 创建触发器可能需要特殊的安全访问权限，但是，触发器的执行时自动的。如果INSERT、UPDATE、DELETE语句能够执行，则相关的触发器也能执行。3. 应该用触发器来保证数据的一致性（大小写、格式等）。在触发器中执行这种类型的处理优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。4. 触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易。5. 遗憾的是，MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。</code></pre><h2 id="二十六、管理事务处理"><a href="#二十六、管理事务处理" class="headerlink" title="二十六、管理事务处理"></a>二十六、管理事务处理</h2><p>（MyISAM和InnoDB是两种常用的引擎，前者不支持事务处理，而后者支持。）<br>1、什么是事务处理<br>　事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。<br>　下面是关于事务处理需要知道的几个术语：</p><pre><code>1. 事务（transaction）指一组SQL语句；2. 回退（rollback）指撤销指定SQL语句的过程；3. 提交（commit）指将未存储的SQL语句结果写入数据库表；4. 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</code></pre><p>2、如何利用COMMIT和ROLLBACK语句来管理事务处理</p><h2 id="二十七、全球化和本地化"><a href="#二十七、全球化和本地化" class="headerlink" title="二十七、全球化和本地化"></a>二十七、全球化和本地化</h2><p>1、字符集和校对顺序<br>　数据库表被用来存储和检索数据。不同的语言和字符集需要以不同的方式存储和检索。<br>　重要术语：</p><pre><code>1. 字符集 为字母和符号的集合；2. 编码 为某个字符集成员的内部表示；3. 校对 为规定字符如何比较的指令。</code></pre><p>　<em>（注：校对为什么重要。考虑词APE、apex和Apple。它们处于正确的排序顺序吗？这有赖于你是否想区分大小写。使用区分大小写的校对顺序，这些词有一种排序方式，使用不区分大小写的校对顺序有另外一种排序方式。这不仅影响（如用ORDER BY排序数据），还影响搜索（例如，寻找apple的WHERE子句是否能够找到APPLE）。）</em><br>2、使用字符集和校对顺序<br>　MySQL支持众多的字符集。<br>　为查看所有支持的字符集完整列表，使用以下语句：<br>　　<code>SHOW CHARACTER SET;</code><br>　这条语句显示所有可用的字符集以及每个字符集的描述和默认校对。<br>　为了查看所支持校对的完整列表，使用以下语句：<br>　　<code>SHOW COLLATION;</code><br>　此语句显示所有可用的校对，以及它们适用的字符集。可以看到有的字符集具有不止一种校对。<br>　通常系统管理在安装时定义一个默认的字符集和校对。此外，也可以在创建数据库时，指定默认的字符集和校对。为了确定所用的字符集和校对，可以使用以下语句：<br>　　<code>SHOW VARIABLES LIKE &#39;character%&#39;;</code><br>　　<code>SHOW VARIABLES LIKE &#39;collation%&#39;;</code><br>　实际上，字符集很少是服务器范围（甚至数据库范围）的设置。不同的表，甚至不同的列都可能需要不同的字符集，而且两者都可以创建表时指定。<br>　一般，MySQL如下确定使用什么样的字符集和校对：</p><pre><code>1. 如果指定CHARACTER SET和COLLATE两者，则使用这些值。2. 如果只指定CHARACTER SET，则使用此字符集及其默认的校对（如SHOW CHARACTER SET的结果中所示）。3. 如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库默认。</code></pre><p>　最后，值得注意的是，如果绝对需要，串可以在字符集之间进行转换。为此，使用Cast()或Convert()函数。</p><h2 id="二十八、安全管理"><a href="#二十八、安全管理" class="headerlink" title="二十八、安全管理"></a>二十八、安全管理</h2><p>1、访问控制<br>　MySQL服务器的安全基础是：用户应该对他们需要的数据具有适当的访问权，既不能多也不要能少。换句话说，用户不能对过多的数据具有过多的访问权。<br>　考虑以下内容：</p><pre><code>1. 多数用户只需要对表进行读和写，但少数用户甚至需要能创建和删除表。2. 某些用户需要读表，但可能不需要更新表；3. 你可能想允许用户添加数据，但不允许它们删除数据；4. 某些用户（管理员）可能需要处理用户账号的权限，但多数用户不需要；5. 你可能想让用户通过存储过程访问数据，但不允许他们直接访问数据；6. 你可能想根据用户登录的地点限制对某些功能的访问。</code></pre><p>2、管理用户<br>　MySQL用户账号和信息存储在名为mysql的MySQL数据库中。一般不需要直接访问mysql数据库和表，但有时需要直接访问。需要直接访问它的时机之一是需要获得所有用户的账号列表时。<br>　mysql数据库有一个名为user的表，它包含所有用户账号。<br>　2.1 创建用户账号<br>　使用CREATE USER语句：<br>　　<code>CREATE USER ben IDENTIFIED BY &#39;p@$$wOrd&#39;;</code><br>　2.2 重新命名一个用户账号<br>　使用RENAME USER语句：<br>　　<code>RENAME USER ben TO bforta;</code><br>　<em>（注：仅MySQL5或之后的版本支持 RENAME USER，为了在以前的MySQL中重命名一个用户，可使用UPDATE直接更新user表。）</em><br>　2.3 删除用户账号<br>　使用DROP USER语句：<br>　　<code>DROP USER bforta;</code><br>　<em>（注：自MySQL5以来，DROP USER删除用户账号和所有相关的账号权限。在MySQL5之前，DROP USER只能用来删除用户账号，不能删除相关账号权限。因此，如果使用旧版本的MySQL，需要先用REVOKE删除和账号相关的权限，然后再用DROP USER删除账号。）</em><br>　2.4 设置访问权限</p><pre><code>1. 查看赋予用户账号的权限，使用SHOW GRANTS FOR语句，如下： `SHOW GRANTS FOR bforta;`2. 设置权限，使用GRANT语句。GRANT要求至少给出以下信息： （1）要授予的权限； （2）被授予访问权限的数据库或表； （3）用户名。如下例子给出GRANT的用法： `GRANT SELECT ON crashcourse.* TO bforta;`此GRANT允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT。通过只授予SELECT访问权限，用户bforta对crashcourse数据库中的所有数据具有只读访问权限。3. GRANT的反操作为REVOKE，用它来撤销特定的权限。举个例子： `REVOKE SELECT ON crashcourse.* FROM bforta;`这条REVOKE语句取消刚赋予用户bforta的SELECT访问权限。被撤销的访问权限必须存在，否则会出错。GRANT和REVOKE可在几个层次上控制访问权限： （1）整个服务器，使用GRANT ALL和REVOKE ALL; （2）整个数据库，使用ON database.*; （3）特定的表，使用ON database.table; （4）特定的列； （5）特定的存储过程。可以授予或撤销的每个权限： 权限            |   说明 ----------------|------------------------------ ALL             |   除GRANT OPTION外的所有权限 SELECT          |   使用SELECT INSERT          |   使用INSERT UPDATE          |   使用UPDATE DELETE          |   使用DELETE CREATE          |   使用CREATE TABLE DROP            |   使用DROP TABLE GRANT OPTION    |   使用GRANT和REVOKE ALTER           |   使用ALTER TABLE ALTER ROUTINE   |   使用ALTER PROCEDURE和DROP PROCEDURE CREATE ROUTINE  |   使用CREATE PROCEDURE CREATE TEMPORARY TABLES |  使用CREATE TEMPORARY TABLE CREATE USER     |   使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGES CREATE VIEW     |   使用CREATE VIEW INDEX           |   使用CREATE INDEX和DROP INDEX LOCK TABLES     |   使用LOCK TABLES EXECUTE         |   使用CALL和存储过程 FILE            |   使用SELECT INTO OUTFILE和LOAD DATA INFILE PROCESS         |   使用SHOW FULL PROCESSLIST RELOAD          |   使用FLUSH REPLICATION CLIENT | 服务器位置的访问 REPLICATION SLAVE  | 由复制从属使用 SHOW DATABASES  |   使用SHOW DATABASES SHOW VIEW       |   使用SHOW CREATE VIEW SHUTDOWN        |   使用mysqladmin shutdown(用来关闭MySQL) SUPER           |   使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER和SET GLOBAL。还允许mysqladmin调试登录 USAGE           |   无访问权限使用GRANT和REVOKE，在结合列出的权限，你能对用户可以就你的宝贵数据做什么事情和不能做什么事情具有完全的控制。（注：多个权限用逗号分隔）</code></pre><p><em>（注：未来授权：在使用GRANT和REVOKE时，用户账号必须存在，但对所涉及的对象没有这个要求。这允许管理员在创建数据库和表之前设计和实现安全措施。 这样做的副作用是，当某个数据库或表删除时（用DROP语句），相关的访问权限仍然存在。而且，如果将来重新创建该数据库或表，这些权限仍然起作用。）</em></p><h2 id="二十九、数据库维护"><a href="#二十九、数据库维护" class="headerlink" title="二十九、数据库维护"></a>二十九、数据库维护</h2><p>MySQL主要的日志文件有以下几种：</p><pre><code>1. 错误日志。它包含启动和关闭问题以及任意关键错误的细节。此日志通常名为hostname.err，位于data目录中。此日志名可用--log-error命令行选项更改。2. 查询日志。它记录所有MySQL活动，在诊断问题时非常有用。此日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为hostname.log，位于data目录中。此名字可以用--log命令行选项更改。3. 二进制日志。它记录更新过数据（或者可能更新过数据）的所有语句。此日志通常名为hostname-bin，位于data目录内。此名字可以用--log-bin命令行选项更改。注意，这个日志文件是MySQL5中添加的，以前的MySQL版本中使用的是更新日志。4. 缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询。这个日志在确定数据库何处需要优化很有用。此日志通常名为hostname-slow.log，位于data目录中。此名字可以用--log-slow-queries命令行选项更改。</code></pre><p>　在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。</p><h2 id="三十、改善新能"><a href="#三十、改善新能" class="headerlink" title="三十、改善新能"></a>三十、改善新能</h2><p>下面是一些性能优化的技巧：</p><pre><code>1. 一般来说，使用存储过程比一条一条地执行其中的各条MySQL语句快；2. 使用正确的数据类型；3. 绝不要检索比需求还要多的数据。换言之，不要用SELECT *（除非你真正需要每个列）。4. 必须索引数据库表以改善数据检索的性能；但注意，索引改善数据检索的性能，但损害数据插入、删除和更新的性能；5. 使用多条SELECT语句和连接它们的UNION语句，能够获得极大的性能改进；6. LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE；7. 最重要的规则就是，每条规则在某些条件下都会被打破。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二十二、使用视图&quot;&gt;&lt;a href=&quot;#二十二、使用视图&quot; class=&quot;headerlink&quot; title=&quot;二十二、使用视图&quot;&gt;&lt;/a&gt;二十二、使用视图&lt;/h2&gt;&lt;p&gt;1、视图是什么？&lt;br&gt;&lt;em&gt;（注：MySQL 5添加了对视图的支持，因此，使用视图需要版本在MySQL 5及以后的版本。）&lt;/em&gt;&lt;br&gt;视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。&lt;br&gt;例如：&lt;br&gt;　　&lt;code&gt;SELECT cust_name,cust_contact FROM customers,orders,orderitems WHERE customers.cust_id = orders.cust_id AND orderitems.order_num = oders.order_num AND prod_id = &amp;#39;TNT2&amp;#39;;&lt;/code&gt;&lt;br&gt;此查询用来检索订购了某个特定产品的用户。&lt;br&gt;假如可以把整个查询包装成一个名为productcustomers的虚拟表，则可以如下轻松地检索出相同的数据：&lt;br&gt;　　&lt;code&gt;SELECT cust_name,cust_contact FROM productcustomers WERE prod_id = &amp;#39;TNT2&amp;#39;;&lt;/code&gt;&lt;br&gt;这就是视图的作用。productcustomers是一个试图，作为视图，它不包含表中应该有的任何列或数据，它包含的是一个SQL查询（与上面用以正确联结表的相同的查询）。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>《MySQL必知必会》-基础知识</title>
    <link href="http://yoursite.com/2017/12/07/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2017/12/07/《MySQL必知必会》-基础知识/</id>
    <published>2017-12-07T02:57:12.000Z</published>
    <updated>2017-12-08T06:50:35.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据库基础"><a href="#一、数据库基础" class="headerlink" title="一、数据库基础"></a>一、数据库基础</h2><p>1、数据库：<br>数据库（database）保存有组织的数据的容器（通常是一个文件或一组文件）。<br>数据库软件应称为DBMS（数据库管理系统）。数据库是通过DBMS创建和操纵的容器。你使用的是DBMS，它替你访问数据库。</p><p>2、表：<br>表（table）某种特定类型数据的结构化清单。<br><em>（注：表名：在不同的数据库中可以使用相同的表名。但是在同一数据库却不能使用相同的表名。 表名 = 数据库_表名）</em><br><a id="more"></a><br>3、列和数据类型：<br>列（column）表中的一个字段。所有的表都是由一个或多个字段构成的。<br>数据类型（datatype）所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。</p><p>4、行：<br>行（row）表中的一个记录（record）。</p><p>5、主键：<br>主键（primary key）一列（或一组列），其值能够唯一区分表中每个行。<br><em>（注：主键列不允许NULL值。 还有一种非常重要的键，称为外键。）</em></p><p>6、什么是SQL<br>SQL是结构化查询语言（Structured Query Language)的缩写。SQL是一种专门用来与数据库通信的语言。</p><h2 id="二、MySQL简介"><a href="#二、MySQL简介" class="headerlink" title="二、MySQL简介"></a>二、MySQL简介</h2><p>MySQL是一种DBMS，即它是一种数据库软件。<br>学习MySQL最好使用专门用途的实用程序，特别有3个工具需要提及：</p><ol><li>mysql命令行实用程序</li><li>MySQL Administrator（MySQL管理器）是一个图形交互客户机，用来简化MySQL服务器的管理。</li><li>MySQL Query Browser为一个图形交互客户机，用来编写和执行MySQL命令。</li></ol><h2 id="三、使用MySQL"><a href="#三、使用MySQL" class="headerlink" title="三、使用MySQL"></a>三、使用MySQL</h2><p>mysql命令行命令：<br>  <code>USE database;</code>  #选择使用数据库<br>  <code>SHOW DATABASES;</code> #显示可用数据库的一个列表<br>  <code>SHOW TABLES;</code> #返回当前数据库内可用表的列表<br>  <code>SHOW STATUS;</code> #用于显示广泛的服务器状态信息<br>  <code>SHOW CREATE DATABASE和SHOWCREATE TABLES name</code>  #显示创建特定数据库或表的MySQL语句<br>  <code>SHOW GRANTS</code>  #用来显示授予用户（所有用户或特定用户）的安全权限<br>  <code>SHOW ERRORS和SHOWWARNINGS</code>  #用来显示服务器错误或警告信息</p><h2 id="四、检索数据"><a href="#四、检索数据" class="headerlink" title="四、检索数据"></a>四、检索数据</h2><p>关键字：<br>    SELECT、DISTINCT、LIMIT</p><h2 id="五、排序检索数据"><a href="#五、排序检索数据" class="headerlink" title="五、排序检索数据"></a>五、排序检索数据</h2><p>子句（clause）SQL语句由子句构成，有些子句是必须的，而有的是可选的。一个子句通常由一个关键字和所提供的数据组成。子句的例子有SELECT语句的FROM子句。<br>排序子句：ORDER BY</p><h2 id="六、过滤数据"><a href="#六、过滤数据" class="headerlink" title="六、过滤数据"></a>六、过滤数据</h2><p>过滤子句：WHERE<br><em>（注：在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后）</em><br>WHERE子句操作符：<br>    >、&lt;、&gt;=、&lt;=、=、!=、&lt;&gt;、BETWEEN(必须用AND关键字分割)</p><h2 id="七、数据过滤"><a href="#七、数据过滤" class="headerlink" title="七、数据过滤"></a>七、数据过滤</h2><p>操作符（operator）用来联结或改变WHERE子句中的子句的关键字。也称为逻辑操作符（logical operator)。<br>操作符：AND、OR、IN、NOT<br><em>（注：SQL在处理OR操作符之前，优先处理AND操作符。如果需要加括号）</em><br><em>（注：IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。）</em><br><em>（注：MySQL支持使用NOT对IN、BETWEEN和EXISTS子句取反）</em></p><h2 id="八、用通配符进行过滤"><a href="#八、用通配符进行过滤" class="headerlink" title="八、用通配符进行过滤"></a>八、用通配符进行过滤</h2><p>通配符（wildcard）用来匹配值的一部分的特殊字符。<br><em>（在搜索子句中使用通配符，必须使用LIKE操作符。）</em><br>通配符：</p><ol><li>百分号（%）通配符：表示任何字符出现任意次数。<br><em>（注：尾空格可能会干扰通配符匹配。办法是去掉首尾空格。）</em></li><li>下划线（_）通配符：用途与%一样，但下划线只匹配单个字符而不是多个字符。</li></ol><h2 id="九、正则表达式"><a href="#九、正则表达式" class="headerlink" title="九、正则表达式"></a>九、正则表达式</h2><p>REGEXP 与 LIKE 使用类似</p><h2 id="十、创建计算字段"><a href="#十、创建计算字段" class="headerlink" title="十、创建计算字段"></a>十、创建计算字段</h2><p>字段拼接函数：Concat()<br>空格删除函数：RTrim()、LTrim()、Trim()<br>关键字：AS （别名用AS赋予）<br>MySQL算数操作符：+、-、*、/</p><h2 id="十一、使用数据处理函数"><a href="#十一、使用数据处理函数" class="headerlink" title="十一、使用数据处理函数"></a>十一、使用数据处理函数</h2><p><em>（注：函数的可移植性不强。因此决定使用函数，应该保证做好代码的注释，以便以后能确切地知道所编写SQL代码的含义。）</em><br><strong>文本处理函数：</strong></p><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>Upper()</td><td>将文本转换为大写</td></tr><tr><td>Lower()</td><td>将串转换为小写</td></tr><tr><td>Length()</td><td>返回串的长度</td></tr><tr><td>LTrim()</td><td>去掉串左边的空格    </td></tr><tr><td>RTrim()</td><td>去掉串右边的空格</td></tr><tr><td>Left()</td><td>返回串左边的字符</td></tr><tr><td>Right()</td><td>返回串右边的字符</td></tr><tr><td>Locate()</td><td>找出串的一个子串</td></tr><tr><td>SubString()</td><td>返回子串的字符</td></tr><tr><td>Soundex()</td><td>返回串的SOUNDEX值日期和时间处理函数：</td></tr><tr><td>AddDate()</td><td>增加一个日期（天、周等）</td></tr><tr><td>AddTime()</td><td>增加一个时间（时、分等）</td></tr><tr><td>CurDate()</td><td>返回当前日期</td></tr><tr><td>CurTime()</td><td>返回当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Date_Add()</td><td>高度灵活的日期运算函数</td></tr><tr><td>Date_Format()</td><td>返回一个格式化的日期或时间串</td></tr><tr><td>Day()</td><td>返回一个日期的天数部分</td></tr><tr><td>DayOfWeek()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>Hour()</td><td>返回一个时间的小时部分</td></tr><tr><td>Minute()</td><td>返回一个时间的分钟部分</td></tr><tr><td>Month()</td><td>返回一个日期的月份部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr><tr><td>Second()</td><td>返回一个时间的秒部分</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Year()</td><td>返回一个日期的年份部分</td></tr></tbody></table><p><em>（注：不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。防止歧义性。）</em></p><hr><p>例子：<br>（1）<code>SELECT cust_id,order_num FROM orders WHERE order_date=&#39;2005-09-01&#39;;</code><br>此例子中值全部具有时间值 00:00:00，但实际中很可能并不总是这样。因此，需要比较日期部分，而把时间部分忽略。如下：<br>  <code>SELECT cust_id,order_num FROM orders WHERE Date(order_date)=&#39;2005-09-01&#39;;</code><br>如果想要比较的是日期部分，Date()是一个很好的选择。<br>（2）如果你想检索出2005年9月下的所有订单？</p><ol><li><code>SELECT cust_id,order_num FROM orders WHERE Date(order_date) BETWEEN &#39;2005-09-01&#39; AND &#39;2009-09-30&#39;;</code><br>弊端：如果搜索的月份是闰年2月的话，还需要注意是否闰月。</li><li><code>SELECT cust_id,order_num FROM orders WHERE Year(order_date)=2005 AND Month(order_date)=9;</code></li></ol><hr><p><strong>数值处理函数：</strong></p><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>Abs()</td><td>返回一个数的绝对值</td></tr><tr><td>Cos()</td><td>返回一个角度的余弦</td></tr><tr><td>Exp()</td><td>返回一个数的指数值</td></tr><tr><td>Mod()</td><td>返回除操作的余数</td></tr><tr><td>Pi()</td><td>返回圆周率</td></tr><tr><td>Rand()</td><td>返回一个随机数</td></tr><tr><td>Sin()</td><td>返回一个角度的正弦</td></tr><tr><td>Sqrt()</td><td>返回一个数的平方根</td></tr><tr><td>Tan()</td><td>返回一个数的正切</td></tr></tbody></table><h2 id="十二、汇总数据"><a href="#十二、汇总数据" class="headerlink" title="十二、汇总数据"></a>十二、汇总数据</h2><p>聚集函数（aggregate function)运行在行组上，计算和返回单个值的函数。<br>SQL聚集函数：<br>    AVG()、COUNT()、MAX()、MIN()、SUM()</p><h2 id="十三、分组数据"><a href="#十三、分组数据" class="headerlink" title="十三、分组数据"></a>十三、分组数据</h2><p>分组数据设计两个SELECT语句子句：GROUP BY子句和HAVING子句<br>分组数据：<code>GROUP BY</code><br>过滤分组：<code>HAVING</code><br><strong>（区别：WHERE过滤行，HAVING过滤分组。且HAVING支持所有WHERE操作符。还有一种理解方法：WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。）</strong><br><em>（注：一般在使用GROUP BY子句时，应该也给出ORDER BY子句，这是保证数据正确排序的唯一方法，千万不要仅依赖GROUP BY排序数据。）</em></p><p><strong>SELECT子句及其顺序：</strong></p><table><thead><tr><th>子句</th><th>说明</th><th>是否必须使用</th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr><tr><td>GROUP BY</td><td>分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>HAVING</td><td>组级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出排序顺序</td><td>否</td></tr><tr><td>LIMIT</td><td>要检索的行数</td><td>否</td></tr></tbody></table><h2 id="十四、使用子查询"><a href="#十四、使用子查询" class="headerlink" title="十四、使用子查询"></a>十四、使用子查询</h2><p>子查询最常见的使用是在WHERE子句的IN操作符中，以及用来填充计算列。</p><h2 id="十五、联结表"><a href="#十五、联结表" class="headerlink" title="十五、联结表"></a>十五、联结表</h2><p>外键（foreign key）：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。<br>可伸缩性（scale）：能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（scale well）。<br>笛卡儿积（cartesian product）：由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数数目将是第一个表中的行数乘以第二个表中的行数。<br>联结：联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。</p><ol><li>使用WHERE创建联结：<br><code>SELECT vend_name,prod_name,prod_price FROM vendors,products WHERE vendors.vend_id = products.vend_id ORDER BY vend_name,prod_name;</code><br><em>（注：如果不加WHERE子句，结果将变成笛卡儿积。）</em></li><li>内部联结（INNER JOIN）<br><code>SELECT vend_name,prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id;</code><br><em>（注：ANSI SQL规范首选INNER JOIN语法。）</em><br><em>（性能考虑：1. MySQL在运行时关联指定的每个表以处理联结。这种处理可能非常耗费资源的，因此不要联结不必要的表。联结的表越多，性能下降越厉害；2. 利用联结而不使用子查询。）</em></li></ol><h2 id="十六、创建高级联结"><a href="#十六、创建高级联结" class="headerlink" title="十六、创建高级联结"></a>十六、创建高级联结</h2><p>使用表别名。<br>外部联结（OUTER JOIN）：包含没有关联行的那些行。<br>    <code>SELECT c.cust_id,o.order_num FROM customers as c LEFT OUTER JOIN orders as o ON c.cust_id = o.cust_id;</code><br>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表。</p><h2 id="十七、组合查询"><a href="#十七、组合查询" class="headerlink" title="十七、组合查询"></a>十七、组合查询</h2><p>MySQL允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。<br>关键字：UNION</p><ol><li>UNION和UNION ALL的区别：<br>UNION从查询结果集中自动去除了重复的行。<br>UNION ALL返回所有匹配的行。</li><li>在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。不允许使用多条ORDER BY子句。</li></ol><h2 id="十八、全文本搜索"><a href="#十八、全文本搜索" class="headerlink" title="十八、全文本搜索"></a>十八、全文本搜索</h2><p><em>（注：并非所有引擎都支持全文本搜索，MyISAM支持，而InnoDB不支持。）</em><br>全文索引：FULLTEXT<br>使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。<br>例如： <code>SELECT note_text FROM productnotes WHERE Match(note_text) Against(&#39;rabbit&#39;);</code><br><em>（注：传递给Match()的值必须与FULLTEXT()定义中的相同。）</em></p><h2 id="十九、插入数据"><a href="#十九、插入数据" class="headerlink" title="十九、插入数据"></a>十九、插入数据</h2><p>关键字：INSERT<br>  <code>INSERT INTO table(fields) VALUES(values);</code><br><em>（注：多行插入时，values值可以是数组。）</em></p><h2 id="二十、更新和删除数据"><a href="#二十、更新和删除数据" class="headerlink" title="二十、更新和删除数据"></a>二十、更新和删除数据</h2><p>关键字：UPDATE、DELETE<br><em>（注：更新和删除操作时，不要省略WHERE子句，否则会删除或更新表中所有行。）</em><br>  <code>UPDATE table SET field1=value1,...fieldn=valuen WHERE ...;</code><br>  <code>DELETE FROM table WHERE ...;</code></p><h2 id="二十一、创建和操纵表"><a href="#二十一、创建和操纵表" class="headerlink" title="二十一、创建和操纵表"></a>二十一、创建和操纵表</h2><p>1、表的创建：CREATE TABLE 语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `customers`(</span><br><span class="line">   &apos;cust_id&apos; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">   &apos;username&apos; varchar(50) NOT NULL DEFAULT=&apos;guest&apos;,</span><br><span class="line">   &apos;email&apos; varchar(20) NOT NULL,</span><br><span class="line">   &apos;sex&apos; enum(&apos;0&apos;, &apos;1&apos;) NOT NULL,</span><br><span class="line">   PRIMARY KEY(&apos;cust_id&apos;)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><p>几种常用引擎：</p><ol><li>InnoDB：是一个可靠的事务处理引擎，它不支持全文本搜索；</li><li>MEMORY：在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）；</li><li>MyISAM：是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。<br><em>（注：引擎类型可以混用。外键不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键。）</em></li></ol><p>2、表的更改：ALTER TABLE 语句</p><ol><li>增加一个列：<br><code>ALTER TABLE customers ADD phone varchar(11);</code></li><li>删除一个列：<br><code>ALTER TABLE customers DROP COLUMN phone;</code></li><li>定义外键：</li></ol><p>3、表的删除：DROP TABLE 语句<br>    <code>DROP TABLE customers;</code><br>4、重命名表：RENAME TABLE 语句<br>    <code>RENAME TABLE customers TO guests;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、数据库基础&quot;&gt;&lt;a href=&quot;#一、数据库基础&quot; class=&quot;headerlink&quot; title=&quot;一、数据库基础&quot;&gt;&lt;/a&gt;一、数据库基础&lt;/h2&gt;&lt;p&gt;1、数据库：&lt;br&gt;数据库（database）保存有组织的数据的容器（通常是一个文件或一组文件）。&lt;br&gt;数据库软件应称为DBMS（数据库管理系统）。数据库是通过DBMS创建和操纵的容器。你使用的是DBMS，它替你访问数据库。&lt;/p&gt;
&lt;p&gt;2、表：&lt;br&gt;表（table）某种特定类型数据的结构化清单。&lt;br&gt;&lt;em&gt;（注：表名：在不同的数据库中可以使用相同的表名。但是在同一数据库却不能使用相同的表名。 表名 = 数据库_表名）&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
</feed>
