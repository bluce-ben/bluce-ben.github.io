<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-06T13:04:23.596Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP异常处理机制</title>
    <link href="http://yoursite.com/2019/05/06/PHP%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/06/PHP异常处理机制/</id>
    <published>2019-05-06T12:55:32.000Z</published>
    <updated>2019-05-06T13:04:23.596Z</updated>
    
    <content type="html"><![CDATA[<h4 id="异常与错误的区别"><a href="#异常与错误的区别" class="headerlink" title="异常与错误的区别"></a>异常与错误的区别</h4><p>首先要明白异常跟错误是两个不一样的概念，异常是出现正常逻辑之外的情况，而错误是指运行时出错了，比如，使用了一个未定义的变量等。异常需要抛出（throw）才能被捕捉到，而错误会导致程序执行终止。</p><p>PHP默认情况下，在代码出现了错误，如notice warning等消息时，错误信息会被直接打印到浏览器上，这个时候你通过 try catch是捕获不到错误信息的。php的try catch只能捕获到你自己 throw new Exception(“ “)抛出的错误，通过throw之后，程度会直接进入到catch中继续执行。如果你想抛弃php自身的错误处理机制，这个时候可以通过set_error_handler自定义一个函数用来处理，在这个函数中你可以抛出异常，然后再通过catch捕捉到异常。<br><a id="more"></a></p><h4 id="异常介绍"><a href="#异常介绍" class="headerlink" title="异常介绍"></a>异常介绍</h4><p>  PHP异常一般是指在业务逻辑上出现的不合预期、与正常流程不同的状况，不是语法错误。</p><p>  PHP异常处理机制借鉴了java  c++等，但是PHP的异常处理机制是不健全的。异常处理机制目的是将程序正常执行的代码与出现异常如何处理的代码分离。异常主要有检测（try）、抛出（throw）和捕获（catch）等操作。</p><p>  PHP异常处理中需要注意的有，<strong>当代码中有throw出来的异常，则必须要catch到，也即是一个 try 至少要有一个与之对应的 catch。</strong>可以定义多个 catch 可以捕获不同的对象，php会按这些 catch 被定义的顺序执行，直到完成最后一个为止。而在这些 catch 内，又可以抛出新的异常。php的异常也像JAVA的异常的一样，可以在最外层catch捕捉，也可以在throw的地方捕捉。</p><p>  当一个异常被抛出时，其后的代码将不会继续执行，PHP 会尝试查找匹配的 “catch” 代码块。如果一个异常没有被捕获，而且又没用使用set_exception_handler()作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出未能捕获异常(Uncaught Exception …)的提示信息。</p><p>  PHP是无法自动捕获异常的（绝大多数），只有主动抛出异常并捕捉。也就是说，对于异常，是可预见的。目前PHP能自动抛出的异常不多，如：PDO类。</p><h4 id="异常相关函数（可自定义处理异常函数）"><a href="#异常相关函数（可自定义处理异常函数）" class="headerlink" title="异常相关函数（可自定义处理异常函数）"></a>异常相关函数（可自定义处理异常函数）</h4><ol><li><p>set_exception_handler - 设置一个用户定义的异常处理函数<br>1）callable set_exception_handler(callable $exception_handler)<br>该函数设置默认的异常处理程序，用于没有用 try/catch 块来捕获的异常。在 exception_handler调用后异常会中止。<br>2）如果把自定义的异常封装到一个类上，则可以使用数组的方式调用：<br><code>set_exception_handler(array(&#39;MyExceptionHander&#39;, &#39;deal&#39;));</code></p></li><li><p>register_shutdown_function - 设置一个当执行关闭时可以调用的一个函数<br>当脚本执行完成或意外死掉导致PHP执行即将关闭时，我们的这个函数将会被调用。<br>该函数使用场景：1）页面被强制停止；2）程序代码意外终止或超时。<br>说明：该函数接收一个回调函数作为参数（注意：如果函数里面有写路径一定要写绝对路径，因为执行回调函数时已经脱离了脚本，是从内存中调用该函数）</p></li><li><p>Exception<br>Exception 是系统自带的异常处理类，是所有异常的基类。（这个在PHP7中有变化）</p></li></ol><h4 id="PHP7中的错误和异常"><a href="#PHP7中的错误和异常" class="headerlink" title="PHP7中的错误和异常"></a>PHP7中的错误和异常</h4><p>在 PHP7 之前的 PHP 版本一个很大的痛点就是：发生了 E_ERROR 错误，无法捕获，导致数据库的事务无法回滚造成数据不一致。<br>PHP 7 改变了大多数错误的报告方式。不同于传统（PHP 5）的错误报告机制，现在大多数错误被作为 Error 异常抛出（在 PHP7 中，只有 fatal error 和 recoverable error 抛出异常，其他 error 比如 warning 和 notice 的表现不变）。PHP7 中的 Error 和 Exception 的关系如图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Throwable</span><br><span class="line">    |- Exception implements Throwable</span><br><span class="line">        |- ...</span><br><span class="line">    |- Error implements Throwable</span><br><span class="line">        |- TypeError extends Error</span><br><span class="line">        |- ParseError extends Error</span><br><span class="line">        |- ArithmeticError extends Error</span><br><span class="line">            |- DivisionByZeroError extends ArithmeticError</span><br><span class="line">        |- AssertionError extends Error</span><br></pre></td></tr></table></figure></p><p>值得注意的是，Error 类表现上和 Exception 基本一致，可以像 Exception 异常一样被第一个匹配的 try / catch 块所捕获，如果没有匹配的 catch 块，则调用异常处理函数（事先通过 set_exception_handler() 注册7）进行处理。 如果尚未注册异常处理函数，则按照传统方式处理，被报告为一个致命错误（Fatal Error）。但并非继承自 Exception 类（要考虑到和 PHP5 的兼容性），所以不能用 catch (Exception $e) { … } 来捕获，而需要使用 catch (Error $e) { … }，当然，也可以使用 set_exception_handler 来捕获。</p><p>但是，用户不能自己定义类实现 Throwable，这是为了保证只有 Exception 和 Error 才可以抛出。</p><blockquote><p>注：平常使用想要自定义处理错误的时候，可直接选择继承 Exception就可以。</p></blockquote><h4 id="对错误和异常的一种实践"><a href="#对错误和异常的一种实践" class="headerlink" title="对错误和异常的一种实践"></a>对错误和异常的一种实践</h4><p>根据以上所述，我们提炼了一个对错误和异常处理较好的实践。<br>对于业务中不应该出现错误的地方，抛出 InternalException，而不是 Error<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class InternalException extends Exception &#123; /*...*/ &#125;</span><br><span class="line"></span><br><span class="line">function find(Array $ids) &#123;</span><br><span class="line">  if (empty($ids)) &#123;</span><br><span class="line">    throw new InternalException(&apos;ids should not be empty&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>1. 只在需要清理现场的时候 catch Error</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">try &#123; /*...*/ &#125;</span><br><span class="line">catch (Throwable $t) &#123;</span><br><span class="line">  // log, transaction rollback, cleanup...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>未捕获的 Error 和Exception 通过 set_exception_handler 做后续清理和log</li><li>其他错误仍然通过 set_error_handler来处理，在处理的时候使用更加明确的 FriendlyErrorType，并抛出ErrorException 记录调用栈。</li></ol><p><strong>FriendlyErrorType:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function FriendlyErrorType($type) </span><br><span class="line">&#123; </span><br><span class="line">    switch($type) </span><br><span class="line">    &#123; </span><br><span class="line">        case E_ERROR: // 1 // </span><br><span class="line">            return &apos;E_ERROR&apos;; </span><br><span class="line">        case E_WARNING: // 2 // </span><br><span class="line">            return &apos;E_WARNING&apos;; </span><br><span class="line">        case E_PARSE: // 4 // </span><br><span class="line">            return &apos;E_PARSE&apos;; </span><br><span class="line">        case E_NOTICE: // 8 // </span><br><span class="line">            return &apos;E_NOTICE&apos;; </span><br><span class="line">        case E_CORE_ERROR: // 16 // </span><br><span class="line">            return &apos;E_CORE_ERROR&apos;; </span><br><span class="line">        case E_CORE_WARNING: // 32 // </span><br><span class="line">            return &apos;E_CORE_WARNING&apos;; </span><br><span class="line">        case E_COMPILE_ERROR: // 64 // </span><br><span class="line">            return &apos;E_COMPILE_ERROR&apos;; </span><br><span class="line">        case E_COMPILE_WARNING: // 128 // </span><br><span class="line">            return &apos;E_COMPILE_WARNING&apos;; </span><br><span class="line">        case E_USER_ERROR: // 256 // </span><br><span class="line">            return &apos;E_USER_ERROR&apos;; </span><br><span class="line">        case E_USER_WARNING: // 512 // </span><br><span class="line">            return &apos;E_USER_WARNING&apos;; </span><br><span class="line">        case E_USER_NOTICE: // 1024 // </span><br><span class="line">            return &apos;E_USER_NOTICE&apos;; </span><br><span class="line">        case E_STRICT: // 2048 // </span><br><span class="line">            return &apos;E_STRICT&apos;; </span><br><span class="line">        case E_RECOVERABLE_ERROR: // 4096 // </span><br><span class="line">            return &apos;E_RECOVERABLE_ERROR&apos;; </span><br><span class="line">        case E_DEPRECATED: // 8192 // </span><br><span class="line">            return &apos;E_DEPRECATED&apos;; </span><br><span class="line">        case E_USER_DEPRECATED: // 16384 // </span><br><span class="line">            return &apos;E_USER_DEPRECATED&apos;; </span><br><span class="line">    &#125; </span><br><span class="line">    return &quot;&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>error_handler:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function exception_error_handler($severity, $message, $file, $line) &#123;</span><br><span class="line">    if (!(error_reporting() &amp; $severity)) &#123;</span><br><span class="line">        // This error code is not included in error_reporting</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> log FriendlyErrorType($severity);</span><br><span class="line">    throw new ErrorException($message, 0, $severity, $file, $line);</span><br><span class="line">&#125;</span><br><span class="line">set_error_handler(&quot;exception_error_handler&quot;);</span><br></pre></td></tr></table></figure></p><p><strong>总结：</strong><br>要注意，PHP中异常与错误是有区别的，并且处理机制也都是不一样的。因此，要区别对待。</p><p>参考博文：</p><ol><li><a href="https://www.jianshu.com/p/fd3683407993" target="_blank" rel="noopener">PHP异常处理机制</a></li><li><a href="https://juejin.im/entry/5987d2ff6fb9a03c314fe732" target="_blank" rel="noopener">PHP的错误和异常处理机制</a></li><li><a href="http://www.laruence.com/2012/02/02/2515.html" target="_blank" rel="noopener">我们什么时候应该使用异常？</a></li><li><a href="http://www.laruence.com/2010/08/03/1697.html" target="_blank" rel="noopener">深入理解PHP原理之异常机制</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;异常与错误的区别&quot;&gt;&lt;a href=&quot;#异常与错误的区别&quot; class=&quot;headerlink&quot; title=&quot;异常与错误的区别&quot;&gt;&lt;/a&gt;异常与错误的区别&lt;/h4&gt;&lt;p&gt;首先要明白异常跟错误是两个不一样的概念，异常是出现正常逻辑之外的情况，而错误是指运行时出错了，比如，使用了一个未定义的变量等。异常需要抛出（throw）才能被捕捉到，而错误会导致程序执行终止。&lt;/p&gt;
&lt;p&gt;PHP默认情况下，在代码出现了错误，如notice warning等消息时，错误信息会被直接打印到浏览器上，这个时候你通过 try catch是捕获不到错误信息的。php的try catch只能捕获到你自己 throw new Exception(“ “)抛出的错误，通过throw之后，程度会直接进入到catch中继续执行。如果你想抛弃php自身的错误处理机制，这个时候可以通过set_error_handler自定义一个函数用来处理，在这个函数中你可以抛出异常，然后再通过catch捕捉到异常。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP错误处理机制</title>
    <link href="http://yoursite.com/2019/05/06/PHP%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/06/PHP错误处理机制/</id>
    <published>2019-05-06T12:51:44.000Z</published>
    <updated>2019-05-07T01:52:59.472Z</updated>
    
    <content type="html"><![CDATA[<h4 id="错误简介"><a href="#错误简介" class="headerlink" title="错误简介"></a>错误简介</h4><p>  PHP提供了错误处理和日志记录的功能. 这些函数允许你定义自己的错误处理规则，以及修改错误记录的方式. 这样，你就可以根据自己的需要，来更改和加强错误输出信息以满足实际需要。<br>  常见的错误类型有：语法错误、环境错误、逻辑错误。平时遇到的warning、notice都是错误，只是级别不同而已。<br>  常见的错误级别有：Deprecated（最低级别）、Notice（通知）、Warning（警告）、Fatal（致命）、Parser（语法解析），E_USER_相关错误。</p><blockquote><p>注：在 PHP 中，默认的错误处理很简单。一条错误消息会被发送到浏览器，这条消息带有文件名、行号以及描述错误的消息。</p></blockquote><a id="more"></a><h4 id="错误处理函数（可自定义处理错误函数）"><a href="#错误处理函数（可自定义处理错误函数）" class="headerlink" title="错误处理函数（可自定义处理错误函数）"></a>错误处理函数（可自定义处理错误函数）</h4><ol><li><p>error_reporting  设置PHP的报错级别<br>1）通过php.ini设置如下： error_reporting = E_ALL<br>2）通过error_reporting()函数设置，如：<br>error_reporting(0); //关闭所有PHP错误报告<br>error_reporting(-1); //报告所有PHP错误<br>error_reporting(E_ALL); //和error_reporting(-1)一样<br>3）通过ini_set()函数运行时设置<br><code>ini_set(&#39;error_reporting&#39;, E_ALL)</code>;</p></li><li><p>display_errors 设置是否将错误信息<br>1）在php.ini设置如下：display_errors = On<br>（注：不管是On还是Off都会记录到你错误日志里面，前提是配置了错误日志log_errors和error_log）<br>2）通过<code>ini_set(&#39;display_errors&#39;, 1);</code> 设置运行时状态</p></li><li><p>set_error_handler  设置一个用户定义的错误处理函数<br>1）<code>set_error_handler(&#39;my_error&#39;);</code> //my_error()函数为自定义的错误处理方法<br>2）如果把自定义的错误封装到一个类上，则使用数组的方式调用：<br><code>set_error_handler(array(&#39;MyErrorHander&#39;, &#39;deal&#39;));</code> //MyErrorHander为错误类，deal为处理方法<br>3）set_error_handler() 参数介绍如下：<br><img src="/uploads/2019/05/set_error_handler.png" alt="" title="set_error_handler"></p></li></ol><blockquote><p>注：(1)以下级别的错误不能由用户定义的函数来处理： E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、E_COMPILE_WARNING，和在调用 set_error_handler() 函数所在文件中产生的大多数 E_STRICT。 官方没有给出原因，但不难看出这些错误要么是运行时的致命错误，要么是php核心或编译时的错误，因此也不难猜想：对于运行时的致命错误，php直接中断，导致了错误处理函数没有机会执行。<br>(2)如果错误发生在脚本执行之前（比如文件上传时），将不会调用自定义的错误处理程序，因为它尚未在那时注册。</p></blockquote><ol start="4"><li><p>trigger_error()  产生一个用户级别的 error/warning/notice 信息</p></li><li><p>error_log —发送错误信息到某个地方<br>1）在配置文件中： error_log = E:\phpStudy\MyError\test_error.txt<br>2）运行时设置：<code>int_set(&#39;error_log&#39;, &#39;E:\phpStudy\MyError\test_error.txt&#39;)</code>;<br>3）使用error_log函数：<code>error_log(&quot;You messed up!&quot;, 3, &quot;./error/my-errors.log&quot;)</code>;</p></li><li><p>error_get_last()  获取最后发生的错误<br>返回一个关联数组，描述了最后错误的信息，以该错误的“type”、“message”、“file”和“line”为数组的键。 如果该错误由PHP内置函数导致的，“message”会以该函数名开头。如果还没有错误则返回NULL。</p></li></ol><h4 id="错误控制配置"><a href="#错误控制配置" class="headerlink" title="错误控制配置"></a>错误控制配置</h4><p>我们按照php+php-fpm的模型来说，会影响php错误显示的其实是有两个配置文件，一个是php本身的配置文件php.ini，另外一个是php-fpm的配置文件，php-fpm.conf。</p><h5 id="1）php-ini中的配置"><a href="#1）php-ini中的配置" class="headerlink" title="1）php.ini中的配置"></a>1）php.ini中的配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error_reporting = E_ALL  // 报告错误级别，什么级别的</span><br><span class="line">error_log = /tmp/php_errors.log // php中的错误显示的日志位置</span><br><span class="line">display_errors = On // 是否把错误展示在输出上，这个输出可能是页面，也可能是stdout</span><br><span class="line">display_startup_errors = On // 是否把启动过程的错误信息显示在页面上，记得上面说的有几个Core类型的错误是启动时候发生的，这个就是控制这些错误是否显示页面的。</span><br><span class="line">log_errors = On // 是否要记录错误日志</span><br><span class="line">log_errors_max_len = 1024 // 错误日志的最大长度</span><br><span class="line">ignore_repeated_errors = Off // 是否忽略重复的错误</span><br><span class="line">track_errors = Off // 是否使用全局变量$php_errormsg来记录最后一个错误</span><br><span class="line">xmlrpc_errors = 0 //是否使用XML-RPC的错误信息格式记录错误</span><br><span class="line">xmlrpc_error_number = 0 // 用作 XML-RPC faultCode 元素的值。</span><br><span class="line">html_errors = On  // 是否把输出中的函数等信息变为HTML链接</span><br><span class="line">docref_root = http://manual/en/ // 如果html_errors开启了，这个链接的根路径是什么</span><br><span class="line">fastcgi.logging = 0 // 是否把php错误抛出到fastcgi中</span><br></pre></td></tr></table></figure><h5 id="2）php-fpm中的配置"><a href="#2）php-fpm中的配置" class="headerlink" title="2）php-fpm中的配置"></a>2）php-fpm中的配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error_log = /var/log/php-fpm/error.log // php-fpm自身的日志</span><br><span class="line">log_level = notice // php-fpm自身的日志记录级别</span><br><span class="line">php_flag[display_errors] = off // 覆盖php.ini中的某个配置变量，可被程序中的ini_set覆盖</span><br><span class="line">php_value[display_errors] = off // 同php_flag</span><br><span class="line">php_admin_value[error_log] = /tmp/www-error.log // 覆盖php.ini中的某个配置变量，不可被程序中的ini_set覆盖</span><br><span class="line">php_admin_flag[log_errors] = on // 同php_admin_value</span><br><span class="line">catch_workers_output = yes // 是否抓取fpmworker的输出</span><br><span class="line">request_slowlog_timeout = 0 // 慢日志时长</span><br><span class="line">slowlog = /var/log/php-fpm/www-slow.log // 慢日志记录</span><br></pre></td></tr></table></figure><p>php-fpm的配置中也有一个error_log配置，这个很经常会和php.ini中的error_log配置弄混。但他们记录的东西是不一样的，php-fpm的error_log只记录php-fpm本身的日志，比如fpm启动，关闭。<br>而php.ini中的error_log是记录php程序本身的错误日志。</p><p>那么在php-fpm中要覆盖php.ini中的error_log配置，就需要使用到下面几个函数：</p><ul><li>php_flag</li><li>php_value</li><li>php_admin_flag</li><li>php_admin_value<br>这四个函数admin的两个函数说明这个变量设置完之后，不能在代码中使用ini_set把这个变量重新赋值了。而php_flag/value就仍然以php代码中的ini_set为准</li></ul><h4 id="错误处理应该遵循的规则"><a href="#错误处理应该遵循的规则" class="headerlink" title="错误处理应该遵循的规则"></a>错误处理应该遵循的规则</h4><ul><li>一定要让PHP报告错误；</li><li>在开发环境中要显示错误；</li><li>在生产环境中不能显示错误；</li><li>在开发和生产环境中都要记录错误。</li></ul><p>参考博文：</p><ol><li><a href="http://www.cnblogs.com/yjf512/p/5314345.html" target="_blank" rel="noopener">PHP错误机制总结</a></li><li><a href="https://www.jianshu.com/p/8752a7339022" target="_blank" rel="noopener">PHP错误处理机制</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;错误简介&quot;&gt;&lt;a href=&quot;#错误简介&quot; class=&quot;headerlink&quot; title=&quot;错误简介&quot;&gt;&lt;/a&gt;错误简介&lt;/h4&gt;&lt;p&gt;  PHP提供了错误处理和日志记录的功能. 这些函数允许你定义自己的错误处理规则，以及修改错误记录的方式. 这样，你就可以根据自己的需要，来更改和加强错误输出信息以满足实际需要。&lt;br&gt;  常见的错误类型有：语法错误、环境错误、逻辑错误。平时遇到的warning、notice都是错误，只是级别不同而已。&lt;br&gt;  常见的错误级别有：Deprecated（最低级别）、Notice（通知）、Warning（警告）、Fatal（致命）、Parser（语法解析），E_USER_相关错误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：在 PHP 中，默认的错误处理很简单。一条错误消息会被发送到浏览器，这条消息带有文件名、行号以及描述错误的消息。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用docker-compose.yml管理LNMP环境</title>
    <link href="http://yoursite.com/2019/01/22/Docker%E4%BD%BF%E7%94%A8docker-compose-yml%E7%AE%A1%E7%90%86LNMP%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2019/01/22/Docker使用docker-compose-yml管理LNMP环境/</id>
    <published>2019-01-22T10:47:03.000Z</published>
    <updated>2019-01-22T11:11:23.887Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、生成必备的镜像文件-php版本"><a href="#一、生成必备的镜像文件-php版本" class="headerlink" title="一、生成必备的镜像文件 - php版本"></a>一、生成必备的镜像文件 - php版本</h4><p>说明：由于官方的镜像文件不满足实际使用需求，因此需要自定义Dockerfile文件来配置PHP。<br><a id="more"></a></p><h5 id="1、基于php5-6-40镜像版本"><a href="#1、基于php5-6-40镜像版本" class="headerlink" title="1、基于php5.6.40镜像版本"></a>1、基于php5.6.40镜像版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ROM php:5.6-fpm</span><br><span class="line">ENV PHPREDIS_VERSION 3.0.0</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">        libfreetype6-dev \</span><br><span class="line">        libjpeg62-turbo-dev \</span><br><span class="line">        libmcrypt-dev \</span><br><span class="line">        libpng-dev \</span><br><span class="line">    &amp;&amp; docker-php-ext-install iconv mcrypt \</span><br><span class="line">    &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \</span><br><span class="line">    &amp;&amp; docker-php-ext-install gd pdo pdo_mysql mysqli opcache</span><br><span class="line"></span><br><span class="line"># 安装memcached</span><br><span class="line">RUN apt-get update \</span><br><span class="line">        # 手动安装依赖</span><br><span class="line">        &amp;&amp; apt-get install -y libmemcached-dev zlib1g-dev \</span><br><span class="line">    # 安装需要的扩展</span><br><span class="line">    &amp;&amp; pecl install memcached-2.2.0 \</span><br><span class="line">    # 启用扩展</span><br><span class="line">    &amp;&amp; docker-php-ext-enable memcached</span><br><span class="line"></span><br><span class="line"># 安装memcache</span><br><span class="line">RUN pecl install memcache-2.2.7 \</span><br><span class="line">    &amp;&amp; docker-php-ext-enable memcache</span><br><span class="line"></span><br><span class="line"># 安装redis</span><br><span class="line">RUN pecl install -o -f redis \</span><br><span class="line">    &amp;&amp; rm -rf /tmp/pear \</span><br><span class="line">    &amp;&amp; docker-php-ext-enable redis</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/local/</span><br><span class="line">CMD [&quot;./sbin/php-fpm&quot;, &quot;-c&quot;, &quot;/usr/local/etc/php-fpm.conf&quot;]</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ul><li>（1）安装扩展<br>由于php的pecl支持安装memcached、memcache、redis扩展，则使用pecl安装即可。<br>注：要使用docker命令 <code>docker-php-ext-enable</code> 来开启扩展。</li></ul><h5 id="2、基于php7-2-14镜像版本"><a href="#2、基于php7-2-14镜像版本" class="headerlink" title="2、基于php7.2.14镜像版本"></a>2、基于php7.2.14镜像版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">FROM php:7.2.14-fpm</span><br><span class="line">ENV PHPREDIS_VERSION 3.0.0</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">        libfreetype6-dev \</span><br><span class="line">        libjpeg62-turbo-dev \</span><br><span class="line">        libpng-dev \</span><br><span class="line">    &amp;&amp; docker-php-ext-install iconv \</span><br><span class="line">    &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \</span><br><span class="line">    &amp;&amp; docker-php-ext-install gd pdo pdo_mysql mysqli opcache</span><br><span class="line"></span><br><span class="line"># 拷贝php.ini文件</span><br><span class="line">RUN cp /usr/local/etc/php/php.ini-development /usr/local/etc/php/php.ini</span><br><span class="line"></span><br><span class="line"># 注：php7不支持pecl安装memcached memcache</span><br><span class="line"># 安装memcached</span><br><span class="line">RUN apt-get install -y libmemcached-dev</span><br><span class="line">COPY ./memcached /tmp/memcached</span><br><span class="line">RUN cd /tmp/memcached &amp;&amp; /usr/local/bin/phpize \</span><br><span class="line">    &amp;&amp; ./configure -with-php-config=/usr/local/bin/php-config \</span><br><span class="line">    &amp;&amp; make \</span><br><span class="line">    &amp;&amp; make install</span><br><span class="line">RUN docker-php-ext-enable memcached</span><br><span class="line"></span><br><span class="line"># 安装memcache</span><br><span class="line">COPY ./memcache /tmp/memcache</span><br><span class="line">RUN cd /tmp/memcache &amp;&amp; /usr/local/bin/phpize \</span><br><span class="line">    &amp;&amp; ./configure -with-php-config=/usr/local/bin/php-config \</span><br><span class="line">    &amp;&amp; make \</span><br><span class="line">    &amp;&amp; make install</span><br><span class="line">RUN docker-php-ext-enable memcache</span><br><span class="line"></span><br><span class="line"># 安装redis</span><br><span class="line">RUN pecl install -o -f redis \</span><br><span class="line">    &amp;&amp; rm -rf /tmp/pear \</span><br><span class="line">    &amp;&amp; docker-php-ext-enable redis</span><br><span class="line"></span><br><span class="line"># 清空脏数据</span><br><span class="line">RUN rm -rf /tmp/*</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/local/</span><br><span class="line">CMD [&quot;./sbin/php-fpm&quot;, &quot;-c&quot;, &quot;/usr/local/etc/php-fpm.conf&quot;]</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ul><li><p>（1）安装memcache扩展<br>php7不支持pecl安装memcached 和memcache扩展，因此只能使用源码安装，所以要下载源码，地址如下：<br>Memcached:  git clone <a href="https://github.com/php-memcached-dev/php-memcached" target="_blank" rel="noopener">https://github.com/php-memcached-dev/php-memcached</a> memcached<br>Memcache: git clone <a href="https://github.com/websupport-sk/pecl-memcache" target="_blank" rel="noopener">https://github.com/websupport-sk/pecl-memcache</a> memcache</p></li><li><p>（2）安装memcache后，开启扩展时<br>不要使用下面命令把扩展添加到php.ini文件，因为镜像中设置的<code>--with-config-file-path</code>参数找不到php.ini。<br><code>RUN echo extension=memcached.so &gt;&gt; /usr/local/etc/php/php.ini</code><br>因此，要用<code>docker-php-ext-enable</code>命令来开启扩展。</p></li><li><p>（3）清空脏数据时<br>不要使用<code>rm -rf /tmp/</code>命令，该命令会删除tmp文件。导致docker构建错误：<code>Fatal Error Unable to create lock file: Bad file descriptor (9)</code></p></li></ul><h5 id="3、构建镜像文件"><a href="#3、构建镜像文件" class="headerlink" title="3、构建镜像文件"></a>3、构建镜像文件</h5><ul><li><p>（1）PHP<br>基于上面书写的Dockerfile文件来构建镜像文件：<br><code>docker build -t lnmp/php5.6:redis-memcache-001 .</code></p></li><li><p>（2）Nginx、mysql<br>使用官方镜像即可，此处不用构建！下面会贴出对应的版本。</p></li></ul><h4 id="二、使用docker-compose-yml管理镜像"><a href="#二、使用docker-compose-yml管理镜像" class="headerlink" title="二、使用docker-compose.yml管理镜像"></a>二、使用docker-compose.yml管理镜像</h4><h5 id="1、docker-compose-yml文件"><a href="#1、docker-compose-yml文件" class="headerlink" title="1、docker-compose.yml文件"></a>1、docker-compose.yml文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">    php-fpm7:</span><br><span class="line">        container_name: php-fpm7</span><br><span class="line">        image: &quot;lnmp/php7.2:redis-memcache-001&quot;</span><br><span class="line">        expose:</span><br><span class="line">            - &quot;9000&quot;</span><br><span class="line">        volumes:</span><br><span class="line">            - /Users/zhengbenwu/Docker/wwwroot/:/usr/share/nginx/html</span><br><span class="line">        networks:</span><br><span class="line">            - lnmp</span><br><span class="line"></span><br><span class="line">    php-fpm5:</span><br><span class="line">        container_name: php-fpm5</span><br><span class="line">        image: &quot;lnmp/php5.6:redis-memcache-001&quot;</span><br><span class="line">        depends_on:</span><br><span class="line">            - mysql</span><br><span class="line">        expose:</span><br><span class="line">            - &quot;9000&quot;</span><br><span class="line">        volumes:</span><br><span class="line">            - /Users/zhengbenwu/Docker/wwwroot/:/usr/share/nginx/html</span><br><span class="line">        networks:</span><br><span class="line">            - lnmp</span><br><span class="line"></span><br><span class="line">    nginx:</span><br><span class="line">        container_name: nginx</span><br><span class="line">        image: &quot;nginx:1.14.2&quot;</span><br><span class="line">        depends_on:</span><br><span class="line">            - php-fpm5</span><br><span class="line">        links:</span><br><span class="line">            - php-fpm5:fpm5</span><br><span class="line">            - php-fpm7:fpm7</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;80:80&quot;</span><br><span class="line">        volumes:</span><br><span class="line">            - /Users/zhengbenwu/Docker/nginx/nginx.conf:/etc/nginx/nginx.conf</span><br><span class="line">            - /Users/zhengbenwu/Docker/nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">            - /Users/zhengbenwu/Docker/nginx/logs:/var/log/nginx</span><br><span class="line">            - /Users/zhengbenwu/Docker/wwwroot/:/usr/share/nginx/html</span><br><span class="line">        networks:</span><br><span class="line">            - lnmp</span><br><span class="line"></span><br><span class="line">    mysql:</span><br><span class="line">        container_name: mysql</span><br><span class="line">        image: mysql:5.7</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;3306:3306&quot;</span><br><span class="line">        environment:</span><br><span class="line">            - MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">        volumes:</span><br><span class="line">            - /Users/zhengbenwu/Docker/mysql/data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">    lnmp:</span><br><span class="line">        driver: bridge</span><br></pre></td></tr></table></figure><h4 id="附常用命令："><a href="#附常用命令：" class="headerlink" title="附常用命令："></a>附常用命令：</h4><h5 id="1、docker-compose"><a href="#1、docker-compose" class="headerlink" title="1、docker-compose"></a>1、docker-compose</h5><p>注： <code>-f docker-compose.yml</code> 参数可省略，若省略默认找docker-compose.yml文件，找不到会报错。且此参数必须紧跟docker-compse后面<br>开启/关闭：<code>docker-compose [-f docker-compose.yml] start/stop</code><br>删除镜像：<code>docker-compose rm</code><br>构建并开启：<code>docker-compose up -d</code> （注：<code>-d</code>参数表示后台执行）</p><h5 id="2、docker"><a href="#2、docker" class="headerlink" title="2、docker"></a>2、docker</h5><p>注：下面说明的<code>container_id</code>或<code>image_id</code> 可相应的使用<code>container_name</code>或<code>image_name</code><br>查看docker详细安装信息：<code>docker info</code><br>查看镜像文件：<code>docker images</code><br>查看容器：<code>docker ps [-a] （注：添加-a表示查看所有）</code><br>查看镜像或容器详细信息：<code>docker inspect container_id/image_id</code><br>进入容器：<code>docker exec -it container_id /bin/bash</code><br>容器关闭/开启：<code>docker stop/start container_id</code><br>删除容器：<code>docker rm container_id</code><br>删除镜像：<code>docker rmi image_id</code><br>构建镜像（Dockerfile）：<code>docker build -t image_name . （注：“.” 表示使用当前目录的Dockerfile）</code><br>生成容器：<code>docker run -itd - -name container_name - -v $PWD/data:/var/data -p 8888:8888 image_id</code><br>查看构建容器日志：<code>docker logs container_id</code></p><h4 id="错误记录："><a href="#错误记录：" class="headerlink" title="错误记录："></a>错误记录：</h4><p>1、Error response from daemon: configured logging driver does not support reading<br>参考文章：<a href="https://docs.docker.com/config/containers/logging/configure/" target="_blank" rel="noopener">https://docs.docker.com/config/containers/logging/configure/</a><br>解决方法：<br>在生成容器的时候多加一个参数：<br><code>docker run -itd --log-driver json-file --name container_name image_id</code><br>注： <code>--log-driver</code>参数含义是指定日志驱动。 报错显示守护进程配置日志不支持，通过<code>docker inspect container_id</code>可查看到容器的 LoggingDriver 参数为null。因此需要指定一个日志驱动即可。</p><p><strong>参考博客：</strong><br>使用docker创建集成服务-lnmp：<a href="https://www.cnblogs.com/s-b-b/p/8624491.html" target="_blank" rel="noopener">https://www.cnblogs.com/s-b-b/p/8624491.html</a><br>Dockerfile构建LNMP平台：<a href="http://blog.51cto.com/ganbing/2074640" target="_blank" rel="noopener">http://blog.51cto.com/ganbing/2074640</a><br>秒懂Docker中安装扩展PHP：<a href="https://blog.csdn.net/u014389734/article/details/79683136" target="_blank" rel="noopener">https://blog.csdn.net/u014389734/article/details/79683136</a><br>Dockerfile文件中添加redis扩展：<a href="https://blog.csdn.net/xiaobinqt/article/details/83105807" target="_blank" rel="noopener">https://blog.csdn.net/xiaobinqt/article/details/83105807</a><br>PHP7下安装memcache和memcached扩展：<a href="https://blog.csdn.net/u011547570/article/details/78325556" target="_blank" rel="noopener">https://blog.csdn.net/u011547570/article/details/78325556</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、生成必备的镜像文件-php版本&quot;&gt;&lt;a href=&quot;#一、生成必备的镜像文件-php版本&quot; class=&quot;headerlink&quot; title=&quot;一、生成必备的镜像文件 - php版本&quot;&gt;&lt;/a&gt;一、生成必备的镜像文件 - php版本&lt;/h4&gt;&lt;p&gt;说明：由于官方的镜像文件不满足实际使用需求，因此需要自定义Dockerfile文件来配置PHP。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Docker实战" scheme="http://yoursite.com/tags/Docker%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>PhpStorm中添加自定义函数注释</title>
    <link href="http://yoursite.com/2019/01/08/PhpStorm%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%B3%A8%E9%87%8A/"/>
    <id>http://yoursite.com/2019/01/08/PhpStorm中添加自定义函数注释/</id>
    <published>2019-01-08T08:29:19.000Z</published>
    <updated>2019-01-08T08:30:58.717Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看更多<br><a id="more"></a></p><h4 id="一、创建模板"><a href="#一、创建模板" class="headerlink" title="一、创建模板"></a>一、创建模板</h4><p>1、首先我们要添加自己的一套模板，点击 file-&gt;settings-&gt;editor-&gt;live Templates<br><img src="/uploads/2019/01/phpstorm_editor_01.png" alt=""></p><p>2、点击右侧加号，选择第二个选项“template group”，创建一个分组。（注：不需要分组，可跳过此步）<br><img src="/uploads/2019/01/phpstorm_editor_02.png" alt=""></p><p>3、选中刚才添加的分组，点击右侧加号，选择第一个选项“live template”添加一个具体模板。<br><img src="/uploads/2019/01/phpstorm_editor_03.png" alt=""></p><p>4、按照图中步骤：其中第四步不一定要改，可以根据个人习惯，我习惯用enter键。<br><img src="/uploads/2019/01/phpstorm_editor_04.png" alt=""></p><p>5、这是第五步点击内容，分别对DATE, TIME标签做设置。<br><img src="/uploads/2019/01/phpstorm_editor_05.png" alt=""></p><p>设置完后点击”Apply”。</p><h4 id="二、使用模板"><a href="#二、使用模板" class="headerlink" title="二、使用模板"></a>二、使用模板</h4><p>上面是设置要用的标签模板，下面是如何来使用它：<br>点击“file and code templates-&gt;includes-&gt;PHP Function Doc Comment”，在里面输入自己想要的注释内容，注意Times对应添加的模板名称。<br><img src="/uploads/2019/01/phpstorm_editor_06.png" alt=""></p><p>之后点击”apply”。</p><h4 id="三、测试使用"><a href="#三、测试使用" class="headerlink" title="三、测试使用"></a>三、测试使用</h4><p>在项目中使用<br>输入”/**”后点击enter键，会出现刚才添加的注释，再次点击enter键，会自动出现系统时间。<br>注意：如果刚才第四步没有设置”enter”，要点击tab键，默认是tab键。<br><img src="/uploads/2019/01/phpstorm_editor_07.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看更多&lt;br&gt;
    
    </summary>
    
      <category term="编辑器" scheme="http://yoursite.com/categories/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>PHP错误日志简单配置</title>
    <link href="http://yoursite.com/2019/01/08/PHP%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/01/08/PHP错误日志简单配置/</id>
    <published>2019-01-08T08:23:42.000Z</published>
    <updated>2019-01-08T08:25:13.061Z</updated>
    
    <content type="html"><![CDATA[<p>php.ini<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; 错误日志</span><br><span class="line">log_errors = On</span><br><span class="line">; 显示错误</span><br><span class="line">display_errors = Off</span><br><span class="line">; 日志路径</span><br><span class="line">error_log = &quot;/usr/local/lnmp/php/var/log/error_log&quot;</span><br><span class="line">; 错误等级</span><br><span class="line">error_reporting = E_ALL&amp;~E_NOTICE</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>php-fpm.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">; php-fpm pid文件</span><br><span class="line">pid = /usr/local/php/var/run/php-fpm.pid</span><br><span class="line">; php-fpm 错误日志路径</span><br><span class="line">error_log = /usr/local/php/var/log/php-fpm.log</span><br><span class="line">; php-fpm 记录错误日志等级</span><br><span class="line">log_level = notice</span><br><span class="line">[www]</span><br><span class="line">; 记录错误到php-fpm的日志中</span><br><span class="line">;catch_workers_output = yes</span><br><span class="line">; 慢日志</span><br><span class="line">slowlog = var/log/slow.log</span><br><span class="line">; 关闭打印日志</span><br><span class="line">php_flag[display_errors] = off</span><br><span class="line">; 错误日志</span><br><span class="line">php_admin_value[error_log] = /usr/local/php/var/log/www.log</span><br><span class="line">; 记录错误</span><br><span class="line">php_admin_flag[log_errors] = on</span><br><span class="line">; 内存使用量</span><br><span class="line">php_admin_value[memory_limit] = 32M</span><br></pre></td></tr></table></figure></p><p>注：如果错误没有写入到文件，查看网站用户对<code>php_admin_value[error_log]</code>的路径是否有写入权限。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;php.ini&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;; 错误日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log_errors = On&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;; 显示错误&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;display_errors = Off&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;; 日志路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;error_log = &amp;quot;/usr/local/lnmp/php/var/log/error_log&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;; 错误等级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;error_reporting = E_ALL&amp;amp;~E_NOTICE&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>图解TCP连接及对TIME_WAIT的理解</title>
    <link href="http://yoursite.com/2018/12/19/%E5%9B%BE%E8%A7%A3TCP%E8%BF%9E%E6%8E%A5%E5%8F%8A%E5%AF%B9TIME-WAIT%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/19/图解TCP连接及对TIME-WAIT的理解/</id>
    <published>2018-12-19T11:14:58.000Z</published>
    <updated>2019-01-08T08:05:31.231Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h4><p>访问路径：<a href="http://118.24.8.229/index.html" target="_blank" rel="noopener">http://118.24.8.229/index.html</a><br>index.html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.zhengbenwu.com</span><br><span class="line">&lt;img src=&quot;./apple.jpg&quot; /&gt;</span><br><span class="line">&lt;img src=&quot;./ceshi.webp&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>监控工具：Wireshark<br>监控筛选条件：<code>ip.addr == 118.24.8.229 &amp;&amp; tcp.port == 80</code><br><a id="more"></a></p><h4 id="监控说明："><a href="#监控说明：" class="headerlink" title="监控说明："></a>监控说明：</h4><h5 id="（1）建立连接"><a href="#（1）建立连接" class="headerlink" title="（1）建立连接"></a>（1）建立连接</h5><p><img src="/uploads/2018/12/network_tcp_wireshark_01.png" alt=""><br>客户端开启了3个连接请求，相应的客户端也会占用3个端口：59746、59747、59748。通过三次握手建立连接，图示连接建立过程很清晰。</p><p>客户端监控端口：<br><img src="/uploads/2018/12/network_tcp_client_01.png" alt=""></p><p>服务端监控端口：<br><img src="/uploads/2018/12/network_tcp_server_01.png" alt=""></p><h5 id="（2）传输数据"><a href="#（2）传输数据" class="headerlink" title="（2）传输数据"></a>（2）传输数据</h5><p>index.html 文件传输：通过59747端口传输<br><img src="/uploads/2018/12/network_tcp_file_01.png" alt=""></p><p>apple.jpg 文件传输：通过59747端口传输<br><img src="/uploads/2018/12/network_tcp_file_02.png" alt=""></p><p>ceshi.webp 文件传输：通过59748端口传输<br><img src="/uploads/2018/12/network_tcp_file_03.png" alt=""></p><h5 id="（3）断开连接"><a href="#（3）断开连接" class="headerlink" title="（3）断开连接"></a>（3）断开连接</h5><p><img src="/uploads/2018/12/network_tcp_unconnect.png" alt=""><br>① 59746端口连接<br>由图示可以看出，首先断开的是59746端口的连接，且是客户端主动断开连接。因此，客户端会产生TIME_WAIT。<br><img src="/uploads/2018/12/network_tcp_client_02.png" alt=""><br><img src="/uploads/2018/12/network_tcp_server_02.png" alt=""></p><blockquote><p>要注意的是，在此URL请求里，客户端建立的59746端口连接并没有用到；并且，很快就被断开了，并没有保持持久连接检测。</p></blockquote><p>② 59747、59748端口连接<br>由上图示可以看出来，这两个端口是服务端主动断开连接的。中间客户端发送了 Keep-Alive保持连接，之后服务端在keepalive_timeout到时间后，自动断开了连接。因此，服务端会产生TIME_WAIT。<br><img src="/uploads/2018/12/network_tcp_client_03.png" alt=""><br><img src="/uploads/2018/12/network_tcp_server_03.png" alt=""></p><blockquote><p>由此可知道，网站如果量比较大的话，尽量不要使用长连接，会产生大量的TIME_WAIT，导致网站瘫痪。<br>量大的话，服务器可采用降配横向扩展，多部署几台服务器，提高端口数量，降低TIME_WAIT。</p></blockquote><h4 id="问题思考："><a href="#问题思考：" class="headerlink" title="问题思考："></a>问题思考：</h4><h5 id="长连接中TCP是如何请求的？"><a href="#长连接中TCP是如何请求的？" class="headerlink" title="长连接中TCP是如何请求的？"></a>长连接中TCP是如何请求的？</h5><p>实验一：客户端请求连接中，有多个额外请求时，TCP使用是怎么样的？<br>服务端程序改成：<br>（1）1个html和1个图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.zhengbenwu.com</span><br><span class="line">&lt;img src=&quot;./apple.jpg&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>结论：<br>客户端仍然会产生3个TCP连接，并且由于html的数据量少，导致服务端只使用了一个TCP连接就传输了html页面和图片数据。客户端产生2个TIME_WAIT，服务端产生1个TIME_WAIT。</p><p>（2）1个html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.zhengbenwu.com</span><br></pre></td></tr></table></figure></p><p>结论：<br>客户端仍然会产生3个TCP连接，传输数据的TCP连接会保持持久连接，其余未传输数据的客户端会主动断开连接，不检测持久连接。客户端产生2个TIME_WAIT，服务端产生1个TIME_WAIT。<br><img src="/uploads/2018/12/network_tcp_wireshark_02.png" alt=""></p><p>（3）1个html和4个图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">www.zhengbenwu.com</span><br><span class="line">&lt;img src=&quot;./apple.jpg&quot; /&gt;</span><br><span class="line">&lt;img src=&quot;./ceshi.webp&quot; /&gt;</span><br><span class="line">&lt;img src=&quot;./timg.jpg&quot; /&gt;</span><br><span class="line">&lt;img src=&quot;./test001.jpg&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>结论：<br>客户端初始仍会产生3个TCP连接，首先建立连接的TCP会先传输html数据，当传输完成后，会自动的继续传输前3个图片，当发现3个TCP连接都用完后，仍有一个图片未传输，客户端会再新建一个TCP连接，用于传输第四个图片。 此时，TCP连接建立了4个，且都会检测是否保持持久连接，因此最后服务端会产生4个TIME_WAIT。<br><img src="/uploads/2018/12/network_tcp_server_04.png" alt=""></p><p>（4）1个html和7个图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">www.zhengbenwu.com</span><br><span class="line">&lt;img src=&quot;./apple.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./ceshi.webp&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./timg.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test001.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test002.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test003.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test004.jpg&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>结论：<br>客户端初始会产生6个TCP连接，并且复用连接。断开TCP连接的是服务端，因此最后服务端会产生6个TIME_WAIT。<br><img src="/uploads/2018/12/network_tcp_server_05.png" alt=""></p><p>解决方案：<br>线上环境可使用负载均衡。</p><h5 id="短连接中TCP是如何请求的？"><a href="#短连接中TCP是如何请求的？" class="headerlink" title="短连接中TCP是如何请求的？"></a>短连接中TCP是如何请求的？</h5><p>实验二：使用短连接（在服务端Nginx配置 <code>keepalive_timeout 0;</code>）<br>（1）1个html和7个图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">www.zhengbenwu.com</span><br><span class="line">&lt;img src=&quot;./apple.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./ceshi.webp&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./timg.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test001.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test002.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test003.jpg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./test004.jpg&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>结论：<br>在使用短连接的情况下，每个请求都会建立一个TCP连接，不会复用。并且，测试显示都是服务端断开的连接，因此服务端会产生TIME_WAIT。<br><img src="/uploads/2018/12/network_tcp_server_06.png" alt=""></p><h5 id="TIME-WAIT在服务端与客户端的理解"><a href="#TIME-WAIT在服务端与客户端的理解" class="headerlink" title="TIME_WAIT在服务端与客户端的理解"></a>TIME_WAIT在服务端与客户端的理解</h5><p>我理解的TIME_WAIT有两种，一种是作为客户端产生的TIME_WAIT，一种是作为服务端产生的TIME_WAIT。<br>这里，我们先说一下请求的过程。首先，客户端会新建一个进程，并随机分配一个端口号，来与服务端的固定端口号进行连接建立。因此，这一条请求就有两个端口，一个是客户端的随机端口，一个是服务端的固定端口。那么，下面来说结论：<br>① 对于客户端来说<br>客户端主动断开连接，TIME_WAIT产生在客户端。那么，服务端的这条TCP连接会被迅速回收；而客户端会耗时2MSL才被回收，端口才会被释放。</p><p>② 对于服务端来说<br>服务端主动断开连接，TIME_WAIT产生在服务端。客户端的TCP连接会被迅速回收，端口释放，重复使用；而服务端会耗时2MSL才会释放该条连接。</p><p>请注意，这里服务端与TCP建立连接并没有占用端口号，服务端的固定端口号一直在监听服务，并不会被请求占用，而是复用端口。这里与客户端建立连接的是服务端的线程或子进程，会复制主进程的资源，进行处理请求，然后，返回给客户端。<br>因此，服务端产生的TIME_WAIT并不会消耗端口号，只会消耗线程或子进程资源。当请求量达到服务器承载的极限值时，服务端会返回错误。</p><font color="red">（注：由上可知，一般说的TIME_WAIT，是指服务端作为客户端发起的请求产生的TIME_WAIT。过多会导致端口号不够，造成错误。）</font><h5 id="那端会产生TIME-WAIT"><a href="#那端会产生TIME-WAIT" class="headerlink" title="那端会产生TIME_WAIT"></a>那端会产生TIME_WAIT</h5><p>主动断开连接的那端会产生TIME_WAIT。 那又有个问题，那端会先断开连接呢？什么情况下客户端先断，什么情况下服务端先断？</p><ol><li>对于http1.0协议来说，如果响应头中有content-length头，则以content-length的长度就可以知道body的长度了，客户端在接收body时，就可以依照这个长度来接收数据，接收完后，就表示这个请求完成了。而如果没有content-length头，则客户端会一直接收数据，直到服务端主动断开连接，才表示body接收完了。</li><li>而对于http1.1协议来说，如果响应头中的Transfer-encoding为chunked传输，则表示body是流式输出，body会被分成多个块，每块的开始会标识出当前块的长度，此时，body不需要通过长度来指定。如果是非chunked传输，而且有content-length，则按照content-length来接收数据。否则，如果是非chunked，并且没有content-length，则客户端接收数据，直到服务端主动断开连接。</li></ol><p><strong>总结：</strong></p><ul><li>http1.0<br>带content-length，body长度可知，客户端在接收body时，就可以依据这个长度来接受数据。接受完毕后，就表示这个请求完毕了。客户端主动调用close进入四次挥手。<br>不带content-length ，body长度不可知，客户端一直接受数据，直到服务端主动断开</li><li>http1.1<br>带content-length，body长度可知，客户端主动断开<br>带Transfer-encoding：chunked，body会被分成多个块，每块的开始会标识出当前块的长度，body就不需要通过content-length来指定了。但依然可以知道body的长度 客户端主动断开<br>不带Transfer-encoding：chunked且不带content-length，客户端接收数据，直到服务端主动断开连接。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;环境说明：&quot;&gt;&lt;a href=&quot;#环境说明：&quot; class=&quot;headerlink&quot; title=&quot;环境说明：&quot;&gt;&lt;/a&gt;环境说明：&lt;/h4&gt;&lt;p&gt;访问路径：&lt;a href=&quot;http://118.24.8.229/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://118.24.8.229/index.html&lt;/a&gt;&lt;br&gt;index.html代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;www.zhengbenwu.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;img src=&amp;quot;./apple.jpg&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;img src=&amp;quot;./ceshi.webp&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;监控工具：Wireshark&lt;br&gt;监控筛选条件：&lt;code&gt;ip.addr == 118.24.8.229 &amp;amp;&amp;amp; tcp.port == 80&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之URL基础知识</title>
    <link href="http://yoursite.com/2018/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BURL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/12/17/计算机网络之URL基础知识/</id>
    <published>2018-12-17T08:27:14.000Z</published>
    <updated>2018-12-17T08:40:39.525Z</updated>
    
    <content type="html"><![CDATA[<p>URI：服务器资源名被称为<strong>统一资源标识符（Uniform Resource Identifier,URI）</strong>。<br>URL：<strong>统一资源定位符（URL）</strong>是资源标识符最常见的形式。URL描述了一台特定服务器上某资源的特定位置。他们可以明确说明如何从一个精确、固定的位置获取资源。<br>URN：URI的第二种形式就是<strong>统一资源名（URN）</strong>。URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与位置无关的URN，就可以将资源四处搬移。通过URN，还可以用同一个名字通过多种网络访问协议来访问资源。（注：仍然处于实验阶段，还未大范围使用。）<br><a id="more"></a><br>URL趣谈</p><blockquote><p>黑暗岁月：<br>想要访问一个资源，需要使用FTP，连接到对应的域名上，匿名登录，切换到对应的目录，然后下载到本地。进行浏览这个文件。<br>现在，只需要将URL输入到浏览器，直接回车进行浏览即可。</p></blockquote><p>URL<br>大多数URL方案的URL语法都建立在这个由9部分构成的通用格式上：<br>    <code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code><br>几乎没有哪个URL中包含所有这些组件。URL最重要的3个部分是方案（scheme）、主机（host）和路径（path）。下表对各种组件进行了总结：</p><p><strong>通用URL组件</strong></p><table><thead><tr><th>组件</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>方案</td><td>访问服务器以获取资源时要使用那种协议</td><td>无</td></tr><tr><td>用户</td><td>某些方案访问资源时需要的用户名</td><td>匿名</td></tr><tr><td>密码</td><td>用户名后面可能要包含的密码，中间由冒号（:）分隔</td><td>&lt;E-mail地址&gt;</td></tr><tr><td>主机</td><td>资源宿主服务器的主机名或点分IP地址</td><td>无</td></tr><tr><td>端口</td><td>资源宿主服务器正在监听的端口号。很多方案都默认端口号（HTTP的默认端口号为80）</td><td>每个方案特有</td></tr><tr><td>路径</td><td>服务器上资源的本地名，有一个斜杠（/）将其与前面的URL组件分隔开来。路径组件的语法是与服务器和方案有关的（本章稍后会讲到URL路径可以分为若干个段，每段都可以有其特有的组件）</td><td>无</td></tr><tr><td>参数</td><td>某些方案会用这个组件来指定输入参数。参数为名/值对。URL中可以包含多个参数字段，他们相互之间以及与路径的其余部分之间用分号（;）分隔</td><td>无</td></tr><tr><td>查询</td><td>某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引擎以及其它因特网网关）。查询组件的内容没有通用格式。用字符“?”将其与URL的其余部分分割开来</td><td>无</td></tr><tr><td>片段</td><td>一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器，这个字段是在客户端内部使用的。通过字符“#”将其与URL的其余部分分隔开来</td><td>无</td></tr></tbody></table><p><strong>常见的方案格式</strong></p><table><thead><tr><th>方案</th><th>描述</th></tr></thead><tbody><tr><td>http</td><td>超文本传输协议方案，除了没有用户名和密码之外，与通用的URL格式相符。如果省略了端口，就默认为80。<br>基本格式：<br><code>http://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</code></td></tr><tr><td>https</td><td>方案https与方案http是一对。唯一的区别在于方案https使用了网景的SSL，SSL为HTTP连接提供了端到端的加密机制。其语法与HTTP的语法相同，默认端口为443。<br>基本格式：<br><code>http://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</code></td></tr><tr><td>mailto</td><td>Mailto URL指向的是E-mail地址。由于E-mail的行为与其他方案都有所不同（他并不指向任何可以直接访问的对象），所以mailto URL的格式与标准URL的格式也有所不同。因特网E-mail地址的语法记录在RFC 822中。<br>基本格式：<br><code>mailto:&lt;RFC-822-addr-spec&gt;</code><br>示例：<br>mailto:<a href="mailto:joe@joes-hardware.com" target="_blank" rel="noopener">joe@joes-hardware.com</a></td></tr><tr><td>ftp</td><td>文件传输协议URL可以用来从FTP服务器上下载或向其上载文件，并获取FTP服务器上的目录结构内容的列表。<br>在Web和URL出现之前FTP就已经存在了。Web应用程序将FTP作为一种数据访问方案使用。URL语法遵循下列通用格式。<br>基本格式：<br><code>ftp://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;</code><br><a href="ftp://anonymous:joe%40joes-hardware.com@prep.ai.mit.edu:21/pub/gnu/" target="_blank" rel="noopener">ftp://anonymous:joe%40joes-hardware.com@prep.ai.mit.edu:21/pub/gnu/</a></td></tr><tr><td>file</td><td>方案file表示一台指定主机（通过本地磁盘、网络文件系统或其他一些文件共享系统）上可直接访问的文件。各字段都遵循通用格式。如果省略了主机名，就默认为正在使用URL的本地主机。<br>基本格式：<br><code>file://&lt;host&gt;/&lt;path&gt;</code></td></tr><tr><td>telnet</td><td>方案telnet用于访问交互式业务。他表示的并不是对象自身，而是可通过telnet协议访问的交互式应用程序（资源）。<br>基本格式：<br><code>telnet://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/</code></td></tr><tr><td>rtsp,rtspu</td><td>RTSP URL是可以通过实时流传输协议（Real Time Streaming Protocol）解析的音/视屏媒体资源的标识符。<br>方案rtspu中的u表示它是使用UDP协议来获取资源的。<br>基本格式：<br><code>rtsp://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code><br><code>rtspu://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></td></tr><tr><td>news</td><td>省略…</td></tr></tbody></table><blockquote><p>URL是一种强有力的工具，但是并不完美。他们表示的是实际的地址，而不是准确的名字。这就意味着如果资源被移走了，URL就不再有效了。就无法对对象进行定位了。<br>为了应对这个问题，因特网工程任务组（Internet Engineering Task Force，IETF）已经对一种名为统一资源名（uniform resource name,URN）的新标准做了一段时间的研究了。无论对象搬移到什么地方（在一个Web服务器内或是在不同的Web服务器间），URN都能为对象提供一个稳定的名称。<br><strong>永久统一资源定位符（persistent uniform resource locators,PURL）</strong>是用URL来实现URN功能的一个例子。其基本思想是在搜索资源的过程中引入另一个中间层，通过一个中间<strong>资源定位符（resource locator）</strong>服务器对资源的实际URL进行登记和跟踪。客户端可以向定位符请求一个永久URL，定位符可以以一个资源作为响应，将客户端重定向到资源当前实际的URL上去。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;URI：服务器资源名被称为&lt;strong&gt;统一资源标识符（Uniform Resource Identifier,URI）&lt;/strong&gt;。&lt;br&gt;URL：&lt;strong&gt;统一资源定位符（URL）&lt;/strong&gt;是资源标识符最常见的形式。URL描述了一台特定服务器上某资源的特定位置。他们可以明确说明如何从一个精确、固定的位置获取资源。&lt;br&gt;URN：URI的第二种形式就是&lt;strong&gt;统一资源名（URN）&lt;/strong&gt;。URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与位置无关的URN，就可以将资源四处搬移。通过URN，还可以用同一个名字通过多种网络访问协议来访问资源。（注：仍然处于实验阶段，还未大范围使用。）&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>[转]计算机网络之端口问题</title>
    <link href="http://yoursite.com/2018/12/17/%E8%BD%AC-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/12/17/转-计算机网络之端口问题/</id>
    <published>2018-12-17T08:26:51.000Z</published>
    <updated>2018-12-17T08:41:51.946Z</updated>
    
    <content type="html"><![CDATA[<p>博文出处：<a href="https://blog.csdn.net/weixin_42204641/article/details/83585277" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42204641/article/details/83585277</a></p><p>搞清楚一些问题，端口就彻底了解了！</p><a id="more"></a><p>1、 端口到底是什么？<br>端口就是一个数字而已；<br>这里的一个常识是：TCP/IP协议中的端口，端口号的范围从0到65535。</p><p>2、 端口到底是用来干嘛的？<br>当系统调用一个应用程序的时候，会将该进程与一个端口绑定，这样一来，传输层传给该端口的数据都被相应的进程接收，与此同时，相应进程发给传输层的数据也都通过该端口输出。所以，<strong>端口就是用来识别系统中运行的应用程序的</strong>。</p><p>3、 一般80端口是用来www服务（网页服务）的，为什么有些网站不是80端口呢？而是别的什么端口呢？<br>我们在IE的地址栏里输入一个网址的时候（比如<a href="http://www.baidu.com.cn）是不必指定端口号的，因为在默认情况下WWW服务的端口号是“80”。" target="_blank" rel="noopener">www.baidu.com.cn）是不必指定端口号的，因为在默认情况下WWW服务的端口号是“80”。</a></p><p>网络服务是可以改的，使用其他端口号完全是可以的，要注意的是，如果不是默认端口号则应该在地址栏上指定端口号。</p><p>4、 主机和端口的关系是什么？<br>大哥比方，就好比你要去银行存钱，这家银行就可以看成是一台主机，然后，银行不可能只有一种业务，对应每种业务就有很多的窗口，那么你一进银行大门的时候，在门口的服务人员就会问你说：你好！你要办什么业务？<br>你跟他说：存钱！！<br>服务员接着就会告诉你：请到三号窗口办理！<br>这个时候你总该不会往其他的窗口跑吧？！<br>这些窗口就可以看成是port。</p><p>5、 端口映射到底是怎么回事呢？<br>就是建立内网主机IP地址和外网IP地址之间的一个映射；<br>那么当我们向这个外网的IP地址发送请求时，该请求会被转发给内网的那台IP主机上去；从而实现了外网对内网的访问，端口映射的过程如果做个类比那就是：<br>你的一个朋友来找你（网络请求），但是来找你但是不知道你住哪里（内网IP），但是他知道你的名字，（外网IP）于是你的朋友向物业告知你的名字后，物业查到了你的具体地址，几栋几单元几零几（内网IP），然后物业联系你，和你确认（端口映射），然后你的朋友就去对应的地址敲了你的门，然后你开门见到了你的朋友（外网访问到内网）<br>这里的端口，是一种逻辑端口，是TCP/IP协议中定义的端口概念而已，通常就是一些装逼文章里的虚拟端口，那些看得见的端口，就叫做接口。</p><blockquote><p>进程是个什么鬼呢？<br>应用程序调入内存运行之后，就不能叫应用程序了，得叫进程；所以进程就是跑起来的应用程序。</p></blockquote><p>6、 TCP和端口有什么关系呢？<br>TCP和联机有关，所谓的联机就是指客户端Client机和服务端Server机的联系和通信；要想实现Client和Server的通信，必须先通过TCP来实现两端的联机！！<br>TCP联机的过程是：<br>第一步：客户端向服务端发送一个TCP封包（客户端发送的时候的端口是随机的）<br>　　这等同于，客户端打电话问服务端：服务端，听得到我说话么？<br>第二步：服务端按端口的服务性质接受到请求后，向客户端发送第二个TCP封包，也就是第一个响应封包<br>　　这等同于，服务端回客户端说：我听得到！<br>第三步：客户端获得这个响应封包之后，再向服务端发送一个确认封包；<br>　　这等同于，客户端向服务端说：好的！<br>第四步：服务端接收到这个确认封包之后，客户端和服务端的联机就算真正建立了；<br>在建立了tcp联机之后，才能进行服务资源的请求-响应。</p><p>了解到这里就可以完全用几句话把TCP协议和UDP协议的区别讲清楚了<br>TCP协议是：不仅发送信息，然后还要确认信息是否送达<br>UDP协议是：只发送信息，不确认信息是否送达</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博文出处：&lt;a href=&quot;https://blog.csdn.net/weixin_42204641/article/details/83585277&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/weixin_42204641/article/details/83585277&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搞清楚一些问题，端口就彻底了解了！&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之端口解析</title>
    <link href="http://yoursite.com/2018/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/17/计算机网络之端口解析/</id>
    <published>2018-12-17T08:26:03.000Z</published>
    <updated>2018-12-17T08:30:15.267Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、端口概述"><a href="#1、端口概述" class="headerlink" title="1、端口概述"></a>1、端口概述</h4><p>在Internet上，各主机间通过TCP/TP协议发送和接收数据报，各个数据报根据其目的主机的ip地址来进行互联网络中的路由选择。可见，把数据报顺利的传送到目的主机是没有问题的。问题出在哪里呢?我们知道大多数操作系统都支持多程序（进程）同时运行，那么目的主机应该把接收到的数据报传送给众多同时运行的进程中的哪一个呢？显然这个问题有待解决，端口机制便由此被引入进来。</p><blockquote><p>请注意，端口号只具有本地意义（即只对本地机器来说才有意义），它只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口。</p></blockquote><a id="more"></a><p>本地操作系统会给那些有需求的进程分配协议端口 （protocal port，即我们常说的端口），每个协议端口由一个正整数标识，如：80，139，445，等等。当目的主机接收到数据报后，将根据报文首部的目的端口号，把数据发送到相应端口，而与此端口相对应的那个进程将会领取数据并等待下一组数据的到来。</p><p>端口其实就是队，操作系统为各个进程分配了不同的队，数据报按照目的端口被推入相应的队中，等待被进程取用，在极特殊的情况下，这个队也是有可能溢出的，不过操作系统允许各进程指定和调整自己的队的大小。</p><p>不光接受数据报的进程需要开启它自己的端口，发送数据报的进程也需要开启端口，这样，数据报中将会标识有源端口，以便接受方能顺利的回传数据报到这个端口。</p><blockquote><p>传输层标识的端口号用16位来表示，说明只能允许有65535（2^16-1）个不同的端口号。</p></blockquote><h4 id="2、端口分类"><a href="#2、端口分类" class="headerlink" title="2、端口分类"></a>2、端口分类</h4><h5 id="（1）服务器端使用的端口号"><a href="#（1）服务器端使用的端口号" class="headerlink" title="（1）服务器端使用的端口号"></a>（1）服务器端使用的端口号</h5><p>这里又分为两类，最重要的一类叫做熟知端口号（well-known port number）或系统端口号，数值为0~1023。可在网址 <a href="http://www.iana.org查到。" target="_blank" rel="noopener">www.iana.org查到。</a><br>IANA把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道。下面给出一些常用的熟知端口号：</p><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>SNMP</th><th>SNMP(trap)</th></tr></thead><tbody><tr><td>熟知端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>161</td><td>162</td></tr></tbody></table><p>另一类叫做登记端口号，数值为 1024~49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。</p><h5 id="（2）客户端使用的端口号数值为-49152-65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。"><a href="#（2）客户端使用的端口号数值为-49152-65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。" class="headerlink" title="（2）客户端使用的端口号数值为 49152~65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。"></a>（2）客户端使用的端口号数值为 49152~65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。</h5><blockquote><p>短暂端口（ephemeral port）表示这种端口的存在时间是短期的。客户进程并不在意操作系统给它分配的是哪一个端口号，因为客户进程之所以必须有一个端口号（在本地主机中必须是唯一的），是为了让传输层的实体能够找到自己。这和熟知端口不同。服务器机器一接通电源，服务器程序就运行起来。为了让因特网上所有的客户程序都能够找到服务器程序，服务器程序所使用的端口（即熟知端口）就必须是固定的，并且是众所周知的。</p></blockquote><h4 id="端口在入侵中的作用"><a href="#端口在入侵中的作用" class="headerlink" title="端口在入侵中的作用"></a>端口在入侵中的作用</h4><p>有人曾经把服务器比作房子，而把端口比作通向不同房间（服务）的门，如果不考虑细节的话，这是一个不错的比喻。入侵者要占领这间房子，势必要破门而入（物理入侵另说），那么对于入侵者来说，了解房子开了几扇门，都是什么样的门，门后面有什么东西就显得至关重要。<br>　 入侵者通常会用扫描器对目标主机的端口进行扫描，以确定哪些端口是开放的，从开放的端口，入侵者可以知道目标主机大致提供了哪些服务，进而猜测可能存在的漏洞，因此对端口的扫描可以帮助我们更好的了解目标主机，而对于管理员，扫描本机的开放端口也是做好安全防范的第一步。</p><h4 id="端口大小设置"><a href="#端口大小设置" class="headerlink" title="端口大小设置"></a>端口大小设置</h4><blockquote><p>端口大小需要先了解MTU是什么？<br>MTU是Maximum Transmission Unit的缩写，意思是网络上传送的最大数据包，它的的单位是字节。</p></blockquote><blockquote><p>大部分网络设备都是1500。如果本机的MTU比网关的MTU大，大的数据包就会被拆开来传送，这样会产生很多数据包碎片，增加丢包率，降低网络速度。把本机的MTU设成比网关的MTU小或相同，就可以减少丢包 。通俗的说也就是，如果你上传一个大的文件，速度非常慢，可能就是这种原因，当你把MTU值改小时，就可以解决。</p></blockquote><p><strong>查看本机的mtu ：</strong> <code>netstat -i</code></p><p><strong>设置本机的mtu ：</strong> <code>echo &quot;1450&quot; &gt; /sys/class/net/eth0/mtu</code> 或直接编辑eth1网卡配置文件。</p><blockquote><p>扩展：不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p></blockquote><p>在应用程序中我们用到的Data的长度最大是多少，直接取决于底层的限制。<br>我们从下到上分析一下：</p><ol><li>在链路层，由以太网的物理特性决定了数据帧的长度为(46＋18)－(1500＋18)，其中的18是数据帧的头和尾，也就是说数据帧的内容最大为1500(不包括帧头和帧尾)，即MTU(Maximum Transmission Unit)为1500；</li><li>在网络层，因为IP包的首部要占用20字节，所以这的MTU为1500－20＝1480；</li><li>在传输层，对于UDP包的首部要占用8字节，所以这的MTU为1480－8＝1472；（注：TCP的首部要占用20字节）　　</li></ol><p>所以，在应用层，你的Data最大长度为1472。当我们的UDP包中的数据多于MTU(1472)时，发送方的IP层需要分片fragmentation进行传输，而在接收方IP层则需要进行数据报重组，由于UDP是不可靠的传输协议，如果分片丢失导致重组失败，将导致UDP数据包被丢弃。</p><blockquote><p><img src="/uploads/2018/12/network_mtu_001.jpg" alt=""><br>由于以太网EthernetII最大的数据帧是1518Bytes这样，刨去以太网帧的帧头（DMAC目的MAC地址48bits=6Bytes+SMAC源MAC地址48bits=6Bytes+Type域2Bytes）14Bytes和帧尾CRC校验部分4Bytes那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值我们就把它称之为MTU。</p></blockquote><blockquote><p>如果我们定义的TCP和UDP包没有超过范围，那么我们的包在IP层就不用分包了，这样传输过程中就避免了在IP层组包发生的错误；如果超过范围，既IP数据报大于1500字节，发送方IP层就需要将数据包分成若干片，而接收方IP层就需要进行数据报的重组。更严重的是，如果使用UDP协议，当IP层组包发生错误，那么包就会被丢弃。接收方无法重组数据报，将导致丢弃整个IP数据报。UDP不保证可靠传输；但是TCP发生组包错误时，该包会被重传，保证可靠传输。</p></blockquote><p>UDP数据报的长度是指包括报头和数据部分在内的总字节数，其中报头长度固定，数据部分可变。数据报的最大长度根据操作环境的不同而各异。从理论上说，包含报头在内的数据报的最大长度为65535字节(64K)。</p><blockquote><p>注：此处的最大字节数，为系统内核缓存区大小。现在默认值已经不是65535字节，可依据机器查询。<br><code>cat /proc/sys/net/core/rmem_max</code>    //读缓存区，单位字节<br>16777216<br><code>cat /proc/sys/net/core/wmem_max</code>    //写缓存区，单位字节<br>16777216<br><code>cat /proc/sys/net/core/rmem_default</code>    //默认读缓存区<br>8388608<br><code>cat /proc/sys/net/core/wmem_default</code>    //默认写缓存区<br>8388608</p></blockquote><p>我们在用Socket编程时，UDP协议要求包小于64K（需要减去IP头(20)+UDP头(8)=65507，否则用sendto函数发送数据会返回错误）。TCP没有限定，TCP包头中就没有“包长度”字段，而完全依靠IP层去处理分帧。这就是为什么TCP常常被称作一种“流协议”的原因，开发者在使用TCP服务的时候，不必去关心数据包的大小，只需讲SOCKET看作一条数据流的入口，往里面放数据就是了，TCP协议本身会进行拥塞/流量控制。</p><h4 id="端口阻塞问题？（自我理解，不一定正确。待后期确认）"><a href="#端口阻塞问题？（自我理解，不一定正确。待后期确认）" class="headerlink" title="端口阻塞问题？（自我理解，不一定正确。待后期确认）"></a>端口阻塞问题？（自我理解，不一定正确。待后期确认）</h4><p>端口号仅仅是为了区别本地机器的进程用的，并不会出现阻塞问题。出现阻塞问题，也都是一些TCP方面的，或者是IP层面的。</p><p>传输层或网络层的发送与接收缓存打满，导致阻塞丢失数据问题，出现阻塞。（这就是为什么TCP有拥塞控制。需要检测拥塞和减少包的发送率，降低拥塞，避免网络瘫痪。）</p><p>（注：一般不会说UDP会阻塞网络，因为UDP是不可靠的传输，因此如果有阻塞发生，UDP就会丢包，没有重传机制。造成阻塞的情况，可能就是源主机一直发送数据，导致拥塞，造成网络不能正常收发数据。）</p><p>还有就是进程阻塞问题。 一般不会说端口阻塞。端口只会被禁止，通过防火墙一类的限制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、端口概述&quot;&gt;&lt;a href=&quot;#1、端口概述&quot; class=&quot;headerlink&quot; title=&quot;1、端口概述&quot;&gt;&lt;/a&gt;1、端口概述&lt;/h4&gt;&lt;p&gt;在Internet上，各主机间通过TCP/TP协议发送和接收数据报，各个数据报根据其目的主机的ip地址来进行互联网络中的路由选择。可见，把数据报顺利的传送到目的主机是没有问题的。问题出在哪里呢?我们知道大多数操作系统都支持多程序（进程）同时运行，那么目的主机应该把接收到的数据报传送给众多同时运行的进程中的哪一个呢？显然这个问题有待解决，端口机制便由此被引入进来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意，端口号只具有本地意义（即只对本地机器来说才有意义），它只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之TCP、UDP解析</title>
    <link href="http://yoursite.com/2018/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BTCP%E3%80%81UDP%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/17/计算机网络之TCP、UDP解析/</id>
    <published>2018-12-17T08:25:45.000Z</published>
    <updated>2018-12-17T08:29:16.114Z</updated>
    
    <content type="html"><![CDATA[<h4 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h4><p>OSI模型最初是用来作为开发网络通信协议族的一个工业参考标准。通过严格遵守OSI模型，不同的网络技术之间可以轻易地实现互操作。<br><img src="/uploads/2018/12/network_osi.png" alt=""><br><a id="more"></a></p><p>OSI模型包含许多被分割成层的组件。在网络数据通信的过程中，每一层完成一个特定的任务。当传输数据的时候，每一层接收到上面层格式化后的数据，对数据进行操作，然后把它传给下面的层。当接收数据的时候，每一层接收到下面层传过来的数据，对数据进行解包，然后把它传给上一层。</p><p>OSI模型的一个关键概念是虚电路。兼容OSI模型的网络栈的每一部分都不知道其上面层和下面层的行为和细节；它只是向上和向下传输数据。就模型的层次而言，每一层都有一虚电路直接连接目的主机上的对应层。就每一层而言，它的数据在目的层被解包的方式和被打包的方式是完全一样的。层不知道传输数据的实际细节；它们只知道数据是从周围层中传过来的。</p><h4 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h4><p>OSI模型是一种通用的、标准的、理论模型，今天市场上没有一个流行的网络协议完全遵守OSI模型，TCP/IP也不例外，TCP/IP协议族有自己的模型，被称为TCP/IP协议栈，又称DOD模型（Department of defense）<br><img src="/uploads/2018/12/network_tcp_ip_01.png" alt=""></p><blockquote><p>问：TCP/IP是什么？<br>答：TCP/IP是协议栈，并不是单指TCP协议、IP协议或者HTTP协议。仅仅是一个协议族，是一个统称。</p></blockquote><h4 id="TCP、UDP概述"><a href="#TCP、UDP概述" class="headerlink" title="TCP、UDP概述"></a>TCP、UDP概述</h4><h5 id="（1）用户数据报协议UDP（User-Datagram-Protocol）：UDP用户数据报"><a href="#（1）用户数据报协议UDP（User-Datagram-Protocol）：UDP用户数据报" class="headerlink" title="（1）用户数据报协议UDP（User Datagram Protocol）：UDP用户数据报"></a>（1）用户数据报协议UDP（User Datagram Protocol）：UDP用户数据报</h5><p>UDP在传送数据之前不需要先建立连接。远地主机的传输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。</p><h5 id="（2）传输控制协议TCP（Transmission-Control-Protocol）：TCP报文段"><a href="#（2）传输控制协议TCP（Transmission-Control-Protocol）：TCP报文段" class="headerlink" title="（2）传输控制协议TCP（Transmission Control Protocol）：TCP报文段"></a>（2）传输控制协议TCP（Transmission Control Protocol）：TCP报文段</h5><p>TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的传输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。</p><p><strong>使用UDP和TCP协议的各种应用和应用层协议</strong></p><table><thead><tr><th>应用</th><th>应用层协议</th><th>运输层协议</th></tr></thead><tbody><tr><td>域名解析</td><td>DNS</td><td>UDP</td></tr><tr><td>文件传送</td><td>TFTP</td><td>UDP</td></tr><tr><td>路由选择协议</td><td>RIP</td><td>UDP</td></tr><tr><td>IP地址配置</td><td>BOOTP，DHCP</td><td>UDP</td></tr><tr><td>网络管理</td><td>SNMP</td><td>UDP</td></tr><tr><td>远程文件服务器</td><td>NFS</td><td>UDP</td></tr><tr><td>多播</td><td>IGMP</td><td>UDP</td></tr><tr><td>万维网</td><td>HTTP</td><td>TCP</td></tr><tr><td>文件传送</td><td>FTP</td><td>TCP</td></tr><tr><td>远程终端接入</td><td>TELNET</td><td>TCP</td></tr></tbody></table><blockquote><p>题外话：如何将一个进程通过网络送到对应服务器的进程中？<br>解决这个问题的方法就是在传输层使用协议端口号（protocol port number），或通常简称为端口（port）。这就是说，虽然通信的终点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的目的端口（通过IP来完成），剩下的工作（即最后交付给目的进程）就由TCP来完成。</p><blockquote><p>请注意，这种在协议栈层间的抽象的协议端口是软件端口，和路由器或交换机上的硬件端口（应该称为接口）是完全不同的概念。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。</p></blockquote></blockquote><blockquote><p>扩展：TCP/IP的传输层用一个16位端口号来标志一个端口。但请注意，端口号只具有本地意义（即本机机器来说才有意义），它只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口。16位的端口号可允许有65535个不同的端口号，这个数目对一个计算机来说是足够用的。</p></blockquote><h4 id="UDP解析"><a href="#UDP解析" class="headerlink" title="UDP解析"></a>UDP解析</h4><h5 id="1、主要特点："><a href="#1、主要特点：" class="headerlink" title="1、主要特点："></a>1、主要特点：</h5><p>（1）UDP是<strong>无连接</strong>的，即发送数据之前不需要建立连接（当然发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延。<br>（2）UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有许多参数）。<br>（3）UDP是<strong>面向报文</strong>的。发送方的UDP对应程序交下来的报文，在添加首部后就向下交付给IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是<strong>保留这些报文的边界</strong>。这就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。如下图，在接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付给上层的应用进程。<br>因此，<font color="red">应用程序必须选择合适大小的报文。</font>若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这回降低IP层的效率。反之，若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。<br><img src="/uploads/2018/12/network_udp_01.png" alt=""><br>（4）UDP<strong>没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。（这对某些实时应用是很重要的。）<br>（5）UDP<strong>支持一对一、一对多、多对一和多对多的交互通信</strong>。<br>（6）UDP的<strong>首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</p><blockquote><p>虽然某些实时应用需要使用没有拥塞控制的UDP，但当很多的源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，结果大家都无法正常接收。因此，不适用拥塞控制功能的UDP有可能会引起网络产生严重的拥塞问题。</p></blockquote><h5 id="2、UDP的首部格式"><a href="#2、UDP的首部格式" class="headerlink" title="2、UDP的首部格式"></a>2、UDP的首部格式</h5><p>用户数据报UDP有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节，由四个字段组成，每个字段的长度都是两个字节。各字段意义如下：</p><table><thead><tr><th>报头字段名</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td>源端口号</td><td>16</td><td>发送主机的UDP端口</td></tr><tr><td>目的端口号</td><td>16</td><td>目标主机的UDP端口</td></tr><tr><td>消息长度</td><td>16</td><td>UDP用户数据报的长度，其最小值是8（仅有首部）</td></tr><tr><td>校验和</td><td>16</td><td>检测UDP用户数据报在传输中是否有错。有错就丢弃</td></tr></tbody></table><p><img src="/uploads/2018/12/network_udp_02.png" alt=""><br>当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交最后的终点——应用进程。</p><h4 id="TCP解析"><a href="#TCP解析" class="headerlink" title="TCP解析"></a>TCP解析</h4><h5 id="1、主要特点：-1"><a href="#1、主要特点：-1" class="headerlink" title="1、主要特点："></a>1、主要特点：</h5><p>（1）TCP是<strong>面向连接的传输层协议</strong>。这就是说，应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。<br>（2）每一条TCP连接只能有<strong>两个端点（endpoint）</strong>，每一条TCP连接只能是点对点的（一对一）。<br>（3）TCP提供<strong>可靠交付</strong>的服务。也就是说，通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。<br>（4）TCP提供<strong>全双工通信</strong>。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。<br>（5）面向字节流。TCP中的<strong>“流”（stream）指的是流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和TCP的交互时一次一个数据块（大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的<strong>无结构的字节流。</strong>TCP并不知道所传送的字节流的含义。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块就把收到的字节流交付给了上层的应用程序）。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。当然，接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。</p><h5 id="2、TCP的连接"><a href="#2、TCP的连接" class="headerlink" title="2、TCP的连接"></a>2、TCP的连接</h5><p>TCP把连接作为最基本的抽象。TCP的许多特性都与TCP是面向连接的这个基本特性有关。<br>前面已经说过，每一条TCP连接有两个端点。那么，TCP连接的端点是什么呢？ 不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口。 TCP连接的端点叫做<strong>套接字（socket）或插口</strong>。根据RFC 793的定义：端口号<strong>拼接到（contatenated with）IP</strong>地址即构成了套接字。</p><p><font color="red">每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。</font>即：<br>    TCP连接 ::= {socket1, socket2} = {(IP1:port1), (IP2:port2)}</p><blockquote><p>应用编程接口API（Application Programming Interface），即传输层与应用程序之间的一种接口，称为socket API，并简称为socket。</p></blockquote><h5 id="3、TCP报文段的首部格式"><a href="#3、TCP报文段的首部格式" class="headerlink" title="3、TCP报文段的首部格式"></a>3、TCP报文段的首部格式</h5><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP的全部功能都提现在它首部中各字段的作用。只有弄清楚TCP首部各字段的作用才能掌握TCP的工作原理。</p><p>TCP报文段首部的前20个字节是固定的，如下图，后面有4N字节是根据需要而增加的选项（N是整数）。因此TCP首部的最小长度是20字节。<br><img src="/uploads/2018/12/network_tcp_01.png" alt=""></p><table><thead><tr><th>报头字段名</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td>源端口号</td><td>16</td><td>本地通信端口，支持TCP的多路复用机制</td></tr><tr><td>目的端口号</td><td>16</td><td>远地通信端口，支持TCP的多路复用机制</td></tr><tr><td>序号（SEQ）</td><td>32</td><td>数据段第一个数据字节的序号（除含有SYN的段外）；SYN段的SYN序号（建立本次连接的初始序号）</td></tr><tr><td>确认号（ACK）</td><td>32</td><td>表示本地希望接收的下一个数据字节的序号</td></tr><tr><td>数据偏移</td><td>4</td><td>指出该段中数据的初始位置（以32位为单位）</td></tr><tr><td>保留</td><td>6</td><td>保留为今后使用，但目前应置为0</td></tr><tr><td>控制字段（CTL）</td><td></td><td></td></tr><tr><td>    URG</td><td>1</td><td>紧急指针字段有效标志，即该段中携带紧急数据</td></tr><tr><td>    ACK</td><td>1</td><td>确认号字段有效标志</td></tr><tr><td>    PSH</td><td>1</td><td>PUSH操作的标志</td></tr><tr><td>    RST</td><td>1</td><td>要求异常终止通信连接的标志</td></tr><tr><td>    SYN</td><td>1</td><td>建立同步连接的标志</td></tr><tr><td>    FIN</td><td>1</td><td>本地数据发送已结束，终止连接的标志</td></tr><tr><td>窗口</td><td>16</td><td>本地接收窗口尺寸，即本地接收缓冲区大小</td></tr><tr><td>校验和</td><td>16</td><td>包括TCP报头和数据在内的校验和</td></tr><tr><td>紧急指针</td><td>16</td><td>从段序号开始的正向位移，指向紧急数据的最后一个字节</td></tr><tr><td>选项</td><td>可变</td><td>提供任选的服务</td></tr><tr><td>填充</td><td>可变</td><td>保证TCP报头以32位为边界对齐</td></tr></tbody></table><h5 id="4、TCP的连接与释放"><a href="#4、TCP的连接与释放" class="headerlink" title="4、TCP的连接与释放"></a>4、TCP的连接与释放</h5><p>用三次握手建立TCP连接：<br><img src="/uploads/2018/12/network_tcp_02.png" alt=""></p><p>TCP连接释放的过程：<br><img src="/uploads/2018/12/network_tcp_03.png" alt=""></p><p>为什么A在TIME-WAIT状态必须等待2MSL的时间呢？这有两个理由。</p><ul><li>第一，为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。</li><li>第二，防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。<br>B只要收到了A发出的确认，就进入CLOSED状态。同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接。我们注意到，B结束TCP连接的时间要比A早一些。</li></ul><blockquote><p>除时间等待计时器外，TCP还设有一个<strong>保活计时器（keepalive timer）</strong>。设想有这样的情况：客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75秒发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p></blockquote><h5 id="5、TCP高级知识点概述"><a href="#5、TCP高级知识点概述" class="headerlink" title="5、TCP高级知识点概述"></a>5、TCP高级知识点概述</h5><p>（1）TCP是怎么保证可靠传输的？<br>通过超时重传、选择确认、滑动窗口机制来保证可靠传输。</p><p>（2）TCP的keepalive保活机制？<br>通过保活计时器来确保TCP的keepalive的连接。</p><p>（3）TCP的时延、瓶颈及存在的障碍？<br>最常见的TCP相关时延，其中包括：</p><ul><li>TCP连接建立握手；</li><li>TCP慢启动拥塞控制；</li><li>数据聚集的Nagle算法；</li><li>用于捎带确认的TCP延迟确认算法；</li><li>TIME_WAIT时延和端口耗尽。</li></ul><p>（4）拥塞控制<br>所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。<br>TCP的流量控制：利用滑动窗口实现流量控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;OSI模型&quot;&gt;&lt;a href=&quot;#OSI模型&quot; class=&quot;headerlink&quot; title=&quot;OSI模型&quot;&gt;&lt;/a&gt;OSI模型&lt;/h4&gt;&lt;p&gt;OSI模型最初是用来作为开发网络通信协议族的一个工业参考标准。通过严格遵守OSI模型，不同的网络技术之间可以轻易地实现互操作。&lt;br&gt;&lt;img src=&quot;/uploads/2018/12/network_osi.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>线上TIME_WAIT日志记录总结</title>
    <link href="http://yoursite.com/2018/12/13/%E7%BA%BF%E4%B8%8ATIME-WAIT%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/13/线上TIME-WAIT日志记录总结/</id>
    <published>2018-12-13T07:55:57.000Z</published>
    <updated>2018-12-13T07:58:55.856Z</updated>
    
    <content type="html"><![CDATA[<p>首先发现的是平响太高了，之后又降下来了。然后，开始查询原因。下面是过程记录</p><p>刚开始是追寻的问题是： CLB的“心跳”突然没了？（注：CLB是负载均衡，心跳应该是CLB那边用来检测的。是一个文件。）<br><a id="more"></a><br>查看php-fpm数量，发现有434个；最后群里有人说是他调的<br><img src="/uploads/2018/12/network_timewait_001.jpg" alt=""><br><img src="/uploads/2018/12/network_timewait_002.png" alt=""></p><p>然后就开始查询为啥“心跳”没了。<br>回答：CLB改心跳检查接口的话，如果改动比较大，应该是大面积报。最后问题回归到我们这边。</p><p>回答为啥将PHP-FPM数量调高？<br>我理解是这样的，后端有请求时间过长的接口，然后PHP-FPM都用于处理了这些请求长的接口，然后堵住了，然后导致后边的请求都在等待，包括心跳的。<br>心跳5s超时，前端CLB自己断的连接，报的499.<br><img src="/uploads/2018/12/network_timewait_003.png" alt=""><br>所以，增加了fpm的进程数。</p><p>查看PHP的error。 只报进程数不够。突然频繁启动PHP进程，结果达到最大值了。<br><img src="/uploads/2018/12/network_timewait_004.jpg" alt=""></p><p><em>说明：在这个时间点，服务器内存和CPU也都没有问题。</em></p><p>在监控记录中发现，5xx的记录有一个高峰。如下图：<br><img src="/uploads/2018/12/network_timewait_005.jpg" alt=""><br>并且，报这么多错误，项目日志中并没有记录。（说明不是项目导致的问题）</p><p>然后有人在监控记录中有了新发现，如下图：<br><img src="/uploads/2018/12/network_timewait_006.jpg" alt=""><br><img src="/uploads/2018/12/network_timewait_007.jpg" alt=""></p><p><em>注：在双十一期间，机器是10台。双十一前是2台（并且量不高）。双十一之后恢复到2台（量比以前高了点）。</em></p><p>现在确定原因了，由于双十一之后量比以前增多了，导致 timewait 增多，2台机器的端口不能够满足那么大的连接。导致频频报5xx。</p><p><strong>解决方案：</strong><br>服务器降级，多开几台低配，降低 timewait。（注：timewait不可避免，只能通过增加机器，或者是调整服务端配置，提高timewait的回收速度。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先发现的是平响太高了，之后又降下来了。然后，开始查询原因。下面是过程记录&lt;/p&gt;
&lt;p&gt;刚开始是追寻的问题是： CLB的“心跳”突然没了？（注：CLB是负载均衡，心跳应该是CLB那边用来检测的。是一个文件。）&lt;br&gt;
    
    </summary>
    
      <category term="问题" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/"/>
    
      <category term="线上业务" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1/"/>
    
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HTTP之长连接、短连接</title>
    <link href="http://yoursite.com/2018/12/11/HTTP%E4%B9%8B%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/12/11/HTTP之长连接、短连接/</id>
    <published>2018-12-11T03:58:29.000Z</published>
    <updated>2018-12-11T04:33:36.561Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、什么是长连接、短连接？"><a href="#1、什么是长连接、短连接？" class="headerlink" title="1、什么是长连接、短连接？"></a>1、什么是长连接、短连接？</h4><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<code>Connection:keep-alive</code>。<br><a id="more"></a><br>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h4 id="2、TCP连接"><a href="#2、TCP连接" class="headerlink" title="2、TCP连接"></a>2、TCP连接</h4><p>当网络通信时采用TCP协议时，在真正的读写操作之前，客户端与服务器端之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时可以释放这个连接。连接的建立依靠“三次握手”，而释放则需要“四次握手”，所以每个连接的建立都是需要资源消耗和时间消耗的。<br>经典的三次握手建立连接示意图：<br><img src="/uploads/2018/12/network_tcp_01.jpg" alt=""><br><img src="/uploads/2018/12/network_tcp_02.png" alt=""><br>经典的四次握手关闭连接示意图：<br><img src="/uploads/2018/12/network_tcp_03.jpg" alt=""><br><img src="/uploads/2018/12/network_tcp_04.jpg" alt=""></p><h5 id="（1）TCP短连接"><a href="#（1）TCP短连接" class="headerlink" title="（1）TCP短连接"></a>（1）TCP短连接</h5><p>模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。</p><p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。</p><h5 id="（2）TCP长连接"><a href="#（2）TCP长连接" class="headerlink" title="（2）TCP长连接"></a>（2）TCP长连接</h5><p>我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p>TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。</p><p>如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：</p><ul><li>客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。</li><li>客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。</li><li>客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li><li>客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。</li></ul><blockquote><p>易混淆概念：TCP的keep alive和HTTP的Keep-alive<br>TCP的keep  alive是检查当前TCP连接是否活着；HTTP的Keep-alive是要让一个TCP连接活久点。它们是不同层次的概念。</p><blockquote><p>TCP keep alive的表现：<br>当一个连接“一段时间”没有数据通讯时，一方会发出一个心跳包（Keep Alive包），如果对方有回包则表明当前连接有效，继续监控。</p></blockquote></blockquote><blockquote><p>HTTP的Keep-alive<br>（1）HTTP Keep-Alive<br>在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。<br>使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。<br>但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。<br>（2）keepalvie timeout<br>Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住keepalive_timeout秒后，才开始关闭这个连接。<br>当httpd守护进程发送完一个响应后，理应马上主动关闭相应的tcp连接，设置 keepalive_timeout后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览发过来http请求，则关闭这个http连接。</p></blockquote><h4 id="3、长短连接的优缺点："><a href="#3、长短连接的优缺点：" class="headerlink" title="3、长短连接的优缺点："></a>3、长短连接的优缺点：</h4><p>长连接和短连接的产生在于client和server采取的关闭策略。不同的应用场景适合采用不同的策略。</p><p>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p><p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽</p><h4 id="4、长短连接操作过程："><a href="#4、长短连接操作过程：" class="headerlink" title="4、长短连接操作过程："></a>4、长短连接操作过程：</h4><ul><li>短连接：<br>操作步骤：连接-&gt;传输数据-&gt;关闭连接</li><li>长连接：<br>操作步骤：连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; 。。。 -&gt;关闭连接。</li></ul><h4 id="5、什么时候用长连接，短连接？"><a href="#5、什么时候用长连接，短连接？" class="headerlink" title="5、什么时候用长连接，短连接？  　　"></a>5、什么时候用长连接，短连接？  　　</h4><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 </p><p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p><p>参考文章：<br>HTTP长连接、短连接究竟是什么？：<a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">https://www.cnblogs.com/gotodsp/p/6366163.html</a><br>HTTP 的长连接和短连接：<a href="http://blog.jobbole.com/104108/" target="_blank" rel="noopener">http://blog.jobbole.com/104108/</a><br>http keep_alive 和 tcp keep_alive：<a href="https://blog.csdn.net/lys86_1205/article/details/21234867" target="_blank" rel="noopener">https://blog.csdn.net/lys86_1205/article/details/21234867</a><br>HTTP Keep-Alive模式：<a href="http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、什么是长连接、短连接？&quot;&gt;&lt;a href=&quot;#1、什么是长连接、短连接？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是长连接、短连接？&quot;&gt;&lt;/a&gt;1、什么是长连接、短连接？&lt;/h4&gt;&lt;p&gt;在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。&lt;/p&gt;
&lt;p&gt;而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：&lt;code&gt;Connection:keep-alive&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP之TIME_WAIT解析</title>
    <link href="http://yoursite.com/2018/12/11/HTTP%E4%B9%8BTIME-WAIT%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/11/HTTP之TIME-WAIT解析/</id>
    <published>2018-12-11T03:58:23.000Z</published>
    <updated>2018-12-11T04:32:39.956Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、查看服务器连接状态信息"><a href="#1、查看服务器连接状态信息" class="headerlink" title="1、查看服务器连接状态信息"></a>1、查看服务器连接状态信息</h4><p>查看服务器TCP链接状态信息：<br><code>netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</code></p><p>它会显示例如下面的信息：<br>TIME_WAIT 814<br>CLOSE_WAIT 1<br>FIN_WAIT1 1<br>ESTABLISHED 634<br>SYN_RECV 2<br>LAST_ACK 1</p><p>常用的三个状态是：ESTABLISHED 表示正在通信（表示正常数据传输状态），TIME_WAIT 表示主动关闭（表示处理完毕，等待超时结束的请求数），CLOSE_WAIT 表示被动关闭。<br><a id="more"></a><br>具体每种状态什么意思，看下图就明白了：<br><img src="/uploads/2018/12/network_timewait_00.gif" alt=""></p><p>这么多状态不用都记住，只要了解到我上面提到的最常见的三种状态的意义就可以了。一般不到万不得已的情况也不会去查看网络状态，如果服务器出了异常，百分之八九十都是下面两种情况：</p><ol><li>服务器保持了大量TIME_WAIT状态</li><li>服务器保持了大量CLOSE_WAIT状态</li></ol><p>因为linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，而且是“占着茅坑不使劲”，一旦达到句柄数上限，新的请求就无法被处理了，接着就是大量Too Many Open Files异常，tomcat崩溃。。。</p><h4 id="2、文件句柄说明"><a href="#2、文件句柄说明" class="headerlink" title="2、文件句柄说明"></a>2、文件句柄说明</h4><p>在Linux里头“一切皆文件”，提示“Too Many Open Files异常”表示句柄不够用了。对应可能就是socket或设备打开太多导致的。</p><p>linux在文件句柄的数目上有两个级别的限制。一个是系统级别的总数限制，一个是针对用户的限制。</p><h5 id="（1）系统级别的句柄操作"><a href="#（1）系统级别的句柄操作" class="headerlink" title="（1）系统级别的句柄操作"></a>（1）系统级别的句柄操作</h5><ul><li>查看系统的句柄限制：<br><code>sysctl -a | grep fs.file-max</code><br>或者<br><code>cat /proc/sys/fs/file-max</code></li><li>修改句柄数限制：<br><code>sysctl -w fs.file-max 797692</code><br>或者<br><code>echo &quot;797692&quot; &gt; /proc/sys/fs/file-max</code><br>两者作用是相同的，前者改内核参数，后者直接作用于内核参数在虚拟文件系统（procfs,psuedo file system）上对应的文件而已。<br>或者<br>修改内核参数 /etc/sysctl.conf<br><code>echo &quot;fs.file-max=797692&quot; &gt;&gt; /etc/sysctl.conf</code><br>（注：查看内核参数： sysctl -p）<br>*查看整个系统目前使用的文件句柄数量命令：<br><code>cat /proc/sys/fs/file-nr</code></li></ul><h5 id="（2）用户级别的句柄操作"><a href="#（2）用户级别的句柄操作" class="headerlink" title="（2）用户级别的句柄操作"></a>（2）用户级别的句柄操作</h5><ul><li>查看当前用户的文件句柄限制： ulimit -a</li><li>修改句柄数限制：<br>修改 /etc/security/limits.conf 增加下面代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*           soft   nofile       262140</span><br><span class="line">*           hard   nofile       262140</span><br><span class="line">*           soft   nproc        102400</span><br><span class="line">*           hard   nproc        102400</span><br></pre></td></tr></table></figure></li></ul><p>（注：*标识所有用户）<br>有两种限制，一种是soft软限制，在数目超过软限制的时候系统会给出warning警告，但是达到hard硬限制的时候系统将拒绝或者异常了。<br>（注：修改之后可能需要重启shell生效。）</p><h5 id="（3）其它操作"><a href="#（3）其它操作" class="headerlink" title="（3）其它操作"></a>（3）其它操作</h5><p>查看某个进程开了那些句柄： <code>lsof -p pid</code><br>某个进程开了几个句柄： <code>lsof -p pid | wc -l</code><br>可以看到某个目录/文件被什么进程占用了，显示已打开该目录或文件的所有进程信息： <code>lsof path/filename</code></p><h4 id="3、下面来讨论下这两种情况的处理方法："><a href="#3、下面来讨论下这两种情况的处理方法：" class="headerlink" title="3、下面来讨论下这两种情况的处理方法："></a>3、下面来讨论下这两种情况的处理方法：</h4><h5 id="（1）服务器保持了大量TIME-WAIT状态"><a href="#（1）服务器保持了大量TIME-WAIT状态" class="headerlink" title="（1）服务器保持了大量TIME_WAIT状态"></a>（1）服务器保持了大量TIME_WAIT状态</h5><p>这种情况比较常见，一些爬虫服务器或者WEB服务器（如果网管在安装的时候没有做内核参数优化的话）上经常会遇到这个问题，这个问题是怎么产生的呢？</p><p>从 上面的示意图可以看得出来，TIME_WAIT是主动关闭连接的一方保持的状态，对于爬虫服务器来说他本身就是“客户端”，在完成一个爬取任务之后，他就 会发起主动关闭连接，从而进入TIME_WAIT的状态，然后在保持这个状态2MSL（max segment lifetime）时间之后，彻底关闭回收资源。为什么要这么做？明明就已经主动关闭连接了为啥还要保持资源一段时间呢？这个是TCP/IP的设计者规定 的，主要出于以下两个方面的考虑：</p><ol><li>防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失）</li><li>可靠的关闭TCP连接。在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。另外这么设计TIME_WAIT 会定时的回收资源，并不会占用很大资源的，除非短时间内接受大量请求或者受到攻击。</li></ol><blockquote><p>关于MSL引用下面一段话：<br>MSL为一个TCP Segment（某一块TCP网路封包）从来源送到目的之间可续存的时间（也就是一个网路封包再网路上传输时能存活的时间），由于RFC 793 TCP传输协议是在1981年定义的，当时的网路速度不像现在的网路那样发达，你可以想象你从浏览器输入等到第一个byte出现要等4分钟吗？在现在的网路环境下几乎不可能有这种事情发生，因此我们大可将 TIME_WAIT 状态的续存时间大幅调低，好让连接口能更快空出来给其它连线使用。</p></blockquote><blockquote><p>再引用网络资源的一段话：<br>值 得一说的是，对于基于TCP的HTTP协议，关闭TCP连接的是Server端，这样，Server端会进入TIME_WAIT状态，可 想而知，对于访 问量大的Web Server，会存在大量的TIME_WAIT状态，假如server一秒钟接收1000个请求，那么就会积压 240*1000=240，000个 TIME_WAIT的记录，维护这些状态给Server带来负担。当然现代操作系统都会用快速的查找算法来管理这些 TIME_WAIT，所以对于新的 TCP连接请求，判断是否hit中一个TIME_WAIT不会太费时间，但是有这么多状态要维护总是不好。<br>HTTP协议1.1版规定default行为是Keep-Alive，也就是会重用TCP连接传输多个 request/response，一个主要原因就是发现了这个问题</p></blockquote><p>也就是说HTTP的交互跟上面画的那个图是不一样的，关闭连接的不是客户端，而是服务器，所以web服务器也是会出现大量的TIME_WAIT的情况的。这也说清楚了，为什么我的客户端服务器会出现大量CLOSE_WAIT的情况。</p><p>现在来说如何来解决这个问题。<br>解决思路很简单，就是让服务器能够快速回收和重用那些TIME_WAIT的资源。<br>下面来看一下我们对/etc/sysctl.conf文件的修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃,不应该大于255，默认值是5，对应于180秒左右时间   </span><br><span class="line">net.ipv4.tcp_syn_retries=2  </span><br><span class="line">#net.ipv4.tcp_synack_retries=2  </span><br><span class="line">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为300秒  </span><br><span class="line">net.ipv4.tcp_keepalive_time=1200  </span><br><span class="line">net.ipv4.tcp_orphan_retries=3  </span><br><span class="line">#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间  </span><br><span class="line">net.ipv4.tcp_fin_timeout=30    </span><br><span class="line">#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。  </span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096  </span><br><span class="line">#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_syncookies = 1  </span><br><span class="line">  </span><br><span class="line">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_reuse = 1  </span><br><span class="line">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭  </span><br><span class="line">net.ipv4.tcp_tw_recycle = 1  </span><br><span class="line">  </span><br><span class="line">##减少超时前的探测次数   </span><br><span class="line">net.ipv4.tcp_keepalive_probes=5   </span><br><span class="line">##优化网络设备接收队列   </span><br><span class="line">net.core.netdev_max_backlog=3000</span><br></pre></td></tr></table></figure></p><p>修改完之后执行/sbin/sysctl -p让参数生效。</p><p>这里头主要注意到的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse </span><br><span class="line">net.ipv4.tcp_tw_recycle </span><br><span class="line">net.ipv4.tcp_fin_timeout </span><br><span class="line">net.ipv4.tcp_keepalive_*</span><br></pre></td></tr></table></figure></p><p>这几个参数。</p><blockquote><p>net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle的开启都是为了回收处于TIME_WAIT状态的资源。<br>net.ipv4.tcp_fin_timeout这个时间可以减少在异常情况下服务器从FIN-WAIT-2转到TIME_WAIT的时间。<br>net.ipv4.tcp_keepalive_*一系列参数，是用来设置服务器检测连接存活的相关配置。</p></blockquote><h5 id="（2）服务器保持了大量CLOSE-WAIT状态"><a href="#（2）服务器保持了大量CLOSE-WAIT状态" class="headerlink" title="（2）服务器保持了大量CLOSE_WAIT状态"></a>（2）服务器保持了大量CLOSE_WAIT状态</h5><p>TIME_WAIT状态可以通过优化服务器参数得到解决，因为发生TIME_WAIT的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的。</p><p>但是CLOSE_WAIT就不一样了，从上面的图可以看出来，如果一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出ack信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。个人觉得这种情况，通过服务器内核参数也没办法解决，服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行。</p><p>简单来说CLOSE_WAIT数目过大是由于被动关闭连接处理不当导致的。</p><blockquote><p>我说一个场景，服务器A会去请求服务器B上面的apache获取文件资源，正常情况下，如果请求成功，那么在抓取完资源后服务器A会主动发出关闭连接的请求，这个时候就是主动关闭连接，连接状态我们可以看到是TIME_WAIT。如果一旦发生异常呢？假设请求的资源服务器B上并不存在，那么这个时候就会由服务器B发出关闭连接的请求，服务器A就是被动的关闭了连接，如果服务器A被动关闭连接之后自己并没有释放连接，那就会造成CLOSE_WAIT的状态了。</p></blockquote><p>所以很明显，问题还是处在程序里头。</p><p>参考资料：<br>服务器TIME_WAIT和CLOSE_WAIT详解和解决办法：<a href="https://www.cnblogs.com/sunxucool/p/3449068.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunxucool/p/3449068.html</a><br>HttpClient4 TIME_WAIT和CLOSE_WAIT：<a href="https://www.cnblogs.com/caoyusongnet/p/9087633.html" target="_blank" rel="noopener">https://www.cnblogs.com/caoyusongnet/p/9087633.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、查看服务器连接状态信息&quot;&gt;&lt;a href=&quot;#1、查看服务器连接状态信息&quot; class=&quot;headerlink&quot; title=&quot;1、查看服务器连接状态信息&quot;&gt;&lt;/a&gt;1、查看服务器连接状态信息&lt;/h4&gt;&lt;p&gt;查看服务器TCP链接状态信息：&lt;br&gt;&lt;code&gt;netstat -n | awk &amp;#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它会显示例如下面的信息：&lt;br&gt;TIME_WAIT 814&lt;br&gt;CLOSE_WAIT 1&lt;br&gt;FIN_WAIT1 1&lt;br&gt;ESTABLISHED 634&lt;br&gt;SYN_RECV 2&lt;br&gt;LAST_ACK 1&lt;/p&gt;
&lt;p&gt;常用的三个状态是：ESTABLISHED 表示正在通信（表示正常数据传输状态），TIME_WAIT 表示主动关闭（表示处理完毕，等待超时结束的请求数），CLOSE_WAIT 表示被动关闭。&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之uniq</title>
    <link href="http://yoursite.com/2018/11/20/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Buniq/"/>
    <id>http://yoursite.com/2018/11/20/Linux命令之uniq/</id>
    <published>2018-11-20T09:21:20.000Z</published>
    <updated>2018-11-20T09:40:43.238Z</updated>
    
    <content type="html"><![CDATA[<p>uniq - 检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">　　uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--help][--version][输入文件][输出文件]</span><br><span class="line">参数：</span><br><span class="line">　　-c或--count 在每列旁边显示该行重复出现的次数。</span><br><span class="line">　　-d或--repeated 仅显示重复出现的行列。</span><br><span class="line">　　-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。</span><br><span class="line">　　-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。</span><br><span class="line">　　-u或--unique 仅显示出一次的行列。</span><br><span class="line">　　-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt; 指定要比较的字符。</span><br><span class="line">　　--help 显示帮助。</span><br><span class="line">　　--version 显示版本信息。</span><br><span class="line">　　[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；</span><br><span class="line">　　[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><strong>描述：</strong></p><ul><li>uniq 命令删除文件中的重复行。</li><li>uniq 命令读取由 InFile 参数指定的标准输入或文件。该命令首先比较相邻的行，然后除去第二行和该行的后续副本。重复的行一定相邻。（在发出 uniq 命令之前，请使用 sort 命令使所有重复行相邻。）</li></ul><p><strong>实例：</strong><br>testfile中的原有内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat testfile      #原有内容  </span><br><span class="line">test 30  </span><br><span class="line">test 30  </span><br><span class="line">test 30  </span><br><span class="line">Hello 95  </span><br><span class="line">Hello 95  </span><br><span class="line">Hello 95  </span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85  </span><br><span class="line">Linux 85</span><br></pre></td></tr></table></figure></p><p>使用uniq 命令删除重复的行后，有如下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ uniq testfile     #删除重复行后的内容  </span><br><span class="line">test 30  </span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85</span><br></pre></td></tr></table></figure></p><p>检查文件并删除文件中重复出现的行，并在行首显示该行重复出现的次数。使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ uniq -c testfile      #删除重复行后的内容  </span><br><span class="line">3 test 30             #前面的数字的意义为该行共出现了3次  </span><br><span class="line">4 Hello 95            #前面的数字的意义为该行共出现了4次  </span><br><span class="line">2 Linux 85            #前面的数字的意义为该行共出现了2次</span><br></pre></td></tr></table></figure></p><font color="red">（当重复的行并不相邻时，uniq 命令是不起作用的，即若文件内容为以下时，uniq 命令不起作用。必须辅以sort排序后再过滤。）</font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;uniq - 检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;语法：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　uniq [-cdu][-f&amp;lt;栏位&amp;gt;][-s&amp;lt;字符位置&amp;gt;][-w&amp;lt;字符位置&amp;gt;][--help][--version][输入文件][输出文件]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-c或--count 	在每列旁边显示该行重复出现的次数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-d或--repeated 仅显示重复出现的行列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-f&amp;lt;栏位&amp;gt;或--skip-fields=&amp;lt;栏位&amp;gt; 忽略比较指定的栏位。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-s&amp;lt;字符位置&amp;gt;或--skip-chars=&amp;lt;字符位置&amp;gt; 忽略比较指定的字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-u或--unique 仅显示出一次的行列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-w&amp;lt;字符位置&amp;gt;或--check-chars=&amp;lt;字符位置&amp;gt; 指定要比较的字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　--help 显示帮助。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　--version 显示版本信息。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的SAFE UPDATE MODE</title>
    <link href="http://yoursite.com/2018/11/20/MySQL%E4%B8%AD%E7%9A%84SAFE-UPDATE-MODE/"/>
    <id>http://yoursite.com/2018/11/20/MySQL中的SAFE-UPDATE-MODE/</id>
    <published>2018-11-20T09:20:17.000Z</published>
    <updated>2018-11-20T09:25:30.761Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面：此<code>SET SQL_SAFE_UPDATES=1</code>命令可防止代码无WHERE条件更新或删除操作。</p><p>在业务中发现一个问题，报错如下：<br><img src="/uploads/2018/11/mysql_safe_update_mode.png" alt=""><br><a id="more"></a><br>在使用 <code>update</code> 的时候，报如上错误。 根据图示可发现是因为开启了 update safe mode，然后where条件中的字段没有索引导致的。</p><p>经过查找，确实发现，MySQL有SAFE UPDATE MODE模式，可使用SQL语句更改：<br><code>SET SQL_SAFE_UPDATES = 0;</code><br>相当于是解除SAFE MODE模式，则可以更新删除了。</p><p>sql_safe_updates参数可以限制不带where条件的update/delete语句执行失败，这个参数设置后，可以防止业务bug/漏洞导致把整个表都更新或者删除（线上发生过的案例），也可以防止DBA在线误操作更新/删除整张表。</p><blockquote><p>官方解释：<br>当sql_safe_updates设置为1时，UPDATE :要有where，并查询条件必须使用为索引字段，或者使用limit，或者两个条件同时存在，才能正常执行。DELETE:where条件中带有索引字段可删除，where中查询条件不是索引，得必须有limit。主要是防止UPDATE和DELETE 没有使用索引导致变更及删除大量数据。系统参数默认值为0</p></blockquote><font color="red">（经验证发现，并不是唯一索引才行（网上某些说法如此），只要是含有索引的就OK。）</font><p>为了防止线上业务出现以下3种情况影响线上服务的正常使用和不小心全表数据删除:</p><ol><li>没有加where条件的全表更新操作</li><li>加了where 条件字段，但是where 字段 没有走索引的表更新</li><li>全表delete 没有加where 条件 或者where 条件没有 走索引</li></ol><p><strong>建议:</strong> DBA 开启此参数限制 ，可以避免线上业务数据误删除操作，但是需要先在测试库开启，这样可以可以先在测试库上补充短缺的表索引，测试验证没问题再部署到线上库 邮件部从去年开始已经在严选电商线上运行。</p><p><strong>业务逻辑：</strong><br>业务中开启SAFE MODE的场景是，由于出现过代码中有更新操作，而没有传where条件，导致全部更新（幸运的是，由于更新数据量过大，更新超时，导致数据并没有被更新成功。否则，数据就得回滚了。）。没有传where条件是因为没有进行过滤验证导致的。所以，DB那边就开启了UPDATE SAFE MODE模式。<br>开启这个之后，线上数据库某些表中的字段没有索引，而<font color="red">代码中却使用了没有索引的字段做where条件进行更新。</font>才引发上面的错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面：此&lt;code&gt;SET SQL_SAFE_UPDATES=1&lt;/code&gt;命令可防止代码无WHERE条件更新或删除操作。&lt;/p&gt;
&lt;p&gt;在业务中发现一个问题，报错如下：&lt;br&gt;&lt;img src=&quot;/uploads/2018/11/mysql_safe_update_mode.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
      <category term="优化" scheme="http://yoursite.com/categories/MySQL/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="MySQL优化" scheme="http://yoursite.com/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL加锁详解</title>
    <link href="http://yoursite.com/2018/11/20/MySQL%E5%8A%A0%E9%94%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/11/20/MySQL加锁详解/</id>
    <published>2018-11-20T09:19:29.000Z</published>
    <updated>2018-11-20T09:26:10.549Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-新建数据表："><a href="#1-新建数据表：" class="headerlink" title="1. 新建数据表："></a>1. 新建数据表：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">| test  | CREATE TABLE `test` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `age` tinyint(3) NOT NULL,</span><br><span class="line">  `hobby` varchar(200) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `name` (`name`),</span><br><span class="line">  KEY `hobby` (`hobby`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 |</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-设置事物隔离级别："><a href="#2-设置事物隔离级别：" class="headerlink" title="2. 设置事物隔离级别："></a>2. 设置事物隔离级别：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set tx_isolation=&apos;READ-COMMITTED&apos;;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| READ-COMMITTED  |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><h4 id="3-测试索引对于锁的影响（事务级别：READ-COMMITTED，默认级别（REPEATABLE-READ））"><a href="#3-测试索引对于锁的影响（事务级别：READ-COMMITTED，默认级别（REPEATABLE-READ））" class="headerlink" title="3. 测试索引对于锁的影响（事务级别：READ-COMMITTED，默认级别（REPEATABLE-READ））"></a>3. 测试索引对于锁的影响（事务级别：READ-COMMITTED，默认级别（REPEATABLE-READ））</h4><h5 id="①-只含有一个主键"><a href="#①-只含有一个主键" class="headerlink" title="① 只含有一个主键"></a>① 只含有一个主键</h5><p><code>delete from test where id = 10;</code><br>这个毋庸置疑，锁的肯定是主键。在id = 10的记录上加上锁即可。<br><img src="/uploads/2018/11/mysql_index_00.jpg" alt=""></p><h5 id="②-只含有一个唯一键"><a href="#②-只含有一个唯一键" class="headerlink" title="② 只含有一个唯一键"></a>② 只含有一个唯一键</h5><p><code>delete from test where id = 10;</code><br>这个id不是主键，而是一个Unique的二级索引键值。<br><img src="/uploads/2018/11/mysql_index_01.jpg" alt=""><br>由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。</p><blockquote><p>为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p></blockquote><h5 id="③-仅含有一个普通索引"><a href="#③-仅含有一个普通索引" class="headerlink" title="③ 仅含有一个普通索引"></a>③ 仅含有一个普通索引</h5><p><code>delete from test where id = 10;</code><br>相对于前两个的变化，id列上的约束又降低了，id列不再唯一，只有一个普通的索引。<br><img src="/uploads/2018/11/mysql_index_02.jpg" alt=""><br>根据此图，可以看到，首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与②唯一的区别在于，②最多只有一个满足等值查询的记录，而③会将所有满足查询条件的记录都加锁。</p><h5 id="④-即含有唯一键，也含有普通索引"><a href="#④-即含有唯一键，也含有普通索引" class="headerlink" title="④ 即含有唯一键，也含有普通索引"></a>④ 即含有唯一键，也含有普通索引</h5><p>（唯一索引和普通索引都会 加锁，其它地方使用主键加锁，死锁概率会增加）</p><h5 id="⑤-不含有索引-（聚簇索引上全部加锁）"><a href="#⑤-不含有索引-（聚簇索引上全部加锁）" class="headerlink" title="⑤ 不含有索引 （聚簇索引上全部加锁）"></a>⑤ 不含有索引 （聚簇索引上全部加锁）</h5><p><code>delete from test where id = 10;</code><br>(没有索引，只能走聚簇索引，进行全部扫描。)<br>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。<br><img src="/uploads/2018/11/mysql_index_03.jpg" alt=""><br>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。</p><h4 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4. 死锁"></a>4. 死锁</h4><p>死锁是指两个或者多个事务在同一资源上相互作用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。</p><h5 id="（1）互锁"><a href="#（1）互锁" class="headerlink" title="（1）互锁"></a>（1）互锁</h5><p><img src="/uploads/2018/11/mysql_deadlock_01.jpg" alt=""><br>最常见的死锁，每个事务执行两条SQL，分别持有了一把锁，然后加另一把锁，产生死锁。</p><h5 id="（2）数据查询顺序导致加锁"><a href="#（2）数据查询顺序导致加锁" class="headerlink" title="（2）数据查询顺序导致加锁"></a>（2）数据查询顺序导致加锁</h5><p><img src="/uploads/2018/11/mysql_deadlock_02.jpg" alt=""><br>虽然每个Session都只有一条语句，仍旧会产生死锁。要分析这个死锁，首先必须用到本文前面提到的MySQL加锁的规则。针对Session 1，从name索引出发，读到的[hdc, 1]，[hdc, 6]均满足条件，不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10]。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。</p><font color="red">（注：死锁的发生与否，并不在于事务中有多少条SQL语句，死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。）</font>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-新建数据表：&quot;&gt;&lt;a href=&quot;#1-新建数据表：&quot; class=&quot;headerlink&quot; title=&quot;1. 新建数据表：&quot;&gt;&lt;/a&gt;1. 新建数据表：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;| test  | CREATE TABLE `test` (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `name` varchar(50) NOT NULL DEFAULT &amp;apos;&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `age` tinyint(3) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `hobby` varchar(200) NOT NULL DEFAULT &amp;apos;&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (`id`),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UNIQUE KEY `name` (`name`),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY `hobby` (`hobby`)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 |&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>PHP-FPM配置文件详解</title>
    <link href="http://yoursite.com/2018/10/24/PHP-FPM%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/10/24/PHP-FPM配置文件详解/</id>
    <published>2018-10-24T09:15:18.000Z</published>
    <updated>2018-10-24T09:35:04.860Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>过滤php-fpm.conf文件中注释行。<br><code>grep -Env &quot;^$|;&quot; php-fpm.conf</code><br>grep - 过滤命令<br>　　-E - 使用正则表达示进行匹配<br>　　-n - 显示行号<br>　　-v - 剔除匹配的项（默认是筛选匹配的项）<br>　　^ - 开头匹配<br>　　$ - 代表空行<br>　　| - 正则中的或运算<br>　　; - ;开头行</p></blockquote><a id="more"></a><h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[www]</span><br><span class="line">user = www#进程的发起用户和用户组，用户user是必须设置，group不是</span><br><span class="line">group = www</span><br><span class="line">listen = 127.0.0.1:9000#监听ip和端口</span><br><span class="line"></span><br><span class="line">pm = dynamic#选择进程池管理器如何控制子进程的数量</span><br><span class="line">pm.max_children = 5</span><br><span class="line">pm.start_servers = 2</span><br><span class="line">pm.min_spare_servers = 1</span><br><span class="line">pm.max_spare_servers = 3</span><br><span class="line"> </span><br><span class="line">slowlog = /opt/webserver/logs/php/$pool.log.slow #用于记录慢请求</span><br><span class="line">request_slowlog_timeout = 3#慢日志请求超时时间，对一个php程序进行跟踪。</span><br><span class="line">;request_terminate_timeout = 0　　#终止请求超时时间，在worker进程被杀掉之后，提供单个请求的超时间隔。由于某种原因不停止脚本执行时，应该使用该选项，0表示关闭不启用</span><br></pre></td></tr></table></figure><blockquote><p>static： 对于子进程的开启数路给定一个锁定的值(pm.max_children)<br>dynamic： 子进程的数目为动态的，它的数目基于下面的指令的值(以下为dynamic适用参数)<br>　　pm.max_children： 同一时刻能够存货的最大子进程的数量<br>　　pm.start_servers： 在启动时启动的子进程数量<br>　　pm.min_spare_servers： 处于空闲”idle”状态的最小子进程，如果空闲进程数量小于这个值，那么相应的子进程会被创建<br>　　pm.max_spare_servers： 最大空闲子进程数量，空闲子进程数量超过这个值，那么相应的子进程会被杀掉。<br>ondemand： 在启动时不会创建，只有当发起请求链接时才会创建(pm.max_children, pm.process_idle_timeout)</p></blockquote><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>在php-fpm的配置文件中，有两个指令非常重要，就是”pm.max_children” 和 “request_terminate_timeout”</p><p>（1）第一个指令”pm.max_children” 确定了php-fpm的处理能力，原则上时越多越好，但这个是在内存足够打的前提下，每开启一个php-fpm进程要占用近30M左右的内存<br>如果请求访问较多，那么可能会出现502，504错误。对于502错误来说，属于繁忙进程而造成的，对于504来说，就是客户发送的请求在限定的时间内没有得到相应，过多的请求导致“504  Gateway  Time-out”。这里也有可能是服务器带宽问题。</p><p>（2）另外一个需要注意的指令”request_terminate_timeout”，它决定php-fpm进程的连接/发送和读取的时间，如果设置过小很容易出现”502 Bad Gateway” 和 “504  Gateway  Time-out”，默认为0，就是说没有启用，不加限制，但是这种设置前提是你的php-fpm足够健康，这个需要根据实际情况加以限定</p><h4 id="附属PHP-FPM配置文件"><a href="#附属PHP-FPM配置文件" class="headerlink" title="附属PHP-FPM配置文件"></a>附属PHP-FPM配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">pid = run/php-fpm.pid</span><br><span class="line">#pid设置，默认在安装目录中的var/run/php-fpm.pid，建议开启</span><br><span class="line"></span><br><span class="line">error_log = log/php-fpm.log</span><br><span class="line">#错误日志，默认在安装目录中的var/log/php-fpm.log</span><br><span class="line"></span><br><span class="line">log_level = notice</span><br><span class="line">#错误级别. 可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice.</span><br><span class="line"></span><br><span class="line">emergency_restart_threshold = 60</span><br><span class="line">emergency_restart_interval = 60s</span><br><span class="line">#表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。</span><br><span class="line"></span><br><span class="line">process_control_timeout = 0</span><br><span class="line">#设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.</span><br><span class="line"></span><br><span class="line">daemonize = yes</span><br><span class="line">#后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。</span><br><span class="line"></span><br><span class="line">listen = 127.0.0.1:9000</span><br><span class="line">#fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: &apos;ip:port&apos;, &apos;port&apos;, &apos;/path/to/unix/socket&apos;. 每个进程池都需要设置.</span><br><span class="line"></span><br><span class="line">listen.backlog = -1</span><br><span class="line">#backlog数，-1表示无限制，由操作系统决定，此行注释掉就行。backlog含义参考：http://www.3gyou.cc/?p=41</span><br><span class="line"></span><br><span class="line">listen.allowed_clients = 127.0.0.1</span><br><span class="line">#允许访问FastCGI进程的IP，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接</span><br><span class="line"></span><br><span class="line">listen.owner = www</span><br><span class="line">listen.group = www</span><br><span class="line">listen.mode = 0666</span><br><span class="line">#unix socket设置选项，如果使用tcp方式访问，这里注释即可。</span><br><span class="line"></span><br><span class="line">user = www</span><br><span class="line">group = www</span><br><span class="line">#启动进程的帐户和组</span><br><span class="line"></span><br><span class="line">pm = dynamic #对于专用服务器，pm可以设置为static。</span><br><span class="line">#如何控制子进程，选项有static和dynamic。如果选择static，则由pm.max_children指定固定的子进程数。如果选择dynamic，则由下开参数决定：</span><br><span class="line">pm.max_children #，子进程最大数</span><br><span class="line">pm.start_servers #，启动时的进程数</span><br><span class="line">pm.min_spare_servers #，保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程</span><br><span class="line">pm.max_spare_servers #，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理</span><br><span class="line"></span><br><span class="line">pm.max_requests = 1000</span><br><span class="line">#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 &apos;0&apos; 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.</span><br><span class="line"></span><br><span class="line">pm.status_path = /status</span><br><span class="line">#FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到</span><br><span class="line"></span><br><span class="line">ping.path = /ping</span><br><span class="line">#FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。</span><br><span class="line"></span><br><span class="line">ping.response = pong</span><br><span class="line">#用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong.</span><br><span class="line"></span><br><span class="line">request_terminate_timeout = 0</span><br><span class="line">#设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的&apos;max_execution_time&apos;因为某些特殊原因没有中止运行的脚本有用. 设置为 &apos;0&apos; 表示 &apos;Off&apos;.当经常出现502错误时可以尝试更改此选项。</span><br><span class="line"></span><br><span class="line">request_slowlog_timeout = 10s</span><br><span class="line">#当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 &apos;0&apos; 表示 &apos;Off&apos;</span><br><span class="line"></span><br><span class="line">slowlog = log/$pool.log.slow</span><br><span class="line">#慢请求的记录日志,配合request_slowlog_timeout使用</span><br><span class="line"></span><br><span class="line">rlimit_files = 1024</span><br><span class="line">#设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。</span><br><span class="line"></span><br><span class="line">rlimit_core = 0</span><br><span class="line">#设置核心rlimit最大限制值. 可用值: &apos;unlimited&apos; 、0或者正整数. 默认值: 系统定义值.</span><br><span class="line"></span><br><span class="line">chroot =</span><br><span class="line">#启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用.</span><br><span class="line"></span><br><span class="line">chdir =</span><br><span class="line">#设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时）</span><br><span class="line"></span><br><span class="line">catch_workers_output = yes</span><br><span class="line">#重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;过滤php-fpm.conf文件中注释行。&lt;br&gt;&lt;code&gt;grep -Env &amp;quot;^$|;&amp;quot; php-fpm.conf&lt;/code&gt;&lt;br&gt;grep - 过滤命令&lt;br&gt;　　-E - 使用正则表达示进行匹配&lt;br&gt;　　-n - 显示行号&lt;br&gt;　　-v - 剔除匹配的项（默认是筛选匹配的项）&lt;br&gt;　　^ - 开头匹配&lt;br&gt;　　$ - 代表空行&lt;br&gt;　　| - 正则中的或运算&lt;br&gt;　　; - ;开头行&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="PHP-FPM" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/PHP-FPM/"/>
    
    
      <category term="PHP-FPM" scheme="http://yoursite.com/tags/PHP-FPM/"/>
    
  </entry>
  
  <entry>
    <title>INI配置文件的格式</title>
    <link href="http://yoursite.com/2018/10/24/INI%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/24/INI配置文件的格式/</id>
    <published>2018-10-24T09:14:55.000Z</published>
    <updated>2018-10-24T09:26:34.226Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习Go语言的时候，发现好多Go框架中的配置文件都支持INI格式的。当然，不仅仅是Go框架，PHP语言的好多框架也使用INI格式的配置文件，例如Yaf等。因此，需要梳理一下INI格式。常用的配置文件格式还有很多，如XML配置文件等。<br><a id="more"></a></p><blockquote><p>在早期的windows桌面系统中主要是用INI文件作为系统的配置文件，从win95以后开始转向使用注册表，但是还有很多系统配置是使用INI文件的。其实INI文件就是简单的text文件，只不过这种txt文件要遵循一定的INI文件格式。现在的WINCE系统上也常常用INI文件作为配置文件。“.INI ”就是英文 “initialization”的头三个字母的缩写；当然INI file的后缀名也不一定是”.ini”也可以是”.cfg”，”.conf ”或者是”.txt”。</p></blockquote><h4 id="INI文件由节、键、值组成"><a href="#INI文件由节、键、值组成" class="headerlink" title="INI文件由节、键、值组成"></a>INI文件由节、键、值组成</h4><p><strong>节</strong><br>　　[section]  </p><p><strong>参数（键=值） </strong><br>　　name=value</p><p><strong>注解</strong><br>　　注解使用分号表示（;）。在分号后面的文字，直到该行结尾都全部为注解。</p><font color="red">INI文件的格式很简单，最基本的三个要素是：parameters，sections和comments。</font><h4 id="什么是parameters？"><a href="#什么是parameters？" class="headerlink" title="什么是parameters？"></a>什么是parameters？</h4><p>INI所包含的最基本的“元素”就是parameter；每一个parameter都有一个name和一个value，name和value是由等号“=”隔开。name在等号的左边。<br>如：<br>　　name = value</p><h4 id="什么是sections-？"><a href="#什么是sections-？" class="headerlink" title="什么是sections ？"></a>什么是sections ？</h4><p>所有的parameters都是以sections为单位结合在一起的。所有的section名称都是独占一行，并且sections名字都被方括号包围着（[ and ])。在section声明后的所有parameters都是属于该section。对于一个section没有明显的结束标志符，一个section的开始就是上一个section的结束，或者是end of the file。Sections一般情况下不能被nested，当然特殊情况下也可以实现sections的嵌套。<br>section如下所示：<br>　　[section]</p><h4 id="什么是comments-？"><a href="#什么是comments-？" class="headerlink" title="什么是comments ？"></a>什么是comments ？</h4><p>在INI文件中注释语句是以分号“；”开始的。所有的所有的注释语句不管多长都是独占一行直到结束的。在分号和行结束符之间的所有内容都是被忽略的。<br>注释实例如下：<br>;comments text</p><p>当然，上面讲的都是最经典的INI文件格式，随着使用的需求INI文件的格式也出现了很多变种；</p><h4 id="INI实例"><a href="#INI实例" class="headerlink" title="INI实例"></a>INI实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; last modified 1 April 2001 by John Doe</span><br><span class="line">[owner]</span><br><span class="line">name = John Doe</span><br><span class="line">organization = Acme Products</span><br><span class="line"></span><br><span class="line">[database]</span><br><span class="line">server=192.0.2.42</span><br><span class="line">; use IP address in case network name resolution is not working</span><br><span class="line">port=143</span><br><span class="line">file = &quot;acme payroll.dat&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习Go语言的时候，发现好多Go框架中的配置文件都支持INI格式的。当然，不仅仅是Go框架，PHP语言的好多框架也使用INI格式的配置文件，例如Yaf等。因此，需要梳理一下INI格式。常用的配置文件格式还有很多，如XML配置文件等。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码499解析</title>
    <link href="http://yoursite.com/2018/10/24/HTTP%E7%8A%B6%E6%80%81%E7%A0%81499%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/10/24/HTTP状态码499解析/</id>
    <published>2018-10-24T09:13:51.000Z</published>
    <updated>2018-10-24T09:32:04.934Z</updated>
    
    <content type="html"><![CDATA[<p>日志记录中HTTP状态码出现499错误有多种情况，我遇到的一种情况是nginx反代到一个永远打不开的后端，就这样了，日志状态记录是499、发送字节数是0。</p><p>499错误是什么？让我们看看NGINX的源码中的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx_string(ngx_http_error_495_page), /* 495, https certificate error */</span><br><span class="line">ngx_string(ngx_http_error_496_page), /* 496, https no certificate */</span><br><span class="line">ngx_string(ngx_http_error_497_page), /* 497, http to https */</span><br><span class="line">ngx_string(ngx_http_error_404_page), /* 498, canceled */</span><br><span class="line">ngx_null_string,                    /* 499, client has closed connection */</span><br></pre></td></tr></table></figure></p><p>可以看到，499对应的是 “client has closed connection”。这很有可能是因为服务器端处理的时间过长，客户端“不耐烦”了。<br><a id="more"></a></p><p><strong>Nginx 499错误的原因及解决方法</strong><br>打开Nginx的access.log发现在最后一次的提交是出现了HTTP1.1 499 0 -这样的错误，在百度搜索nginx 499错误，结果都是说客户端主动断开了连接。</p><p>但经过我的测试这显然不是客户端的问题，因为使用端口+IP直接访问后端服务器不存在此问题，后来测试nginx发现如果两次提交post过快就会出现499的情况，看来是nginx认为是不安全的连接，主动拒绝了客户端的连接.</p><p>但搜索相关问题一直找不到解决方法，最后终于在google上搜索到一英文论坛上有关于此错误的解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_ignore_client_abort on;</span><br><span class="line">Don’t know if this is safe.</span><br></pre></td></tr></table></figure></p><p>就是说要配置参数 proxy_ignore_client_abort on;<br>表示代理服务端不要主要主动关闭客户端连接。</p><p>以此配置重启nginx,问题果然得到解决。只是安全方面稍有欠缺，但比总是出现找不到服务器好多了。</p><p>还有一种原因是 我后来测试发现 确实是客户端关闭了连接,或者说连接超时 ,无论你设置多少超时时间多没用 原来是php进程不够用了 改善一下php进程数 问题解决 默认测试环境才开5个子进程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志记录中HTTP状态码出现499错误有多种情况，我遇到的一种情况是nginx反代到一个永远打不开的后端，就这样了，日志状态记录是499、发送字节数是0。&lt;/p&gt;
&lt;p&gt;499错误是什么？让我们看看NGINX的源码中的定义：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ngx_string(ngx_http_error_495_page), /* 495, https certificate error */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ngx_string(ngx_http_error_496_page), /* 496, https no certificate */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ngx_string(ngx_http_error_497_page), /* 497, http to https */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ngx_string(ngx_http_error_404_page), /* 498, canceled */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ngx_null_string,                    /* 499, client has closed connection */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到，499对应的是 “client has closed connection”。这很有可能是因为服务器端处理的时间过长，客户端“不耐烦”了。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Shell常用知识点总结</title>
    <link href="http://yoursite.com/2018/10/23/Shell%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/10/23/Shell常用知识点总结/</id>
    <published>2018-10-23T10:42:55.000Z</published>
    <updated>2018-10-23T10:49:08.709Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、整型变量自增的几种方法"><a href="#1、整型变量自增的几种方法" class="headerlink" title="1、整型变量自增的几种方法"></a>1、整型变量自增的几种方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line">a=$(($a+1))</span><br><span class="line">a=$[$a+1]</span><br><span class="line">a=`expr $a + 1`</span><br><span class="line">let a++</span><br><span class="line">let a+=1</span><br><span class="line">((a++))</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2、读取文件中的内容"><a href="#2、读取文件中的内容" class="headerlink" title="2、读取文件中的内容"></a>2、读取文件中的内容</h4><p>（1）直接读取对应文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">      echo $line     #这里可根据实际用途变化</span><br><span class="line">done &lt; urfile</span><br></pre></td></tr></table></figure></p><p>（2）使用管道符形式读取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">cat urfile | while read line</span><br><span class="line">do</span><br><span class="line">    echo $line</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>（注意：以上代码中urfile 为被读取的文件）</p><p>（3）将文件赋值给变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">last | while read wOne wTwo wThree</span><br><span class="line">do</span><br><span class="line">echo $wOne&quot;,&quot;$wTwo&quot;,&quot;$wThree</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h4 id="3、判断文件是否为空"><a href="#3、判断文件是否为空" class="headerlink" title="3、判断文件是否为空"></a>3、判断文件是否为空</h4><p><code>if [[ ! -s filename ]]</code> # 如果文件存在且为空，-s代表存在不为空，！将它取反</p><h4 id="4、比较两个字符串的大小"><a href="#4、比较两个字符串的大小" class="headerlink" title="4、比较两个字符串的大小"></a>4、比较两个字符串的大小</h4><p>&lt;    小于，在ASCII字母顺序下，如：<br>    <code>if [[ &quot;$a&quot; &lt; &quot;$b&quot; ]]</code><br>    <code>if [ &quot;$a&quot; \&lt; &quot;$b&quot; ]</code><br>&#60;    大于，在ASCII字母顺序下，如：<br>    <code>if [[ &quot;$a&quot; &gt; &quot;$b&quot; ]]</code><br>    <code>if [ &quot;$a&quot; \&gt; &quot;$b&quot; ]</code><br>注意：在[]结构中”&gt;”需要被转义。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、整型变量自增的几种方法&quot;&gt;&lt;a href=&quot;#1、整型变量自增的几种方法&quot; class=&quot;headerlink&quot; title=&quot;1、整型变量自增的几种方法&quot;&gt;&lt;/a&gt;1、整型变量自增的几种方法&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a=$(($a+1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a=$[$a+1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a=`expr $a + 1`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let a++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let a+=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;((a++))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
</feed>
