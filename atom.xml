<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-14T10:49:54.541Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 详解之常用命令汇总（四）</title>
    <link href="http://yoursite.com/2018/03/14/Git-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/14/Git-详解之常用命令汇总（四）/</id>
    <published>2018-03-14T09:48:01.000Z</published>
    <updated>2018-03-14T10:49:54.541Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Git提交三步走："><a href="#Git提交三步走：" class="headerlink" title="Git提交三步走："></a>Git提交三步走：</h4><p>（1）git add xx<br>git add xx命令可以将xx文件添加到暂存区，如果有很多改动可以通过 git add -A .来一次添加所有改变的文件。<br>注意 -A 选项后面还有一个句点。 git add -A表示添加所有内容， git add . 表示添加新文件和编辑过的文件不包括删除的文件; git add -u 表示添加编辑或者删除的文件，不包括新添加的文件<br>（2）git commit -m “注释”<br>（3）git push origin 分支名称，一般使用：git push origin master</p><p>正常来说，这三步基本满足需求了。<br><a id="more"></a></p><h4 id="下面进行命令的详细介绍"><a href="#下面进行命令的详细介绍" class="headerlink" title="下面进行命令的详细介绍"></a>下面进行命令的详细介绍</h4><p><code>git checkout</code>  查看当前分支</p><p><code>git branch name</code>  新建分支name<br><code>git checkout name</code>  切换当前分支为name</p><p><font color="red">合并语句：</font><code>git checkout -b name</code>  新建分支并切换到分支name</p><p><code>git add filename</code>  增加文件到分支<br><code>git commit -m &quot;remark&quot;</code>  提交修改内容到分支并添加注释</p><p><font color="red">合并语句：</font><code>git commit -m &quot;remark&quot; filename</code></p><p><code>git diff filename</code>  查看文件修改了什么内容</p><p><code>git status</code>  查看当前工作区状态</p><p><code>git checkout master</code><br><code>git merge name</code>  合并分支到master分支</p><p><code>git branch -d name</code>  删除name分支</p><p><code>git log --graph --pretty=oneline --abbrev-commit</code>  用git log查看分支历史</p><h4 id="特殊需求详解："><a href="#特殊需求详解：" class="headerlink" title="特殊需求详解："></a>特殊需求详解：</h4><h5 id="1、合并文件："><a href="#1、合并文件：" class="headerlink" title="1、合并文件："></a>1、合并文件：</h5><p><code>git merge name</code> 这种合并 Git会优先选择 Fast forward模式，这种模式下，删除分支后，会丢掉分支信息<br>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样从分支历史上就可以看出来分支信息。<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>  合并分支dev并禁用Fast forward模式 </p><h5 id="2、冲突解决："><a href="#2、冲突解决：" class="headerlink" title="2、冲突解决："></a>2、冲突解决：</h5><p>① 手动修改冲突文件并再次提交<br>打开产生冲突的文件后，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，>>>>>>>标记出不同分支的内容，其中<code>&lt;&lt;&lt;HEAD</code>是指主分支修改的内容，<code>&gt;&gt;&gt;&gt;&gt;fenzhi1</code> 是指fenzhi1上修改的内容，我们可以修改后保存即解决冲突。</p><h5 id="3、版本回退："><a href="#3、版本回退：" class="headerlink" title="3、版本回退："></a>3、版本回退：</h5><p>（1）使用<code>HEAD^</code>回退版本，<code>HEAD^</code>回退上个版本，<code>HEAD^^</code>回退上上个版本，以此类推。如果回退前100个版本的话，使用<code>HEAD~100</code>即可。<br><code>git reset --hard HEAD^</code><br><code>git reset --hard HEAD~100</code></p><p>（2）使用commit_id回退版本<br><code>git log</code> 查看需要回退的 commit_id<br><code>git reflog</code> 查看未来版本的 commit_id<br><code>git reset --hard commit_id</code><br>（注：这个回退可以回到以前版本，也可回到未来版本，只要知道commit_id即可）</p><h5 id="4、撤销修改："><a href="#4、撤销修改：" class="headerlink" title="4、撤销修改："></a>4、撤销修改：</h5><p>在工作区：（就是开发环境本地）<br><code>git checkout -- file</code>  可以丢弃工作区的修改。<strong>（注：如果没有 -- 的话，那么命令就变成创建分支了。）</strong></p><p>在暂存区：（已经 git add了）<br><code>git reset HEAD file</code>  可以把暂存区的修改撤销掉，重新放回到工作区</p><p>在本地版本中：（已经提交到分支）<br>只能版本回退了</p><h5 id="5、删除文件："><a href="#5、删除文件：" class="headerlink" title="5、删除文件："></a>5、删除文件：</h5><p>工作区删除：<br><code>rm file</code><br>工作区删除后文件恢复：<br><code>git checkout -- file</code><br>版本库删除：<br><code>git rm file</code><br><code>git commit -m &#39;remark&#39;</code><br>（注：删除后必须得提交更新版本库）</p><h5 id="6、BUG分支"><a href="#6、BUG分支" class="headerlink" title="6、BUG分支"></a>6、BUG分支</h5><p><code>git stash</code>  把当前工作现场“储藏”起来，等以后恢复现场后继续工作<br><code>git stash list</code>  查看工作现场存储到什么地方<br><code>git stash apply</code>  恢复，但stash内容并不删除<br><code>git stash pop</code>  恢复，但同时把stash内容也删除</p><h5 id="7、多人协作"><a href="#7、多人协作" class="headerlink" title="7、多人协作"></a>7、多人协作</h5><p><code>git remote</code>  查看远程库的信息 -v 更详细信息<br>推送分支： 就是把该分支上的所有本地提交推送到远程库。<br><code>git push origin master</code><br>抓取分支：把线上最新的提交抓下来<br><code>git pull</code></p><h4 id="工作模式通常是这样："><a href="#工作模式通常是这样：" class="headerlink" title="工作模式通常是这样："></a>工作模式通常是这样：</h4><p>1、首先，可以试图用git push origin branch-name推送自己的修改；<br>2、如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；<br>3、如果合并有冲突，则解决冲突，并在本地提交；<br>4、没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！<br>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。<br>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Git提交三步走：&quot;&gt;&lt;a href=&quot;#Git提交三步走：&quot; class=&quot;headerlink&quot; title=&quot;Git提交三步走：&quot;&gt;&lt;/a&gt;Git提交三步走：&lt;/h4&gt;&lt;p&gt;（1）git add xx&lt;br&gt;git add xx命令可以将xx文件添加到暂存区，如果有很多改动可以通过 git add -A .来一次添加所有改变的文件。&lt;br&gt;注意 -A 选项后面还有一个句点。 git add -A表示添加所有内容， git add . 表示添加新文件和编辑过的文件不包括删除的文件; git add -u 表示添加编辑或者删除的文件，不包括新添加的文件&lt;br&gt;（2）git commit -m “注释”&lt;br&gt;（3）git push origin 分支名称，一般使用：git push origin master&lt;/p&gt;
&lt;p&gt;正常来说，这三步基本满足需求了。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 详解之客户端安装（三）</title>
    <link href="http://yoursite.com/2018/03/14/Git-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/14/Git-详解之客户端安装（三）/</id>
    <published>2018-03-14T09:47:43.000Z</published>
    <updated>2018-03-14T10:00:45.155Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Linux下安装"><a href="#一、Linux下安装" class="headerlink" title="一、Linux下安装"></a>一、Linux下安装</h4><p>首先，你可以试着输入git，看看系统有没有安装Git：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program &apos;git&apos; is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p><p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。<br>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。<br><a id="more"></a></p><p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code> 这几个命令安装就好了。</p><h4 id="二、windows下安装"><a href="#二、windows下安装" class="headerlink" title="二、windows下安装"></a>二、windows下安装</h4><p>windows下客户端分为两种：<br>（1）Git客户端程序。<br>　　Git目前最新版本2.16.2<br>　　Git官网下载地址：<a href="http://git-scm.com/" target="_blank" rel="noopener"><font color="red">传送门</font></a><br>（2）Git客户端图形化操作程序 TortoiseGit。<br>　　TortoiseGit目前最新版本2.6.0<br>　　TortoiseGit官网下载地址：<a href="http://tortoisegit.org/download/" target="_blank" rel="noopener"><font color="red">传送门</font></a></p><p>安装过程可以按照程序的默认选项，都选择“下一步”安装完成。</p><p><strong>下面以 Git客户端程序为例来安装：</strong></p><blockquote><p>1.双击安装程序“Git-2.10.2-64-bit.exe”<br>2.点击“Next” ，根据自己的情况，选择程序的安装目录。<br>3.继续点击“Next”，显示截图如下：<br><img src="/uploads/2018/03/git_image_01.jpg" alt=""><br><strong>说明：</strong><br>（1）图标组件(Addition icons) : 选择是否创建桌面快捷方式。<br>（2）桌面浏览(Windows Explorer integration) : 浏览源码的方法，使用bash 或者 使用Git GUI工具。<br>（3）关联配置文件 : 是否关联 git 配置文件, 该配置文件主要显示文本编辑器的样式。<br>（4）关联shell脚本文件 : 是否关联Bash命令行执行的脚本文件。<br>（5）使用TrueType编码 : 在命令行中是否使用TruthType编码, 该编码是微软和苹果公司制定的通用编码。<br>4.选择完之后，点击“Next”，开始菜单快捷方式目录：设置开始菜单中快捷方式的目录名称, 也可以选择不在开始菜单中创建快捷方式。<br>5.点击“Next”，显示截图如下：<br><img src="/uploads/2018/03/git_image_02.jpg" alt=""><br><strong>设置环境变量</strong><br>选择使用什么样的命令行工具，一般情况下我们默认使用Git Bash即可：<br>（1）Git自带：使用Git自带的Git Bash命令行工具。<br>（2）系统自带CMD：使用Windows系统的命令行工具。<br>（3）二者都有：上面二者同时配置，但是注意，这样会将windows中的find.exe 和 sort.exe工具覆盖，如果不懂这些尽量不要选择。<br>6.选择之后，继续点击“Next”，显示如下：<br><img src="/uploads/2018/03/git_image_03.jpg" alt=""><br><strong>选择提交的时候换行格式</strong><br>（1）检查出windows格式转换为unix格式：将windows格式的换行转为unix格式的换行再进行提交。<br>（2）检查出原来格式转为unix格式：不管什么格式的，一律转为unix格式的换行再进行提交。<br>（3）不进行格式转换 : 不进行转换，检查出什么，就提交什么。<br>7.选择之后，点击“Next”<br>8.选择之后，点击“Next”<br>9.选择之后，点击“Install”，开始安装</p></blockquote><p>这样，我们的Git客户端就安装完成了。</p><p>安装完成后，在开始菜单里面能够找到 “Git –&gt; Git Bash”,如下：<br><img src="/uploads/2018/03/git_image_04.JPG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、Linux下安装&quot;&gt;&lt;a href=&quot;#一、Linux下安装&quot; class=&quot;headerlink&quot; title=&quot;一、Linux下安装&quot;&gt;&lt;/a&gt;一、Linux下安装&lt;/h4&gt;&lt;p&gt;首先，你可以试着输入git，看看系统有没有安装Git：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The program &amp;apos;git&amp;apos; is currently not installed. You can install it by typing:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。&lt;br&gt;如果你碰巧用Debian或Ubuntu Linux，通过一条&lt;code&gt;sudo apt-get install git&lt;/code&gt;就可以直接完成Git的安装，非常简单。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 详解之服务器搭建（二）</title>
    <link href="http://yoursite.com/2018/03/14/Git-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/14/Git-详解之服务器搭建（二）/</id>
    <published>2018-03-14T09:46:31.000Z</published>
    <updated>2018-03-14T10:03:34.793Z</updated>
    
    <content type="html"><![CDATA[<p>参考博文：<a href="https://www.cnblogs.com/dee0912/p/5815267.html" target="_blank" rel="noopener">https://www.cnblogs.com/dee0912/p/5815267.html</a><br><a href="https://www.cnblogs.com/lxmhhy/p/6038243.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxmhhy/p/6038243.html</a></p><p>服务器环境：CentOS7 + Git(version 1.8.3.1)</p><h4 id="1、安装Git"><a href="#1、安装Git" class="headerlink" title="1、安装Git"></a>1、安装Git</h4><p>　　<code>yum install -y git</code><br>安装完后，查看 Git 版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# git version</span><br><span class="line">git version 1.8.3.1</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="2、新建Git账号，用来管理Git服务"><a href="#2、新建Git账号，用来管理Git服务" class="headerlink" title="2、新建Git账号，用来管理Git服务"></a>2、新建Git账号，用来管理Git服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# id git</span><br><span class="line">id: git：无此用户</span><br><span class="line">[root@VM_0_7_centos ~]# useradd git</span><br><span class="line">[root@VM_0_7_centos ~]# passwd git</span><br></pre></td></tr></table></figure><h4 id="3、服务器端创建Git仓库"><a href="#3、服务器端创建Git仓库" class="headerlink" title="3、服务器端创建Git仓库"></a>3、服务器端创建Git仓库</h4><p>设置 /data/git/gittest.git 为 Git 仓库<br>然后把 Git 仓库的 owner 修改为 git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# mkdir -p /data/git/gittest.git</span><br><span class="line">[root@VM_0_7_centos ~]# git init --bare /data/git/gittest.git</span><br><span class="line">Initialized empty Git repository in /data/git/gittest.git/</span><br><span class="line">[root@VM_0_7_centos ~]# cd /data/git/</span><br><span class="line">[root@VM_0_7_centos git]# chown -R git:git gittest.git/</span><br></pre></td></tr></table></figure></p><h4 id="4、客户端首次-clone-远程仓库"><a href="#4、客户端首次-clone-远程仓库" class="headerlink" title="4、客户端首次 clone 远程仓库"></a>4、客户端首次 clone 远程仓库</h4><p>进入 Git Bash 命令行客户端，创建项目地址（设置在 d:/wamp64/www/gittest_gitbash）并进入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dee@Lenovo-PC MINGW64 /d</span><br><span class="line">$ cd wamp64/www</span><br><span class="line"></span><br><span class="line">dee@Lenovo-PC MINGW64 /d/wamp64/www</span><br><span class="line">$ mkdir gittest_gitbash</span><br><span class="line"></span><br><span class="line">dee@Lenovo-PC MINGW64 /d/wamp64/www</span><br><span class="line">$ cd gittest_gitbash</span><br><span class="line"></span><br><span class="line">dee@Lenovo-PC MINGW64 /d/wamp64/www/gittest_gitbash</span><br></pre></td></tr></table></figure></p><p>然后从 Linux Git 服务器上 clone 项目：<br><code>$ git clone git@192.168.56.101:/home/data/gittest.git</code></p><p>如果SSH用的不是默认的22端口，则需要使用以下的命令（假设SSH端口号是7700）：<br><code>$ git clone ssh://git@192.168.56.101:7700/home/data/gittest.git</code></p><p>当第一次连接到目标 Git 服务器时会得到一个提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;192.168.56.101 (192.168.56.101)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:Ve6WV/SCA059EqoUOzbFoZdfmMh3B259nigfmvdadqQ.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p><p>选择 yes：<br><code>Warning: Permanently added &#39;192.168.56.101&#39; (RSA) to the list of known hosts.</code><br>此时 C:\Users\用户名\.ssh 下会多出一个文件 known_hosts，以后在这台电脑上再次连接目标 Git 服务器时不会再提示上面的语句。</p><p>后面提示要输入密码，可以采用 SSH 公钥来进行验证。</p><h4 id="5、服务器端Git打开RSA认证"><a href="#5、服务器端Git打开RSA认证" class="headerlink" title="5、服务器端Git打开RSA认证"></a>5、服务器端Git打开RSA认证</h4><p>进入 /etc/ssh 目录，编辑 sshd_config，打开以下三个配置的注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure></p><p>保存并重启 sshd 服务：<br><code>[root@localhost ssh]# /etc/rc.d/init.d/sshd restart</code></p><p>由 AuthorizedKeysFile 得知公钥的存放路径是 .ssh/authorized_keys，实际上是 $Home/.ssh/authorized_keys，由于管理 Git 服务的用户是 git，所以实际存放公钥的路径是 /home/git/.ssh/authorized_keys</p><p>在 /home/git/ 下创建目录 .ssh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost git]# pwd</span><br><span class="line">/home/git</span><br><span class="line">[root@localhost git]# mkdir .ssh</span><br><span class="line">[root@localhost git]# ls -a </span><br><span class="line">. .. .bash_logout .bash_profile .bashrc .gnome2 .mozilla .ssh</span><br></pre></td></tr></table></figure></p><p>然后把 .ssh 文件夹的 owner 修改为 git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost git]# chown -R git:git .ssh</span><br><span class="line">[root@localhost git]# ll -a</span><br><span class="line">总用量 32</span><br><span class="line">drwx------. 5 git  git  4096 8月  28 20:04 .</span><br><span class="line">drwxr-xr-x. 8 root root 4096 8月  28 19:32 ..</span><br><span class="line">-rw-r--r--. 1 git  git    18 10月 16 2014 .bash_logout</span><br><span class="line">-rw-r--r--. 1 git  git   176 10月 16 2014 .bash_profile</span><br><span class="line">-rw-r--r--. 1 git  git   124 10月 16 2014 .bashrc</span><br><span class="line">drwxr-xr-x. 2 git  git  4096 11月 12 2010 .gnome2</span><br><span class="line">drwxr-xr-x. 4 git  git  4096 5月   8 12:22 .mozilla</span><br><span class="line">drwxr-xr-x. 2 git  git  4096 8月  28 20:08 .ssh</span><br></pre></td></tr></table></figure></p><h4 id="6、客户端创建SSH公钥和私钥并将公钥导入服务器端"><a href="#6、客户端创建SSH公钥和私钥并将公钥导入服务器端" class="headerlink" title="6、客户端创建SSH公钥和私钥并将公钥导入服务器端"></a>6、客户端创建SSH公钥和私钥并将公钥导入服务器端</h4><p><code>$ ssh-keygen -t rsa</code><br>此时 C:\Users\用户名\.ssh 下会多出两个文件 id_rsa 和 id_rsa.pub</p><blockquote><p>id_rsa 是私钥<br>id_rsa.pub 是公钥</p></blockquote><p>回到 Git Bash 下，导入文件：<br><code>$ ssh git@192.168.56.101 &#39;cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></p><p>需要输入服务器端 git 用户的密码</p><p>回到服务器端，查看 .ssh 下是否存在 authorized_keys 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost git]# cd .ssh</span><br><span class="line">[root@localhost .ssh]# ll</span><br><span class="line">总用量 4</span><br><span class="line">-rw-rw-r--. 1 git git 398 8月  28 20:08 authorized_keys</span><br></pre></td></tr></table></figure></p><p>可以查看一下是否是客户端生成的公钥。</p><blockquote><font color="red">重要：<br>修改 .ssh 目录的权限为 700<br>修改 .ssh/authorized_keys 文件的权限为 600</font></blockquote><h4 id="7、客户端再次-clone-远程仓库"><a href="#7、客户端再次-clone-远程仓库" class="headerlink" title="7、客户端再次 clone 远程仓库"></a>7、客户端再次 clone 远程仓库</h4><p><code>$ git clone git@192.168.56.101:/home/data/git/gittest.git</code><br>查看客户端项目目录：<br>项目已经 clone 了。</p><h4 id="8、禁止-Git-用户-SSH-登录服务器"><a href="#8、禁止-Git-用户-SSH-登录服务器" class="headerlink" title="8、禁止 Git 用户 SSH 登录服务器"></a>8、禁止 Git 用户 SSH 登录服务器</h4><p>编辑 /etc/passwd<br>找到：<br><code>git:x:502:504::/home/git:/bin/bash</code><br>修改为<br><code>git:x:502:504::/home/git:/bin/git-shell</code><br>此时 git 用户可以正常通过 ssh 使用 git，但无法通过 ssh 登录系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考博文：&lt;a href=&quot;https://www.cnblogs.com/dee0912/p/5815267.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/dee0912/p/5815267.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/lxmhhy/p/6038243.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/lxmhhy/p/6038243.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;服务器环境：CentOS7 + Git(version 1.8.3.1)&lt;/p&gt;
&lt;h4 id=&quot;1、安装Git&quot;&gt;&lt;a href=&quot;#1、安装Git&quot; class=&quot;headerlink&quot; title=&quot;1、安装Git&quot;&gt;&lt;/a&gt;1、安装Git&lt;/h4&gt;&lt;p&gt;　　&lt;code&gt;yum install -y git&lt;/code&gt;&lt;br&gt;安装完后，查看 Git 版本&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@VM_0_7_centos ~]# git version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git version 1.8.3.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 详解之协议篇（一）</title>
    <link href="http://yoursite.com/2018/03/14/Git-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%8D%8F%E8%AE%AE%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/14/Git-详解之协议篇（一）/</id>
    <published>2018-03-14T09:46:12.000Z</published>
    <updated>2018-03-14T09:49:45.261Z</updated>
    
    <content type="html"><![CDATA[<p><strong>协议</strong><br>Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。下面分别介绍一下哪些情形应该使用（或避免使用）这些协议。</p><p>值得注意的是，除了 HTTP 协议外，其他所有协议都要求在服务器端安装并运行 Git。<br><a id="more"></a></p><h4 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h4><p>最基本的就是本地协议（Local protocol），所谓的远程仓库在该协议中的表示，就是硬盘上的另一个目录。这常见于团队每一个成员都对一个共享的文件系统（例如 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。后面一种情况并不安全，因为所有代码仓库实例都储存在同一台电脑里，增加了灾难性数据损失的可能性。</p><p>如果你使用一个共享的文件系统，就可以在一个本地文件系统中克隆仓库，推送和获取。克隆的时候只需要将远程仓库的路径作为 URL 使用，比如下面这样：<br>　　<code>$ git clone /opt/git/project.git</code></p><p>要添加一个本地仓库作为现有 Git 项目的远程仓库，可以这样做：<br>　　<code>$ git remote add local_proj /opt/git/project.git</code></p><p>然后就可以像在网络上一样向这个远程仓库推送和获取数据了。</p><h4 id="SSH-协议（推荐）"><a href="#SSH-协议（推荐）" class="headerlink" title="SSH 协议（推荐）"></a>SSH 协议<font color="red">（推荐）</font></h4><p>Git 使用的传输协议中最常见的可能就是 SSH 了。这是因为大多数环境已经支持通过 SSH 对服务器的访问 — 即便还没有，架设起来也很容易。SSH 也是唯一一个同时支持读写操作的网络协议。另外两个网络协议（HTTP 和 Git）通常都是只读的，所以虽然二者对大多数人都可用，但执行写操作时还是需要 SSH。SSH 同时也是一个验证授权的网络协议；而因为其普遍性，一般架设和使用都很容易。</p><p>通过 SSH 克隆一个 Git 仓库，你可以像下面这样给出 ssh:// 的 URL：<br>　　<code>$ git clone ssh://user@server/project.git</code></p><p>或者不指明某个协议 — 这时 Git 会默认使用 SSH ：<br>　　<code>$ git clone user@server:project.git</code></p><p>（注：SSH 的限制在于你不能通过它实现仓库的匿名访问。即使仅为读取数据，人们也必须在能通过 SSH 访问主机的前提下才能访问仓库，这使得 SSH 不利于开源的项目。如果你仅仅在公司网络里使用，SSH 可能是你唯一需要使用的协议。）</p><h4 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h4><p>接下来是 Git 协议。这是一个包含在 Git 软件包中的特殊守护进程； 它会监听一个提供类似于 SSH 服务的特定端口（9418），而无需任何授权。打算支持 Git 协议的仓库，需要先创建 git-daemon-export-ok 文件 — 它是协议进程提供仓库服务的必要条件 — 但除此之外该服务没有什么安全措施。要么所有人都能克隆 Git 仓库，要么谁也不能。这也意味着该协议通常不能用来进行推送。你可以允许推送操作；然而由于没有授权机制，一旦允许该操作，网络上任何一个知道项目 URL 的人将都有推送权限。不用说，这是十分罕见的情况。</p><p>（注：Git 协议是现存最快的传输协议。如果你在提供一个有很大访问量的公共项目，或者一个不需要对读操作进行授权的庞大项目，架设一个 Git 守护进程来供应仓库是个不错的选择。Git 协议消极的一面是缺少授权机制。用 Git 协议作为访问项目的唯一方法通常是不可取的。一般的做法是，同时提供 SSH 接口，让几个开发者拥有推送（写）权限，其他人通过 git:// 拥有只读权限。 Git 协议可能也是最难架设的协议。）</p><h4 id="HTTP-S-协议"><a href="#HTTP-S-协议" class="headerlink" title="HTTP/S 协议"></a>HTTP/S 协议</h4><p>最后还有 HTTP 协议。HTTP 或 HTTPS 协议的优美之处在于架设的简便性。基本上，只需要把 Git 的裸仓库文件放在 HTTP 的根目录下，配置一个特定的 post-update 挂钩（hook）就可以搞定（Git 挂钩的细节见第 7 章）。此后，每个能访问 Git 仓库所在服务器上 web 服务的人都可以进行克隆操作。下面的操作可以允许通过 HTTP 对仓库进行读取：</p><p>$ cd /var/www/htdocs/<br>$ git clone –bare /path/to/git_project gitproject.git<br>$ cd gitproject.git<br>$ mv hooks/post-update.sample hooks/post-update<br>$ chmod a+x hooks/post-update<br>这样就可以了。Git 附带的 post-update 挂钩会默认运行合适的命令（git update-server-info）来确保通过 HTTP 的获取和克隆正常工作。这条命令在你用 SSH 向仓库推送内容时运行；之后，其他人就可以用下面的命令来克隆仓库：</p><p>$ git clone <a href="http://example.com/gitproject.git" target="_blank" rel="noopener">http://example.com/gitproject.git</a></p><p>（注：使用 HTTP 协议的好处是易于架设。几条必要的命令就可以让全世界读取到仓库的内容。花费不过几分钟。HTTP 协议不会占用过多服务器资源。因为它一般只用到静态的 HTTP 服务提供所有数据。你可以通过 HTTPS 提供只读的仓库，这意味着你可以加密传输内容。但是，HTTP 协议的消极面在于，相对来说客户端效率更低。克隆或者下载仓库内容可能会花费更多时间，而且 HTTP 传输的体积和网络开销比其他任何一个协议都大。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;协议&lt;/strong&gt;&lt;br&gt;Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。下面分别介绍一下哪些情形应该使用（或避免使用）这些协议。&lt;/p&gt;
&lt;p&gt;值得注意的是，除了 HTTP 协议外，其他所有协议都要求在服务器端安装并运行 Git。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7默认Python升级</title>
    <link href="http://yoursite.com/2018/03/13/CentOS-7%E9%BB%98%E8%AE%A4Python%E5%8D%87%E7%BA%A7/"/>
    <id>http://yoursite.com/2018/03/13/CentOS-7默认Python升级/</id>
    <published>2018-03-13T10:01:05.000Z</published>
    <updated>2018-03-14T06:16:06.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>CentOS 7 中默认安装了 Python，版本比较低（2.7.5），为了使用新版 3.x，需要对旧版本进行升级。</p><p>由于很多基本的命令、软件包都依赖旧版本，比如：yum。所以，在更新 Python 时，建议不要删除旧版本（新旧版本可以共存）。</p><h3 id="安装Python3-6-4"><a href="#安装Python3-6-4" class="headerlink" title="安装Python3.6.4"></a>安装Python3.6.4</h3><a id="more"></a><h4 id="（1）下载并解压缩"><a href="#（1）下载并解压缩" class="headerlink" title="（1）下载并解压缩"></a>（1）下载并解压缩</h4><p>下载地址：<a href="https://www.python.org/downloads/release/python-364/" title="Python3.x" target="_blank" rel="noopener"><font color="red">传送门</font></a><br>此处我选择的版本是Python3.6.4：<br>　　<code>wget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tgz</code><br>解压缩：<br>　　<code>tar -xvf Python-3.6.4.tgz</code></p><h4 id="（2）检测编译环境"><a href="#（2）检测编译环境" class="headerlink" title="（2）检测编译环境"></a>（2）检测编译环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Python-3.6.4/</span><br><span class="line">./configure</span><br></pre></td></tr></table></figure><p>执行 ./configure 时，如果报错：</p><blockquote><p>configure: error: no acceptable C compiler found in $PATH</p></blockquote><p>说明没有安装合适的编译器。这时，需要安装/升级 gcc 及其它依赖包。<br>　　<code>yum install make gcc gcc-c++</code><br>完成之后，重新执行：<br>　　<code>./configure</code></p><h4 id="（3）编译-amp-安装"><a href="#（3）编译-amp-安装" class="headerlink" title="（3）编译 &amp; 安装"></a>（3）编译 &amp; 安装</h4><p>　　<code>make &amp; make install</code><br>安装中如果报错：</p><blockquote><p>zipimport.ZipImportError: can’t decompress data; zlib not available</p></blockquote><p>说明是因为缺少zlib 的相关工具包导致的，知道了问题所在，那么我们只需要安装相关依赖包即可，<br>① 打开终端，输入一下命令安装zlib相关依赖包：<br>　　<code>yum -y install zlib*</code> 或 <code>yum -y install zlib zlib-devel</code>（未试）</p><p>② 进入 python安装包,修改Module路径的setup文件：<br>　　<code>vim Module/Setup.dist</code><br>找到以下这行代码，去掉注释：</p><blockquote><p>#zlib zlibmodule.c -I$(prefix)/include -L$(exec_prefix)/lib -lz</p></blockquote><p>然后再次执行编译 &amp; 安装。</p><h3 id="设置Python默认版本"><a href="#设置Python默认版本" class="headerlink" title="设置Python默认版本"></a>设置Python默认版本</h3><h4 id="（1）查看Python版本"><a href="#（1）查看Python版本" class="headerlink" title="（1）查看Python版本"></a>（1）查看Python版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# python -V</span><br><span class="line">Python 2.7.5</span><br><span class="line">[root@VM_0_7_centos ~]# python3 -V</span><br><span class="line">Python 3.6.4</span><br></pre></td></tr></table></figure><p>查看Python命令路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# which python</span><br><span class="line">/usr/bin/python</span><br><span class="line">[root@VM_0_7_centos ~]# which python3</span><br><span class="line">/usr/local/bin/python3</span><br></pre></td></tr></table></figure></p><h4 id="（2）设置Python3-x为默认版本"><a href="#（2）设置Python3-x为默认版本" class="headerlink" title="（2）设置Python3.x为默认版本"></a>（2）设置Python3.x为默认版本</h4><p>查看Python默认版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# ll /usr/bin/ | grep python</span><br><span class="line">-rwxr-xr-x. 1 root root      11232 Aug 10  2017 abrt-action-analyze-python</span><br><span class="line">lrwxrwxrwx. 1 root root          7 Jan  9 18:20 python -&gt; python2</span><br><span class="line">lrwxrwxrwx. 1 root root          9 Jan  9 18:20 python2 -&gt; python2.7</span><br><span class="line">-rwxr-xr-x. 1 root root       7136 Aug  4  2017 python2.7</span><br></pre></td></tr></table></figure></p><p>更改Python默认版本，将原来 python 的软链接重命名：<br>　　<code>mv /usr/bin/python /usr/bin/python.bak</code><br>将 python 链接至 python3：<br>　　<code>ln -s /usr/local/bin/python3 /usr/bin/python</code><br>这时，再查看 Python 的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# python -V</span><br><span class="line">Python 3.6.4</span><br></pre></td></tr></table></figure></p><p>输出的是 3.x，说明已经使用的是 python3了。</p><h3 id="配置yum"><a href="#配置yum" class="headerlink" title="配置yum"></a>配置yum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# yum</span><br><span class="line">  File &quot;/usr/bin/yum&quot;, line 30</span><br><span class="line">    except KeyboardInterrupt, e:</span><br><span class="line">                            ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>升级 Python 之后，由于将默认的 python 指向了 python3，yum 不能正常使用，需要编辑 yum 的配置文件：<br>　　<code>vi /usr/bin/yum</code><br>同时修改：<br>　　<code>vi /usr/libexec/urlgrabber-ext-down</code><br>将 #!/usr/bin/python 改为 #!/usr/bin/python2.7，保存退出即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;CentOS 7 中默认安装了 Python，版本比较低（2.7.5），为了使用新版 3.x，需要对旧版本进行升级。&lt;/p&gt;
&lt;p&gt;由于很多基本的命令、软件包都依赖旧版本，比如：yum。所以，在更新 Python 时，建议不要删除旧版本（新旧版本可以共存）。&lt;/p&gt;
&lt;h3 id=&quot;安装Python3-6-4&quot;&gt;&lt;a href=&quot;#安装Python3-6-4&quot; class=&quot;headerlink&quot; title=&quot;安装Python3.6.4&quot;&gt;&lt;/a&gt;安装Python3.6.4&lt;/h3&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CSS 图片居中问题（水平居中和垂直居中）</title>
    <link href="http://yoursite.com/2018/03/13/CSS-%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98%EF%BC%88%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/13/CSS-图片居中问题（水平居中和垂直居中）/</id>
    <published>2018-03-13T03:29:17.000Z</published>
    <updated>2018-03-13T03:38:33.545Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、水平居中"><a href="#1、水平居中" class="headerlink" title="1、水平居中"></a>1、水平居中</h4><p>（1）利用margin: 0 auto实现图片水平居中<br>利用margin: 0 auto实现图片居中就是在图片上加上css样式margin: 0 auto 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center; width: 500px; border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">         style=&quot;margin: 0 auto;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>（2）利用文本的水平居中属性text-align: center<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center; width: 500px; border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">         style=&quot;display: inline-block;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2、垂直居中"><a href="#2、垂直居中" class="headerlink" title="2、垂直居中"></a>2、垂直居中</h4><p>（1）利用高==行高实现图片垂直居中<br>这种方法是要知道高度才可以使用，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center; width: 500px;height:200px; </span><br><span class="line">            line-height:200px; border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">         style=&quot;display: inline-block; vertical-align: middle;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>（2）利用table实现图片垂直居中<br>利用table的方法是利用了table的垂直居中属性，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center; width: 500px;height:200px; </span><br><span class="line">            display: table;border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;span style=&quot;display: table-cell; vertical-align: middle; &quot;&gt;</span><br><span class="line">        &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">             style=&quot;display: inline-block;&quot; /&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这里使用display: table;和display: table-cell;来模拟table，这种方法并不兼容IE6/IE7，IE67不支持display: table，如果你不需要支持IE67那就可以用<br><strong>（缺点：当你设置了display: table;可能会改变你的原有布局）</strong></p><p>（3）利用绝对定位实现图片垂直居中<br>如果已知图片的宽度和高度可以这样，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width: 500px;height:200px; position: relative; border: green solid 1px;&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; </span><br><span class="line">         style=&quot;width: 120px; height: 40px;position: absolute; left:50%; top: 50%; </span><br><span class="line">                margin-left: -60px;margin-top: -20px;&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>（4）移动端可以利用flex布局实现css图片垂直居中<br>移动端一般浏览器版本都比较高，所以可以大胆的使用flex布局，（flex布局参考css3的flex布局用法）演示代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*css代码：*/</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.ui-flex &#123;</span><br><span class="line">    display: -webkit-box !important;</span><br><span class="line">    display: -webkit-flex !important;</span><br><span class="line">    display: -ms-flexbox !important;</span><br><span class="line">    display: flex !important;</span><br><span class="line">    -webkit-flex-wrap: wrap;</span><br><span class="line">    -ms-flex-wrap: wrap;</span><br><span class="line">    flex-wrap: wrap</span><br><span class="line">&#125;</span><br><span class="line">.ui-flex, .ui-flex *, .ui-flex :after, .ui-flex :before &#123;</span><br><span class="line">    box-sizing: border-box</span><br><span class="line">&#125;</span><br><span class="line">.ui-flex.justify-center &#123;</span><br><span class="line">    -webkit-box-pack: center;</span><br><span class="line">    -webkit-justify-content: center;</span><br><span class="line">    -ms-flex-pack: center;</span><br><span class="line">    justify-content: center</span><br><span class="line">&#125;</span><br><span class="line">.ui-flex.center &#123;</span><br><span class="line">    -webkit-box-pack: center;</span><br><span class="line">    -webkit-justify-content: center;</span><br><span class="line">    -ms-flex-pack: center;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    -webkit-box-align: center;</span><br><span class="line">    -webkit-align-items: center;</span><br><span class="line">    -ms-flex-align: center;</span><br><span class="line">    align-items: center</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">/*html代码：*/</span><br><span class="line">&lt;div class=&quot;ui-flex justify-center center&quot; </span><br><span class="line">     style=&quot;border: green solid 1px; width: 500px; height: 200px;&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">        &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; style=&quot;&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、水平居中&quot;&gt;&lt;a href=&quot;#1、水平居中&quot; class=&quot;headerlink&quot; title=&quot;1、水平居中&quot;&gt;&lt;/a&gt;1、水平居中&lt;/h4&gt;&lt;p&gt;（1）利用margin: 0 auto实现图片水平居中&lt;br&gt;利用margin: 0 auto实现图片居中就是在图片上加上css样式margin: 0 auto 如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div style=&amp;quot;text-align: center; width: 500px; border: green solid 1px;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;img alt=&amp;quot;&amp;quot; src=&amp;quot;https://www.baidu.com/img/baidu_jgylogo3.gif&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         style=&amp;quot;margin: 0 auto;&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
      <category term="CSS问题" scheme="http://yoursite.com/categories/CSS/CSS%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="CSS问题" scheme="http://yoursite.com/tags/CSS%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>CSS 获取同类中第几个元素</title>
    <link href="http://yoursite.com/2018/03/13/CSS-%E8%8E%B7%E5%8F%96%E5%90%8C%E7%B1%BB%E4%B8%AD%E7%AC%AC%E5%87%A0%E4%B8%AA%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2018/03/13/CSS-获取同类中第几个元素/</id>
    <published>2018-03-13T03:28:46.000Z</published>
    <updated>2018-03-13T03:33:51.403Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，我们可能会碰到这样的需求：想让列表中的第一个部分显示不同的样式，想让列表中的偶数部分显示不同的背景颜色，想让列表中的最后一部分样式不一样……这样的需求，我们怎样来实现？<br>我们还可以通过CSS来实现，CSS给我们提供了几个非常有用的样式参数：first-child、last-child、nth-child(n)。下面，详细看一下它们的使用。<br><a id="more"></a></p><h4 id="1、first-child"><a href="#1、first-child" class="headerlink" title="1、first-child"></a>1、first-child</h4><p>first-child表示选择列表中的第一个标签。代码如下：<br>　　<code>li:first-child{background:#090}</code><br>上面的意思是，li 列表中的 第一个li模块的背景颜色。</p><h4 id="2、last-child"><a href="#2、last-child" class="headerlink" title="2、last-child"></a>2、last-child</h4><p>last-child表示选择列表中的最后一个标签，代码如下：<br>　　<code>li:last-child{background:#090}</code></p><h4 id="3、nth-child-3"><a href="#3、nth-child-3" class="headerlink" title="3、nth-child(3)"></a>3、nth-child(3)</h4><p>表示选择列表中的第3个标签，代码如下：<br>　　<code>li:nth-child(3){background:#090}</code><br>上面代码中的3也可以改成其它数字，如4、5等。想选择第几个标签，就填写几。</p><h4 id="4、nth-child-2n"><a href="#4、nth-child-2n" class="headerlink" title="4、nth-child(2n)"></a>4、nth-child(2n)</h4><p>这个表示选择列表中的偶数标签，即选择 第2、第4、第6…… 标签。</p><h4 id="5、nth-child-2n-1"><a href="#5、nth-child-2n-1" class="headerlink" title="5、nth-child(2n-1)"></a>5、nth-child(2n-1)</h4><p>这个表示选择列表中的奇数标签，即选择 第1、第3、第5、第7……标签。</p><h4 id="6、nth-child-n-3"><a href="#6、nth-child-n-3" class="headerlink" title="6、nth-child(n+3)"></a>6、nth-child(n+3)</h4><p>这个表示选择列表中的标签从第3个开始到最后。</p><h4 id="7、nth-child-n-3"><a href="#7、nth-child-n-3" class="headerlink" title="7、nth-child(-n+3)"></a>7、nth-child(-n+3)</h4><p>这个表示选择列表中的标签从0到3，即小于3的标签。</p><h4 id="8、nth-last-child-3"><a href="#8、nth-last-child-3" class="headerlink" title="8、nth-last-child(3)"></a>8、nth-last-child(3)</h4><p>这个表示选择列表中的倒数第3个标签。</p><p>上面这些CSS样式是非常有用的，在我们的网页开发过程中，会派上非常大的用场，可以给我们的网页带来不一样的风格。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前端开发中，我们可能会碰到这样的需求：想让列表中的第一个部分显示不同的样式，想让列表中的偶数部分显示不同的背景颜色，想让列表中的最后一部分样式不一样……这样的需求，我们怎样来实现？&lt;br&gt;我们还可以通过CSS来实现，CSS给我们提供了几个非常有用的样式参数：first-child、last-child、nth-child(n)。下面，详细看一下它们的使用。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
      <category term="CSS问题" scheme="http://yoursite.com/categories/CSS/CSS%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="CSS问题" scheme="http://yoursite.com/tags/CSS%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端切图技巧总结</title>
    <link href="http://yoursite.com/2018/03/09/%E5%89%8D%E7%AB%AF%E5%88%87%E5%9B%BE%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/09/前端切图技巧总结/</id>
    <published>2018-03-09T08:13:30.000Z</published>
    <updated>2018-03-09T08:20:56.363Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、传统切图方法"><a href="#一、传统切图方法" class="headerlink" title="一、传统切图方法"></a>一、传统切图方法</h4><p>使用范围：需要切多张图，带背景的<br>1.打开下载的psd文件<br>出现下面没关系，直接点确定即可<br><img src="/uploads/2018/03/photoshop_001.JPG" alt=""><br><a id="more"></a></p><p>打开后，因为文件比较长所以看不清细节，所以我们要放大图片到合适的大小。 </p><blockquote><font color="red">放大图片：”CTRL” +“+”<br>缩小图片：“CTRL”+ “-”</font></blockquote><p>然后我们来认识下photoshop中的一些工具<br><img src="/uploads/2018/03/photoshop_01.JPG" alt=""></p><p>2.修改参考线<br>我们可以看到我们的图片中很多条蓝色的参考线，这些线是设计人员用来设计用的，有的文件中的线会直接把我们需要切的东西给包裹出来，但是像我们练习的这个文件中的参考线特别的多，特别的密集，很多我们都不需要，所以我们先把这些参考线都清除掉。</p><p>删除参考线：选择移动工具，然后把要删除的参考线往标尺上拖，往上或者往左都可以</p><p>没有参考线的可能是参考线被隐藏了，通过<font color="red">“CTRL”+“ALT”+“;”</font>就可以显示出来了。<br><img src="/uploads/2018/03/photoshop_02.gif" alt=""></p><p>我们只要把挡住图标的参考线给删除就可以</p><p>3.选择要切的图标<br>这里我们就切几个页面上的图标，文字部分我们都可以通过代码来实现，所以就不切了。<br><img src="/uploads/2018/03/photoshop_03.gif" alt=""></p><blockquote><p>①选择工具栏第一个“移动工具”<br>②然后查看上面选项栏“自动选择”有没有被选中，没有被选中点击选中，将它旁边的“组”改为“图层”，这样我们点击图标的时候，右下角的图层面板就能自动的选中对应的图层<br>③点击我们要切的图标，然后到右下角的图层面板，点击当前选中的这个图层旁边的小眼睛来隐藏当前图层，通过显隐来确定是不是我们要切的图标<br>④确认了我们要切的图标后，分别从水平标尺和竖直标尺的地方拉取参考线来把图标给包裹住。因为我们当前选中的就是我们要切的图层，所以当参考线拖过去的时候会自动吸附到图标的边缘。<br>⑤用同样的方法把图标都用参考线包裹出来，最下面一排，要把图标切成一样高的才好，所以以第一个的上边界和下边界为基准。</p></blockquote><p>4.切片需要的图标<br>现在，我们已经用参考线把我们的图标给包裹出来了，下面，我们要用切片工具来切出我们的图标<br><img src="/uploads/2018/03/photoshop_04.gif" alt=""></p><blockquote><p>①选择切片工具，左边工具栏从上往下数第五个，然后右键就可以找到，然后选中<br>②然后找到我们刚才用参考线包裹的图标，从左上角一直拖到右下角，因为有参考线的帮助，所以软件能够自动吸附到参考线上，所以只要大概找准左上角和右下角就可以选取出来<br>③用同样的方法把剩下的都选取出来 </p></blockquote><p>5.将切片存储为图片</p><blockquote><p>①选择 “文件”=》“存储为Web所用格式”<br><img src="/uploads/2018/03/photoshop_05.JPG" alt=""><br>②调整缩放比例，让图片能完整的在窗口显示<br>③在窗口中，从左上角一直拖到右下角，选中所有切片，这样我们才能把切片都存储为我们想要的格式<br>④存储为png-24格式，png-24格式的图片质量比较高<br><img src="/uploads/2018/03/photoshop_06.JPG" alt=""><br>⑤保存，选择用户所有切片可以只保存我们自己切出来的切片<br><img src="/uploads/2018/03/photoshop_07.JPG" alt=""><br>⑥然后查看保存的文件里面就多了一个images文件夹，里面就是我们切出来的图片</p></blockquote><p><strong>（注：但是这样做会发现png格式的背景还是有的，而且如果只是需要一张图的时候，还要这样切就会比较麻烦，所以(二)中会介绍一些切一两个小图标的方法）</strong></p><h4 id="二、切单个图标方法"><a href="#二、切单个图标方法" class="headerlink" title="二、切单个图标方法"></a>二、切单个图标方法</h4><p>之前介绍了传统的切图技巧，主要用于切多张图片的时候，但很多时候我们可能只需要切一两张图标，如果还用传统的方法就会很繁琐，所以这次分享一种导出单个图标的方法。</p><p>1.还是之前的文件，这次我们就切一个图标<br><img src="/uploads/2018/03/photoshop_08.JPG" alt=""></p><p>2.选择移动工具，并在选项中选中“自动选择”和“图层”<br><img src="/uploads/2018/03/photoshop_09.JPG" alt=""></p><p>3.点击我们要切的图标，这里是点击中间的笔，然后右边的图层面板就会自动聚焦到对应的图层，通过点击左边的小眼睛来确定是不是我们想要的图层。<br><img src="/uploads/2018/03/photoshop_10.JPG" alt=""></p><p>4.这里我们找到了我们需要的图标有两部分组成，里面的笔和外面的圆，两个图层被放在了一个组里面<br><img src="/uploads/2018/03/photoshop_11.JPG" alt=""></p><p>5.在icon文件上右键，选择“转换为智能对象”<br><img src="/uploads/2018/03/photoshop_12.JPG" alt=""></p><p>6.然后，我们会发现，两个图层合并为了一个图层，这个就是我们需要的图标<br><img src="/uploads/2018/03/photoshop_13.JPG" alt=""></p><p>7.在icon图层上右键，选择“编辑内容”，出现提示框的话直接点击“确定”即可<br><img src="/uploads/2018/03/photoshop_14.JPG" alt=""></p><p>8.然后，我们的图标就被单独提取出来了<br><img src="/uploads/2018/03/photoshop_15.JPG" alt=""></p><p>9.选择“文件”=》“存储为”，将我们的图标保存为PNG格式就大功告成了！ </p><h4 id="三、自动生成图标方法"><a href="#三、自动生成图标方法" class="headerlink" title="三、自动生成图标方法"></a>三、自动生成图标方法</h4><p>1.打开给大家准备的psd文件<br>2.选择“编辑”=》“首选项”=》“增效工具”<br><img src="/uploads/2018/03/photoshop_16.JPG" alt=""></p><p>3.勾选“启用生成器”，选择“确定”<br><img src="/uploads/2018/03/photoshop_17.JPG" alt=""></p><p>4.重启一下photoshop</p><p>5.重启后，重新打开我们的文件，感觉参考线太碍事了，我们用快捷键“CTRL”+“；”把参考线隐藏了。</p><p>6.选择“文件”=》“生成”=》“图像资源”<br><img src="/uploads/2018/03/photoshop_18.JPG" alt=""></p><p>7.用之前一样的方法找到我们要的图标的图层<br><img src="/uploads/2018/03/photoshop_19.JPG" alt=""></p><p>8.我们需要的图标放在了icon这个分组中，现在我们将icon重命名为icon.png<br><img src="/uploads/2018/03/photoshop_20.JPG" alt=""></p><p>9.现在我们打开我们存放psd文件的文件夹中，可以发现现在多了一个文件夹<br><img src="/uploads/2018/03/photoshop_21.JPG" alt=""></p><p>10.打开这个多出来的文件夹就会看到我们的图标躺在那里了，是不是很激动！！！<br>11.我们还可以继续把第二个图标重命名为icon.jpg<br>12.然后会发现刚才那个文件夹中又多了一个icon.jpg文件<br>13.当然还可以把图标改为icon.svg（注：有时候不可以，原因未查）<br>16.如果不想要要这个图标，我们可以把文件的命名重新改回来 </p><p>这个方法生成图标非常的方便，很适合我们生成svg图片，可以保存到fontello或者iconfont中，强烈建议！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、传统切图方法&quot;&gt;&lt;a href=&quot;#一、传统切图方法&quot; class=&quot;headerlink&quot; title=&quot;一、传统切图方法&quot;&gt;&lt;/a&gt;一、传统切图方法&lt;/h4&gt;&lt;p&gt;使用范围：需要切多张图，带背景的&lt;br&gt;1.打开下载的psd文件&lt;br&gt;出现下面没关系，直接点确定即可&lt;br&gt;&lt;img src=&quot;/uploads/2018/03/photoshop_001.JPG&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="切图篇" scheme="http://yoursite.com/tags/%E5%88%87%E5%9B%BE%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Flask - 相关知识点总结</title>
    <link href="http://yoursite.com/2018/03/06/Flask-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/06/Flask-相关知识点总结/</id>
    <published>2018-03-06T10:46:40.000Z</published>
    <updated>2018-03-06T10:48:01.046Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、Flask入口文件集成-shell"><a href="#1、Flask入口文件集成-shell" class="headerlink" title="1、Flask入口文件集成 shell"></a>1、Flask入口文件集成 shell</h4><p>每次启动shell 会话都要导入数据库实例和模型，这真是份枯燥的工作。为了避免一直重复导入，我们可以做些配置，让Flask-Script 的shell 命令自动导入特定的对象。</p><p>若想把对象添加到导入列表中，我们要为shell 命令注册一个make_context 回调函数，如示例5-7 所示。<br><a id="more"></a><br>示例5-7　hello.py：为shell 命令添加一个上下文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.script import Shell</span><br><span class="line">def make_shell_context():</span><br><span class="line">    return dict(app=app, db=db, User=User, Role=Role)</span><br><span class="line">manager.add_command(&quot;shell&quot;, Shell(make_context=make_shell_context))</span><br></pre></td></tr></table></figure></p><p>make_shell_context() 函数注册了程序、数据库实例以及模型，因此这些对象能直接导入shell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python hello.py shell</span><br><span class="line">&gt;&gt;&gt; app</span><br><span class="line">&lt;Flask &apos;app&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; db</span><br><span class="line">&lt;SQLAlchemy engine=&apos;sqlite:////home/flask/flasky/data.sqlite&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; User</span><br><span class="line">&lt;class &apos;app.User&apos;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2、Flash消息"><a href="#2、Flash消息" class="headerlink" title="2、Flash消息"></a>2、Flash消息</h4><p>请求完成后，有时需要让用户知道状态发生了变化。这里可以使用确认消息、警告或者错误提醒。一个典型例子是，用户提交了有一项错误的登录表单后，服务器发回的响应重新渲染了登录表单，并在表单上面显示一个消息，提示用户用户名或密码错误。</p><p>这种功能是Flask 的核心特性。如示例所示，flash() 函数可实现这种效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, render_template, session, redirect, url_for, flash</span><br><span class="line">@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line">def index():</span><br><span class="line">form = NameForm()</span><br><span class="line">if form.validate_on_submit():</span><br><span class="line">old_name = session.get(&apos;name&apos;)</span><br><span class="line">if old_name is not None and old_name != form.name.data:</span><br><span class="line">flash(&apos;Looks like you have changed your name!&apos;)</span><br><span class="line">session[&apos;name&apos;] = form.name.data</span><br><span class="line">return redirect(url_for(&apos;index&apos;))</span><br><span class="line">return render_template(&apos;index.html&apos;, form = form, name = session.get(&apos;name&apos;))</span><br></pre></td></tr></table></figure></p><p>在这个示例中，每次提交的名字都会和存储在用户会话中的名字进行比较，而会话中存储的名字是前一次在这个表单中提交的数据。如果两个名字不一样，就会调用flash() 函数，在发给客户端的下一个响应中显示一个消息。</p><p>仅调用flash() 函数并不能把消息显示出来，程序使用的模板要渲染这些消息。最好在基模板中渲染Flash 消息，因为这样所有页面都能使用这些消息。Flask 把get_flashed_messages() 函数开放给模板，用来获取并渲染消息，如示例所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&#123;% for message in get_flashed_messages() %&#125;</span><br><span class="line">&lt;div class=&quot;alert alert-warning&quot;&gt;</span><br><span class="line">&lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;</span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block page_content %&#125;&#123;% endblock %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>在模板中使用循环是因为在之前的请求循环中每次调用flash() 函数时都会生成一个消息，所以可能有多个消息在排队等待显示。get_flashed_messages() 函数获取的消息在下次调用时不会再次返回，因此Flash 消息只显示一次，然后就消失了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、Flask入口文件集成-shell&quot;&gt;&lt;a href=&quot;#1、Flask入口文件集成-shell&quot; class=&quot;headerlink&quot; title=&quot;1、Flask入口文件集成 shell&quot;&gt;&lt;/a&gt;1、Flask入口文件集成 shell&lt;/h4&gt;&lt;p&gt;每次启动shell 会话都要导入数据库实例和模型，这真是份枯燥的工作。为了避免一直重复导入，我们可以做些配置，让Flask-Script 的shell 命令自动导入特定的对象。&lt;/p&gt;
&lt;p&gt;若想把对象添加到导入列表中，我们要为shell 命令注册一个make_context 回调函数，如示例5-7 所示。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask - 认证扩展</title>
    <link href="http://yoursite.com/2018/03/06/Flask-%E8%AE%A4%E8%AF%81%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/03/06/Flask-认证扩展/</id>
    <published>2018-03-06T10:43:25.000Z</published>
    <updated>2018-03-06T10:44:11.349Z</updated>
    
    <content type="html"><![CDATA[<p>Flask-Login：管理已登录用户的用户会话。<br>Werkzeug：计算密码散列值并进行核对。<br>itsdangerous：生成并核对加密安全令牌。</p><h4 id="1、密码安全性-使用Werkzeug实现密码散列"><a href="#1、密码安全性-使用Werkzeug实现密码散列" class="headerlink" title="1、密码安全性 - 使用Werkzeug实现密码散列"></a>1、密码安全性 - 使用Werkzeug实现密码散列</h4><p>众所周知，大多数用户都在不同的网站中使用相同的密码，因此，即便不保存任何敏感信息，攻击者获得存储在数据库中的密码之后，也能访问用户在其他网站中的账户。<br><a id="more"></a><br>若想保证数据库中用户密码的安全，关键在于不能存储密码本身，而要存储密码的散列值。计算密码散列值的函数接收密码作为输入，使用一种或多种加密算法转换密码，最终得到一个和原始密码没有关系的字符序列。核对密码时，密码散列值可代替原始密码，因为计算散列值的函数是可复现的：只要输入一样，结果就一样。</p><p>Werkzeug 中的security 模块能够很方便地实现密码散列值的计算。这一功能的实现只需要两个函数，分别用在注册用户和验证用户阶段。</p><ul><li>generate_password_hash(password, method=pbkdf2:sha1, salt_length=8)：这个函数将原始密码作为输入，以字符串形式输出密码的散列值，输出的值可保存在用户数据库中。method 和salt_length 的默认值就能满足大多数需求。</li><li>check_password_hash(hash, password)：这个函数的参数是从数据库中取回的密码散列值和用户输入的密码。返回值为True 表明密码正确。</li></ul><p>示例8-1 展示了创建的User 模型为支持密码散列所做的改动。<br>示例8-1　app/models.py：在User 模型中加入密码散列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from werkzeug.security import generate_password_hash, check_password_hash</span><br><span class="line">class User(db.Model):</span><br><span class="line">    __tablename__ == &apos;users&apos;</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    username = db.Column(db.String(64), unique=True, index=True)</span><br><span class="line">    password_hash = db.Column(db.String(128))</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def password(self):</span><br><span class="line">        raise AttributeError(&apos;password is not a readable attribute&apos;)</span><br><span class="line"></span><br><span class="line">    @password.setter</span><br><span class="line">    def password(self, password):</span><br><span class="line">        self.password_hash = generate_password_hash(password)</span><br><span class="line">    </span><br><span class="line">    def verify_password(self, password):</span><br><span class="line">        return check_password_hash(self.password_hash, password)</span><br><span class="line">    </span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;User %r&gt;&apos; % self.username</span><br></pre></td></tr></table></figure></p><p>计算密码散列值的函数通过名为password 的只写属性实现。设定这个属性的值时，赋值方法会调用Werkzeug 提供的generate_password_hash() 函数，并把得到的结果赋值给password_hash 字段。如果试图读取password 属性的值，则会返回错误，原因很明显，因为生成散列值后就无法还原成原来的密码了。</p><p>verify_password 方法接受一个参数（ 即密码）， 将其传给Werkzeug 提供的check_password_hash() 函数，和存储在User 模型中的密码散列值进行比对。如果这个方法返回True，就表明密码是正确的。</p><h4 id="2、使用Flask-Login认证用户"><a href="#2、使用Flask-Login认证用户" class="headerlink" title="2、使用Flask-Login认证用户"></a>2、使用Flask-Login认证用户</h4><p>用户登录程序后，他们的认证状态要被记录下来，这样浏览不同的页面时才能记住这个状态。Flask-Login 是个非常有用的小型扩展，专门用来管理用户认证系统中的认证状态，且不依赖特定的认证机制。</p><h5 id="（1）准备用于登录的用户模型"><a href="#（1）准备用于登录的用户模型" class="headerlink" title="（1）准备用于登录的用户模型"></a>（1）准备用于登录的用户模型</h5><p>要想使用Flask-Login 扩展，程序的User 模型必须实现几个方法。需要实现的方法如表8-1所示。<br>表8-1　Flask-Login要求实现的用户方法</p><table><thead><tr><th>方　　法</th><th>说　　明</th></tr></thead><tbody><tr><td>is_authenticated()</td><td>如果用户已经登录，必须返回True，否则返回False</td></tr><tr><td>is_active()</td><td>如果允许用户登录，必须返回True，否则返回False。如果要禁用账户，可以返回False</td></tr><tr><td>is_anonymous()</td><td>对普通用户必须返回False</td></tr><tr><td>get_id()</td><td>必须返回用户的唯一标识符，使用Unicode 编码字符串</td></tr></tbody></table><p>这4 个方法可以在模型类中作为方法直接实现，不过还有一种更简单的替代方案。Flask-Login 提供了一个UserMixin 类，其中包含这些方法的默认实现，且能满足大多数需求。修改后的User 模型如示例8-6 所示。</p><p>示例8-6　app/models.py：修改User 模型，支持用户登录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.login import UserMixin</span><br><span class="line">class User(UserMixin, db.Model):</span><br><span class="line">    __tablename__ = &apos;users&apos;</span><br><span class="line">    id = db.Column(db.Integer, primary_key = True)</span><br><span class="line">    email = db.Column(db.String(64), unique=True, index=True)</span><br><span class="line">    username = db.Column(db.String(64), unique=True, index=True)</span><br><span class="line">    password_hash = db.Column(db.String(128))</span><br></pre></td></tr></table></figure></p><p>注意，示例中同时还添加了email 字段。在这个程序中，用户使用电子邮件地址登录，因为相对于用户名而言，用户更不容易忘记自己的电子邮件地址。</p><p>Flask-Login 在程序的工厂函数中初始化，如示例8-7 所示。<br>示例8-7　app/<strong>init</strong>.py：初始化Flask-Login<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.login import LoginManager</span><br><span class="line"></span><br><span class="line">login_manager = LoginManager()</span><br><span class="line">login_manager.session_protection = &apos;strong&apos;</span><br><span class="line">login_manager.login_view = &apos;auth.login&apos;</span><br><span class="line"></span><br><span class="line">def create_app(config_name):</span><br><span class="line">    # ...</span><br><span class="line">    login_manager.init_app(app)</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure></p><p>LoginManager 对象的session_protection 属性可以设为None、’basic’ 或’strong’，以提供不同的安全等级防止用户会话遭篡改。设为’strong’ 时，Flask-Login 会记录客户端IP地址和浏览器的用户代理信息，如果发现异动就登出用户。login_view 属性设置登录页面的端点。如果登录路由在蓝本中定义，因此要在前面加上蓝本的名字。</p><p>最后，Flask-Login 要求程序实现一个回调函数，使用指定的标识符加载用户。这个函数的定义如示例8-8 所示。</p><p>示例8-8　app/models.py：加载用户的回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from . import login_manager</span><br><span class="line"></span><br><span class="line">@login_manager.user_loader</span><br><span class="line">def load_user(user_id):</span><br><span class="line">    return User.query.get(int(user_id))</span><br></pre></td></tr></table></figure></p><p>加载用户的回调函数接收以Unicode 字符串形式表示的用户标识符。如果能找到用户，这个函数必须返回用户对象；否则应该返回None。</p><h5 id="（2）保护路由"><a href="#（2）保护路由" class="headerlink" title="（2）保护路由"></a>（2）保护路由</h5><p>为了保护路由只让认证用户访问，Flask-Login 提供了一个login_required 修饰器。用法演示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.login import login_required</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/secret&apos;)</span><br><span class="line">@login_required</span><br><span class="line">def secret():</span><br><span class="line">    return &apos;Only authenticated users are allowed!&apos;</span><br></pre></td></tr></table></figure></p><p>如果未认证的用户访问这个路由，Flask-Login 会拦截请求，把用户发往登录页面。</p><h4 id="3、使用itsdangerous生成确认令牌"><a href="#3、使用itsdangerous生成确认令牌" class="headerlink" title="3、使用itsdangerous生成确认令牌"></a>3、使用itsdangerous生成确认令牌</h4><p>为验证电子邮件地址，用户注册后，程序会立即发送一封确认邮件。新账户先被标记成待确认状态，用户按照邮件中的说明操作后，才能证明自己可以被联系上。账户确认过程中，往往会要求用户点击一个包含确认令牌的特殊URL 链接。</p><p>确认邮件中最简单的确认链接是<a href="http://www.example.com/auth/confirm/" target="_blank" rel="noopener">http://www.example.com/auth/confirm/</a><id> 这种形式的URL，其中id 是数据库分配给用户的数字id。用户点击链接后，处理这个路由的视图函数就将收到的用户id 作为参数进行确认，然后将用户状态更新为已确认。</id></p><p>但这种实现方式显然不是很安全，只要用户能判断确认链接的格式，就可以随便指定URL中的数字，从而确认任意账户。解决方法是把URL 中的id 换成将相同信息安全加密后得到的令牌。</p><p>下面这个简短的shell 会话显示了如何使用itsdangerous 包生成包含用户id 的安全令牌：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python manage.py shell</span><br><span class="line">&gt;&gt;&gt; from manage import app</span><br><span class="line">&gt;&gt;&gt; from itsdangerous import TimedJSONWebSignatureSerializer as Serializer</span><br><span class="line">&gt;&gt;&gt; s = Serializer(app.config[&apos;SECRET_KEY&apos;], expires_in = 3600)</span><br><span class="line">&gt;&gt;&gt; token = s.dumps(&#123; &apos;confirm&apos;: 23 &#125;)</span><br><span class="line">&gt;&gt;&gt; token</span><br><span class="line">&apos;eyJhbGciOiJIUzI1NiIsImV4cCI6MTM4MTcxODU1OCwiaWF0IjoxMzgxNzE0OTU4fQ.ey ...&apos;</span><br><span class="line">&gt;&gt;&gt; data = s.loads(token)</span><br><span class="line">&gt;&gt;&gt; data</span><br><span class="line">&#123;u&apos;confirm&apos;: 23&#125;</span><br></pre></td></tr></table></figure></p><p>itsdangerous 提供了多种生成令牌的方法。其中，TimedJSONWebSignatureSerializer 类生成具有过期时间的JSON Web 签名（JSON Web Signatures，JWS）。这个类的构造函数接收的参数是一个密钥，在Flask 程序中可使用SECRET_KEY 设置。</p><p>dumps() 方法为指定的数据生成一个加密签名，然后再对数据和签名进行序列化，生成令牌字符串。expires_in 参数设置令牌的过期时间，单位为秒。</p><p>为了解码令牌，序列化对象提供了loads() 方法，其唯一的参数是令牌字符串。这个方法会检验签名和过期时间，如果通过，返回原始数据。如果提供给loads() 方法的令牌不正确或过期了，则抛出异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask-Login：管理已登录用户的用户会话。&lt;br&gt;Werkzeug：计算密码散列值并进行核对。&lt;br&gt;itsdangerous：生成并核对加密安全令牌。&lt;/p&gt;
&lt;h4 id=&quot;1、密码安全性-使用Werkzeug实现密码散列&quot;&gt;&lt;a href=&quot;#1、密码安全性-使用Werkzeug实现密码散列&quot; class=&quot;headerlink&quot; title=&quot;1、密码安全性 - 使用Werkzeug实现密码散列&quot;&gt;&lt;/a&gt;1、密码安全性 - 使用Werkzeug实现密码散列&lt;/h4&gt;&lt;p&gt;众所周知，大多数用户都在不同的网站中使用相同的密码，因此，即便不保存任何敏感信息，攻击者获得存储在数据库中的密码之后，也能访问用户在其他网站中的账户。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>物联网入门必备</title>
    <link href="http://yoursite.com/2018/03/06/%E7%89%A9%E8%81%94%E7%BD%91%E5%85%A5%E9%97%A8%E5%BF%85%E5%A4%87/"/>
    <id>http://yoursite.com/2018/03/06/物联网入门必备/</id>
    <published>2018-03-06T03:20:52.000Z</published>
    <updated>2018-03-06T10:49:55.139Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是物联网？"><a href="#什么是物联网？" class="headerlink" title="什么是物联网？"></a>什么是物联网？</h4><p>物联网是新一代信息技术的重要组成部分，也是“信息化”时代的重要发展阶段。其英文名称是：“Internet of things（IoT）”。顾名思义，物联网就是物物相连的互联网。这有两层意思：其一，物联网的核心和基础仍然是互联网，是在互联网基础上的延伸和扩展的网络；其二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信，也就是物物相息。物联网通过智能感知、识别技术与普适计算等通信感知技术，广泛应用于网络的融合中，也因此被称为继计算机、互联网之后世界信息产业发展的第三次浪潮。物联网是互联网的应用拓展，与其说物联网是网络，不如说物联网是业务和应用。因此，应用创新是物联网发展的核心，以用户体验为核心的创新2.0是物联网发展的灵魂。<br><a id="more"></a></p><h4 id="什么是认知物联网？"><a href="#什么是认知物联网？" class="headerlink" title="什么是认知物联网？"></a>什么是认知物联网？</h4><p>简单地说，认知物联网是将认知计算技术与互连设备产生的数据和这些设备可以执行的操作结合使用。您可能已经知道物联网，也知道我们所说的传感器和执行器的意思。从认知计算方面讲，物联网又是什么意思呢？当然，认知意味着思考，而计算机不具备普通人类的思考能力，它们现在可以执行一些人类认为是思考 的基本功能。认知涉及三个关键要素：</p><ul><li>理解</li><li>推理</li><li>学习</li></ul><p>在计算机中，系统理解意味着，能够读入大量的结构化和非结构化数据，并从中获取其意义，也就是说，建立一个概念、实体和关系的模型。推理 意味着，使用这个模型能够得出答案或解决相关问题，无需专门对答案和解决方案进行编程。而学习 意味着，能够自动地从数据推断出新的知识，这是大规模理解的一个关键组成部分。<br><img src="/uploads/2018/03/cognitive-iot-blog.jpg" alt=""></p><p>构建大规模的概念和关系的复杂模型过于费时，且成本高昂。此外，有许多关系是事先不知道或不明确的，所以只能让机器自动分析大数据集来发现模式，然后才能真正发现这些关系。</p><h4 id="会思考的物体"><a href="#会思考的物体" class="headerlink" title="会思考的物体"></a>会思考的物体</h4><p>认知计算对于物联网非常重要，这有几个关键原因。</p><ul><li><p><strong>生成数据的速率和规模：</strong>学习有助于优化流程或系统，在结合有关系统的传感器数据与其他上下文信息的基础上，使其更加高效。从设备生成的数据快速超越了人类通过分析去发现重要模式和学习的能力。应用机器学习对于能够扩展物联网是必不可少的。</p></li><li><p><strong>计算转移到物理世界：</strong>随着越来越多各种年龄和技术技能水平的人在与物联网系统进行交互，我们需要超越当前的机器接口范式，这种范式要求人类学会与机器交互所需的抽象和专用接口。此外，这种转移需要走向更加以人类为中心的接口。换句话说，人们需要能够用自然语言与物联网系统（物体）进行交互。该系统必须开始理解人类。来自麻省理工媒体实验室 (MIT Media Lab) 的作者 David Rose 提出了术语 “魔法对象 (enchanted objects) ” 来描述看似智能的行为，我们可以通过物联网和认知计算将这些行为注入连接的设备。</p></li><li><p><strong>多种数据源和数据类型的集成：</strong>在物联网中，存在许多数据源，可以提供相关的信息或上下文，有助于更好地理解和制定决策。数据有多种不同的类型，包括数字传感器数据、音频、视频、非结构化的文本数据、位置数据等，消化和分析这些数据类型并通过这些数据类型识别相关性和模式的能力，是一项非常强大的功能。通过掌握上下文可以大大提高对人类操作者的意图的理解，这包括物理环境、时间维度，甚至是情绪状况。通过集成多个不同的数据源可以完善推理和决策，例如，关联传感器数据与声学数据。</p></li></ul><h4 id="人类感知设备"><a href="#人类感知设备" class="headerlink" title="人类感知设备"></a>人类感知设备</h4><p><strong>认知物联网</strong> 是下一次飞跃，它通过学习并将更多的人类意识注入到与我们交互的设备和环境中，提高传感器驱动的复杂系统的准确性和效率。这一飞跃可以让我们的物体 用我们的语言（而不是其他方式）来理解我们，并与我们进行交互。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是物联网？&quot;&gt;&lt;a href=&quot;#什么是物联网？&quot; class=&quot;headerlink&quot; title=&quot;什么是物联网？&quot;&gt;&lt;/a&gt;什么是物联网？&lt;/h4&gt;&lt;p&gt;物联网是新一代信息技术的重要组成部分，也是“信息化”时代的重要发展阶段。其英文名称是：“Internet of things（IoT）”。顾名思义，物联网就是物物相连的互联网。这有两层意思：其一，物联网的核心和基础仍然是互联网，是在互联网基础上的延伸和扩展的网络；其二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信，也就是物物相息。物联网通过智能感知、识别技术与普适计算等通信感知技术，广泛应用于网络的融合中，也因此被称为继计算机、互联网之后世界信息产业发展的第三次浪潮。物联网是互联网的应用拓展，与其说物联网是网络，不如说物联网是业务和应用。因此，应用创新是物联网发展的核心，以用户体验为核心的创新2.0是物联网发展的灵魂。&lt;br&gt;
    
    </summary>
    
      <category term="物联网" scheme="http://yoursite.com/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="科技前沿" scheme="http://yoursite.com/tags/%E7%A7%91%E6%8A%80%E5%89%8D%E6%B2%BF/"/>
    
      <category term="物联网" scheme="http://yoursite.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>区块链入门必备</title>
    <link href="http://yoursite.com/2018/03/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E5%BF%85%E5%A4%87/"/>
    <id>http://yoursite.com/2018/03/06/区块链入门必备/</id>
    <published>2018-03-06T02:44:47.000Z</published>
    <updated>2018-03-06T03:21:45.859Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、区块链是什么？"><a href="#1、区块链是什么？" class="headerlink" title="1、区块链是什么？"></a>1、区块链是什么？</h4><p>区块链是一种防篡改的、共享的数字化账本，用于记录公有或私有对等网络中的交易。账本分发给网络中的所有成员节点，在通过哈希密码算法链接的区块的顺序链中，永久记录网络中的对等节点之间发生的资产交易的历史记录。</p><p>所有经过确认和证明的交易都从链的开头一直链接到最新的区块，因此得名区块链。区块链可以充当单一事实来源，而且区块链网络中的成员只能查看与他们相关的交易。<br><a id="more"></a></p><h4 id="2、区块链网络的工作原理"><a href="#2、区块链网络的工作原理" class="headerlink" title="2、区块链网络的工作原理"></a>2、区块链网络的工作原理</h4><p>区块链网络中的成员节点不依赖于第三方（比如金融机构）来仲裁交易，它们使用共识协议来协商账本内容，使用哈希加密算法和数字签名来确保交易的完整性。</p><p>共识性能确保共享账本是精确副本，并降低了发生交易欺诈的风险，因为篡改需要在许多地方同时执行。哈希加密算法（比如 SHA256 计算算法）能确保对交易输入的任何改动 — 甚至是最细微的改动 — 都会计算出一个不同的哈希值，表明交易输入可能被损坏。数字签名确保交易源自发送方（已使用私钥签名）而不是冒名顶替者。</p><p>去中心化对等区块链网络可阻止任何单个或一组参与者控制底层基础架构或破坏整个系统。网络中的参与者是平等的，都遵守相同的协议。它们可以是个人、国家代表、企业或所有这三种参与者的组合。</p><p>在其核心，该系统会记录交易的时间顺序，而且所有节点都使用选定的共识模型来协商交易的有效性。这会使交易不可逆并被网络中的所有成员接受。</p><h4 id="3、区块链技术的商业优势"><a href="#3、区块链技术的商业优势" class="headerlink" title="3、区块链技术的商业优势"></a>3、区块链技术的商业优势</h4><p>在传统业务网络中，所有参与者都维护着自己的账本，这些账本之间的重复和差异会导致争议、更长的结算时间，而且因为需要中介，还会导致相关的间接管理成本。但是，通过使用基于区块链的共享账本，交易在通过共识性验证并写入账本后，就不能再更改，这样企业就能节省时间和成本，同时减少风险。</p><p>区块链共识机制提供了经过整合的、一致的数据集的优势，减少了错误，拥有近实时的引用数据，而且参与者能够灵活更改其拥有的资产的描述。</p><p>因为没有参与成员拥有共享账本中所含信息的来源，所以区块链技术会提高参与成员之间的交易信息流中的可信度和完整性。</p><p>区块链技术的不变性机制降低了审计和合规性成本，增加了透明性。而且在使用区块链技术的业务网络上，合约得以智能、自动化执行并最终确认，所以企业会获得更高的执行速度、更低的成本和更少的风险，所有这些使企业能构建新收入流来与客户交互。</p><h4 id="4、如何才算是好的区块链用例？"><a href="#4、如何才算是好的区块链用例？" class="headerlink" title="4、如何才算是好的区块链用例？"></a>4、如何才算是好的区块链用例？</h4><p>要确定您的用例是否适合使用区块链，请询问自己以下问题：</p><ol><li>是否涉及业务网络？</li><li>是否使用共识性来验证交易？</li><li>是否需要审计线索或来源？</li><li>交易记录是否必须不可变或防篡改？</li><li>争议的解决方法是否会是最终解决方法？<br>如果第一个问题和其他问题中的至少一个问题的答案为“是”，那么您的用例就会从区块链技术受益。要成为合适的解决方案，区块链必须涉及一个网络，但该网络可以具有多种形式。该网络可位于企业之间，比如供应链，或者该网络可以在一个企业内。例如：在企业内，可以使用区块链网络在部门之间共享参考数据，或者创建审计或合规性网络。该网络也可存在于个人之间，比如需要在区块链上存储数据、数字资产或合约的人。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、区块链是什么？&quot;&gt;&lt;a href=&quot;#1、区块链是什么？&quot; class=&quot;headerlink&quot; title=&quot;1、区块链是什么？&quot;&gt;&lt;/a&gt;1、区块链是什么？&lt;/h4&gt;&lt;p&gt;区块链是一种防篡改的、共享的数字化账本，用于记录公有或私有对等网络中的交易。账本分发给网络中的所有成员节点，在通过哈希密码算法链接的区块的顺序链中，永久记录网络中的对等节点之间发生的资产交易的历史记录。&lt;/p&gt;
&lt;p&gt;所有经过确认和证明的交易都从链的开头一直链接到最新的区块，因此得名区块链。区块链可以充当单一事实来源，而且区块链网络中的成员只能查看与他们相关的交易。&lt;br&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="科技前沿" scheme="http://yoursite.com/tags/%E7%A7%91%E6%8A%80%E5%89%8D%E6%B2%BF/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 大型程序的结构</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-大型程序的结构/</id>
    <published>2018-03-05T10:04:46.000Z</published>
    <updated>2018-03-06T02:20:59.991Z</updated>
    
    <content type="html"><![CDATA[<p>尽管在单一脚本中编写小型Web 程序很方便，但这种方法并不能广泛使用。程序变复杂后，使用单个大型源码文件会导致很多问题。</p><p>不同于大多数其他的Web 框架，Flask 并不强制要求大型项目使用特定的组织方式，程序结构的组织方式完全由开发者决定。在本章，我们将介绍一种使用包和模块组织大型程序的方式。本书后续示例都将采用这种结构。</p><h4 id="1、项目结构"><a href="#1、项目结构" class="headerlink" title="1、项目结构"></a>1、项目结构</h4><p>Flask 程序的基本结构如示例7-1 所示。<br><a id="more"></a><br><strong>示例7-1　多文件Flask 程序的基本结构</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">|-flasky</span><br><span class="line">　　|-app/</span><br><span class="line">　　　　|-templates/</span><br><span class="line">　　　　|-static/</span><br><span class="line">　　　　|-main/</span><br><span class="line">　　　　　　|-__init__.py</span><br><span class="line">　　　　　　|-errors.py</span><br><span class="line">　　　　　　|-forms.py</span><br><span class="line">　　　　　　|-views.py</span><br><span class="line">　　　　|-__init__.py</span><br><span class="line">　　　　|-email.py</span><br><span class="line">　　　　|-models.py</span><br><span class="line">　　|-migrations/</span><br><span class="line">　　|-tests/</span><br><span class="line">　　　　|-__init__.py</span><br><span class="line">　　　　|-test*.py</span><br><span class="line">　　|-venv/</span><br><span class="line">　　|-requirements.txt</span><br><span class="line">　　|-config.py</span><br><span class="line">　　|-manage.py</span><br></pre></td></tr></table></figure></p><p>这种结构有4 个顶级文件夹：</p><ul><li>Flask程序一般都保存在名为app 的包中；</li><li>和之前一样，migrations文件夹包含数据库迁移脚本；</li><li>单元测试编写在 tests包中；</li><li>和之前一样，venv 文件夹包含 Python 虚拟环境。</li></ul><p>同时还创建了一些新文件：</p><ul><li>requirements.txt列出了所有依赖包，便于在其他电脑中重新生成相同的虚拟环境；</li><li>config.py 存储配置；</li><li>manage.py用于启动程序以及其他的程序任务。</li></ul><p>为了帮助你完全理解这个结构，下面几节讲解把hello.py 程序转换成这种结构的过程。</p><h4 id="2、配置选项"><a href="#2、配置选项" class="headerlink" title="2、配置选项"></a>2、配置选项</h4><p>程序经常需要设定多个配置。这方面最好的例子就是开发、测试和生产环境要使用不同的数据库，这样才不会彼此影响。</p><p>我们不再使用hello.py 中简单的字典状结构配置，而使用层次结构的配置类。config.py 文件的内容如示例7-2 所示。</p><p>示例7-2　config.py：程序的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">basedir = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line"></span><br><span class="line">class Config:</span><br><span class="line">    SECRET_KEY = os.environ.get(&apos;SECRET_KEY&apos;) or &apos;hard to guess string&apos;</span><br><span class="line">    SQLALCHEMY_COMMIT_ON_TEARDOWN = True</span><br><span class="line">    FLASKY_MAIL_SUBJECT_PREFIX = &apos;[Flasky]&apos;</span><br><span class="line">    FLASKY_MAIL_SENDER = &apos;Flasky Admin &lt;flasky@example.com&gt;&apos;</span><br><span class="line">    FLASKY_ADMIN = os.environ.get(&apos;FLASKY_ADMIN&apos;)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def init_app(app):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class DevelopmentConfig(Config):</span><br><span class="line">    DEBUG = True</span><br><span class="line">    MAIL_SERVER = &apos;smtp.googlemail.com&apos;</span><br><span class="line">    MAIL_PORT = 587</span><br><span class="line">    MAIL_USE_TLS = True</span><br><span class="line">    MAIL_USERNAME = os.environ.get(&apos;MAIL_USERNAME&apos;)</span><br><span class="line">    MAIL_PASSWORD = os.environ.get(&apos;MAIL_PASSWORD&apos;)</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;DEV_DATABASE_URL&apos;) or \</span><br><span class="line">        &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data-dev.sqlite&apos;)</span><br><span class="line"></span><br><span class="line">class TestingConfig(Config):</span><br><span class="line">    TESTING = True</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;TEST_DATABASE_URL&apos;) or \</span><br><span class="line">        &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data-test.sqlite&apos;)</span><br><span class="line"></span><br><span class="line">class ProductionConfig(Config):</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;DATABASE_URL&apos;) or \</span><br><span class="line">        &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;)</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    &apos;development&apos;: DevelopmentConfig,</span><br><span class="line">    &apos;testing&apos;: TestingConfig,</span><br><span class="line">    &apos;production&apos;: ProductionConfig,</span><br><span class="line">    &apos;default&apos;: DevelopmentConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基类Config 中包含通用配置，子类分别定义专用的配置。如果需要，你还可添加其他配置类。</p><p>为了让配置方式更灵活且更安全，某些配置可以从环境变量中导入。例如，SECRET_KEY 的值，这是个敏感信息，可以在环境中设定，但系统也提供了一个默认值，以防环境中没有定义。</p><p>在3 个子类中，SQLALCHEMY_DATABASE_URI 变量都被指定了不同的值。这样程序就可在不同的配置环境中运行，每个环境都使用不同的数据库。</p><p>配置类可以定义init_app() 类方法，其参数是程序实例。在这个方法中，可以执行对当前环境的配置初始化。现在，基类Config 中的init_app() 方法为空。</p><p>在这个配置脚本末尾，config 字典中注册了不同的配置环境，而且还注册了一个默认配置。</p><h4 id="3、程序包"><a href="#3、程序包" class="headerlink" title="3、程序包"></a>3、程序包</h4><p>程序包用来保存程序的所有代码、模板和静态文件。我们可以把这个包直接称为app（应用），如果有需求，也可使用一个程序专用名字。templates 和static 文件夹是程序包的一部分，因此这两个文件夹被移到了app 中。数据库模型和电子邮件支持函数也被移到了这个包中，分别保存为app/models.py 和app/email.py。</p><h5 id="（1）使用程序工厂函数"><a href="#（1）使用程序工厂函数" class="headerlink" title="（1）使用程序工厂函数"></a>（1）使用程序工厂函数</h5><p>在单个文件中开发程序很方便，但却有个很大的缺点，因为程序在全局作用域中创建，所以无法动态修改配置。运行脚本时，程序实例已经创建，再修改配置为时已晚。这一点对单元测试尤其重要，因为有时为了提高测试覆盖度，必须在不同的配置环境中运行程序。这个问题的解决方法是延迟创建程序实例，把创建过程移到可显式调用的工厂函数中。这种方法不仅可以给脚本留出配置程序的时间，还能够创建多个程序实例，这些实例有时在测试中非常有用。程序的工厂函数在app 包的构造文件中定义，如示例7-3 所示。</p><p>构造文件导入了大多数正在使用的Flask 扩展。由于尚未初始化所需的程序实例，所以没有初始化扩展，创建扩展类时没有向构造函数传入参数。create_app() 函数就是程序的工厂函数，接受一个参数，是程序使用的配置名。配置类在config.py 文件中定义，其中保存的配置可以使用Flask app.config 配置对象提供的from_object() 方法直接导入程序。至于配置对象，则可以通过名字从config 字典中选择。程序创建并配置好后，就能初始化扩展了。在之前创建的扩展对象上调用init_app() 可以完成初始化过程。</p><p>示例7-3　app/__init__.py：程序包的构造文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, render_template</span><br><span class="line">from flask.ext.bootstrap import Bootstrap</span><br><span class="line">from flask.ext.mail import Mail</span><br><span class="line">from flask.ext.moment import Moment</span><br><span class="line">from flask.ext.sqlalchemy import SQLAlchemy</span><br><span class="line">from config import config</span><br><span class="line"></span><br><span class="line">bootstrap = Bootstrap()</span><br><span class="line">mail = Mail()</span><br><span class="line">moment = Moment()</span><br><span class="line">db = SQLAlchemy()</span><br><span class="line"></span><br><span class="line">def create_app(config_name):</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(config[config_name])</span><br><span class="line">    config[config_name].init_app(app)</span><br><span class="line"></span><br><span class="line">    bootstrap.init_app(app)</span><br><span class="line">    mail.init_app(app)</span><br><span class="line">    moment.init_app(app)</span><br><span class="line">    db.init_app(app)</span><br><span class="line"></span><br><span class="line">    # 附加路由和自定义的错误页面</span><br><span class="line"></span><br><span class="line">    return app</span><br></pre></td></tr></table></figure></p><p>工厂函数返回创建的程序示例，不过要注意，现在工厂函数创建的程序还不完整，因为没<br>有路由和自定义的错误页面处理程序。</p><h5 id="（2）在蓝本中实现程序功能"><a href="#（2）在蓝本中实现程序功能" class="headerlink" title="（2）在蓝本中实现程序功能"></a>（2）在蓝本中实现程序功能</h5><p>转换成程序工厂函数的操作让定义路由变复杂了。在单脚本程序中，程序实例存在于全局作用域中，路由可以直接使用app.route 修饰器定义。但现在程序在运行时创建，只有调用create_app() 之后才能使用app.route 修饰器，这时定义路由就太晚了。和路由一样，自定义的错误页面处理程序也面临相同的困难，因为错误页面处理程序使用app.errorhandler 修饰器定义。</p><p>幸好Flask 使用蓝本提供了更好的解决方法。蓝本和程序类似，也可以定义路由。不同的是，在蓝本中定义的路由处于休眠状态，直到蓝本注册到程序上后，路由才真正成为程序的一部分。使用位于全局作用域中的蓝本时，定义路由的方法几乎和单脚本程序一样。</p><p>和程序一样，蓝本可以在单个文件中定义，也可使用更结构化的方式在包中的多个模块中创建。为了获得最大的灵活性，程序包中创建了一个子包，用于保存蓝本。示例7-4 是这个子包的构造文件，蓝本就创建于此。</p><p>示例7-4　app/main/__init__.py：创建蓝本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from flask import Blueprint</span><br><span class="line">main = Blueprint(&apos;main&apos;, __name__)</span><br><span class="line">from . import views, errors</span><br></pre></td></tr></table></figure></p><p>通过实例化一个Blueprint 类对象可以创建蓝本。这个构造函数有两个必须指定的参数：蓝本的名字和蓝本所在的包或模块。和程序一样，大多数情况下第二个参数使用Python 的__name__ 变量即可。</p><p>程序的路由保存在包里的app/main/views.py 模块中，而错误处理程序保存在app/main/errors.py 模块中。导入这两个模块就能把路由和错误处理程序与蓝本关联起来。注意，这些模块在app/main/__init__.py 脚本的末尾导入，这是为了避免循环导入依赖，因为在views.py 和errors.py 中还要导入蓝本main。</p><p>蓝本在工厂函数create_app() 中注册到程序上，如示例7-5 所示。<br>示例7-5　app/__init__.py：注册蓝本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def create_app(config_name):</span><br><span class="line">    # ...</span><br><span class="line">    from .main import main as main_blueprint</span><br><span class="line">    app.register_blueprint(main_blueprint)</span><br><span class="line">    </span><br><span class="line">    return app</span><br></pre></td></tr></table></figure></p><p>示例7-6 显示了错误处理程序。<br>示例7-6　app/main/errors.py：蓝本中的错误处理程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from flask import render_template</span><br><span class="line">from . import main</span><br><span class="line"></span><br><span class="line">@main.app_errorhandler(404)</span><br><span class="line">def page_not_found(e):</span><br><span class="line">    return render_template(&apos;404.html&apos;), 404</span><br><span class="line"></span><br><span class="line">@main.app_errorhandler(500)</span><br><span class="line">def internal_server_error(e):</span><br><span class="line">    return render_template(&apos;500.html&apos;), 500</span><br></pre></td></tr></table></figure></p><p>在蓝本中编写错误处理程序稍有不同，如果使用errorhandler 修饰器，那么只有蓝本中的错误才能触发处理程序。要想注册程序全局的错误处理程序，必须使用app_errorhandler。</p><p>在蓝本中定义的程序路由如示例7-7 所示。<br>示例7-7　app/main/views.py：蓝本中定义的程序路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">from flask import render_template, session, redirect, url_for</span><br><span class="line">from . import main</span><br><span class="line">from .forms import NameForm</span><br><span class="line">from .. import db</span><br><span class="line">from ..models import User</span><br><span class="line"></span><br><span class="line">@main.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line">def index():</span><br><span class="line">    form = NameForm()</span><br><span class="line">    if form.validate_on_submit():</span><br><span class="line">        # ...</span><br><span class="line">        return redirect(url_for(&apos;.index&apos;))</span><br><span class="line">    return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;),</span><br><span class="line">        known=session.get(&apos;known&apos;, False), current_time=datetime.utcnow())</span><br></pre></td></tr></table></figure></p><p>在蓝本中编写视图函数主要有两点不同：第一，和前面的错误处理程序一样，路由修饰器由蓝本提供；第二，url_for() 函数的用法不同。你可能还记得，url_for() 函数的第一个参数是路由的端点名，在程序的路由中，默认为视图函数的名字。例如，在单脚本程序中，index() 视图函数的URL 可使用url_for(‘index’) 获取。</p><p>在蓝本中就不一样了，Flask 会为蓝本中的全部端点加上一个命名空间，这样就可以在不同的蓝本中使用相同的端点名定义视图函数，而不会产生冲突。命名空间就是蓝本的名字（Blueprint 构造函数的第一个参数），所以视图函数index() 注册的端点名是main.index，其URL 使用url_for(‘main.index’) 获取。</p><p>url_for() 函数还支持一种简写的端点形式，在蓝本中可以省略蓝本名，例如url_for(‘.index’)。在这种写法中，命名空间是当前请求所在的蓝本。这意味着同一蓝本中的重定向可以使用简写形式，但跨蓝本的重定向必须使用带有命名空间的端点名。</p><p>为了完全修改程序的页面，表单对象也要移到蓝本中，保存于app/main/forms.py 模块。</p><h4 id="4、启动脚本"><a href="#4、启动脚本" class="headerlink" title="4、启动脚本"></a>4、启动脚本</h4><p>顶级文件夹中的manage.py 文件用于启动程序。脚本内容如示例7-8 所示。<br>示例7-8　manage.py：启动脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import os</span><br><span class="line">from app import create_app, db</span><br><span class="line">from app.models import User, Role</span><br><span class="line">from flask.ext.script import Manager, Shell</span><br><span class="line">from flask.ext.migrate import Migrate, MigrateCommand</span><br><span class="line"></span><br><span class="line">app = create_app(os.getenv(&apos;FLASK_CONFIG&apos;) or &apos;default&apos;)</span><br><span class="line"></span><br><span class="line">manager = Manager(app)</span><br><span class="line">migrate = Migrate(app, db)</span><br><span class="line"></span><br><span class="line">def make_shell_context():</span><br><span class="line">    return dict(app=app, db=db, User=User, Role=Role)</span><br><span class="line">manager.add_command(&quot;shell&quot;, Shell(make_context=make_shell_context))</span><br><span class="line"></span><br><span class="line">manager.add_command(&apos;db&apos;, MigrateCommand)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure></p><p>这个脚本先创建程序。如果已经定义了环境变量FLASK_CONFIG，则从中读取配置名；否则使用默认配置。然后初始化Flask-Script、Flask-Migrate 和为Python shell 定义的上下文。出于便利，脚本中加入了shebang 声明，所以在基于Unix 的操作系统中可以通过./manage.py 执行脚本，而不用使用复杂的python manage.py。</p><h4 id="5、需求文件"><a href="#5、需求文件" class="headerlink" title="5、需求文件"></a>5、需求文件</h4><p>程序中必须包含一个requirements.txt 文件，用于记录所有依赖包及其精确的版本号。如果要在另一台电脑上重新生成虚拟环境，这个文件的重要性就体现出来了，例如部署程序时使用的电脑。pip 可以使用如下命令自动生成这个文件：<br>　　<code>(venv) $ pip freeze &gt;requirements.txt</code></p><p>安装或升级包后，最好更新这个文件。需求文件的内容示例如下：</p><blockquote><p>Flask==0.10.1<br>Flask-Bootstrap==3.0.3.1<br>Flask-Mail==0.9.0<br>Flask-Migrate==1.1.0<br>Flask-Moment==0.2.0<br>Flask-SQLAlchemy==1.0<br>Flask-Script==0.6.6<br>Flask-WTF==0.9.4<br>Jinja2==2.7.1<br>Mako==0.9.1<br>MarkupSafe==0.18<br>SQLAlchemy==0.8.4<br>WTForms==1.0.5<br>Werkzeug==0.9.4<br>alembic==0.6.2<br>blinker==1.3<br>itsdangerous==0.23</p></blockquote><p>如果你要创建这个虚拟环境的完全副本，可以创建一个新的虚拟环境，并在其上运行以下命令：<br>　　<code>(venv) $ pip install -r requirements.txt</code></p><p>当你阅读本书时，该示例requirements.txt 文件中的版本号可能已经过期了。如果愿意，你可以试着使用这些包的最新版。如果遇到问题，你可以随时换回这个需求文件中的版本，因为这些版本和程序兼容。</p><h4 id="6、单元测试"><a href="#6、单元测试" class="headerlink" title="6、单元测试"></a>6、单元测试</h4><p>这个程序很小，所以没什么可测试的。不过为了演示，我们可以编写两个简单的测试，如示例7-9 所示。</p><p>示例7-9　tests/test_basics.py：单元测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line">from flask import current_app</span><br><span class="line">from app import create_app, db</span><br><span class="line"></span><br><span class="line">class BasicsTestCase(unittest.TestCase):</span><br><span class="line">    def setUp(self):</span><br><span class="line">        self.app = create_app(&apos;testing&apos;)</span><br><span class="line">        self.app_context = self.app.app_context()</span><br><span class="line">        self.app_context.push()</span><br><span class="line">        db.create_all()</span><br><span class="line">    </span><br><span class="line">    def tearDown(self):</span><br><span class="line">        db.session.remove()</span><br><span class="line">        db.drop_all()</span><br><span class="line">        self.app_context.pop()</span><br><span class="line"></span><br><span class="line">    def test_app_exists(self):</span><br><span class="line">        self.assertFalse(current_app is None)</span><br><span class="line">        def test_app_is_testing(self):</span><br><span class="line">        self.assertTrue(current_app.config[&apos;TESTING&apos;])</span><br></pre></td></tr></table></figure></p><p>这个测试使用Python 标准库中的unittest 包编写。setUp() 和tearDown() 方法分别在各测试前后运行，并且名字以test_ 开头的函数都作为测试执行。</p><p>setUp() 方法尝试创建一个测试环境，类似于运行中的程序。首先，使用测试配置创建程序，然后激活上下文。这一步的作用是确保能在测试中使用current_app，像普通请求一样。然后创建一个全新的数据库，以备不时之需。数据库和程序上下文在tearDown() 方法中删除。</p><p>第一个测试确保程序实例存在。第二个测试确保程序在测试配置中运行。若想把tests 文件夹作为包使用，需要添加tests/__init__.py 文件，不过这个文件可以为空，因为unittest 包会扫描所有模块并查找测试。</p><p>为了运行单元测试，你可以在manage.py 脚本中添加一个自定义命令。示例7-10 展示了如何添加test 命令。</p><p>示例7-10　manage.py：启动单元测试的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@manager.command</span><br><span class="line">def test():</span><br><span class="line">    &quot;&quot;&quot;Run the unit tests.&quot;&quot;&quot;</span><br><span class="line">    import unittest</span><br><span class="line">    tests = unittest.TestLoader().discover(&apos;tests&apos;)</span><br><span class="line">    unittest.TextTestRunner(verbosity=2).run(tests)</span><br></pre></td></tr></table></figure></p><p>manager.command 修饰器让自定义命令变得简单。修饰函数名就是命令名，函数的文档字符串会显示在帮助消息中。test() 函数的定义体中调用了unittest 包提供的测试运行函数。</p><p>单元测试可使用下面的命令运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python manage.py test</span><br><span class="line">test_app_exists (test_basics.BasicsTestCase) ... ok</span><br><span class="line">test_app_is_testing (test_basics.BasicsTestCase) ... ok</span><br><span class="line">.----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.001s</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><h4 id="7、创建数据库"><a href="#7、创建数据库" class="headerlink" title="7、创建数据库"></a>7、创建数据库</h4><p>重组后的程序和单脚本版本使用不同的数据库。</p><p>首选从环境变量中读取数据库的URL，同时还提供了一个默认的SQLite 数据库做备用。3种配置环境中的环境变量名和SQLite 数据库文件名都不一样。例如，在开发环境中，数据库URL 从环境变量DEV_DATABASE_URL 中读取，如果没有定义这个环境变量，则使用名为data-dev.sqlite 的SQLite 数据库。</p><p>不管从哪里获取数据库URL，都要在新数据库中创建数据表。如果使用Flask-Migrate 踪迁移，可使用如下命令创建数据表或者升级到最新修订版本：<br>　　<code>(venv) $ python manage.py db upgrade</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管在单一脚本中编写小型Web 程序很方便，但这种方法并不能广泛使用。程序变复杂后，使用单个大型源码文件会导致很多问题。&lt;/p&gt;
&lt;p&gt;不同于大多数其他的Web 框架，Flask 并不强制要求大型项目使用特定的组织方式，程序结构的组织方式完全由开发者决定。在本章，我们将介绍一种使用包和模块组织大型程序的方式。本书后续示例都将采用这种结构。&lt;/p&gt;
&lt;h4 id=&quot;1、项目结构&quot;&gt;&lt;a href=&quot;#1、项目结构&quot; class=&quot;headerlink&quot; title=&quot;1、项目结构&quot;&gt;&lt;/a&gt;1、项目结构&lt;/h4&gt;&lt;p&gt;Flask 程序的基本结构如示例7-1 所示。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 数据库之Flask-SQLAlchemy管理数据库</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BFlask-SQLAlchemy%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-数据库之Flask-SQLAlchemy管理数据库/</id>
    <published>2018-03-05T08:03:11.000Z</published>
    <updated>2018-03-06T02:24:36.616Z</updated>
    
    <content type="html"><![CDATA[<p>Flask-SQLAlchemy 是一个Flask 扩展，简化了在Flask 程序中使用SQLAlchemy 的操作。SQLAlchemy 是一个很强大的关系型数据库框架，支持多种数据库后台。SQLAlchemy 提供了高层ORM，也提供了使用数据库原生SQL 的低层功能。</p><p>和其他大多数扩展一样，Flask-SQLAlchemy 也使用pip 安装：<br>　　<code>(venv) $ pip install flask-sqlalchemy</code><br><a id="more"></a><br>在Flask-SQLAlchemy 中，数据库使用URL 指定。最流行的数据库引擎采用的数据库URL格式如表5-1 所示。</p><p><strong>表5-1　FLask-SQLAlchemy数据库URL</strong></p><table><thead><tr><th>数据库引擎</th><th>URL</th></tr></thead><tbody><tr><td>MySQL</td><td>mysql://username:password@hostname/database</td></tr><tr><td>Postgres</td><td>postgresql://username:password@hostname/database</td></tr><tr><td>SQLite（Unix）</td><td>sqlite:////absolute/path/to/database</td></tr><tr><td>SQLite（Windows）</td><td>sqlite:///c:/absolute/path/to/database</td></tr></tbody></table><p>在这些URL 中，hostname 表示MySQL 服务所在的主机，可以是本地主机（localhost），也可以是远程服务器。数据库服务器上可以托管多个数据库，因此database 表示要使用的数据库名。如果数据库需要进行认证，username 和password 表示数据库用户密令。<br><em>（注：SQLite 数据库不需要使用服务器，因此不用指定hostname、username 和password。URL 中的database 是硬盘上文件的文件名。）</em></p><p>程序使用的数据库URL 必须保存到Flask 配置对象的SQLALCHEMY_DATABASE_URI 键中。配置对象中还有一个很有用的选项，即SQLALCHEMY_COMMIT_ON_TEARDOWN 键，将其设为True时，每次请求结束后都会自动提交数据库中的变动。其他配置选项的作用请参阅Flask-SQLAlchemy 的文档。示例5-1 展示了如何初始化及配置一个简单的SQLite 数据库。</p><p>示例5-1　hello.py：配置数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.sqlalchemy import SQLAlchemy</span><br><span class="line">basedir = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;)</span><br><span class="line">app.config[&apos;SQLALCHEMY_COMMIT_ON_TEARDOWN&apos;] = True</span><br><span class="line">db = SQLAlchemy(app)</span><br></pre></td></tr></table></figure></p><p>db 对象是SQLAlchemy 类的实例，表示程序使用的数据库，同时还获得了Flask-SQLAlchemy提供的所有功能。</p><h4 id="1、定义模型"><a href="#1、定义模型" class="headerlink" title="1、定义模型"></a>1、定义模型</h4><p>模型这个术语表示程序使用的持久化实体。在ORM 中，模型一般是一个Python 类，类中的属性对应数据库表中的列。</p><p>Flask-SQLAlchemy 创建的数据库实例为模型提供了一个基类以及一系列辅助类和辅助函数，可用于定义模型的结构。图5-1 中的roles 表和users 表可定义为模型Role 和User，如示例5-2 所示。</p><p>示例5-2　hello.py：定义Role 和User 模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Role(db.Model):</span><br><span class="line">    __tablename__ = &apos;roles&apos;</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    name = db.Column(db.String(64), unique=True)</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;Role %r&gt;&apos; % self.name</span><br><span class="line">class User(db.Model):</span><br><span class="line">    __tablename__ = &apos;users&apos;</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    username = db.Column(db.String(64), unique=True, index=True)</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;User %r&gt;&apos; % self.username</span><br></pre></td></tr></table></figure></p><p>类变量__tablename__ 定义在数据库中使用的表名。如果没有定义__tablename__，Flask-SQLAlchemy 会使用一个默认名字，但默认的表名没有遵守使用复数形式进行命名的约定，所以最好由我们自己来指定表名。其余的类变量都是该模型的属性，被定义为db.Column类的实例。</p><p>db.Column 类构造函数的第一个参数是数据库列和模型属性的类型。表5-2 列出了一些可用的列类型以及在模型中使用的Python 类型。</p><p><strong>表5-2　最常用的SQLAlchemy列类型</strong></p><table><thead><tr><th>类型名</th><th>Python类型</th><th>说　　明</th></tr></thead><tbody><tr><td>Integer</td><td>int</td><td>普通整数，一般是32 位</td></tr><tr><td>SmallInteger</td><td>int</td><td>取值范围小的整数，一般是16 位</td></tr><tr><td>BigInteger</td><td>int 或long</td><td>不限制精度的整数</td></tr><tr><td>Float</td><td>float</td><td>浮点数</td></tr><tr><td>Numeric</td><td>decimal.Decimal</td><td>定点数</td></tr><tr><td>String</td><td>str</td><td>变长字符串</td></tr><tr><td>Text</td><td>str</td><td>变长字符串，对较长或不限长度的字符串做了优化</td></tr><tr><td>Unicode</td><td>unicode</td><td>变长Unicode 字符串</td></tr><tr><td>UnicodeText</td><td>unicode</td><td>变长Unicode 字符串，对较长或不限长度的字符串做了优化</td></tr><tr><td>Boolean</td><td>bool</td><td>布尔值</td></tr><tr><td>Date</td><td>datetime.date</td><td>日期</td></tr><tr><td>Time</td><td>datetime.time</td><td>时间</td></tr><tr><td>DateTime</td><td>datetime.datetime</td><td>日期和时间</td></tr><tr><td>Interval</td><td>datetime.timedelta</td><td>时间间隔</td></tr><tr><td>Enum</td><td>str</td><td>一组字符串</td></tr><tr><td>PickleType</td><td>任何Python 对象</td><td>自动使用Pickle 序列化</td></tr><tr><td>LargeBinary</td><td>str</td><td>二进制文件</td></tr></tbody></table><p>db.Column 中其余的参数指定属性的配置选项。表5-3 列出了一些可用选项。</p><p><strong>表5-3　最常使用的SQLAlchemy列选项</strong></p><table><thead><tr><th>选项名</th><th>说　　明</th></tr></thead><tbody><tr><td>primary_key</td><td>如果设为True，这列就是表的主键</td></tr><tr><td>unique</td><td>如果设为True，这列不允许出现重复的值</td></tr><tr><td>index</td><td>如果设为True，为这列创建索引，提升查询效率</td></tr><tr><td>nullable</td><td>如果设为True，这列允许使用空值；如果设为False，这列不允许使用空值</td></tr><tr><td>default</td><td>为这列定义默认值</td></tr></tbody></table><p><strong>（注：Flask-SQLAlchemy 要求每个模型都要定义主键，这一列经常命名为id。）</strong></p><p>虽然没有强制要求，但这两个模型都定义了__repr()__ 方法，返回一个具有可读性的字符串表示模型，可在调试和测试时使用。</p><h4 id="2、关系"><a href="#2、关系" class="headerlink" title="2、关系"></a>2、关系</h4><p>关系型数据库使用关系把不同表中的行联系起来。图5-1 所示的关系图表示用户和角色之间的一种简单关系。这是角色到用户的一对多关系，因为一个角色可属于多个用户，而每个用户都只能有一个角色。</p><p>图5-1 中的一对多关系在模型类中的表示方法如示例5-3 所示。</p><p>示例5-3　hello.py：关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Role(db.Model):</span><br><span class="line">    # ...</span><br><span class="line">    users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;)</span><br><span class="line"></span><br><span class="line">class User(db.Model):</span><br><span class="line">    # ...</span><br><span class="line">    role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;))</span><br></pre></td></tr></table></figure></p><p>如图5-1 所示，关系使用users 表中的外键连接了两行。添加到User 模型中的role_id 列被定义为外键，就是这个外键建立起了关系。传给db.ForeignKey() 的参数’roles.id’ 表明，这列的值是roles 表中行的id 值。</p><p>添加到Role 模型中的users 属性代表这个关系的面向对象视角。对于一个Role 类的实例，其users 属性将返回与角色相关联的用户组成的列表。db.relationship() 的第一个参数表明这个关系的另一端是哪个模型。如果模型类尚未定义，可使用字符串形式指定。</p><p>db.relationship() 中的backref 参数向User 模型中添加一个role 属性，从而定义反向关系。这一属性可替代role_id 访问Role 模型，此时获取的是模型对象，而不是外键的值。</p><p>大多数情况下，db.relationship() 都能自行找到关系中的外键，但有时却无法决定把哪一列作为外键。例如，如果User 模型中有两个或以上的列定义为Role 模型的外键，SQLAlchemy 就不知道该使用哪列。如果无法决定外键，你就要为db.relationship() 提供额外参数，从而确定所用外键。表5-4 列出了定义关系时常用的配置选项。</p><p><strong>表5-4　常用的SQLAlchemy关系选项</strong></p><table><thead><tr><th>选项名</th><th>说　　明</th></tr></thead><tbody><tr><td>backref</td><td>在关系的另一个模型中添加反向引用</td></tr><tr><td>primaryjoin</td><td>明确指定两个模型之间使用的联结条件。只在模棱两可的关系中需要指定</td></tr><tr><td>lazy</td><td>指定如何加载相关记录。可选值有select（首次访问时按需加载）、immediate（源对象加载后就加载）、joined（加载记录，但使用联结）、subquery（立即加载，但使用子查询），noload（永不加载）和dynamic（不加载记录，但提供加载记录的查询）</td></tr><tr><td>uselist</td><td>如果设为Fales，不使用列表，而使用标量值</td></tr><tr><td>order_by</td><td>指定关系中记录的排序方式</td></tr><tr><td>secondary</td><td>指定多对多关系中关系表的名字</td></tr><tr><td>secondaryjoin</td><td>SQLAlchemy 无法自行决定时，指定多对多关系中的二级联结条件</td></tr></tbody></table><p>除了一对多之外，还有几种其他的关系类型。一对一关系可以用前面介绍的一对多关系表示，但调用db.relationship() 时要把uselist 设为False，把“多”变成“一”。多对一关系也可使用一对多表示，对调两个表即可，或者把外键和db.relationship() 都放在“多”这一侧。最复杂的关系类型是多对多，需要用到第三张表，这个表称为关系表。</p><h4 id="3、数据库操作"><a href="#3、数据库操作" class="headerlink" title="3、数据库操作"></a>3、数据库操作</h4><h5 id="（1）创建表"><a href="#（1）创建表" class="headerlink" title="（1）创建表"></a>（1）创建表</h5><p>首先，我们要让Flask-SQLAlchemy 根据模型类创建数据库。方法是使用db.create_all()函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py shell</span><br><span class="line">&gt;&gt;&gt; from hello import db</span><br><span class="line">&gt;&gt;&gt; db.create_all()</span><br></pre></td></tr></table></figure></p><p>如果你查看程序目录，会发现新建了一个名为data.sqlite 的文件。这个SQLite 数据库文件的名字就是在配置中指定的。如果数据库表已经存在于数据库中，那么db.create_all()不会重新创建或者更新这个表。如果修改模型后要把改动应用到现有的数据库中，这一特性会带来不便。更新现有数据库表的粗暴方式是先删除旧表再重新创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.drop_all()</span><br><span class="line">&gt;&gt;&gt; db.create_all()</span><br></pre></td></tr></table></figure></p><p>（注：遗憾的是，这个方法有个我们不想看到的副作用，它把数据库中原有的数据都销毁了。末尾将会介绍一种更好的方式用于更新数据库。）</p><h5 id="（2）插入行"><a href="#（2）插入行" class="headerlink" title="（2）插入行"></a>（2）插入行</h5><p>下面这段代码创建了一些角色和用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from hello import Role, User</span><br><span class="line">&gt;&gt;&gt; admin_role = Role(name=&apos;Admin&apos;)</span><br><span class="line">&gt;&gt;&gt; mod_role = Role(name=&apos;Moderator&apos;)</span><br><span class="line">&gt;&gt;&gt; user_role = Role(name=&apos;User&apos;)</span><br><span class="line">&gt;&gt;&gt; user_john = User(username=&apos;john&apos;, role=admin_role)</span><br><span class="line">&gt;&gt;&gt; user_susan = User(username=&apos;susan&apos;, role=user_role)</span><br><span class="line">&gt;&gt;&gt; user_david = User(username=&apos;david&apos;, role=user_role)</span><br></pre></td></tr></table></figure></p><p>模型的构造函数接受的参数是使用关键字参数指定的模型属性初始值。注意，role 属性也可使用，虽然它不是真正的数据库列，但却是一对多关系的高级表示。这些新建对象的id属性并没有明确设定，因为主键是由Flask-SQLAlchemy 管理的。现在这些对象只存在于Python 中，还未写入数据库。因此id 尚未赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(admin_role.id)</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; print(mod_role.id)</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; print(user_role.id)</span><br><span class="line">None</span><br></pre></td></tr></table></figure></p><p>通过数据库会话管理对数据库所做的改动，在Flask-SQLAlchemy 中，会话由db.session表示。准备把对象写入数据库之前，先要将其添加到会话中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.session.add(admin_role)</span><br><span class="line">&gt;&gt;&gt; db.session.add(mod_role)</span><br><span class="line">&gt;&gt;&gt; db.session.add(user_role)</span><br><span class="line">&gt;&gt;&gt; db.session.add(user_john)</span><br><span class="line">&gt;&gt;&gt; db.session.add(user_susan)</span><br><span class="line">&gt;&gt;&gt; db.session.add(user_david)</span><br></pre></td></tr></table></figure></p><p>或者简写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.session.add_all([admin_role, mod_role, user_role,</span><br><span class="line">... user_john, user_susan, user_david])</span><br></pre></td></tr></table></figure></p><p>为了把对象写入数据库，我们要调用commit() 方法提交会话：<br><code>&gt;&gt;&gt; db.session.commit()</code></p><p>再次查看id 属性，现在它们已经赋值了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(admin_role.id)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(mod_role.id)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; print(user_role.id)</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>数据库会话能保证数据库的一致性。提交操作使用原子方式把会话中的对象全部写入数据库。如果在写入会话的过程中发生了错误，整个会话都会失效。如果你始终把相关改动放在会话中提交，就能避免因部分更新导致的数据库不一致性。</p><h5 id="（3）修改行"><a href="#（3）修改行" class="headerlink" title="（3）修改行"></a>（3）修改行</h5><p>在数据库会话上调用add() 方法也能更新模型。我们继续在之前的shell 会话中进行操作，下面这个例子把”Admin” 角色重命名为”Administrator”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; admin_role.name = &apos;Administrator&apos;</span><br><span class="line">&gt;&gt;&gt; db.session.add(admin_role)</span><br><span class="line">&gt;&gt;&gt; db.session.commit()</span><br></pre></td></tr></table></figure></p><h5 id="（4）删除行"><a href="#（4）删除行" class="headerlink" title="（4）删除行"></a>（4）删除行</h5><p>数据库会话还有个delete() 方法。下面这个例子把”Moderator” 角色从数据库中删除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.session.delete(mod_role)</span><br><span class="line">&gt;&gt;&gt; db.session.commit()</span><br></pre></td></tr></table></figure></p><p>注意，删除与插入和更新一样，提交数据库会话后才会执行。</p><h5 id="（5）查询行"><a href="#（5）查询行" class="headerlink" title="（5）查询行"></a>（5）查询行</h5><p>Flask-SQLAlchemy 为每个模型类都提供了query 对象。最基本的模型查询是取回对应表中的所有记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Role.query.all()</span><br><span class="line">[&lt;Role u&apos;Administrator&apos;&gt;, &lt;Role u&apos;User&apos;&gt;]</span><br><span class="line">&gt;&gt;&gt; User.query.all()</span><br><span class="line">[&lt;User u&apos;john&apos;&gt;, &lt;User u&apos;susan&apos;&gt;, &lt;User u&apos;david&apos;&gt;]</span><br></pre></td></tr></table></figure></p><p>使用过滤器可以配置query 对象进行更精确的数据库查询。下面这个例子查找角色为”User” 的所有用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; User.query.filter_by(role=user_role).all()</span><br><span class="line">[&lt;User u&apos;susan&apos;&gt;, &lt;User u&apos;david&apos;&gt;]</span><br></pre></td></tr></table></figure></p><p>若要查看SQLAlchemy 为查询生成的原生SQL 查询语句，只需把query 对象转换成字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(User.query.filter_by(role=user_role))</span><br><span class="line">&apos;SELECT users.id AS users_id, users.username AS users_username,</span><br><span class="line">users.role_id AS users_role_id FROM users WHERE :param_1 = users.role_id&apos;</span><br></pre></td></tr></table></figure></p><p>filter_by() 等过滤器在query 对象上调用，返回一个更精确的query 对象。多个过滤器可以一起调用，直到获得所需结果。</p><p>表5-5 列出了可在query 对象上调用的常用过滤器。完整的列表参见SQLAlchemy 文档（<a href="http://docs.sqlalchemy.org）。" target="_blank" rel="noopener">http://docs.sqlalchemy.org）。</a></p><p><strong>表5-5　常用的SQLAlchemy查询过滤器</strong></p><table><thead><tr><th>过滤器</th><th>说　　明</th></tr></thead><tbody><tr><td>filter()</td><td>把过滤器添加到原查询上，返回一个新查询</td></tr><tr><td>filter_by()</td><td>把等值过滤器添加到原查询上，返回一个新查询</td></tr><tr><td>limit()</td><td>使用指定的值限制原查询返回的结果数量，返回一个新查询</td></tr><tr><td>offset()</td><td>偏移原查询返回的结果，返回一个新查询</td></tr><tr><td>order_by()</td><td>根据指定条件对原查询结果进行排序，返回一个新查询</td></tr><tr><td>group_by()</td><td>根据指定条件对原查询结果进行分组，返回一个新查询</td></tr></tbody></table><p>在查询上应用指定的过滤器后，通过调用all() 执行查询，以列表的形式返回结果。除了all() 之外，还有其他方法能触发查询执行。表5-6 列出了执行查询的其他方法。</p><p><strong>表5-6　最常使用的SQLAlchemy查询执行函数</strong></p><table><thead><tr><th>方　法</th><th>说　　明</th></tr></thead><tbody><tr><td>all()</td><td>以列表形式返回查询的所有结果</td></tr><tr><td>first()</td><td>返回查询的第一个结果，如果没有结果，则返回None</td></tr><tr><td>first_or_404()</td><td>返回查询的第一个结果，如果没有结果，则终止请求，返回404 错误响应</td></tr><tr><td>get()</td><td>返回指定主键对应的行，如果没有对应的行，则返回None</td></tr><tr><td>get_or_404()</td><td>返回指定主键对应的行，如果没找到指定的主键，则终止请求，返回404 错误响应</td></tr><tr><td>count()</td><td>返回查询结果的数量</td></tr><tr><td>paginate()</td><td>返回一个Paginate 对象，它包含指定范围内的结果</td></tr></tbody></table><p>关系和查询的处理方式类似。下面这个例子分别从关系的两端查询角色和用户之间的一对多关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; users = user_role.users</span><br><span class="line">&gt;&gt;&gt; users</span><br><span class="line">[&lt;User u&apos;susan&apos;&gt;, &lt;User u&apos;david&apos;&gt;]</span><br><span class="line">&gt;&gt;&gt; users[0].role</span><br><span class="line">&lt;Role u&apos;User&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>这个例子中的user_role.users 查询有个小问题。执行user_role.users 表达式时，隐含的查询会调用all() 返回一个用户列表。query 对象是隐藏的，因此无法指定更精确的查询过滤器。就这个特定示例而言，返回一个按照字母顺序排序的用户列表可能更好。如果修改了关系的设置，加入了lazy = ‘dynamic’ 参数，从而禁止自动执行查询。</p><h4 id="4、使用Flask-Migrate实现数据库迁移"><a href="#4、使用Flask-Migrate实现数据库迁移" class="headerlink" title="4、使用Flask-Migrate实现数据库迁移"></a>4、使用Flask-Migrate实现数据库迁移</h4><p>在开发程序的过程中，你会发现有时需要修改数据库模型，而且修改之后还需要更新数据库。</p><p>仅当数据库表不存在时，Flask-SQLAlchemy 才会根据模型进行创建。因此，更新表的唯一方式就是先删除旧表，不过这样做会丢失数据库中的所有数据。</p><p>更新表的更好方法是使用数据库迁移框架。源码版本控制工具可以跟踪源码文件的变化，类似地，数据库迁移框架能跟踪数据库模式的变化，然后增量式的把变化应用到数据库中。</p><p>SQLAlchemy 的主力开发人员编写了一个迁移框架，称为Alembic（<a href="https://alembic.readthedocs.org/en/latest/index.html）。除了直接使用Alembic" target="_blank" rel="noopener">https://alembic.readthedocs.org/en/latest/index.html）。除了直接使用Alembic</a> 之外，Flask 程序还可使用Flask-Migrate（<a href="http://flask-migrate.readthedocs.org/en/latest/）扩展。这个扩展对Alembic" target="_blank" rel="noopener">http://flask-migrate.readthedocs.org/en/latest/）扩展。这个扩展对Alembic</a> 做了轻量级包装，并集成到Flask-Script 中，所有操作都通过Flask-Script 命令完成。</p><h5 id="（1）创建迁移仓库"><a href="#（1）创建迁移仓库" class="headerlink" title="（1）创建迁移仓库"></a>（1）创建迁移仓库</h5><p>首先，我们要在虚拟环境中安装Flask-Migrate：<br>　　<code>(venv) $ pip install flask-migrate</code><br>这个扩展的初始化方法如示例5-8 所示。</p><p>示例5-8　hello.py：配置Flask-Migrate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.migrate import Migrate, MigrateCommand</span><br><span class="line"># ...</span><br><span class="line">migrate = Migrate(app, db)</span><br><span class="line">manager.add_command(&apos;db&apos;, MigrateCommand)</span><br></pre></td></tr></table></figure></p><p>为了导出数据库迁移命令，Flask-Migrate 提供了一个MigrateCommand 类，可附加到Flask-Script 的manager 对象上。在这个例子中，MigrateCommand 类使用db 命令附加。</p><p>在维护数据库迁移之前，要使用init 子命令创建迁移仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py db init</span><br><span class="line">Creating directory /home/flask/flasky/migrations...done</span><br><span class="line">Creating directory /home/flask/flasky/migrations/versions...done</span><br><span class="line">Generating /home/flask/flasky/migrations/alembic.ini...done</span><br><span class="line">Generating /home/flask/flasky/migrations/env.py...done</span><br><span class="line">Generating /home/flask/flasky/migrations/env.pyc...done</span><br><span class="line">Generating /home/flask/flasky/migrations/README...done</span><br><span class="line">Generating /home/flask/flasky/migrations/script.py.mako...done</span><br><span class="line">Please edit configuration/connection/logging settings in</span><br><span class="line">&apos;/home/flask/flasky/migrations/alembic.ini&apos; before proceeding.</span><br></pre></td></tr></table></figure></p><p>这个命令会创建migrations 文件夹，所有迁移脚本都存放其中。</p><h5 id="（2）创建迁移脚本"><a href="#（2）创建迁移脚本" class="headerlink" title="（2）创建迁移脚本"></a>（2）创建迁移脚本</h5><p>在Alembic 中，数据库迁移用迁移脚本表示。脚本中有两个函数，分别是upgrade() 和downgrade()。upgrade() 函数把迁移中的改动应用到数据库中，downgrade() 函数则将改动删除。Alembic 具有添加和删除改动的能力，因此数据库可重设到修改历史的任意一点。</p><p>我们可以使用revision 命令手动创建Alembic 迁移，也可使用migrate 命令自动创建。手动创建的迁移只是一个骨架，upgrade() 和downgrade() 函数都是空的，开发者要使用Alembic 提供的Operations 对象指令实现具体操作。自动创建的迁移会根据模型定义和数据库当前状态之间的差异生成upgrade() 和downgrade() 函数的内容。</p><p>migrate 子命令用来自动创建迁移脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py db migrate -m &quot;initial migration&quot;</span><br><span class="line">INFO [alembic.migration] Context impl SQLiteImpl.</span><br><span class="line">INFO [alembic.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO [alembic.autogenerate] Detected added table &apos;roles&apos;</span><br><span class="line">INFO [alembic.autogenerate] Detected added table &apos;users&apos;</span><br><span class="line">INFO [alembic.autogenerate.compare] Detected added index</span><br><span class="line">&apos;ix_users_username&apos; on &apos;[&apos;username&apos;]&apos;</span><br><span class="line">Generating /home/flask/flasky/migrations/versions/1bc</span><br><span class="line">594146bb5_initial_migration.py...done</span><br></pre></td></tr></table></figure></p><h5 id="（3）更新数据库"><a href="#（3）更新数据库" class="headerlink" title="（3）更新数据库"></a>（3）更新数据库</h5><p>检查并修正好迁移脚本之后，我们可以使用db upgrade 命令把迁移应用到数据库中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py db upgrade</span><br><span class="line">INFO [alembic.migration] Context impl SQLiteImpl.</span><br><span class="line">INFO [alembic.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO [alembic.migration] Running upgrade None -&gt; 1bc594146bb5, initial migration</span><br></pre></td></tr></table></figure></p><p>对第一个迁移来说， 其作用和调用db.create_all() 方法一样。但在后续的迁移中，upgrade 命令能把改动应用到数据库中，且不影响其中保存的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask-SQLAlchemy 是一个Flask 扩展，简化了在Flask 程序中使用SQLAlchemy 的操作。SQLAlchemy 是一个很强大的关系型数据库框架，支持多种数据库后台。SQLAlchemy 提供了高层ORM，也提供了使用数据库原生SQL 的低层功能。&lt;/p&gt;
&lt;p&gt;和其他大多数扩展一样，Flask-SQLAlchemy 也使用pip 安装：&lt;br&gt;　　&lt;code&gt;(venv) $ pip install flask-sqlalchemy&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 数据库概述</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-数据库概述/</id>
    <published>2018-03-05T08:02:31.000Z</published>
    <updated>2018-03-06T02:27:36.004Z</updated>
    
    <content type="html"><![CDATA[<p>数据库按照一定规则保存程序数据，程序再发起查询取回所需的数据。Web 程序最常用基于关系模型的数据库，这种数据库也称为SQL 数据库，因为它们使用结构化查询语言。不过最近几年文档数据库和键值对数据库成了流行的替代选择，这两种数据库合称NoSQL数据库。</p><h4 id="1、SQL数据库"><a href="#1、SQL数据库" class="headerlink" title="1、SQL数据库"></a>1、SQL数据库</h4><p>关系型数据库把数据存储在表中，表模拟程序中不同的实体。例如，订单管理程序的数据库中可能有表customers、products 和orders。<br><a id="more"></a><br>表的列数是固定的，行数是可变的。列定义表所表示的实体的数据属性。例如，customers表中可能有name、address、phone 等列。表中的行定义各列对应的真实数据。</p><p>表中有个特殊的列，称为主键，其值为表中各行的唯一标识符。表中还可以有称为外键的列，引用同一个表或不同表中某行的主键。行之间的这种联系称为关系，这是关系型数据库模型的基础。</p><p>图5-1 展示了一个简单数据库的关系图。这个数据库中有两个表，分别存储用户和用户角色。连接两个表的线代表两个表之间的关系。<br><img src="/uploads/2018/03/flask_database_sql.JPG" alt="" title="图5-1　关系型数据库示例"></p><p>在这个数据库关系图中，roles 表存储所有可用的用户角色，每个角色都使用一个唯一的id 值（即表的主键）进行标识。users 表包含用户列表，每个用户也有唯一的id 值。除了id 主键之外，roles 表中还有name 列，users 表中还有username 列和password 列。users表中的role_id 列是外键，引用角色的id，通过这种方式为每个用户指定角色。</p><p>从这个例子可以看出，关系型数据库存储数据很高效，而且避免了重复。将这个数据库中的用户角色重命名也很简单，因为角色名只出现在一个地方。一旦在roles 表中修改完角色名，所有通过role_id 引用这个角色的用户都能立即看到更新。</p><p>但从另一方面来看，把数据分别存放在多个表中还是很复杂的。生成一个包含角色的用户列表会遇到一个小问题，因为在此之前要分别从两个表中读取用户和用户角色，再将其联结起来。关系型数据库引擎为联结操作提供了必要的支持。</p><h4 id="2、NoSQL数据库"><a href="#2、NoSQL数据库" class="headerlink" title="2、NoSQL数据库"></a>2、NoSQL数据库</h4><p>所有不遵循上节所述的关系模型的数据库统称为NoSQL 数据库。NoSQL 数据库一般使用集合代替表，使用文档代替记录。NoSQL 数据库采用的设计方式使联结变得困难，所以大多数数据库根本不支持这种操作。对于结构如图5-1 所示的NoSQL 数据库，若要列出各用户及其角色，就需要在程序中执行联结操作，即先读取每个用户的role_id，再在roles表中搜索对应的记录。</p><p>NoSQL 数据库更适合设计成如图5-2 所示的结构。这是执行反规范化操作得到的结果，它减少了表的数量，却增加了数据重复量。<br><img src="/uploads/2018/03/flask_database_nosql.JPG" alt="" title="图5-2　NoSQL 数据库示例"></p><p>这种结构的数据库要把角色名存储在每个用户中。如此一来，将角色重命名的操作就变得很耗时，可能需要更新大量文档。</p><p>使用NoSQL 数据库当然也有好处。数据重复可以提升查询速度。列出用户及其角色的操作很简单，因为无需联结。</p><h4 id="3、使用SQL还是使用NoSQL"><a href="#3、使用SQL还是使用NoSQL" class="headerlink" title="3、使用SQL还是使用NoSQL"></a>3、使用SQL还是使用NoSQL</h4><p>SQL 数据库擅于用高效且紧凑的形式存储结构化数据。这种数据库需要花费大量精力保证数据的一致性。NoSQL 数据库放宽了对这种一致性的要求，从而获得性能上的优势。</p><p>对不同类型数据库的全面分析、对比待续。对中小型程序来说，SQL 和NoSQL数据库都是很好的选择，而且性能相当。</p><h4 id="4、Python数据库框架"><a href="#4、Python数据库框架" class="headerlink" title="4、Python数据库框架"></a>4、Python数据库框架</h4><p>大多数的数据库引擎都有对应的Python 包，包括开源包和商业包。Flask 并不限制你使用何种类型的数据库包，因此可以根据自己的喜好选择使用MySQL、Postgres、SQLite、Redis、MongoDB 或者CouchDB。</p><p>如果这些都无法满足需求，还有一些数据库抽象层代码包供选择，例如SQLAlchemy 和MongoEngine。你可以使用这些抽象包直接处理高等级的Python 对象，而不用处理如表、文档或查询语言此类的数据库实体。</p><p>选择数据库框架时，你要考虑很多因素。</p><p><strong>易用性</strong><br>如果直接比较数据库引擎和数据库抽象层，显然后者取胜。抽象层，也称为对象关系映射（Object-Relational Mapper，ORM） 或对象文档映射（Object-Document Mapper，ODM），在用户不知觉的情况下把高层的面向对象操作转换成低层的数据库指令。</p><p><strong>性能</strong><br>ORM 和ODM 把对象业务转换成数据库业务会有一定的损耗。大多数情况下，这种性能的降低微不足道，但也不一定都是如此。一般情况下，ORM 和ODM 对生产率的提升远远超过了这一丁点儿的性能降低，所以性能降低这个理由不足以说服用户完全放弃ORM 和ODM。真正的关键点在于如何选择一个能直接操作低层数据库的抽象层，以防特定的操作需要直接使用数据库原生指令优化。</p><p><strong>可移植性</strong><br>选择数据库时，必须考虑其是否能在你的开发平台和生产平台中使用。例如，如果你打算利用云平台托管程序，就要知道这个云服务提供了哪些数据库可供选择。<br>可移植性还针对ORM 和ODM。尽管有些框架只为一种数据库引擎提供抽象层，但其他框架可能做了更高层的抽象，它们支持不同的数据库引擎，而且都使用相同的面向对象接口。SQLAlchemy ORM 就是一个很好的例子，它支持很多关系型数据库引擎，包括流行的MySQL、Postgres 和SQLite。</p><p><strong>FLask集成度</strong><br>选择框架时，你不一定非得选择已经集成了Flask 的框架，但选择这些框架可以节省你编写集成代码的时间。使用集成了Flask 的框架可以简化配置和操作，所以专门为Flask 开发的扩展是你的首选。</p><p>基于以上因素，选择使用的数据库框架是Flask-SQLAlchemy（<a href="http://pythonhosted.org/Flask-SQLAlchemy/），这个Flask" target="_blank" rel="noopener">http://pythonhosted.org/Flask-SQLAlchemy/），这个Flask</a> 扩展包装了SQLAlchemy（<a href="http://www.sqlalchemy.org/）框架。" target="_blank" rel="noopener">http://www.sqlalchemy.org/）框架。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库按照一定规则保存程序数据，程序再发起查询取回所需的数据。Web 程序最常用基于关系模型的数据库，这种数据库也称为SQL 数据库，因为它们使用结构化查询语言。不过最近几年文档数据库和键值对数据库成了流行的替代选择，这两种数据库合称NoSQL数据库。&lt;/p&gt;
&lt;h4 id=&quot;1、SQL数据库&quot;&gt;&lt;a href=&quot;#1、SQL数据库&quot; class=&quot;headerlink&quot; title=&quot;1、SQL数据库&quot;&gt;&lt;/a&gt;1、SQL数据库&lt;/h4&gt;&lt;p&gt;关系型数据库把数据存储在表中，表模拟程序中不同的实体。例如，订单管理程序的数据库中可能有表customers、products 和orders。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 表单(Flask-WTF)</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E8%A1%A8%E5%8D%95-Flask-WTF/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-表单-Flask-WTF/</id>
    <published>2018-03-05T08:02:19.000Z</published>
    <updated>2018-03-06T02:23:51.143Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、引入模块"><a href="#1、引入模块" class="headerlink" title="1、引入模块"></a>1、引入模块</h4><p>Flask-WTF（<a href="http://pythonhosted.org/Flask-WTF/）扩展可以把处理Web" target="_blank" rel="noopener">http://pythonhosted.org/Flask-WTF/）扩展可以把处理Web</a> 表单的过程变成一种愉悦的体验。这个扩展对独立的WTForms（<a href="http://wtforms.simplecodes.com）包进行了包装，方便集成到Flask" target="_blank" rel="noopener">http://wtforms.simplecodes.com）包进行了包装，方便集成到Flask</a> 程序中。</p><p>Flask-WTF 及其依赖可使用pip 安装：<br>　　<code>(venv) $ pip install flask-wtf</code><br><a id="more"></a></p><h4 id="2、跨站请求伪造保护"><a href="#2、跨站请求伪造保护" class="headerlink" title="2、跨站请求伪造保护"></a>2、跨站请求伪造保护</h4><p>默认情况下，Flask-WTF 能保护所有表单免受跨站请求伪造（Cross-Site Request Forgery，CSRF）的攻击。恶意网站把请求发送到被攻击者已登录的其他网站时就会引发CSRF 攻击。</p><p>为了实现CSRF 保护，Flask-WTF 需要程序设置一个密钥。Flask-WTF 使用这个密钥生成加密令牌，再用令牌验证请求中表单数据的真伪。设置密钥的方法如示例4-1 所示。</p><p>示例4-1　hello.py：设置Flask-WTF<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[&apos;SECRET_KEY&apos;] = &apos;hard to guess string&apos;</span><br></pre></td></tr></table></figure></p><p><strong>（注：SECRET_KEY 常量一般放在配置文件中，而常量的值一般放在环境变量中，配置文件从环境变量中获取值。防止他人获取配置文件拿到SECRET_KEY值）</strong></p><h4 id="3、表单类"><a href="#3、表单类" class="headerlink" title="3、表单类"></a>3、表单类</h4><p>使用Flask-WTF 时，每个Web 表单都由一个继承自Form 的类表示。这个类定义表单中的一组字段，每个字段都用对象表示。字段对象可附属一个或多个验证函数。验证函数用来验证用户提交的输入值是否符合要求。<br>示例4-2 是一个简单的Web 表单，包含一个文本字段和一个提交按钮。</p><p>示例4-2 是一个简单的Web 表单，包含一个文本字段和一个提交按钮。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例4-2　hello.py：定义表单类</span><br><span class="line">from flask_wtf import Form</span><br><span class="line">from wtforms import StringField, SubmitField</span><br><span class="line">from wtforms.validators import Required</span><br><span class="line"></span><br><span class="line">class NameForm(Form):</span><br><span class="line">    name = StringField(&apos;What is your name?&apos;, validators=[Required()])</span><br><span class="line">    submit = SubmitField(&apos;Submit&apos;)</span><br></pre></td></tr></table></figure></p><p>这个表单中的字段都定义为类变量，类变量的值是相应字段类型的对象。在这个示例中，NameForm 表单中有一个名为name 的文本字段和一个名为submit 的提交按钮。StringField类表示属性为type=”text” 的<code>&lt;input&gt;</code> 元素。SubmitField 类表示属性为type=”submit” 的<code>&lt;input&gt;</code> 元素。字段构造函数的第一个参数是把表单渲染成HTML 时使用的标号。</p><p>StringField 构造函数中的可选参数validators 指定一个由验证函数组成的列表，在接受用户提交的数据之前验证数据。验证函数Required() 确保提交的字段不为空。<br><strong>（注：Form 基类由Flask-WTF 扩展定义，所以从flask.ext.wtf 中导入。字段和验证函数却可以直接从WTForms 包中导入。）</strong></p><p><strong>表4-1　WTForms支持的HTML标准字段</strong></p><table><thead><tr><th>字段类型</th><th>说　　明</th></tr></thead><tbody><tr><td>StringField</td><td>文本字段</td></tr><tr><td>TextAreaField</td><td>多行文本字段</td></tr><tr><td>PasswordField</td><td>密码文本字段</td></tr><tr><td>HiddenField</td><td>隐藏文本字段</td></tr><tr><td>DateField</td><td>文本字段，值为datetime.date 格式</td></tr><tr><td>DateTimeField</td><td>文本字段，值为datetime.datetime 格式</td></tr><tr><td>IntegerField</td><td>文本字段，值为整数</td></tr><tr><td>DecimalField</td><td>文本字段，值为decimal.Decimal</td></tr><tr><td>FloatField</td><td>文本字段，值为浮点数</td></tr><tr><td>BooleanField</td><td>复选框，值为True 和False</td></tr><tr><td>RadioField</td><td>一组单选框</td></tr><tr><td>SelectField</td><td>下拉列表</td></tr><tr><td>SelectMultipleField</td><td>下拉列表，可选择多个值</td></tr><tr><td>FileField</td><td>文件上传字段</td></tr><tr><td>SubmitField</td><td>表单提交按钮</td></tr><tr><td>FormField</td><td>把表单作为字段嵌入另一个表单</td></tr><tr><td>FieldList</td><td>一组指定类型的字段</td></tr></tbody></table><p><strong>表4-2　WTForms验证函数</strong></p><table><thead><tr><th>验证函数</th><th>说　　明</th></tr></thead><tbody><tr><td>Email</td><td>验证电子邮件地址</td></tr><tr><td>EqualTo</td><td>比较两个字段的值；常用于要求输入两次密码进行确认的情况</td></tr><tr><td>IPAddress</td><td>验证IPv4 网络地址</td></tr><tr><td>Length</td><td>验证输入字符串的长度</td></tr><tr><td>NumberRange</td><td>验证输入的值在数字范围内</td></tr><tr><td>Optional</td><td>无输入值时跳过其他验证函数</td></tr><tr><td>Required</td><td>确保字段中有数据</td></tr><tr><td>Regexp</td><td>使用正则表达式验证输入值</td></tr><tr><td>URL</td><td>验证URL</td></tr><tr><td>AnyOf</td><td>确保输入值在可选值列表中</td></tr><tr><td>NoneOf</td><td>确保输入值不在可选值列表中</td></tr></tbody></table><h4 id="4、把表单渲染成HTML"><a href="#4、把表单渲染成HTML" class="headerlink" title="4、把表单渲染成HTML"></a>4、把表单渲染成HTML</h4><h5 id="（1）手工方式渲染"><a href="#（1）手工方式渲染" class="headerlink" title="（1）手工方式渲染"></a>（1）手工方式渲染</h5><p>表单字段是可调用的，在模板中调用后会渲染成HTML。假设视图函数把一个NameForm 实例通过参数form 传入模板，在模板中可以生成一个简单的表单，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot;&gt;</span><br><span class="line">&#123;&#123; form.hidden_tag() &#125;&#125;</span><br><span class="line">&#123;&#123; form.name.label &#125;&#125; &#123;&#123; form.name() &#125;&#125;</span><br><span class="line">&#123;&#123; form.submit() &#125;&#125;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><p>当然，这个表单还很简陋。要想改进表单的外观，可以把参数传入渲染字段的函数，传入的参数会被转换成字段的HTML 属性。例如，可以为字段指定id 或class 属性，然后定义CSS 样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot;&gt;</span><br><span class="line">&#123;&#123; form.hidden_tag() &#125;&#125;</span><br><span class="line">&#123;&#123; form.name.label &#125;&#125; &#123;&#123; form.name(id=&apos;my-text-field&apos;) &#125;&#125;</span><br><span class="line">&#123;&#123; form.submit() &#125;&#125;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><p>即便能指定HTML 属性，但按照这种方式渲染表单的工作量还是很大，所以在条件允许的情况下最好能使用Bootstrap 中的表单样式。</p><h5 id="（2）使用Bootstrap表单样式渲染"><a href="#（2）使用Bootstrap表单样式渲染" class="headerlink" title="（2）使用Bootstrap表单样式渲染"></a>（2）使用Bootstrap表单样式渲染</h5><p>Flask-Bootstrap 提供了一个非常高端的辅助函数，可以使用Bootstrap 中预先定义好的表单样式渲染整个Flask-WTF 表单，而这些操作只需一次调用即可完成。使用Flask-Bootstrap，上述表单可使用下面的方式渲染：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% import &quot;bootstrap/wtf.html&quot; as wtf %&#125;</span><br><span class="line">&#123;&#123; wtf.quick_form(form) &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>import 指令的使用方法和普通Python 代码一样，允许导入模板中的元素并用在多个模板中。导入的bootstrap/wtf.html 文件中定义了一个使用Bootstrap 渲染Falsk-WTF 表单对象的辅助函数。wtf.quick_form() 函数的参数为Flask-WTF 表单对象，使用Bootstrap 的默认样式渲染传入的表单。</p><h4 id="5、在视图函数中处理表单"><a href="#5、在视图函数中处理表单" class="headerlink" title="5、在视图函数中处理表单"></a>5、在视图函数中处理表单</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例4-4　hello.py：路由方法</span><br><span class="line">@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line">def index():</span><br><span class="line">    name = None</span><br><span class="line">    form = NameForm()</span><br><span class="line">    if form.validate_on_submit():</span><br><span class="line">        name = form.name.data</span><br><span class="line">        form.name.data = &apos;&apos;</span><br><span class="line">    return render_template(&apos;index.html&apos;, form=form, name=name)</span><br></pre></td></tr></table></figure><p>app.route 修饰器中添加的methods 参数告诉Flask 在URL 映射中把这个视图函数注册为GET 和POST 请求的处理程序。如果没指定methods 参数，就只把视图函数注册为GET 请求的处理程序。</p><p>把POST 加入方法列表很有必要，因为将提交表单作为POST 请求进行处理更加便利。表单也可作为GET 请求提交，不过GET 请求没有主体，提交的数据以查询字符串的形式附加到URL 中，可在浏览器的地址栏中看到。基于这个以及其他多个原因，提交表单大都作为POST 请求进行处理。</p><p>局部变量name 用来存放表单中输入的有效名字，如果没有输入，其值为None。如上述代码所示，在视图函数中创建一个NameForm 类实例用于表示表单。提交表单后，如果数据能被所有验证函数接受，那么validate_on_submit() 方法的返回值为True，否则返回False。这个函数的返回值决定是重新渲染表单还是处理表单提交的数据。</p><p>用户第一次访问程序时，服务器会收到一个没有表单数据的GET 请求，所以validate_on_submit() 将返回False。if 语句的内容将被跳过，通过渲染模板处理请求，并传入表单对象和值为None 的name 变量作为参数。用户会看到浏览器中显示了一个表单。</p><p>用户提交表单后，服务器收到一个包含数据的POST 请求。validate_on_submit() 会调用name 字段上附属的Required() 验证函数。如果名字不为空，就能通过验证，validate_on_submit() 返回True。现在，用户输入的名字可通过字段的data 属性获取。在if 语句中，把名字赋值给局部变量name，然后再把data 属性设为空字符串，从而清空表单字段。最后一行调用render_template() 函数渲染模板，但这一次参数name 的值为表单中输入的名字，因此会显示一个针对该用户的欢迎消息。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、引入模块&quot;&gt;&lt;a href=&quot;#1、引入模块&quot; class=&quot;headerlink&quot; title=&quot;1、引入模块&quot;&gt;&lt;/a&gt;1、引入模块&lt;/h4&gt;&lt;p&gt;Flask-WTF（&lt;a href=&quot;http://pythonhosted.org/Flask-WTF/）扩展可以把处理Web&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pythonhosted.org/Flask-WTF/）扩展可以把处理Web&lt;/a&gt; 表单的过程变成一种愉悦的体验。这个扩展对独立的WTForms（&lt;a href=&quot;http://wtforms.simplecodes.com）包进行了包装，方便集成到Flask&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://wtforms.simplecodes.com）包进行了包装，方便集成到Flask&lt;/a&gt; 程序中。&lt;/p&gt;
&lt;p&gt;Flask-WTF 及其依赖可使用pip 安装：&lt;br&gt;　　&lt;code&gt;(venv) $ pip install flask-wtf&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 模板续(集成 Twitter Bootstrap)</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E6%A8%A1%E6%9D%BF%E7%BB%AD-%E9%9B%86%E6%88%90-Twitter-Bootstrap/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-模板续-集成-Twitter-Bootstrap/</id>
    <published>2018-03-05T08:02:02.000Z</published>
    <updated>2018-03-06T02:23:07.749Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、集成-Bootstrap"><a href="#1、集成-Bootstrap" class="headerlink" title="1、集成 Bootstrap"></a>1、集成 Bootstrap</h4><p>Bootstrap（<a href="http://getbootstrap.com/）是Twitter" target="_blank" rel="noopener">http://getbootstrap.com/）是Twitter</a> 开发的一个开源框架，它提供的用户界面组件可用于创建整洁且具有吸引力的网页，而且这些网页还能兼容所有现代Web 浏览器。</p><p>Bootstrap 是客户端框架，因此不会直接涉及服务器。服务器需要做的只是提供引用了Bootstrap 层叠样式表（CSS） 和JavaScript 文件的HTML 响应， 并在HTML、CSS 和JavaScript 代码中实例化所需组件。这些操作最理想的执行场所就是模板。</p><p>Flask-Bootstrap 使用pip安装：<br><code>(venv) $ pip install flask-bootstrap</code><br><a id="more"></a><br>Flask 扩展一般都在创建程序实例时初始化。示例3-4 是Flask-Bootstrap 的初始化方法。<br>示例3-4　hello.py：初始化Flask-Bootstrap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from flask_bootstrap import Bootstrap</span><br><span class="line"># ...</span><br><span class="line">bootstrap = Bootstrap(app)</span><br></pre></td></tr></table></figure></p><p>初始化Flask-Bootstrap 之后，就可以在程序中使用一个包含所有Bootstrap 文件的基模板。这个模板利用Jinja2 的模板继承机制，让程序扩展一个具有基本页面结构的基模板，其中就有用来引入Bootstrap 的元素。</p><p>Jinja2 的模板继承机制可以帮助我们解决这一问题。Flask-Bootstrap 提供了一个具有页面基本布局的基模板，同样，程序可以定义一个具有更完整页面布局的基模板，其中包含导航条，而页面内容则可留到衍生模板中定义。示例3-7 展示了templates/base.html 的内容，这是一个继承自bootstrap/base.html 的新模板，其中定义了导航条。这个模板本身也可作为其他模板的基模板，例如templates/user.html、templates/404.html 和templates/500.html。</p><p>示例3-7　templates/base.html：包含导航条的程序基模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;bootstrap/base.html&quot; %&#125;</span><br><span class="line">&#123;% block title %&#125;Flasky&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block navbar %&#125;</span><br><span class="line">&lt;div class=&quot;navbar navbar-inverse&quot; role=&quot;navigation&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;navbar-header&quot;&gt;</span><br><span class="line">            &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; </span><br><span class="line">            data-target=&quot;.navbar-collapse&quot;&gt;</span><br><span class="line">                &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;</span><br><span class="line">                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;Flasky&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;navbar-collapse collapse&quot;&gt;</span><br><span class="line">&lt;ul class=&quot;nav navbar-nav&quot;&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&#123;% block page_content %&#125;&#123;% endblock %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>这个模板的content 块中只有一个<code>&lt;div&gt;</code> 容器，其中包含了一个名为page_content 的新的空块，块中的内容由衍生模板定义。</p><p>Jinja2 中的extends 指令从Flask-Bootstrap 中导入bootstrap/base.html， 从而实现模板继承。Flask-Bootstrap 中的基模板提供了一个网页框架，引入了Bootstrap 中的所有CSS 和JavaScript 文件。</p><p>基模板中定义了可在衍生模板中重定义的块。block 和endblock 指令定义的块中的内容可添加到基模板中。</p><p>上面这个base.html 模板定义了3 个块，分别名为title、navbar 和content。这些块都是基模板提供的，可在衍生模板中重新定义。title 块的作用很明显，其中的内容会出现在渲染后的HTML 文档头部，放在<code>&lt;title&gt;</code> 标签中。navbar 和content 这两个块分别表示页面中的导航条和主体内容。</p><p>在这个模板中，navbar 块使用Bootstrap 组件定义了一个简单的导航条。content 块中有个<code>&lt;div&gt;</code> 容器，其中包含一个页面头部。之前版本的模板中的欢迎信息，现在就放在这个页面头部。</p><p>Flask-Bootstrap 的base.html 模板还定义了很多其他块，都可在衍生模板中使用。表3-2 列出了所有可用的快。<br><strong>表3-2 　Flask-Bootstrap基模板中定义的块</strong></p><table><thead><tr><th>块　　名</th><th>说　　明</th></tr></thead><tbody><tr><td>doc</td><td>整个HTML 文档</td></tr><tr><td>html_attribs</td><td><html> 标签的属性</html></td></tr><tr><td>html</td><td><html> 标签中的内容</html></td></tr><tr><td>head</td><td><head> 标签中的内容</head></td></tr><tr><td>title</td><td><title> 标签中的内容</title></td></tr><tr><td>metas</td><td>一组<meta> 标签</td></tr><tr><td>styles</td><td>层叠样式表定义</td></tr><tr><td>body_attribs</td><td><body> 标签的属性</body></td></tr><tr><td>body</td><td><body> 标签中的内容</body></td></tr><tr><td>navbar</td><td>用户定义的导航条</td></tr><tr><td>content</td><td>用户定义的页面内容</td></tr><tr><td>scripts</td><td>文档底部的JavaScript 声明</td></tr></tbody></table><p>表3-2 中的很多块都是Flask-Bootstrap 自用的，如果直接重定义可能会导致一些问题。例如，Bootstrap 所需的文件在styles 和scripts 块中声明。如果程序需要向已经有内容的块中添加新内容，必须使用Jinja2 提供的super() 函数。例如，如果要在衍生模板中添加新的JavaScript 文件，需要这么定义scripts 块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block scripts %&#125;</span><br><span class="line">    &#123;&#123; super() &#125;&#125;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;my-script.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、自定义错误页面"><a href="#2、自定义错误页面" class="headerlink" title="2、自定义错误页面"></a>2、自定义错误页面</h4><p>像常规路由一样，Flask 允许程序使用基于模板的自定义错误页面。最常见的错误代码有两个：404，客户端请求未知页面或路由时显示；500，有未处理的异常时显示。为这两个错误代码指定自定义处理程序的方式如示例3-6 所示。</p><p>示例3-6　hello.py：自定义错误页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@app.errorhandler(404)</span><br><span class="line">def page_not_found(e):</span><br><span class="line">    return render_template(&apos;404.html&apos;), 404</span><br><span class="line">@app.errorhandler(500)</span><br><span class="line">def internal_server_error(e):</span><br><span class="line">    return render_template(&apos;500.html&apos;), 500</span><br></pre></td></tr></table></figure></p><p>和视图函数一样，错误处理程序也会返回响应。它们还返回与该错误对应的数字状态码。</p><p>错误处理程序中引用的模板也需要编写。这些模板应该和常规页面使用相同的布局，因此要有一个导航条和显示错误消息的页面头部。</p><p>现在，程序使用的模板继承自 templates/base.html 模板，而不直接继承自Flask-Bootstrap 的基模板。通过继承templates/base.html 模板编写自定义的404 错误页面很简单，如示例3-8 所示。</p><p>示例3-8　templates/404.html：使用模板继承机制自定义404 错误页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line">&#123;% block title %&#125;Flasky - Page Not Found&#123;% endblock %&#125;</span><br><span class="line">&#123;% block page_content %&#125;</span><br><span class="line">    &lt;div class=&quot;page-header&quot;&gt;</span><br><span class="line">        &lt;h1&gt;Not Found&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>templates/user.html 现在可以通过继承这个基模板来简化内容，如示例3-9 所示。<br>示例3-9　templates/user.html：使用模板继承机制简化页面模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line">&#123;% block title %&#125;Flasky&#123;% endblock %&#125;</span><br><span class="line">&#123;% block page_content %&#125;</span><br><span class="line">&lt;div class=&quot;page-header&quot;&gt;</span><br><span class="line">&lt;h1&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、链接"><a href="#3、链接" class="headerlink" title="3、链接"></a>3、链接</h4><p>在模板中直接编写简单路由的URL 链接不难，但对于包含可变部分的动态路由，在模板中构建正确的URL 就很困难。而且，直接编写URL 会对代码中定义的路由产生不必要的依赖关系。如果重新定义路由，模板中的链接可能会失效。</p><p>为了避免这些问题，Flask 提供了url_for() 辅助函数，它可以使用程序URL 映射中保存的信息生成URL。</p><p>url_for() 函数最简单的用法是以视图函数名（或者app.add_url_route() 定义路由时使用的端点名）作为参数，返回对应的URL。例如，在当前版本的hello.py 程序中调用url_for(‘index’) 得到的结果是/。调用url_for(‘index’, _external=True) 返回的则是绝对地址，在这个示例中是<a href="http://localhost:5000/。" target="_blank" rel="noopener">http://localhost:5000/。</a></p><p>使用url_for() 生成动态地址时， 将动态部分作为关键字参数传入。例如，url_for(‘user’, name=’john’, _external=True) 的返回结果是<a href="http://localhost:5000/user/john。传入url_for(" target="_blank" rel="noopener">http://localhost:5000/user/john。传入url_for(</a>) 的关键字参数不仅限于动态路由中的参数。函数能将任何额外参数添加到查询字符串中。例如，url_for(‘index’, page=2) 的返回结果是/?page=2。</p><h4 id="4、静态文件"><a href="#4、静态文件" class="headerlink" title="4、静态文件"></a>4、静态文件</h4><p>Web 程序不是仅由Python 代码和模板组成。大多数程序还会使用静态文件，例如HTML代码中引用的图片、JavaScript 源码文件和CSS。</p><p>默认设置下，Flask 在程序根目录中名为static 的子目录中寻找静态文件。如果需要，可在static 文件夹中使用子文件夹存放文件。服务器收到前面那个URL 后，会生成一个响应，包含文件系统中static/css/styles.css 文件的内容。</p><p>示例3-10 展示了如何在程序的基模板中放置favicon.ico 图标。这个图标会显示在浏览器的地址栏中。<br>示例3-10　templates/base.html：定义收藏夹图标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block head %&#125;</span><br><span class="line">&#123;&#123; super() &#125;&#125;</span><br><span class="line">&lt;link rel=&quot;shortcut icon&quot; href=&quot;&#123;&#123; url_for(&apos;static&apos;, filename = &apos;favicon.ico&apos;) &#125;&#125;&quot;</span><br><span class="line"> type=&quot;image/x-icon&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;icon&quot; href=&quot;&#123;&#123; url_for(&apos;static&apos;, filename = &apos;favicon.ico&apos;) &#125;&#125;&quot;</span><br><span class="line"> type=&quot;image/x-icon&quot;&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>图标的声明会插入head 块的末尾。注意如何使用super() 保留基模板中定义的块的原始内容。</p><h4 id="5、使用Flask-Moment-本地化日期和时间"><a href="#5、使用Flask-Moment-本地化日期和时间" class="headerlink" title="5、使用Flask-Moment 本地化日期和时间"></a>5、使用Flask-Moment 本地化日期和时间</h4><p>服务器需要统一时间单位，这和用户所在的地理位置无关，所以一般使用协调世界时（Coordinated Universal Time，UTC）。不过用户看到UTC 格式的时间会感到困惑，他们更希望看到当地时间，而且采用当地惯用的格式。</p><p>要想在服务器上只使用UTC 时间，一个优雅的解决方案是，把时间单位发送给Web 浏览器，转换成当地时间，然后渲染。Web 浏览器可以更好地完成这一任务，因为它能获取用户电脑中的时区和区域设置。</p><p>有一个使用JavaScript 开发的优秀客户端开源代码库，名为moment.js（<a href="http://momentjs.com/），它可以在浏览器中渲染日期和时间。Flask-Moment" target="_blank" rel="noopener">http://momentjs.com/），它可以在浏览器中渲染日期和时间。Flask-Moment</a> 是一个Flask 程序扩展，能把moment.js 集成到Jinja2 模板中。Flask-Moment 可以使用pip 安装：<br><code>(venv) $ pip install flask-moment</code></p><p>这个扩展的初始化方法如示例3-11 所示。<br>示例3-11　hello.py：初始化Flask-Moment<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.moment import Moment</span><br><span class="line">moment = Moment(app)</span><br></pre></td></tr></table></figure></p><p>除了moment.js，Flask-Moment 还依赖jquery.js。要在HTML 文档的某个地方引入这两个库，可以直接引入，这样可以选择使用哪个版本，也可使用扩展提供的辅助函数，从内容分发网络（Content Delivery Network，CDN）中引入通过测试的版本。Bootstrap 已经引入了jquery.js，因此只需引入moment.js 即可。示例3-12 展示了如何在基模板的scripts 块中引入这个库。<br>示例3-12　templates/base.html：引入moment.js 库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block scripts %&#125;</span><br><span class="line">&#123;&#123; super() &#125;&#125;</span><br><span class="line">&#123;&#123; moment.include_moment() &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>为了处理时间戳，Flask-Moment 向模板开放了moment 类。示例3-13 中的代码把变量current_time 传入模板进行渲染。</p><p>示例3-13　hello.py：加入一个datetime 变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&apos;index.html&apos;, current_time=datetime.utcnow())</span><br></pre></td></tr></table></figure></p><p>示例3-14 展示了如何在模板中渲染current_time。<br>代码3-14　templates/index.html：使用Flask-Moment 渲染时间戳<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;The local date and time is &#123;&#123; moment(current_time).format(&apos;LLL&apos;) &#125;&#125;.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;That was &#123;&#123; moment(current_time).fromNow(refresh=True) &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>format(‘LLL’) 根据客户端电脑中的时区和区域设置渲染日期和时间。参数决定了渲染的方式，’L’ 到’LLLL’ 分别对应不同的复杂度。format() 函数还可接受自定义的格式说明符。</p><p>第二行中的fromNow() 渲染相对时间戳，而且会随着时间的推移自动刷新显示的时间。这个时间戳最开始显示为“a few seconds ago”，但指定refresh 参数后，其内容会随着时间的推移而更新。如果一直待在这个页面，几分钟后，会看到显示的文本变成“a minuteago”“2 minutes ago”等。</p><p>Flask-Moment 实现了moment.js 中的format()、fromNow()、fromTime()、calendar()、valueOf()和unix() 方法。你可查阅文档（<a href="http://momentjs.com/docs/#/displaying/）学习moment.js" target="_blank" rel="noopener">http://momentjs.com/docs/#/displaying/）学习moment.js</a> 提供的全部格式化选项。</p><p>Flask-Moment 渲染的时间戳可实现多种语言的本地化。语言可在模板中选择，把语言代码传给lang() 函数即可：<br><code>\{\{ moment.lang(&#39;es&#39;) \}\}</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、集成-Bootstrap&quot;&gt;&lt;a href=&quot;#1、集成-Bootstrap&quot; class=&quot;headerlink&quot; title=&quot;1、集成 Bootstrap&quot;&gt;&lt;/a&gt;1、集成 Bootstrap&lt;/h4&gt;&lt;p&gt;Bootstrap（&lt;a href=&quot;http://getbootstrap.com/）是Twitter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://getbootstrap.com/）是Twitter&lt;/a&gt; 开发的一个开源框架，它提供的用户界面组件可用于创建整洁且具有吸引力的网页，而且这些网页还能兼容所有现代Web 浏览器。&lt;/p&gt;
&lt;p&gt;Bootstrap 是客户端框架，因此不会直接涉及服务器。服务器需要做的只是提供引用了Bootstrap 层叠样式表（CSS） 和JavaScript 文件的HTML 响应， 并在HTML、CSS 和JavaScript 代码中实例化所需组件。这些操作最理想的执行场所就是模板。&lt;/p&gt;
&lt;p&gt;Flask-Bootstrap 使用pip安装：&lt;br&gt;&lt;code&gt;(venv) $ pip install flask-bootstrap&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask 基础模块 - 模板(Jinjia2)</title>
    <link href="http://yoursite.com/2018/03/05/Flask-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97-%E6%A8%A1%E6%9D%BF-Jinjia2/"/>
    <id>http://yoursite.com/2018/03/05/Flask-基础模块-模板-Jinjia2/</id>
    <published>2018-03-05T08:01:35.000Z</published>
    <updated>2018-03-06T02:23:37.458Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、渲染模板"><a href="#1、渲染模板" class="headerlink" title="1、渲染模板"></a>1、渲染模板</h4><p>默认情况下，Flask 在程序文件夹中的templates 子文件夹中寻找模板。在下一个hello.py版本中，要把前面定义的模板保存在templates 文件夹中，并分别命名为index.html 和user.html。</p><p>示例3-3　hello.py：渲染模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, render_template</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&apos;index.html&apos;)</span><br><span class="line">@app.route(&apos;/user/&lt;name&gt;&apos;)</span><br><span class="line">def user(name):</span><br><span class="line">    return render_template(&apos;user.html&apos;, name=name)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>Flask 提供的render_template 函数把Jinja2 模板引擎集成到了程序中。<font color="red">render_template 函数的第一个参数是模板的文件名。随后的参数都是键值对，表示模板中变量对应的真实值。</font>在这段代码中，第二个模板收到一个名为name 的变量。</p><h4 id="2、变量"><a href="#2、变量" class="headerlink" title="2、变量"></a>2、变量</h4><p>在模板中使用的 结构表示一个变量，它是一种特殊的占位符，告诉模板引擎这个位置的值从渲染模板时使用的数据中获取。</p><p>Jinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。在模板中使用变量的一些示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;A value from a dictionary: &#123;&#123; mydict[&apos;key&apos;] &#125;&#125;.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;A value from a list: &#123;&#123; mylist[3] &#125;&#125;.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;A value from a list, with a variable index: &#123;&#123; mylist[myintvar] &#125;&#125;.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;A value from an object&apos;s method: &#123;&#123; myobj.somemethod() &#125;&#125;.&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>可以使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述<br>模板以首字母大写形式显示变量name 的值：<br>　　<code>Hello, \{\{ name|capitalize \}\}</code></p><p><strong>表3-1 列出了Jinja2 提供的部分常用过滤器。</strong></p><table><thead><tr><th>过滤器名</th><th>说　　明</th></tr></thead><tbody><tr><td>safe</td><td>渲染值时不转义</td></tr><tr><td>capitalize</td><td>把值的首字母转换成大写，其他字母转换成小写</td></tr><tr><td>lower</td><td>把值转换成小写形式</td></tr><tr><td>upper</td><td>把值转换成大写形式</td></tr><tr><td>title</td><td>把值中每个单词的首字母都转换成大写</td></tr><tr><td>trim</td><td>把值的首尾空格去掉</td></tr><tr><td>striptags</td><td>渲染之前把值中所有的HTML 标签都删掉</td></tr></tbody></table><p>safe 过滤器值得特别说明一下。默认情况下，出于安全考虑，Jinja2 会转义所有变量。例如，如果一个变量的值为<code>&lt;h1&gt;Hello&lt;/h1&gt;</code>，Jinja2 会将其渲染成<code>&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;</code>，浏览器能显示这个h1 元素，但不会进行解释。很多情况下需要显示变量中存储的HTML 代码，这时就可使用safe 过滤器。</p><p>完整的过滤器列表可在Jinja2 文档（<a href="http://jinja.pocoo.org/docs/templates/#builtin-filters）中查看。" target="_blank" rel="noopener">http://jinja.pocoo.org/docs/templates/#builtin-filters）中查看。</a></p><h4 id="3、控制结构"><a href="#3、控制结构" class="headerlink" title="3、控制结构"></a>3、控制结构</h4><p>Jinja2 提供了多种控制结构，可用来改变模板的渲染流程。<br>下面这个例子展示了如何在模板中使用条件控制语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if user %&#125;</span><br><span class="line">    Hello, &#123;&#123; user &#125;&#125;!</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    Hello, Stranger!</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>另一种常见需求是在模板中渲染一组元素。下例展示了如何使用for 循环实现这一需求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for comment in comments %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>Jinja2 还支持宏。宏类似于Python 代码中的函数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% macro render_comment(comment) %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for comment in comments %&#125;</span><br><span class="line">        &#123;&#123; render_comment(comment) &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>为了重复使用宏，我们可以将其保存在单独的文件中，然后在需要使用的模板中导入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% import &apos;macros.html&apos; as macros %&#125;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for comment in comments %&#125;</span><br><span class="line">        &#123;&#123; macros.render_comment(comment) &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>需要在多处重复使用的模板代码片段可以写入单独的文件，再包含在所有模板中，以避免重复：<br><code>include &quot;comment.html&quot;</code></p><p>另一种重复使用代码的强大方式是模板继承，它类似于Python 代码中的类继承。首先，创建一个名为base.html 的基模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &#123;% block head %&#125;</span><br><span class="line">    &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - My Application&lt;/title&gt;</span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;% block body %&#125;</span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>block 标签定义的元素可在衍生模板中修改。在本例中，我们定义了名为head、title 和body 的块。注意，title 包含在head 中。下面这个示例是基模板的衍生模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line">&#123;% block title %&#125;Index&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block head %&#125;</span><br><span class="line">    &#123;&#123; super() &#125;&#125;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block body %&#125;</span><br><span class="line">    &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p>extends 指令声明这个模板衍生自base.html。在extends 指令之后，基模板中的3 个块被重新定义，模板引擎会将其插入适当的位置。注意新定义的head 块，在基模板中其内容不是空的，所以使用super() 获取原来的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、渲染模板&quot;&gt;&lt;a href=&quot;#1、渲染模板&quot; class=&quot;headerlink&quot; title=&quot;1、渲染模板&quot;&gt;&lt;/a&gt;1、渲染模板&lt;/h4&gt;&lt;p&gt;默认情况下，Flask 在程序文件夹中的templates 子文件夹中寻找模板。在下一个hello.py版本中，要把前面定义的模板保存在templates 文件夹中，并分别命名为index.html 和user.html。&lt;/p&gt;
&lt;p&gt;示例3-3　hello.py：渲染模板&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;from flask import Flask, render_template&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app = Flask(__name__)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@app.route(&amp;apos;/&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def index():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return render_template(&amp;apos;index.html&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@app.route(&amp;apos;/user/&amp;lt;name&amp;gt;&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def user(name):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return render_template(&amp;apos;user.html&amp;apos;, name=name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if __name__ == &amp;apos;__main__&amp;apos;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    app.run()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask  整体概述-一个完整的程序</title>
    <link href="http://yoursite.com/2018/03/02/Flask-%E6%95%B4%E4%BD%93%E6%A6%82%E8%BF%B0-%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/03/02/Flask-整体概述-一个完整的程序/</id>
    <published>2018-03-02T08:25:45.000Z</published>
    <updated>2018-03-13T08:51:32.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Flask-简介"><a href="#一、Flask-简介" class="headerlink" title="一、Flask 简介"></a>一、Flask 简介</h3><p>Flask(<a href="http://flask.pocoo.org/)是一种小型框架，小到可以称为“微框架”。但是，小并不意味着它比其他框架的功能少。Flask" target="_blank" rel="noopener">http://flask.pocoo.org/)是一种小型框架，小到可以称为“微框架”。但是，小并不意味着它比其他框架的功能少。Flask</a> 自开发伊始就被设计为可扩展的框架，它具有一个包含基本服务的强健核心，其他功能则可通过扩展实现。你可以自己挑选所需的扩展包，组成一个没有附加功能的精益组合，从而完全精确满足自身需求。</p><p>Flask 有两个主要依赖：路由、调试和Web 服务器网关接口（Web Server Gateway Interface，WSGI）子系统由Werkzeug（<a href="http://werkzeug.pocoo.org/）提供；模板系统由Jinja2（http://jinja.pocoo.org/）提供。Werkzeug" target="_blank" rel="noopener">http://werkzeug.pocoo.org/）提供；模板系统由Jinja2（http://jinja.pocoo.org/）提供。Werkzeug</a> 和Jinjia2 都是由Flask 的核心开发者开发而成。</p><p>Flask 并不原生支持数据库访问、Web 表单验证和用户认证等高级功能。这些功能以及其他大多数Web 程序中需要的核心服务都以扩展的形式实现，然后再与核心包集成。开发者可以任意挑选符合项目需求的扩展，甚至可以自行开发。这和大型框架的做法相反，大型框架往往已经替你做出了大多数决定，难以（有时甚至不允许）使用替代方案。<br><a id="more"></a></p><p><strong>Flask与django、tornado的区别：</strong></p><style type="text/css">    table th:first-of-type {        width: 10%;    }    table th:nth-of-type(2) {        width: 30%;    }</style><table><thead><tr><th>框架</th><th>图标</th><th>特点</th></tr></thead><tbody><tr><td>flask</td><td><img src="/uploads/2018/03/logo-full.png" alt=""></td><td>Flask扩展丰富，冗余度小，可自由选择组合各种插件，性能优越，相比其它web框架十分轻量级，其优雅的设计哲学易于学习掌握，小型项目快速开发，大项目毫无压力。Flask灵活开发，Python高手基本都会喜欢Flask</td></tr><tr><td>django</td><td><img src="/uploads/2018/03/logo-django.jpg" alt=""></td><td>Django是重量级全栈型web框架，虽然功能强大，但冗余度高，自带ORM和模板引擎，灵活和自由度不够高，开发小型项目时显得过于臃肿与庞大。</td></tr><tr><td>tornado</td><td><img src="/uploads/2018/03/tornado.png" alt=""></td><td>Tornado是一个强大的、支持协程、高效并发且可扩展的Web服务器，发布于2009年9月，应用于FriendFeed、Facebook等社交网站。Tornado的强项在于可以利用它的异步协程机制开发高并发的服务器系统。</td></tr></tbody></table><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><h4 id="1、使用虚拟环境"><a href="#1、使用虚拟环境" class="headerlink" title="1、使用虚拟环境"></a>1、使用虚拟环境</h4><p>安装Flask 最便捷的方式是使用虚拟环境。虚拟环境是Python解释器的一个私有副本，在这个环境中你可以安装私有包，而且不会影响系统中安装的全局Python 解释器。</p><p>虚拟环境非常有用，可以在系统的Python 解释器中避免包的混乱和版本的冲突。为每个程序单独创建虚拟环境可以保证程序只能访问虚拟环境中的包，从而保持全局解释器的干净整洁，使其只作为创建（更多）虚拟环境的源。</p><p>虚拟环境使用第三方实用工具virtualenv 创建。输入以下命令可以检查系统是否安装了virtualenv：<br>　　<code>$ virtualenv --version</code><br>如果结果显示错误，你就需要安装这个工具。</p><h5 id="（1）安装virtualenv"><a href="#（1）安装virtualenv" class="headerlink" title="（1）安装virtualenv"></a>（1）安装virtualenv</h5><p>① 大多数Linux 发行版都提供了virtualenv 包。例如，Ubuntu 用户可以使用下述命令安装它：<br>　　<code>$ sudo apt-get install python-virtualenv</code><br>② 如果你的电脑是Mac OS X 系统，就可以使用easy_install 安装virtualenv：<br>　　<code>$ sudo easy_install virtualenv</code><br>③ 如果你使用微软的Windows 系统或其他没有官方virtualenv 包的操作系统，那么安装过程要稍微复杂一点。<br>在浏览器中输入网址<a href="https://bitbucket.org/pypa/setuptools，回车后会进入setuptools" target="_blank" rel="noopener">https://bitbucket.org/pypa/setuptools，回车后会进入setuptools</a> 安装程序的主页。在这个页面中找到下载安装脚本的链接，脚本名为ez_setup.py。把这个文件保存到电脑的一个临时文件夹中，然后在这个文件夹中执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python ez_setup.py</span><br><span class="line">$ easy_install virtualenv</span><br></pre></td></tr></table></figure></p><h5 id="（2）创建虚拟环境"><a href="#（2）创建虚拟环境" class="headerlink" title="（2）创建虚拟环境"></a>（2）创建虚拟环境</h5><p>下一步是使用virtualenv 命令在flasky 文件夹中创建Python 虚拟环境。这个命令只有一个必需的参数，即虚拟环境的名字。创建虚拟环境后，当前文件夹中会出现一个子文件夹，名字就是上述命令中指定的参数，与虚拟环境相关的文件都保存在这个子文件夹中。<br>按照惯例，一般虚拟环境会被命名为venv：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv venv</span><br><span class="line">New python executable in venv/bin/python2.7</span><br><span class="line">Also creating executable in venv/bin/python</span><br><span class="line">Installing setuptools............done.</span><br><span class="line">Installing pip...............done.</span><br></pre></td></tr></table></figure></p><h5 id="（3）激活虚拟环境"><a href="#（3）激活虚拟环境" class="headerlink" title="（3）激活虚拟环境"></a>（3）激活虚拟环境</h5><p>现在，flasky 文件夹中就有了一个名为venv 的子文件夹，它保存一个全新的虚拟环境，其中有一个私有的Python 解释器。在使用这个虚拟环境之前，你需要先将其“激活”。如果你使用bash 命令行（Linux 和Mac OS X 用户），可以通过下面的命令激活这个虚拟环境：<br>　　<code>$ source venv/bin/activate</code><br>如果使用微软Windows 系统，激活命令是：<br>　　<code>$ venv\Scripts\activate</code><br>虚拟环境被激活后，其中Python 解释器的路径就被添加进PATH 中，但这种改变不是永久性的，它只会影响当前的命令行会话。为了提醒你已经激活了虚拟环境，激活虚拟环境的命令会修改命令行提示符，加入环境名：<br>　　<code>(venv) $</code><br>当虚拟环境中的工作完成后，如果你想回到全局Python 解释器中，可以在命令行提示符下输入deactivate。</p><h4 id="2、使用pip安装Python包（Flask）"><a href="#2、使用pip安装Python包（Flask）" class="headerlink" title="2、使用pip安装Python包（Flask）"></a>2、使用pip安装Python包（Flask）</h4><p>大多数Python 包都使用pip 实用工具安装，使用virtualenv 创建虚拟环境时会自动安装pip。激活虚拟环境后，pip 所在的路径会被添加进PATH。<br>执行下述命令可在虚拟环境中安装Flask：<br>　　<code>(venv) $ pip install flask</code><br>执行上述命令，你就在虚拟环境中安装Flask 及其依赖了。要想验证Flask 是否正确安装，你可以启动Python 解释器，尝试导入Flask：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python</span><br><span class="line">&gt;&gt;&gt; import flask</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>如果没有看到错误提醒，那恭喜你——你已经可以安装完成了。</p><h3 id="三、程序的基本结构"><a href="#三、程序的基本结构" class="headerlink" title="三、程序的基本结构"></a>三、程序的基本结构</h3><p>首先，来梳理一下Flask的工作流程。</p><h4 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h4><p>所有Flask 程序都必须创建一个程序实例。Web 服务器使用一种名为Web 服务器网关接口（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这个对象处理。程序实例是Flask 类的对象，经常使用下述代码创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure></p><p>Flask 类的构造函数<font color="red">只有一个必须指定的参数，即程序主模块或包的名字</font>。在大多数程序中，Python 的<strong>name</strong> 变量就是所需的值。</p><h4 id="2、路由和视图函数"><a href="#2、路由和视图函数" class="headerlink" title="2、路由和视图函数"></a>2、路由和视图函数</h4><p>客户端（例如Web 浏览器）把请求发送给Web 服务器，Web 服务器再把请求发送给Flask程序实例。程序实例需要知道对每个URL 请求运行哪些代码，所以保存了一个URL 到Python 函数的映射关系。<font color="red">处理URL和函数之间关系的程序称为路由</font>。</p><p>在Flask 程序中定义路由的最简便方式，是使用程序实例提供的app.route 修饰器，把修<br>饰的函数注册为路由。下面的例子说明了如何使用这个修饰器声明路由：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos;</span><br></pre></td></tr></table></figure></p><p><strong>（注：修饰器是Python 语言的标准特性，可以使用不同的方式修改函数的行为。惯常用法是使用修饰器把函数注册为事件的处理程序。）</strong></p><p>前例把index() 函数注册为程序根地址的处理程序，即将跟地址映射到index() 函数处理程序。在浏览器中访问<a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a> 后，会触发服务器执行index() 函数。这个函数的返回值称为响应，是客户端接收到的内容。如果客户端是Web 浏览器，响应就是显示给用户查看的文档。</p><p>像index() 这样的函数称为<font color="red">视图函数（view function）</font>。视图函数返回的响应可以是包含HTML 的简单字符串，也可以是复杂的表单，当然也可以是接口所需的数据格式（JSON或XML）。</p><p>此处再扩展一下，route 修饰器也支持动态URL，下例定义的路由中就有一部分是动态名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/user/&lt;name&gt;&apos;)</span><br><span class="line">def user(name):</span><br><span class="line">    return &apos;&lt;h1&gt;Hello, %s!&lt;/h1&gt;&apos; % name</span><br></pre></td></tr></table></figure></p><p>尖括号中的内容就是动态部分，任何能匹配静态部分的URL 都会映射到这个路由上。调用视图函数时，Flask 会将动态部分作为参数传入函数。在这个视图函数中，参数用于生成针对个人的欢迎消息。</p><p>路由中的动态部分默认使用字符串，不过也可使用类型定义。例如，路由/user/<int:id>只会匹配动态片段id 为整数的URL。Flask 支持在路由中使用int、float 和path 类型。path 类型也是字符串，但不把斜线视作分隔符，而将其当作动态片段的一部分。</int:id></p><h4 id="3、启动服务器"><a href="#3、启动服务器" class="headerlink" title="3、启动服务器"></a>3、启动服务器</h4><p>程序实例用run 方法启动Flask 集成的开发Web 服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">app.run(debug=True)</span><br></pre></td></tr></table></figure></p><p>__name__==’__main__‘ 是Python 的惯常用法，在这里确保直接执行这个脚本时才启动开发Web 服务器。如果这个脚本由其他脚本引入，程序假定父级脚本会启动不同的服务器，因此不会执行app.run()。</p><p>服务器启动后，会进入轮询，等待并处理请求。轮询会一直运行，直到程序停止，比如按Ctrl-C 键。</p><p>有一些选项参数可被app.run() 函数接受用于设置Web 服务器的操作模式。在开发过程中启用调试模式会带来一些便利，比如说激活调试器和重载程序。要想启用调试模式，我们可以把debug 参数设为True。</p><h4 id="4、一个完整的程序"><a href="#4、一个完整的程序" class="headerlink" title="4、一个完整的程序"></a>4、一个完整的程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># hello.py</span><br><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos;</span><br><span class="line"></span><br><span class="line">@app.route(&apos;user/&lt;name&gt;&apos;)</span><br><span class="line">def user(name):</span><br><span class="line">    return &apos;&lt;h1&gt;Hello, %s&lt;/h1&gt;&apos; % self.name</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>然后使用下述命令启动程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py</span><br><span class="line">* Running on http://127.0.0.1:5000/</span><br><span class="line">* Restarting with reloader</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Flask-简介&quot;&gt;&lt;a href=&quot;#一、Flask-简介&quot; class=&quot;headerlink&quot; title=&quot;一、Flask 简介&quot;&gt;&lt;/a&gt;一、Flask 简介&lt;/h3&gt;&lt;p&gt;Flask(&lt;a href=&quot;http://flask.pocoo.org/)是一种小型框架，小到可以称为“微框架”。但是，小并不意味着它比其他框架的功能少。Flask&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://flask.pocoo.org/)是一种小型框架，小到可以称为“微框架”。但是，小并不意味着它比其他框架的功能少。Flask&lt;/a&gt; 自开发伊始就被设计为可扩展的框架，它具有一个包含基本服务的强健核心，其他功能则可通过扩展实现。你可以自己挑选所需的扩展包，组成一个没有附加功能的精益组合，从而完全精确满足自身需求。&lt;/p&gt;
&lt;p&gt;Flask 有两个主要依赖：路由、调试和Web 服务器网关接口（Web Server Gateway Interface，WSGI）子系统由Werkzeug（&lt;a href=&quot;http://werkzeug.pocoo.org/）提供；模板系统由Jinja2（http://jinja.pocoo.org/）提供。Werkzeug&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://werkzeug.pocoo.org/）提供；模板系统由Jinja2（http://jinja.pocoo.org/）提供。Werkzeug&lt;/a&gt; 和Jinjia2 都是由Flask 的核心开发者开发而成。&lt;/p&gt;
&lt;p&gt;Flask 并不原生支持数据库访问、Web 表单验证和用户认证等高级功能。这些功能以及其他大多数Web 程序中需要的核心服务都以扩展的形式实现，然后再与核心包集成。开发者可以任意挑选符合项目需求的扩展，甚至可以自行开发。这和大型框架的做法相反，大型框架往往已经替你做出了大多数决定，难以（有时甚至不允许）使用替代方案。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Python 模块之cPickle</title>
    <link href="http://yoursite.com/2018/02/05/Python-%E6%A8%A1%E5%9D%97%E4%B9%8BcPickle/"/>
    <id>http://yoursite.com/2018/02/05/Python-模块之cPickle/</id>
    <published>2018-02-05T09:28:00.000Z</published>
    <updated>2018-02-05T10:00:09.263Z</updated>
    
    <content type="html"><![CDATA[<p>在python中，一般可以使用pickle类来进行python对象的序列化，而cPickle提供了一个更快速简单的接口，如python文档所说的：“cPickle – A faster pickle”。使用cPickle模块永久地把这些对象储存在你的硬盘上。</p><blockquote><p><strong>对象持久化：</strong><br>如果希望透明地存储 Python 对象，而不丢失其身份和类型等信息，则需要某种形式的对象序列化：它是一个将任意复杂的对象转成对象的文本或二进制表示的过程。同样，必须能够将对象经过序列化后的形式恢复到原有的对象。在 Python 中，这种序列化过程称为 pickle，可以将对象 pickle 成字符串、磁盘上的文件或者任何类似于文件的对象，也可以将这些字符串、文件或任何类似于文件的对象 unpickle 成原来的对象。</p></blockquote><a id="more"></a><p>cPickle可以对任意一种类型的python对象进行序列化操作，比如list，dict，甚至是一个类的对象等。 pickle 模块提供了以下函数对： dumps(object) 返回一个字符串，它包含一个 pickle 格式的对象； loads(string) 返回包含在 pickle 字符串中的对象； dump(object, file) 将对象写到文件，这个文件可以是实际的物理文件，但也可以是任何类似于文件的对象，这个对象具有 write() 方法，可以接受单个的字符串参数； load(file) 返回包含在 pickle 文件中的对象。</p><h5 id="dump-和-load"><a href="#dump-和-load" class="headerlink" title="dump() 和 load()"></a>dump() 和 load()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a1 = &apos;apple&apos;</span><br><span class="line">&gt;&gt;&gt; b1 = &#123;1: &apos;One&apos;, 2: &apos;Two&apos;, 3: &apos;Three&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; c1 = [&apos;fee&apos;, &apos;fie&apos;, &apos;foe&apos;, &apos;fum&apos;]</span><br><span class="line">&gt;&gt;&gt; f1 = file(&apos;temp.pkl&apos;, &apos;wb&apos;)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(a1, f1, True)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(b1, f1, True)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(c1, f1, True)</span><br><span class="line">&gt;&gt;&gt; f1.close()</span><br><span class="line">&gt;&gt;&gt; f2 = file(&apos;temp.pkl&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; a2 = pickle.load(f2)</span><br><span class="line">&gt;&gt;&gt; a2</span><br><span class="line">&apos;apple&apos;</span><br><span class="line">&gt;&gt;&gt; b2 = pickle.load(f2)</span><br><span class="line">&gt;&gt;&gt; b2</span><br><span class="line">&#123;1: &apos;One&apos;, 2: &apos;Two&apos;, 3: &apos;Three&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; c2 = pickle.load(f2)</span><br><span class="line">&gt;&gt;&gt; c2</span><br><span class="line">[&apos;fee&apos;, &apos;fie&apos;, &apos;foe&apos;, &apos;fum&apos;]</span><br><span class="line">&gt;&gt;&gt; f2.close()</span><br></pre></td></tr></table></figure><blockquote><p><strong>dump： 将python对象序列化保存到本地的文件</strong><br>dump函数需要指定两个参数，第一个是需要序列化的python对象名称，第二个是本地的文件，需要注意的是，在这里需要使用open函数打开一个文件，并指定“写”操作<br><strong>load：载入本地文件，恢复python对象</strong><br>同dump一样，这里需要使用open函数打开本地的一个文件，并指定“读”操作 </p></blockquote><h5 id="dumps-和-loads"><a href="#dumps-和-loads" class="headerlink" title="dumps() 和 loads()"></a>dumps() 和 loads()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import cPickle as pickle</span><br><span class="line">&gt;&gt;&gt; t1 = (&apos;this is a string&apos;, 42, [1, 2, 3], None)</span><br><span class="line">&gt;&gt;&gt; t1</span><br><span class="line">(&apos;this is a string&apos;, 42, [1, 2, 3], None)</span><br><span class="line">&gt;&gt;&gt; p1 = pickle.dumps(t1)</span><br><span class="line">&gt;&gt;&gt; p1</span><br><span class="line">&quot;(S&apos;this is a string&apos;/nI42/n(lp1/nI1/naI2/naI3/naNtp2/n.&quot;</span><br><span class="line">&gt;&gt;&gt; print p1</span><br><span class="line">(S&apos;this is a string&apos;</span><br><span class="line">I42</span><br><span class="line">(lp1</span><br><span class="line">I1</span><br><span class="line">aI2</span><br><span class="line">aI3</span><br><span class="line">aNtp2</span><br><span class="line">.</span><br><span class="line">&gt;&gt;&gt; t2 = pickle.loads(p1)</span><br><span class="line">&gt;&gt;&gt; t2</span><br><span class="line">(&apos;this is a string&apos;, 42, [1, 2, 3], None)</span><br><span class="line">&gt;&gt;&gt; p2 = pickle.dumps(t1, True)</span><br><span class="line">&gt;&gt;&gt; p2</span><br><span class="line">&apos;(U/x10this is a stringK*]q/x01(K/x01K/x02K/x03eNtq/x02.&apos;</span><br><span class="line">&gt;&gt;&gt; t3 = pickle.loads(p2)</span><br><span class="line">&gt;&gt;&gt; t3</span><br><span class="line">(&apos;this is a string&apos;, 42, [1, 2, 3], None)</span><br></pre></td></tr></table></figure><blockquote><p><strong>dumps：将python对象序列化保存到一个字符串变量中</strong><br><strong>loads：从字符串变量中载入python对象</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在python中，一般可以使用pickle类来进行python对象的序列化，而cPickle提供了一个更快速简单的接口，如python文档所说的：“cPickle – A faster pickle”。使用cPickle模块永久地把这些对象储存在你的硬盘上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对象持久化：&lt;/strong&gt;&lt;br&gt;如果希望透明地存储 Python 对象，而不丢失其身份和类型等信息，则需要某种形式的对象序列化：它是一个将任意复杂的对象转成对象的文本或二进制表示的过程。同样，必须能够将对象经过序列化后的形式恢复到原有的对象。在 Python 中，这种序列化过程称为 pickle，可以将对象 pickle 成字符串、磁盘上的文件或者任何类似于文件的对象，也可以将这些字符串、文件或任何类似于文件的对象 unpickle 成原来的对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python模块" scheme="http://yoursite.com/tags/Python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
</feed>
