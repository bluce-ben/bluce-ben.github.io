<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-01T08:38:42.422Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP预定义变量梳理（PHP手册版）</title>
    <link href="http://yoursite.com/2018/01/31/PHP%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E6%A2%B3%E7%90%86%EF%BC%88PHP%E6%89%8B%E5%86%8C%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/31/PHP预定义变量梳理（PHP手册版）/</id>
    <published>2018-01-31T09:46:04.000Z</published>
    <updated>2018-02-01T08:38:42.422Z</updated>
    
    <content type="html"><![CDATA[<p><strong>预定义变量</strong><br>超全局数组：$GLOBALS<br>服务器和执行环境信息：$_SERVER （详解）<br>URL参数获取变量数组：$_GET<br>表单参数获取变量数组：$_POST<br>上传数据获取：$_FILES<br>$_REQUEST（包含$_GET、$_POST和$_COOKIE）<br>SESSION变量的数组：$_SESSION<br>环境变量数组：$_ENV<br>COOKIE变量的数组：$_COOKIE<br><a id="more"></a><br><strong>下面只对$_SERVER这个变量进行详细说明其参数及其意义：</strong><br>$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。<br><strong>Note:</strong>  PHP 5.4.0 之前，$HTTP_SERVER_VARS 包含着相同的信息，但它不是一个超全局变量。 (注意 $HTTP_SERVER_VARS 与 $_SERVER 是不同的变量，PHP处理它们的方式不同) </p><p>在 $_SERVER 中，你也许能够，也许不能够找到下面的这些元素。注意，如果以命令行方式运行 PHP，下面列出的元素几乎没有有效的(或是没有任何实际意义的)。 </p><h5 id="‘PHP-SELF’"><a href="#‘PHP-SELF’" class="headerlink" title="‘PHP_SELF’"></a>‘PHP_SELF’</h5><p>当前执行脚本的文件名，与 document root 有关。例如，在地址为 <a href="http://example.com/foo/bar.php" target="_blank" rel="noopener">http://example.com/foo/bar.php</a> 的脚本中使用 $_SERVER[‘PHP_SELF’] 将得到 /foo/bar.php。<strong>FILE</strong> 常量包含当前(例如包含)文件的完整路径和文件名。   从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。</p><h5 id="‘argv’"><a href="#‘argv’" class="headerlink" title="‘argv’"></a>‘argv’</h5><p>传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。</p><h5 id="‘argc’"><a href="#‘argc’" class="headerlink" title="‘argc’"></a>‘argc’</h5><p>包含命令行模式下传递给该脚本的参数的数目(如果运行在命令行模式下)。</p><h5 id="‘GATEWAY-INTERFACE’"><a href="#‘GATEWAY-INTERFACE’" class="headerlink" title="‘GATEWAY_INTERFACE’"></a>‘GATEWAY_INTERFACE’</h5><p>服务器使用的 CGI 规范的版本；例如，”CGI/1.1”。</p><h5 id="‘SERVER-ADDR’"><a href="#‘SERVER-ADDR’" class="headerlink" title="‘SERVER_ADDR’"></a>‘SERVER_ADDR’</h5><p>当前运行脚本所在的服务器的 IP 地址。</p><h5 id="‘SERVER-NAME’"><a href="#‘SERVER-NAME’" class="headerlink" title="‘SERVER_NAME’"></a>‘SERVER_NAME’</h5><p>当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。<br>　　<strong>Note:</strong> 在 Apache 2 里，必须设置 UseCanonicalName = On 和 ServerName。 否则该值会由客户端提供，就有可能被伪造。 上下文有安全性要求的环境里，不应该依赖此值。</p><h5 id="‘SERVER-SOFTWARE’"><a href="#‘SERVER-SOFTWARE’" class="headerlink" title="‘SERVER_SOFTWARE’"></a>‘SERVER_SOFTWARE’</h5><p>服务器标识字符串，在响应请求时的头信息中给出。  ‘SERVER_PROTOCOL’请求页面时通信协议的名称和版本。例如，”HTTP/1.0”。</p><h5 id="‘REQUEST-METHOD’"><a href="#‘REQUEST-METHOD’" class="headerlink" title="‘REQUEST_METHOD’"></a>‘REQUEST_METHOD’</h5><p>访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”。<br>　　<strong>Note:</strong> 如果请求方法为 HEAD，PHP 脚本将在发送 Header 头信息之后终止(这意味着在产生任何输出后，不再有输出缓冲)。</p><h5 id="‘REQUEST-TIME’"><a href="#‘REQUEST-TIME’" class="headerlink" title="‘REQUEST_TIME’"></a>‘REQUEST_TIME’</h5><p>请求开始时的时间戳。从 PHP 5.1.0 起可用。</p><h5 id="‘REQUEST-TIME-FLOAT’"><a href="#‘REQUEST-TIME-FLOAT’" class="headerlink" title="‘REQUEST_TIME_FLOAT’"></a>‘REQUEST_TIME_FLOAT’</h5><p>请求开始时的时间戳，微秒级别的精准度。 自 PHP 5.4.0 开始生效。</p><h5 id="‘QUERY-STRING’"><a href="#‘QUERY-STRING’" class="headerlink" title="‘QUERY_STRING’"></a>‘QUERY_STRING’</h5><p>query string（查询字符串），如果有的话，通过它进行页面访问。</p><h5 id="‘DOCUMENT-ROOT’"><a href="#‘DOCUMENT-ROOT’" class="headerlink" title="‘DOCUMENT_ROOT’"></a>‘DOCUMENT_ROOT’</h5><p>当前运行脚本所在的文档根目录。在服务器配置文件中定义。</p><h5 id="‘HTTP-ACCEPT’"><a href="#‘HTTP-ACCEPT’" class="headerlink" title="‘HTTP_ACCEPT’"></a>‘HTTP_ACCEPT’</h5><p>当前请求头中 Accept: 项的内容，如果存在的话。</p><h5 id="‘HTTP-ACCEPT-CHARSET’"><a href="#‘HTTP-ACCEPT-CHARSET’" class="headerlink" title="‘HTTP_ACCEPT_CHARSET’"></a>‘HTTP_ACCEPT_CHARSET’</h5><p>当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。</p><h5 id="‘HTTP-ACCEPT-ENCODING’"><a href="#‘HTTP-ACCEPT-ENCODING’" class="headerlink" title="‘HTTP_ACCEPT_ENCODING’"></a>‘HTTP_ACCEPT_ENCODING’</h5><p>当前请求头中 Accept-Encoding: 项的内容，如果存在的话。例如：”gzip”。</p><h5 id="‘HTTP-ACCEPT-LANGUAGE’"><a href="#‘HTTP-ACCEPT-LANGUAGE’" class="headerlink" title="‘HTTP_ACCEPT_LANGUAGE’"></a>‘HTTP_ACCEPT_LANGUAGE’</h5><p>当前请求头中 Accept-Language: 项的内容，如果存在的话。例如：”en”。</p><h5 id="‘HTTP-CONNECTION’"><a href="#‘HTTP-CONNECTION’" class="headerlink" title="‘HTTP_CONNECTION’"></a>‘HTTP_CONNECTION’</h5><p>当前请求头中 Connection: 项的内容，如果存在的话。例如：”Keep-Alive”。</p><h5 id="‘HTTP-HOST’"><a href="#‘HTTP-HOST’" class="headerlink" title="‘HTTP_HOST’"></a>‘HTTP_HOST’</h5><p>当前请求头中 Host: 项的内容，如果存在的话。</p><h5 id="‘HTTP-REFERER’"><a href="#‘HTTP-REFERER’" class="headerlink" title="‘HTTP_REFERER’"></a>‘HTTP_REFERER’</h5><p>引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。</p><h5 id="‘HTTP-USER-AGENT’"><a href="#‘HTTP-USER-AGENT’" class="headerlink" title="‘HTTP_USER_AGENT’"></a>‘HTTP_USER_AGENT’</h5><p>当前请求头中 User-Agent: 项的内容，如果存在的话。该字符串表明了访问该页面的用户代理的信息。一个典型的例子是：Mozilla/4.5 [en] (X11; U; Linux 2.2.9 i586)。除此之外，你可以通过 get_browser() 来使用该值，从而定制页面输出以便适应用户代理的性能。  ‘HTTPS’如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。<br>　　<strong>Note:</strong> 注意当使用 IIS 上的 ISAPI 方式时，如果不是通过 HTTPS 协议被访问，这个值将为 off。</p><h5 id="‘REMOTE-ADDR’"><a href="#‘REMOTE-ADDR’" class="headerlink" title="‘REMOTE_ADDR’"></a>‘REMOTE_ADDR’</h5><p>浏览当前页面的用户的 IP 地址。</p><h5 id="‘REMOTE-HOST’"><a href="#‘REMOTE-HOST’" class="headerlink" title="‘REMOTE_HOST’"></a>‘REMOTE_HOST’</h5><p>浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。<br>　　<strong>Note:</strong> 你的服务器必须被配置以便产生这个变量。例如在 Apache 中，你需要在 httpd.conf 中设置 HostnameLookups On 来产生它。参见 gethostbyaddr()。</p><h5 id="‘REMOTE-PORT’"><a href="#‘REMOTE-PORT’" class="headerlink" title="‘REMOTE_PORT’"></a>‘REMOTE_PORT’</h5><p>用户机器上连接到 Web 服务器所使用的端口号。</p><h5 id="‘REMOTE-USER’"><a href="#‘REMOTE-USER’" class="headerlink" title="‘REMOTE_USER’"></a>‘REMOTE_USER’</h5><p>经验证的用户</p><h5 id="‘REDIRECT-REMOTE-USER’"><a href="#‘REDIRECT-REMOTE-USER’" class="headerlink" title="‘REDIRECT_REMOTE_USER’"></a>‘REDIRECT_REMOTE_USER’</h5><p>验证的用户，如果请求已在内部重定向。</p><h5 id="‘SCRIPT-FILENAME’"><a href="#‘SCRIPT-FILENAME’" class="headerlink" title="‘SCRIPT_FILENAME’"></a>‘SCRIPT_FILENAME’</h5><p>当前执行脚本的绝对路径。<br>　　<strong>Note:</strong> 如果在命令行界面（Command Line Interface, CLI）使用相对路径执行脚本，例如 file.php 或 ../file.php，那么 $_SERVER[‘SCRIPT_FILENAME’] 将包含用户指定的相对路径。</p><h5 id="‘SERVER-ADMIN’"><a href="#‘SERVER-ADMIN’" class="headerlink" title="‘SERVER_ADMIN’"></a>‘SERVER_ADMIN’</h5><p>该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。</p><h5 id="‘SERVER-PORT’"><a href="#‘SERVER-PORT’" class="headerlink" title="‘SERVER_PORT’"></a>‘SERVER_PORT’</h5><p>Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。<br>　　<strong>Note:</strong> 在 Apache 2 里，为了获取真实物理端口，必须设置 UseCanonicalName = On 以及 UseCanonicalPhysicalPort = On。 否则此值可能被伪造，不一定会返回真实端口值。 上下文有安全性要求的环境里，不应该依赖此值。</p><h5 id="‘SERVER-SIGNATURE’"><a href="#‘SERVER-SIGNATURE’" class="headerlink" title="‘SERVER_SIGNATURE’"></a>‘SERVER_SIGNATURE’</h5><p>包含了服务器版本和虚拟主机名的字符串。</p><h5 id="‘PATH-TRANSLATED’"><a href="#‘PATH-TRANSLATED’" class="headerlink" title="‘PATH_TRANSLATED’"></a>‘PATH_TRANSLATED’</h5><p>当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。<br>　　<strong>Note:</strong> 自 PHP 4.3.2 起，PATH_TRANSLATED 在 Apache 2 SAPI 模式下不再和 Apache 1 一样隐含赋值，而是若 Apache 不生成此值，PHP 便自己生成并将其值放入 SCRIPT_FILENAME 服务器常量中。这个修改遵守了 CGI 规范，PATH_TRANSLATED 仅在 PATH_INFO 被定义的条件下才存在。  Apache 2 用户可以在 httpd.conf 中设置 AcceptPathInfo = On 来定义 PATH_INFO。</p><h5 id="‘SCRIPT-NAME’"><a href="#‘SCRIPT-NAME’" class="headerlink" title="‘SCRIPT_NAME’"></a>‘SCRIPT_NAME’</h5><p>包含当前脚本的路径。这在页面需要指向自己时非常有用。<strong>FILE</strong> 常量包含当前脚本(例如包含文件)的完整路径和文件名。</p><h5 id="‘REQUEST-URI’"><a href="#‘REQUEST-URI’" class="headerlink" title="‘REQUEST_URI’"></a>‘REQUEST_URI’</h5><p>URI 用来指定要访问的页面。例如 “/index.html”。</p><h5 id="‘PHP-AUTH-DIGEST’"><a href="#‘PHP-AUTH-DIGEST’" class="headerlink" title="‘PHP_AUTH_DIGEST’"></a>‘PHP_AUTH_DIGEST’</h5><p>当作为 Apache 模块运行时，进行 HTTP Digest 认证的过程中，此变量被设置成客户端发送的”Authorization” HTTP 头内容（以便作进一步的认证操作）。</p><h5 id="‘PHP-AUTH-USER’"><a href="#‘PHP-AUTH-USER’" class="headerlink" title="‘PHP_AUTH_USER’"></a>‘PHP_AUTH_USER’</h5><p>当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名。</p><h5 id="‘PHP-AUTH-PW’"><a href="#‘PHP-AUTH-PW’" class="headerlink" title="‘PHP_AUTH_PW’"></a>‘PHP_AUTH_PW’</h5><p>当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码。</p><h5 id="‘AUTH-TYPE’"><a href="#‘AUTH-TYPE’" class="headerlink" title="‘AUTH_TYPE’"></a>‘AUTH_TYPE’</h5><p>当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型。</p><h5 id="‘PATH-INFO’"><a href="#‘PATH-INFO’" class="headerlink" title="‘PATH_INFO’"></a>‘PATH_INFO’</h5><p>包含由客户端提供的、跟在真实脚本名称之后并且在查询语句（query string）之前的路径信息，如果存在的话。例如，如果当前脚本是通过 URL <a href="http://www.example.com/php/path_info.php/some/stuff?foo=bar" target="_blank" rel="noopener">http://www.example.com/php/path_info.php/some/stuff?foo=bar</a> 被访问，那么 $_SERVER[‘PATH_INFO’] 将包含 /some/stuff。</p><h5 id="‘ORIG-PATH-INFO’"><a href="#‘ORIG-PATH-INFO’" class="headerlink" title="‘ORIG_PATH_INFO’"></a>‘ORIG_PATH_INFO’</h5><p>在被 PHP 处理之前，”PATH_INFO” 的原始版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;预定义变量&lt;/strong&gt;&lt;br&gt;超全局数组：$GLOBALS&lt;br&gt;服务器和执行环境信息：$_SERVER （详解）&lt;br&gt;URL参数获取变量数组：$_GET&lt;br&gt;表单参数获取变量数组：$_POST&lt;br&gt;上传数据获取：$_FILES&lt;br&gt;$_REQUEST（包含$_GET、$_POST和$_COOKIE）&lt;br&gt;SESSION变量的数组：$_SESSION&lt;br&gt;环境变量数组：$_ENV&lt;br&gt;COOKIE变量的数组：$_COOKIE&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP高级整理（PHP手册版）</title>
    <link href="http://yoursite.com/2018/01/31/PHP%E9%AB%98%E7%BA%A7%E6%95%B4%E7%90%86%EF%BC%88PHP%E6%89%8B%E5%86%8C%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/31/PHP高级整理（PHP手册版）/</id>
    <published>2018-01-31T09:45:52.000Z</published>
    <updated>2018-02-01T03:54:22.488Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>（1）用户自定义函数：</p><p>（2）函数的参数：<br>值传递（默认情况）<br>引用传递：在该参数前面加上符号 &amp;</p><p>（3）类型声明<br>在PHP 5中，类型声明也被称为类型提示。<br>类型声明允许函数在调用时要求参数为特定类型。 如果给出的值类型不对，那么将会产生一个错误： 在PHP 5中，这将是一个可恢复的致命错误，而在PHP 7中将会抛出一个TypeError异常。<br><a id="more"></a><br>（4）返回值：return</p><p>（5）匿名函数<br>匿名函数（Anonymous functions），也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。 </p><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><h5 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h5><p>每个类的定义都以关键字 class 开头，后面跟着类名，后面跟着一对花括号，里面包含有类的属性与方法的定义。<br>一个类可以包含有属于自己的常量，变量（称为”属性”）以及函数（称为”方法”）。<br>当一个方法在类定义内部被调用时，有一个可用的伪变量 $this。$this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象静态调用时也可能是另一个对象）。</p><p><strong>new</strong><br>要创建一个类的实例，必须使用 new 关键字。当创建新对象时该对象总是被赋值，除非该对象定义了构造函数并且在出错时抛出了一个异常。类应在被实例化之前定义（某些情况下则必须这样）。<br>如果在 new 之后跟着的是一个包含有类名的字符串，则该类的一个实例被创建。如果该类属于一个名字空间，则必须使用其完整名称。</p><p>在类定义内部，可以用 new self 和 new parent 创建新对象。<br>当把一个对象已经创建的实例赋给一个新变量时，新变量会访问同一个实例，就和用该对象赋值一样。此行为和给函数传递入实例时一样。可以用克隆给一个已创建的对象建立一个新实例。</p><p><strong>extends</strong><br>一个类可以在声明中用 extends 关键字继承另一个类的方法和属性。PHP不支持多重继承，一个类只能继承一个基类。<br>被继承的方法和属性可以通过用同样的名字重新声明被覆盖。但是如果父类定义方法时使用了 final，则该方法不可被覆盖。可以通过 parent:: 来访问被覆盖的方法或属性。<br>当覆盖方法时，参数必须保持一致否则 PHP 将发出 E_STRICT 级别的错误信息。但构造函数例外，构造函数可在被覆盖时使用不同的参数。</p><p><strong>匿名类</strong><br>PHP 7 开始支持匿名类。 匿名类很有用，可以创建一次性的简单对象。 </p><h5 id="（2）属性"><a href="#（2）属性" class="headerlink" title="（2）属性"></a>（2）属性</h5><p>类的变量成员叫做”属性”，或者叫”字段”、”特征”，在本文档统一称为”属性”。属性声明是由关键字 public，protected 或者 private 开头，然后跟一个普通的变量声明来组成。属性中的变量可以初始化，但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。</p><p>在类的成员方法里面，可以用 -&gt;（对象运算符）：$this-&gt;property（其中 property 是该属性名）这种方式来访问非静态属性。静态属性则是用 ::（双冒号）：self::$property 来访问。</p><p><strong>类常量：</strong><br>可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。<br>常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。<br>接口（interface）中也可以定义常量。</p><h5 id="（3）构造函数与析构函数"><a href="#（3）构造函数与析构函数" class="headerlink" title="（3）构造函数与析构函数"></a>（3）构造函数与析构函数</h5><p>PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 </p><p><strong>Note: </strong>如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。</p><p>PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p><p>和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 parent::__destruct()。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。<br>析构函数即使在使用 exit() 终c止脚本运行时也会被调用。在析构函数中调用 exit() 将会中止其余关闭操作的运行。 </p><h5 id="（4）访问控制符"><a href="#（4）访问控制符" class="headerlink" title="（4）访问控制符"></a>（4）访问控制符</h5><p>对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。<br><strong>final关键字：</strong><br>PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。</p><p><em>（注：类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有。类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。 ）</em></p><h5 id="（5）对象继承"><a href="#（5）对象继承" class="headerlink" title="（5）对象继承"></a>（5）对象继承</h5><p>继承已为大家所熟知的一个程序设计特性，PHP 的对象模型也使用了继承。继承将会影响到类与类，对象与对象之间的关系。<br>比如，当扩展一个类，子类就会继承父类所有公有的和受保护的方法。除非子类覆盖了父类的方法，被继承的方法都会保留其原有功能。<br>继承对于功能的设计和抽象是非常有用的，而且对于类似的对象增加新功能就无须重新再写这些公用的功能。</p><h5 id="（6）静态关键字-static"><a href="#（6）静态关键字-static" class="headerlink" title="（6）静态关键字 static"></a>（6）静态关键字 static</h5><p>声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。<br><em>（注：由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。）</em><br><strong>注意事项：</strong></p><ul><li>静态属性不可以由对象通过 -&gt; 操作符来访问。 </li><li>用静态方式调用一个非静态方法会导致一个 E_STRICT 级别的错误。 </li><li>就像其它所有的 PHP 静态变量一样，静态属性只能被初始化为文字或常量，不能使用表达式。所以可以把静态属性初始化为整数或数组，但不能初始化为另一个变量或函数返回值，也不能指向一个对象。 </li></ul><h5 id="（7）抽象类"><a href="#（7）抽象类" class="headerlink" title="（7）抽象类"></a>（7）抽象类</h5><p>PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。 </p><p>继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。 </p><h5 id="（8）对象接口"><a href="#（8）对象接口" class="headerlink" title="（8）对象接口"></a>（8）对象接口</h5><p>使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。<br>接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。<br>接口中定义的所有方法都必须是公有，这是接口的特性。 </p><p><strong>实现（implements）</strong><br>要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。 </p><p><strong>Note: </strong><br>实现多个接口时，接口中的方法不能有重名。<br><strong>Note: </strong><br>接口也可以继承，通过使用 extends 操作符。<br><strong>Note: </strong><br>类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。 </p><p><strong>常量</strong><br>接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所覆盖。</p><h5 id="（9）魔术方法"><a href="#（9）魔术方法" class="headerlink" title="（9）魔术方法"></a>（9）魔术方法</h5><p>__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()， __invoke()， __set<em>state()， \</em>_clone() 和 __debugInfo() 等方法在 PHP 中被称为”魔术方法”（Magic methods）。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。 </p><h4 id="10、命名空间"><a href="#10、命名空间" class="headerlink" title="10、命名空间"></a>10、命名空间</h4><h5 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h5><p>什么是命名空间？从广义上来说，命名空间是一种封装事物的方法。在很多地方都可以见到这种抽象概念。例如，在操作系统中目录用来将相关文件分组，对于目录中的文件来说，它就扮演了命名空间的角色。具体举个例子，文件 foo.txt 可以同时在目录/home/greg 和 /home/other 中存在，但在同一个目录中不能存在两个 foo.txt 文件。另外，在目录 /home/greg 外访问 foo.txt 文件时，我们必须将目录名以及目录分隔符放在文件名之前得到 /home/greg/foo.txt。这个原理应用到程序设计领域就是命名空间的概念。 </p><p>在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题： </p><ol><li>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。  </li><li>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</li></ol><h5 id="（2）定义命名空间-PHP-5-gt-5-3-0-PHP-7"><a href="#（2）定义命名空间-PHP-5-gt-5-3-0-PHP-7" class="headerlink" title="（2）定义命名空间(PHP 5 &gt;= 5.3.0, PHP 7)"></a>（2）定义命名空间(PHP 5 &gt;= 5.3.0, PHP 7)</h5><p>虽然任意合法的PHP代码都可以包含在命名空间中，但只有以下类型的代码受命名空间的影响，它们是：类（包括抽象类和traits）、接口、函数和常量。 </p><p>命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，除了一个以外：declare关键字。<br><em>（注：在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。另外，所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前）</em></p><h5 id="（3）使用命名空间：基础"><a href="#（3）使用命名空间：基础" class="headerlink" title="（3）使用命名空间：基础"></a>（3）使用命名空间：基础</h5><p>在讨论如何使用命名空间之前，必须了解 PHP 是如何知道要使用哪一个命名空间中的元素的。可以将 PHP 命名空间与文件系统作一个简单的类比。在文件系统中访问一个文件有三种方式： </p><ol><li>相对文件名形式如foo.txt。它会被解析为 currentdirectory/foo.txt，其中 currentdirectory 表示当前目录。因此如果当前目录是 /home/foo，则该文件名被解析为/home/foo/foo.txt。  </li><li>相对路径名形式如subdirectory/foo.txt。它会被解析为 currentdirectory/subdirectory/foo.txt。  </li><li>绝对路径名形式如/main/foo.txt。它会被解析为/main/foo.txt。  </li></ol><p>PHP 命名空间中的元素使用同样的原理。例如，类名可以通过三种方式引用：</p><ol><li><strong>非限定名称</strong>，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。   警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。详情参见 使用命名空间：后备全局函数名称/常量名称。  </li><li><strong>限定名称</strong>,或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。  </li><li><strong>完全限定名称</strong>，或包含了全局前缀操作符的名称，例如， $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。</li></ol><h5 id="（4）使用命名空间：别名-导入"><a href="#（4）使用命名空间：别名-导入" class="headerlink" title="（4）使用命名空间：别名/导入"></a>（4）使用命名空间：别名/导入</h5><p>允许通过别名引用或导入外部的完全限定名称，是命名空间的一个重要特征。这有点类似于在类 unix 文件系统中可以创建对其它的文件或目录的符号连接。<br>所有支持命名空间的PHP版本支持三种别名或导入方式：为类名称使用别名、为接口使用别名或为命名空间名称使用别名。PHP 5.6开始允许导入函数或常量或者为它们设置别名。<br>在PHP中，别名是通过操作符 use 来实现的. 下面是一个使用所有可能的五种导入方式的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Example #1 使用use操作符导入/使用别名</span><br><span class="line">&lt;?php</span><br><span class="line">namespace foo;</span><br><span class="line">use My\Full\Classname as Another;</span><br><span class="line"></span><br><span class="line">// 下面的例子与 use My\Full\NSname as NSname 相同</span><br><span class="line">use My\Full\NSname;</span><br><span class="line"></span><br><span class="line">// 导入一个全局类</span><br><span class="line">use ArrayObject;</span><br><span class="line"></span><br><span class="line">// importing a function (PHP 5.6+)</span><br><span class="line">use function My\Full\functionName;</span><br><span class="line"></span><br><span class="line">// aliasing a function (PHP 5.6+)</span><br><span class="line">use function My\Full\functionName as func;</span><br><span class="line"></span><br><span class="line">// importing a constant (PHP 5.6+)</span><br><span class="line">use const My\Full\CONSTANT;</span><br><span class="line"></span><br><span class="line">$obj = new namespace\Another; // 实例化 foo\Another 对象</span><br><span class="line">$obj = new Another; // 实例化 My\Full\Classname　对象</span><br><span class="line">NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func</span><br><span class="line">$a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象</span><br><span class="line">// 如果不使用 &quot;use \ArrayObject&quot; ，则实例化一个 foo\ArrayObject 对象</span><br><span class="line">func(); // calls function My\Full\functionName</span><br><span class="line">echo CONSTANT; // echoes the value of My\Full\CONSTANT</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>注意对命名空间中的名称（包含命名空间分隔符的完全限定名称如 Foo\Bar以及相对的不包含命名空间分隔符的全局名称如 FooBar）来说，前导的反斜杠是不必要的也不推荐的，因为导入的名称必须是完全限定的，不会根据当前的命名空间作相对解析。</p><h5 id="（5）名称解析规则"><a href="#（5）名称解析规则" class="headerlink" title="（5）名称解析规则"></a>（5）名称解析规则</h5><p>在说明名称解析规则之前，我们先看一些重要的定义： </p><blockquote><p>命名空间名称定义<br>① 非限定名称Unqualified name<br>    名称中不包含命名空间分隔符的标识符，例如 Foo<br>② 限定名称Qualified name<br>    名称中含有命名空间分隔符的标识符，例如 Foo\Bar<br>③ 完全限定名称Fully qualified name<br>    名称中包含命名空间分隔符，并以命名空间分隔符开始的标识符，例如 \Foo\Bar。 namespace\Foo 也是一个完全限定名称。 </p></blockquote><p>名称解析遵循下列规则： </p><ol><li>对完全限定名称的函数，类和常量的调用在编译时解析。例如 new \A\B 解析为类 A\B。  </li><li>所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 A\B\C 被导入为 C，那么对 C\D\e() 的调用就会被转换为 A\B\C\D\e()。  </li><li>在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 A\B 内部调用 C\D\e()，则 C\D\e() 会被转换为 A\B\C\D\e() 。  </li><li>非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 A\B\C 导入为C，则 new C() 被转换为 new A\B\C() 。  </li><li>在命名空间内部（例如A\B），对非限定名称的函数调用是在运行时解析的。例如对函数 foo() 的调用是这样解析的：  <ol><li>在当前命名空间中查找名为 A\B\foo() 的函数  </li><li>尝试查找并调用 全局(global) 空间中的函数 foo()。  </li></ol></li><li>在命名空间（例如A\B）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 new C() 及 new D\E() 的解析过程： new C()的解析:  <ol><li>在当前命名空间中查找A\B\C类。  </li><li>尝试自动装载类A\B\C。<br>new D\E()的解析:  </li><li>在类名称前面加上当前命名空间名称变成：A\B\D\E，然后查找该类。  </li><li>尝试自动装载类 A\B\D\E。<br>为了引用全局命名空间中的全局类，必须使用完全限定名称 new \C()。 </li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h4&gt;&lt;p&gt;（1）用户自定义函数：&lt;/p&gt;
&lt;p&gt;（2）函数的参数：&lt;br&gt;值传递（默认情况）&lt;br&gt;引用传递：在该参数前面加上符号 &amp;amp;&lt;/p&gt;
&lt;p&gt;（3）类型声明&lt;br&gt;在PHP 5中，类型声明也被称为类型提示。&lt;br&gt;类型声明允许函数在调用时要求参数为特定类型。 如果给出的值类型不对，那么将会产生一个错误： 在PHP 5中，这将是一个可恢复的致命错误，而在PHP 7中将会抛出一个TypeError异常。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP数据类型详解（PHP手册版）</title>
    <link href="http://yoursite.com/2018/01/31/PHP%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88PHP%E6%89%8B%E5%86%8C%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/31/PHP数据类型详解（PHP手册版）/</id>
    <published>2018-01-31T09:45:42.000Z</published>
    <updated>2018-02-01T03:26:47.510Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据类型</strong><br>四种标量类型：</p><blockquote><p>boolean（布尔型）、integer（整型）、float（浮点型，也称为double）、string（字符串）</p></blockquote><p>两种复合类型：</p><blockquote><p>array（数组）、object（对象）</p></blockquote><p>两种特殊类型：</p><blockquote><p>resource（资源）、Null</p></blockquote><p>其它伪类型：</p><blockquote><p>mixed（混合类型）、number（数字类型）、callback（回调类型）、void（无类型）</p></blockquote><a id="more"></a><h4 id="布尔型（boolean）："><a href="#布尔型（boolean）：" class="headerlink" title="布尔型（boolean）："></a>布尔型（boolean）：</h4><p>（1）指定一个布尔值，使用常量 TRUE 或 FALSE。两个都不区分大小写。<br>（2）强制转换为布尔型，用 (bool) 或 (boolean) 来强制转换。但是很多情况下不需要强制转换，会被自动转换。<br>当转换为 boolean 时，以下值被认为是 FALSE： </p><ul><li>布尔值 FALSE 本身  </li><li>整型值 0（零）  </li><li>浮点型值 0.0（零）  </li><li>空字符串，以及字符串 “0”  </li><li>不包括任何元素的数组  </li><li>特殊类型 NULL（包括尚未赋值的变量）  </li><li>从空标记生成的 SimpleXML 对象  </li></ul><p>所有其它值都被认为是 TRUE（包括任何资源 和 NAN）。</p><h4 id="整型（interger）："><a href="#整型（interger）：" class="headerlink" title="整型（interger）："></a>整型（interger）：</h4><p>（1）整型值可以使用十进制，十六进制，八进制或二进制表示，前面可以加上可选的符号（- 或者 +）。<br>要使用八进制表达，数字前必须加上 0（零）。要使用十六进制表达，数字前必须加上 0x。要使用二进制表达，数字前必须加上 0b。<br>（2）要明确地将一个值转换为 integer，用 (int) 或 (integer) 强制转换。不过大多数情况下都不需要强制转换，因为当运算符，函数或流程控制需要一个 integer 参数时，值会自动转换。还可以通过函数 intval() 来将一个值转换成整型。<br>当从浮点数转换成整数时，将向下取整。 </p><h4 id="浮点型（float）："><a href="#浮点型（float）：" class="headerlink" title="浮点型（float）："></a>浮点型（float）：</h4><p>（1）浮点型（也叫浮点数 float，双精度数 double 或实数 real）。<br>（2）浮点数的精度<br>浮点数的精度有限。尽管取决于系统，PHP 通常使用 IEEE 754 双精度格式，则由于取整而导致的最大相对误差为 1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运算时的误差传递。<br>（3）NaN<br>某些数学运算会产生一个由常量 NAN 所代表的结果。此结果代表着一个在浮点数运算中未定义或不可表述的值。任何拿此值与其它任何值（除了 TRUE）进行的松散或严格比较的结果都是 FALSE。<br>由于 NAN 代表着任何不同值，不应拿 NAN 去和其它值进行比较，包括其自身，应该用 is_nan() 来检查。 </p><h4 id="字符串（string）："><a href="#字符串（string）：" class="headerlink" title="字符串（string）："></a>字符串（string）：</h4><p>（1）一个字符串 string 就是由一系列的字符组成，其中每个字符等同于一个字节。这意味着 PHP 只能支持 256 的字符集，因此不支持 Unicode 。<br>（注：Note: string 最大可以达到 2GB。）<br>（2）一个字符串可以用 4 种方式表达： </p><ul><li>单引号  ：定义一个字符串的最简单的方法是用单引号把它包围起来（字符 ‘）。</li><li>双引号  ：如果字符串是包围在双引号（”）中， PHP 将对一些特殊的字符进行解析。</li><li>heredoc 语法结构  ：<br>第三种表达字符串的方法是用 heredoc 句法结构：&lt;&lt;&lt;。在该运算符之后要提供一个标识符，然后换行。接下来是字符串 string 本身，最后要用前面定义的标识符作为结束标志。<br>结束时所引用的标识符必须在该行的第一列，而且，标识符的命名也要像其它标签一样遵守 PHP 的规则：只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。<br>（Heredoc 结构就象是没有使用双引号的双引号字符串，这就是说在 heredoc 结构中单引号不用被转义，但是上文中列出的转义序列还可以使用。变量将被替换，但在 heredoc 结构中含有复杂的变量时要格外小心。 ）</li><li>nowdoc 语法结构（自 PHP 5.3.0 起）<br>就象 heredoc 结构类似于双引号字符串，Nowdoc 结构是类似于单引号字符串的。Nowdoc 结构很象 heredoc 结构，但是 nowdoc 中不进行解析操作。这种结构很适合用于嵌入 PHP 代码或其它大段文本而无需对其中的特殊字符进行转义。与 SGML 的 &lt;![CDATA[ ]]&gt; 结构是用来声明大段的不用解析的文本类似，nowdoc 结构也有相同的特征。<br>一个 nowdoc 结构也用和 heredocs 结构一样的标记 &lt;&lt;&lt;， 但是跟在后面的标识符要用单引号括起来，即 &lt;&lt;&lt;’EOT’。Heredoc 结构的所有规则也同样适用于 nowdoc 结构，尤其是结束标识符的规则。</li></ul><p><strong>（注：函数、方法、静态类变量和类常量只有在 PHP 5 以后才可在 {$} 中使用。然而，只有在该字符串被定义的命名空间中才可以将其值作为变量名来访问。只单一使用花括号 ({}) 无法处理从函数或方法的返回值或者类常量以及类静态变量的值。 ）</strong><br>（3）字符串可以用 ‘.’（点）运算符连接起来，注意 ‘+’（加号）运算符没有这个功能。对于 string 的操作有很多有用的函数，后面予以单独说明。</p><h4 id="数组（array）："><a href="#数组（array）：" class="headerlink" title="数组（array）："></a>数组（array）：</h4><p>PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。<br>（1）语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义数组 array()</span><br><span class="line">可以用 array() 语言结构来新建一个数组。它接受任意数量用逗号分隔的 键（key） =&gt; 值（value）对。 </span><br><span class="line">array(  key =&gt;  value</span><br><span class="line">     , ...</span><br><span class="line">     )</span><br><span class="line">// 键（key）可是是一个整数 integer 或字符串 string</span><br><span class="line">// 值（value）可以是任意类型的值</span><br></pre></td></tr></table></figure></p><p>最后一个数组单元之后的逗号可以省略。通常用于单行数组定义中，例如常用 array(1, 2) 而不是 array(1, 2, )。对多行数组定义通常保留最后一个逗号，这样要添加一个新单元时更方便。<br>自 5.4 起可以使用短数组定义语法，用 [] 替代 array()。<br><strong>（注：key 可以是 integer 或者 string。value 可以是任意类型。）</strong></p><p><strong>此外 key 会有如下的强制转换： </strong></p><ul><li>包含有合法整型值的字符串会被转换为整型。例如键名 “8” 实际会被储存为 8。但是 “08” 则不会强制转换，因为其不是一个合法的十进制数值。  </li><li>浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。  </li><li>布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。  </li><li>Null 会被转换为空字符串，即键名 null 实际会被储存为 “”。  </li><li>数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。  </li></ul><p>如果在数组定义中多个单元都使用了同一个键名，则只使用了最后一个，之前的都被覆盖了。</p><p>（2）注意事项：<br> ① 方括号和花括号可以互换使用来访问数组单元（例如 $array[42] 和 $array{42} 在上例中效果相同）。<br> ② 试图访问一个未定义的数组键名与访问任何未定义变量一样：会导致 E_NOTICE 级别错误信息，其结果为 NULL。<br> ③ 要修改某个值，通过其键名给该单元赋一个新值。要删除某键值对，对其调用 unset() 函数。<br> ④ 应该始终在用字符串表示的数组索引上加上引号。例如用 $foo[‘bar’] 而不是 $foo[bar]。原因是此代码中有一个未定义的常量（bar）而不是字符串（’bar’－注意引号），而 PHP 可能会在以后定义此常量，不幸的是你的代码中有同样的名字。它能运行，是因为 PHP 自动将裸字符串（没有引号的字符串且不对应于任何已知符号）转换成一个其值为该裸字符串的正常字符串。例如，如果没有常量定义为 bar，PHP 将把它替代为 ‘bar’ 并使用之。<br> 但这并不意味着总是给键名加上引号。用不着给键名为常量或变量的加上引号，否则会使 PHP 不能解析它们。</p><h4 id="对象类型（Object）："><a href="#对象类型（Object）：" class="headerlink" title="对象类型（Object）："></a>对象类型（Object）：</h4><p>要创建一个新的对象 object，使用 new 语句实例化一个类。<br>转换为对象：如果将一个对象转换成对象，它将不会有任何变化。如果其它任何类型的值被转换成对象，将会创建一个内置类 stdClass 的实例。如果该值为 NULL，则新的实例为空。 array 转换成 object 将使键名成为属性名并具有相对应的值，除了数字键，不迭代就无法被访问。 </p><h4 id="资源类型（resource）："><a href="#资源类型（resource）：" class="headerlink" title="资源类型（resource）："></a>资源类型（resource）：</h4><p>资源 resource 是一种特殊变量，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。<br>转换为资源：由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，因此将其它类型的值转换为资源没有意义。 </p><h4 id="NULL："><a href="#NULL：" class="headerlink" title="NULL："></a>NULL：</h4><p>特殊的 NULL 值表示一个变量没有值。NULL 类型唯一可能的值就是 NULL。<br><strong>（注：NULL 类型只有一个值，就是不区分大小写的常量 NULL。）</strong><br>在下列情况下一个变量被认为是 NULL： </p><ul><li>被赋值为 NULL。 </li><li>尚未被赋值。 </li><li>被 unset()。</li></ul><h4 id="许的强制转换有："><a href="#许的强制转换有：" class="headerlink" title="许的强制转换有："></a>许的强制转换有：</h4><ul><li>(int), (integer) - 转换为整形 integer </li><li>(bool), (boolean) - 转换为布尔类型 boolean </li><li>(float), (double), (real) - 转换为浮点型 float </li><li>(string) - 转换为字符串 string </li><li>(array) - 转换为数组 array </li><li>(object) - 转换为对象 object </li><li>(unset) - 转换为 NULL (PHP 5) </li><li>(binary) 转换和 b 前缀转换支持为 PHP 5.2.1 新增。 </li></ul><p><strong>（注意在括号内允许有空格和制表符）</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;br&gt;四种标量类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;boolean（布尔型）、integer（整型）、float（浮点型，也称为double）、string（字符串）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两种复合类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;array（数组）、object（对象）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两种特殊类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;resource（资源）、Null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其它伪类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mixed（混合类型）、number（数字类型）、callback（回调类型）、void（无类型）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP基础整理（PHP手册版）</title>
    <link href="http://yoursite.com/2018/01/31/PHP%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88PHP%E6%89%8B%E5%86%8C%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/31/PHP基础整理（PHP手册版）/</id>
    <published>2018-01-31T09:45:30.000Z</published>
    <updated>2018-02-01T03:40:09.541Z</updated>
    
    <content type="html"><![CDATA[<h4 id="PHP概述："><a href="#PHP概述：" class="headerlink" title="PHP概述："></a>PHP概述：</h4><p>PHP（“PHP: Hypertext Preprocessor”，超文本预处理器的字母缩写）是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML中，尤其适合 web 开发。<br>PHP常用于服务端脚本和命令行脚本。<br>服务端脚本。是 PHP 最传统，也是最主要的目标领域。开展这项工作需要具备以下三点：PHP 解析器（CGI 或者服务器模块）、web 服务器和 web 浏览器。需要在运行 web 服务器时，安装并配置 PHP，然后，可以用 web 浏览器来访问 PHP 程序的输出，即浏览服务端的 PHP 页面。一般做 web 开发和 api 开发。<br>命令行脚本。可以编写一段 PHP 脚本，并且不需要任何服务器或者浏览器来运行它。通过这种方式，仅仅只需要 PHP 解析器来执行。这种用法对于依赖 cron（Unix 或者 Linux 环境）或者 Task Scheduler（Windows 环境）的日常运行的脚本来说是理想的选择。这些脚本也可以用来处理简单的文本。<br><a id="more"></a></p><h4 id="基础语法："><a href="#基础语法：" class="headerlink" title="基础语法："></a>基础语法：</h4><h5 id="1、PHP标记："><a href="#1、PHP标记：" class="headerlink" title="1、PHP标记："></a>1、PHP标记：</h5><p>普通：&lt;?php ?&gt;<br>短标记：&lt;? ?&gt; 通过 php.ini 配置中的 short_open_tag 开启即可。</p><h5 id="2、注释"><a href="#2、注释" class="headerlink" title="2、注释"></a>2、注释</h5><p>单行：//<br>多行：/<em>  </em>/</p><h5 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h5><h6 id="（1）基础"><a href="#（1）基础" class="headerlink" title="（1）基础"></a>（1）基础</h6><p>PHP 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。<br>变量名与 PHP 中其它的标签一样遵循相同的规则。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。</p><p>变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。<br>PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用（换言之，”成为其别名” 或者 “指向”）了原始变量。改动新的变量将影响到原始变量，反之亦然。<br>使用引用赋值，简单地将一个 &amp; 符号加到将要赋值的变量前（源变量）。</p><p>虽然在 PHP 中并不需要初始化变量，但对变量进行初始化是个好习惯。未初始化的变量具有其类型的默认值 - 布尔类型的变量默认值是 FALSE，整形和浮点型变量默认值是零，字符串型变量（例如用于 echo 中）默认值是空字符串以及数组变量的默认值是空数组。 </p><h6 id="（2）变量范围："><a href="#（2）变量范围：" class="headerlink" title="（2）变量范围："></a>（2）变量范围：</h6><p>变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的 PHP 变量只有一个单独的范围。这个单独的范围跨度同样包含了 include 和 require 引入的文件。</p><p>局部变量：局部函数内部的变量将被限制在局部函数范围内。<br>全局变量：PHP 中全局变量在函数中使用时必须声明为 global。<br>超全局变量：PHP自定义特殊的数组。$GLOBALS、$_POST、$_GET、$_REQUEST、$_COOKIE。<br>静态变量：静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。</p><h6 id="（3）可变变量："><a href="#（3）可变变量：" class="headerlink" title="（3）可变变量："></a>（3）可变变量：</h6><p>有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &apos;hello&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。在上面的例子中 hello 使用了两个美元符号（$）以后，就可以作为一个可变变量的变量了。例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$$a = &apos;world&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这时，两个变量都被定义了：$a 的内容是”hello”并且 $hello 的内容是”world”。</p><p>要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下 $$a[1] 时，解析器需要知道是想要 $a[1] 作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 [1] 的值。解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1]。<br>类的属性也可以通过可变属性名来访问。可变属性名将在该调用所处的范围内被解析。例如，对于 $foo-&gt;$bar 表达式，则会在本地范围来解析 $bar 并且其值将被用于 $foo 的属性名。对于 $bar 是数组单元时也是一样。<br>也可使用花括号来给属性名清晰定界。最有用是在属性位于数组中，或者属性名包含有多个部分或者属性名包含有非法字符时。<br><strong>（注意，在 PHP 的函数和类的方法中，超全局变量不能用作可变变量。$this 变量也是一个特殊变量，不能被动态引用。）</strong></p><h5 id="5、常量"><a href="#5、常量" class="headerlink" title="5、常量"></a>5、常量</h5><p>常量是一个简单值的标识符（名字）。如同其名称所暗示的，在脚本执行期间该值不能改变（除了所谓的魔术常量，它们其实不是常量）。常量默认为大小写敏感。传统上常量标识符总是大写的。<br>常量名和其它任何 PHP 标签遵循同样的命名规则。合法的常量名以字母或下划线开始，后面跟着任何字母，数字或下划线。</p><h6 id="（1）语法"><a href="#（1）语法" class="headerlink" title="（1）语法"></a>（1）语法</h6><p>可以用 define() 函数来定义常量，在 PHP 5.3.0 以后，可以使用 const 关键字在类定义之外定义常量。一个常量一旦被定义，就不能再改变或者取消定义。如果只想检查是否定义了某常量，用 defined() 函数。</p><p>常量只能包含标量数据（boolean，integer，float 和 string）。可以定义 resource 常量，但应尽量避免，因为会造成不可预料的结果。 </p><p>可以简单的通过指定其名字来取得常量的值，与变量不同，不应该在常量前面加上 $ 符号。如果常量名是动态的，也可以用函数 constant() 来获取常量的值。用 get_defined_constants() 可以获得所有已定义的常量列表。<br><strong>（注: 常量和（全局）变量在不同的名字空间中。这意味着例如 TRUE 和 $TRUE 是不同的。）</strong></p><p>如果使用了一个未定义的常量，PHP 假定想要的是该常量本身的名字，如同用字符串调用它一样（CONSTANT 对应 “CONSTANT”）。此时将发出一个 E_NOTICE 级的错误。参见手册中为什么 $foo[bar] 是错误的（除非事先用 define() 将 bar 定义为一个常量）。 </p><p><strong>常量和变量有如下不同： </strong></p><ul><li>常量前面没有美元符号（$）；  </li><li>常量只能用 define() 函数定义，而不能通过赋值语句；  </li><li>常量可以不用理会变量的作用域而在任何地方定义和访问；  </li><li>常量一旦定义就不能被重新定义或者取消定义；  </li><li>常量的值只能是标量。</li></ul><p><strong>define() 与 const 区别：</strong><br>和使用 define() 来定义常量相反的是，使用 const 关键字定义常量必须处于最顶端的作用区域，因为用此方法是在编译时定义的。这就意味着不能在函数内，循环内以及 if 语句之内用 const 来定义常量。</p><h6 id="（2）魔术常量"><a href="#（2）魔术常量" class="headerlink" title="（2）魔术常量"></a>（2）魔术常量</h6><p>PHP 向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。<br>有八个魔术常量它们的值随着它们在代码中的位置改变而改变。例如 <strong>LINE</strong> 的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下： </p><p>几个 PHP 的”魔术常量”</p><style type="text/css">    table th:first-of-type{        width: 100px;    }</style><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>LINE</strong></td><td>文件中的当前行号。  </td></tr><tr><td><strong>FILE</strong></td><td>文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，<strong>FILE</strong> 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。  </td></tr><tr><td><strong>DIR</strong></td><td>文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(<strong>FILE</strong>)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增） =  </td></tr><tr><td><strong>FUNCTION</strong></td><td>函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。  </td></tr><tr><td><strong>CLASS</strong></td><td>类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 <strong>CLASS</strong> 对 trait 也起作用。当用在 trait 方法中时，<strong>CLASS</strong> 是调用 trait 方法的类的名字。  </td></tr><tr><td><strong>TRAIT</strong></td><td>Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4 起此常量返回 trait 被定义时的名字（区分大小写）。Trait 名包括其被声明的作用区域（例如 Foo\Bar）。  </td></tr><tr><td><strong>METHOD</strong></td><td>类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。  </td></tr><tr><td><strong>NAMESPACE</strong></td><td>当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。 </td></tr></tbody></table><h5 id="6、运算符"><a href="#6、运算符" class="headerlink" title="6、运算符"></a>6、运算符</h5><p>运算符优先级</p><table><thead><tr><th>结合方向</th><th>运算符</th><th>附加信息</th></tr></thead><tbody><tr><td>无</td><td>clone new</td><td>clone 和 new </td></tr><tr><td>左</td><td>[</td><td>array() </td></tr><tr><td>右</td><td>**</td><td>算术运算符 </td></tr><tr><td>右</td><td>++ – ~ (int) (float) (string) (array) (object) (bool) @</td><td>类型和递增／递减  </td></tr><tr><td>无</td><td>instanceof</td><td>类型  </td></tr><tr><td>右</td><td>!</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>* / %</td><td>算术运算符  </td></tr><tr><td>左</td><td>+ - .</td><td>算术运算符和字符串运算符 </td></tr><tr><td>左</td><td>&lt;&lt; &gt;&gt;</td><td>位运算符  </td></tr><tr><td>无</td><td>&lt; &lt;= &gt; &gt;=</td><td>比较运算符  </td></tr><tr><td>无</td><td>== != === !== &lt;&gt; &lt;=&gt;</td><td>比较运算符  </td></tr><tr><td>左</td><td>&amp;</td><td>位运算符和引用 </td></tr><tr><td>左</td><td>^</td><td>位运算符  </td></tr><tr><td>左</td><td>&#124;</td><td>位运算符  </td></tr><tr><td>左</td><td>&amp;&amp;</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>&#124;&#124;</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>??</td><td>比较运算符  </td></tr><tr><td>左</td><td>? :</td><td>ternary  </td></tr><tr><td>右</td><td>= += -= <em>= *</em>= /= .= %= &amp;= &#124;= ^= &lt;&lt;= &gt;&gt;=</td><td>赋值运算符  </td></tr><tr><td>左</td><td>and</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>xor</td><td>逻辑运算符  </td></tr><tr><td>左</td><td>or</td><td>逻辑运算符  </td></tr></tbody></table><h5 id="7、流程控制"><a href="#7、流程控制" class="headerlink" title="7、流程控制"></a>7、流程控制</h5><h6 id="（1）条件判断"><a href="#（1）条件判断" class="headerlink" title="（1）条件判断"></a>（1）条件判断</h6><p><strong>if语句：</strong><br>单分支if语句：if(){}else{}<br>多分支if语句：if(){}elseif(){}else{}<br>分支嵌套语句：if(){if(){}}else{}</p><p><strong>switch语句：</strong><br>switch(expr){<br>    case 0:<br>        statement<br>        break;<br>    case 1:<br>        statement<br>        break;<br>    default:<br>        statement<br>        break;<br>}</p><h6 id="（2）循环判断"><a href="#（2）循环判断" class="headerlink" title="（2）循环判断"></a>（2）循环判断</h6><p><strong>for循环：</strong><br>for(expr1; expr2; expr3){</p><p>}</p><p><strong>foreach循环：</strong><br>仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。<br>foreach(array_expression as $value){<br>    statement<br>}<br>foreach(array_expression as $key=&gt;$value){<br>    statement<br>}</p><p><strong>while循环：</strong><br>while(){</p><p>}</p><p><strong>do-while循环：</strong><br>do{</p><p>}while();</p><h6 id="（3）中止语句"><a href="#（3）中止语句" class="headerlink" title="（3）中止语句"></a>（3）中止语句</h6><p>跳出循环语句：break;<br>跳出本次循环，执行下一个循环：continue;<br>结束函数的执行并将它的值返回：return;</p><h6 id="（4）加载语句"><a href="#（4）加载语句" class="headerlink" title="（4）加载语句"></a>（4）加载语句</h6><p>require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include 只产生警告（E_WARNING），脚本会继续运行。<br>require：<br>include：<br>唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。<br>require_once：<br>include_once：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;PHP概述：&quot;&gt;&lt;a href=&quot;#PHP概述：&quot; class=&quot;headerlink&quot; title=&quot;PHP概述：&quot;&gt;&lt;/a&gt;PHP概述：&lt;/h4&gt;&lt;p&gt;PHP（“PHP: Hypertext Preprocessor”，超文本预处理器的字母缩写）是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML中，尤其适合 web 开发。&lt;br&gt;PHP常用于服务端脚本和命令行脚本。&lt;br&gt;服务端脚本。是 PHP 最传统，也是最主要的目标领域。开展这项工作需要具备以下三点：PHP 解析器（CGI 或者服务器模块）、web 服务器和 web 浏览器。需要在运行 web 服务器时，安装并配置 PHP，然后，可以用 web 浏览器来访问 PHP 程序的输出，即浏览服务端的 PHP 页面。一般做 web 开发和 api 开发。&lt;br&gt;命令行脚本。可以编写一段 PHP 脚本，并且不需要任何服务器或者浏览器来运行它。通过这种方式，仅仅只需要 PHP 解析器来执行。这种用法对于依赖 cron（Unix 或者 Linux 环境）或者 Task Scheduler（Windows 环境）的日常运行的脚本来说是理想的选择。这些脚本也可以用来处理简单的文本。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Linux VPS、Linux系统防止DDOS攻击脚本[转]</title>
    <link href="http://yoursite.com/2018/01/25/Linux-VPS%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E9%98%B2%E6%AD%A2DDOS%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC-%E8%BD%AC/"/>
    <id>http://yoursite.com/2018/01/25/Linux-VPS、Linux系统防止DDOS攻击脚本-转/</id>
    <published>2018-01-25T07:00:10.000Z</published>
    <updated>2018-01-25T07:04:52.803Z</updated>
    
    <content type="html"><![CDATA[<p>转载地址：<a href="http://www.1987.name/33.html" target="_blank" rel="noopener">http://www.1987.name/33.html</a></p><p>互联网上明争暗斗如同现实社会一样，DDOS攻击屡见不鲜，是很多站长烦恼的事情，尤其是个人站长，资金有限，没有硬件防火墙那只能使用软件。Linux系统上第一个想到的替代软件肯定是iptables，但是它不会智能屏蔽攻击IP，需要手动执行，这样也是不现实。本文主要介绍一款配合iptables来智能抵御DDOS攻击的软件：<strong>DDoS Deflate。</strong><br><a id="more"></a></p><h4 id="关于DDOS-Deflate脚本"><a href="#关于DDOS-Deflate脚本" class="headerlink" title="关于DDOS Deflate脚本"></a>关于DDOS Deflate脚本</h4><p>DDOS deflate是一个轻量级的脚本，以协助阻止拒绝服务攻击的过程中的bash shell脚本。它使用下面的命令来创建一个连接到服务器的IP地址列表，以及与它们的连接总数 。这是最简单的安装软件的解决方案之一。我已经使用一年多，抵御一般性的DDOS攻击效果还是不错的。</p><p>主要原理是超过了预先配置的连接数的IP地址自动被服务器防火墙（iptables）阻止！<br><code>netstat -ntu | awk &#39;{print $5}&#39; | cut -d: -f1 | sort | uniq -c | sort -n</code></p><h4 id="DDOS-Deflate的5个主要功能"><a href="#DDOS-Deflate的5个主要功能" class="headerlink" title="DDOS Deflate的5个主要功能"></a>DDOS Deflate的5个主要功能</h4><ol><li>可以配置白名单的IP地址文件，配置文件路径：/usr/local/ddos/ignore.ip.list</li><li>配置文件简单明了，文件路径：/usr/local/ddos/ddos.conf</li><li>可以设置被防火墙（iptables）屏蔽的IP地址封锁时间（默认：600秒后自动解除封锁）</li><li>可以修改配置文件，脚本可以定时周期性运行（默认是：1分钟）</li><li>当遇到攻击，IP被封锁之后可以为指定的邮箱接收电子邮件警报。</li></ol><h4 id="DDOS-Deflate的安装方法"><a href="#DDOS-Deflate的安装方法" class="headerlink" title="DDOS Deflate的安装方法"></a>DDOS Deflate的安装方法</h4><p>DDOS Deflate非常简单，下载脚本后，直接执行脚本，结束后会显示安装信息，按ESC退出即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.inetbase.com/scripts/ddos/install.sh</span><br><span class="line">chmod +x install.sh</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure></p><p>安装结束后，配置主配文件ddos.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">##### Paths of the script and other files</span><br><span class="line">PROGDIR=&quot;/usr/local/ddos&quot; #软件文件存放位置</span><br><span class="line">PROG=&quot;/usr/local/ddos/ddos.sh&quot; #主要功能脚本路径</span><br><span class="line">IGNORE_IP_LIST=&quot;/usr/local/ddos/ignore.ip.list&quot; #白名单列表路径</span><br><span class="line">CRON=&quot;/etc/cron.d/ddos.cron&quot; #定时任务脚本路径</span><br><span class="line">APF=&quot;/etc/apf/apf&quot; #APF路径</span><br><span class="line">IPT=&quot;/sbin/iptables&quot; #iptables路径</span><br><span class="line"></span><br><span class="line">##### frequency in minutes for running the script</span><br><span class="line">##### Caution: Every time this setting is changed, run the script with --cron</span><br><span class="line">##### option so that the new frequency takes effect</span><br><span class="line">FREQ=1 #检查周期时间，默认1分钟</span><br><span class="line"></span><br><span class="line">##### How many connections define a bad IP? Indicate that below.</span><br><span class="line">NO_OF_CONNECTIONS=150 #允许客户端与服务器的最大连接数，超过IP就会被屏蔽，一般保持默认即可</span><br><span class="line"></span><br><span class="line">##### APF_BAN=1 (Make sure your APF version is atleast 0.96)</span><br><span class="line">##### APF_BAN=0 (Uses iptables for banning ips instead of APF)</span><br><span class="line">APF_BAN=0  #数字1为使用APF，数字0为使用iptables，这里推荐使用iptables </span><br><span class="line"></span><br><span class="line">##### KILL=0 (Bad IPs are&apos;nt banned, good for interactive execution of script)</span><br><span class="line">##### KILL=1 (Recommended setting)</span><br><span class="line">KILL=1 #是否屏蔽IP，当然是屏蔽，默认即可</span><br><span class="line"></span><br><span class="line">##### An email is sent to the following address when an IP is banned.</span><br><span class="line">##### Blank would suppress sending of mails</span><br><span class="line">EMAIL_TO=&quot;admin@1987.name&quot; #指定一个 电子邮件，用于发送警报 </span><br><span class="line"></span><br><span class="line">##### Number of seconds the banned ip should remain in blacklist.</span><br><span class="line">BAN_PERIOD=600 #屏蔽时间，这里自由设定</span><br></pre></td></tr></table></figure></p><p>配置文件中提到的APF，它也是linux系统中防火墙之一，这里稍作介绍：APF（Advanced Policy Firewall），是 Rf-x Networks 出品的Linux环境下的软件防火墙。APF采用Linux系统默认的 iptables 规则。APF可以算是Linux中最出名的软件防火墙之一。</p><h4 id="为DDOS-Deflate开启相关服务"><a href="#为DDOS-Deflate开启相关服务" class="headerlink" title="为DDOS Deflate开启相关服务"></a>为DDOS Deflate开启相关服务</h4><p>开启iptables<br><code>service iptables start</code><br>开启crontab，定时任务<br><code>service crond start</code></p><h4 id="如何卸载DDOS-Deflate"><a href="#如何卸载DDOS-Deflate" class="headerlink" title="如何卸载DDOS Deflate"></a>如何卸载DDOS Deflate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.inetbase.com/scripts/ddos/uninstall.ddos</span><br><span class="line">chmod +x uninstall.ddos</span><br><span class="line">./uninstall.ddos</span><br></pre></td></tr></table></figure><p>希望遇到DDOS攻击的朋友使用此软件能解决头疼问题，也感谢软件作者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载地址：&lt;a href=&quot;http://www.1987.name/33.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.1987.name/33.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;互联网上明争暗斗如同现实社会一样，DDOS攻击屡见不鲜，是很多站长烦恼的事情，尤其是个人站长，资金有限，没有硬件防火墙那只能使用软件。Linux系统上第一个想到的替代软件肯定是iptables，但是它不会智能屏蔽攻击IP，需要手动执行，这样也是不现实。本文主要介绍一款配合iptables来智能抵御DDOS攻击的软件：&lt;strong&gt;DDoS Deflate。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的vim标配</title>
    <link href="http://yoursite.com/2018/01/24/%E6%88%91%E7%9A%84vim%E6%A0%87%E9%85%8D/"/>
    <id>http://yoursite.com/2018/01/24/我的vim标配/</id>
    <published>2018-01-24T09:33:52.000Z</published>
    <updated>2018-01-24T10:05:48.897Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux下开发程序，一般都会离不开vi编辑器，而vim是vi的进阶版IDE。目前vim已经取代了vi编辑器，正常使用vi的时候就默认启用的是vim编辑器，不信你可自己查看，在bash命令行下输入”alias”即可看到是否vim已经取代了vi编辑器。但vim的用法与vi编辑器是一模一样，所以，不用担心使用过vi，而不会使用vim，只不过vim有更高级的用法罢了。而vim的配置就是其中一个非常好的用法。<br>一千个vimer就有一千个配置，vim的配置之多让人眩目，但常用的基本配置也就那些——我的vim标配。<br>首先，要知道在什么地方配置vim，一般只修改用户自己的vim配置文件即可(~/.vimrc)。下面给出我的配置清单：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set tabstop=4   &quot;设定tab缩进空格数</span><br><span class="line">set expandtab      &quot;设定tab自动转为空格</span><br><span class="line">set number         &quot;set nu 显示行号</span><br><span class="line">set hlsearch       &quot;搜索时高亮显示被找到的文本</span><br><span class="line">set syntax=on      &quot;自动语法高亮</span><br><span class="line">set smartindent    &quot;开启新行时使用智能自动缩进</span><br><span class="line">set showmatch   &quot;自动匹配括号</span><br></pre></td></tr></table></figure></p><p>（注：vim配置注释，使用双引号 “ 注释。）</p><h5 id="常用配置："><a href="#常用配置：" class="headerlink" title="常用配置："></a>常用配置：</h5><p>“显示行号<br>set nu/nonu</p><p>“语法高亮<br>syntax on/off</p><p>“tab缩进<br>set tabstop=4<br>set shiftwidth=4<br>set expandtab<br>set smarttab</p><p>“智能缩进<br>set smartindent<br>（表示在换行的时候光标进行智能缩进，触发智能缩进的场景有：以”{“结尾，以C语言关键字开头，可以通过:h cinwords进行查看，包括：if, else, while, do, for, switch，以”}”开头，此情况只有在执行”O”命令时候有效，但是这个配置有一点问题，就是当换行之后本来已经处于缩进状态了，如果输入”#”，那么缩进就会取消，”#”就会被插入到第一列，可是我们在写Python代码的时候，往往不希望这样做，所以我们可以增加配置”:inoremap # X^H”，其中 ^H 是先按CTRL-V再按CTRL-H输入的。）</p><p>“高亮被搜索的字符<br>set hlsearch</p><p>“背景色<br>set background=dark</p><p>“显示匹配（可自动匹配括号）<br>set showmatch</p><font color="red">待补录…</font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Linux下开发程序，一般都会离不开vi编辑器，而vim是vi的进阶版IDE。目前vim已经取代了vi编辑器，正常使用vi的时候就默认启用的是vim编辑器，不信你可自己查看，在bash命令行下输入”alias”即可看到是否vim已经取代了vi编辑器。但vim的用法与vi编辑器是一模一样，所以，不用担心使用过vi，而不会使用vim，只不过vim有更高级的用法罢了。而vim的配置就是其中一个非常好的用法。&lt;br&gt;一千个vimer就有一千个配置，vim的配置之多让人眩目，但常用的基本配置也就那些——我的vim标配。&lt;br&gt;首先，要知道在什么地方配置vim，一般只修改用户自己的vim配置文件即可(~/.vimrc)。下面给出我的配置清单：&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Linux 用户与账号管理</title>
    <link href="http://yoursite.com/2018/01/22/Linux-%E7%94%A8%E6%88%B7%E4%B8%8E%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/01/22/Linux-用户与账号管理/</id>
    <published>2018-01-22T10:25:29.000Z</published>
    <updated>2018-01-22T10:29:09.203Z</updated>
    
    <content type="html"><![CDATA[<p>Linux是个多用户多任务的分时操作系统，所有一个要使用系统资源的用户都必须先向系统管理员申请一个账号，然后以这个账号的身份进入系统。用户的账号一方面能帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也能帮助用户组织文件，并为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和用户口令。用户在登录时键入正确的用户名和口令后，才能进入系统和自己的主目录。</p><p>实现用户账号的管理，要完成的工作主要有如下几个方面：<br>a.用户账号的管理。<br>b.用户口令的管理。<br>c.用户组的管理。<br>d.用户切换<br><a id="more"></a></p><h4 id="用户账号的管理：添加、删除和修改："><a href="#用户账号的管理：添加、删除和修改：" class="headerlink" title="用户账号的管理：添加、删除和修改："></a>用户账号的管理：添加、删除和修改：</h4><h5 id="1、新增用户：useradd"><a href="#1、新增用户：useradd" class="headerlink" title="1、新增用户：useradd"></a>1、新增用户：useradd</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM]\</span><br><span class="line">&gt; [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号名</span><br><span class="line">选项与参数：</span><br><span class="line">    -u ：后面接的是 UID ，是一组数字。直接指定一个特定的 UID 给这个账号；</span><br><span class="line">    -g ：后面接的那个组名就是用户所属的用户组。该群组的 GID 会被放置到 /etc/passwd 的第四个字段内。</span><br><span class="line">    -G ：后面接的组名则是这个账号还可以加入的群组，即附加组。这个选项与参数会修改 /etc/group 内的相关资料！</span><br><span class="line">    -M ：强制！不要建立用户家目录！(系统账号默认值)</span><br><span class="line">    -m ：强制！要建立用户家目录！(一般账号默认值)</span><br><span class="line">    -c ：这个就是 /etc/passwd 的第五栏的说明内容(comment)！可以随便我们设定</span><br><span class="line">    -d ：指定某个目录成为家目录，而不要使用默认值。务必使用绝对路径！如果此目录不存在，则同时使用-m选项，能创建主目录。</span><br><span class="line">    -s ：后面接一个 shell ，若没有指定则预设是 /bin/bash</span><br><span class="line">    -r ：建立一个系统的账号，这个账号的 UID 会有限制 (参考 /etc/login.defs)</span><br><span class="line">    -e ：后面接一个日期，格式为【YYYY-MM-DD】此项目可写入 shadow 第八字段，亦即账号失效日的设定项目；</span><br><span class="line">    -f ：后面接 shadow 的第七字段项目，指定密码是否会失效。0 为立刻失效，-1 为永远不失效(密码只会过期而强制于登入时重新设定而已。)</span><br></pre></td></tr></table></figure><p>范例一：完全参考默认值建立一个用户，名称为 ben<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# useradd ben</span><br><span class="line">[root@www ~]# ll -d /home/ben</span><br><span class="line">drwx------ 4 ben ben 4096 Feb 25 09:38 /home/ben</span><br><span class="line"># 默认会建立用户家目录，且权限为 700 ！这是重点！</span><br><span class="line">[root@www ~]# grep ben /etc/passwd /etc/shadow /etc/group</span><br><span class="line">/etc/passwd:ben:x:504:505::/home/ben:/bin/bash</span><br><span class="line">/etc/shadow:ben:!!:14300:0:99999:7:::</span><br><span class="line">/etc/group:ben:x:505: &lt;==预设会建立一个与账号一模一样的群组名</span><br></pre></td></tr></table></figure></p><p>其实系统已经帮我们规定好非常多的默认值了，所以我们可以简单的使用【 useradd 账号 】来建立使用者即可。CentOS 这些默认值主要会帮我们处理几个项目：</p><ul><li>在 /etc/passwd 里面建立一行与账号相关的数据，包括建立 UID/GID/ 家目录等；</li><li>在 /etc/shadow 里面将此账号的密码相关参数填入，但是尚未有密码；</li><li>在 /etc/group 里面加入一个与账号名称一模一样的组名；</li><li>在 /home 底下建立一个与账号同名的目录作为用户家目录，且权限为 700</li></ul><p>由于在 /etc/shadow 内仅会有密码参数而不会有加密过的密码数据，因此我们在建立使用者账号时，还需要使用【 passwd 账号 】来给予密码才算是完成了用户建立的流程。</p><h5 id="2、删除用户：userdel"><a href="#2、删除用户：userdel" class="headerlink" title="2、删除用户：userdel"></a>2、删除用户：userdel</h5><p>这个功能就太简单了，目的在删除用户的相关数据，而用户的数据有：</p><ul><li>用户账号/密码相关参数：/etc/passwd, /etc/shadow</li><li>使用者群组相关参数：/etc/group, /etc/gshadow</li><li>用户个人档案数据： /home/username, /var/spool/mail/username..</li></ul><p>整个指令的语法非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# userdel [-r] username</span><br><span class="line">选项与参数：</span><br><span class="line">    -r ：连同用户的家目录也一起删除</span><br></pre></td></tr></table></figure></p><p>范例一：删除 ben ，连同家目录一起删除<br><code>[root@www ~]# userdel -r ben</code></p><p>这个指令下达的时候要小心了！通常我们要移除一个账号的时候，你可以手动的将 /etc/passwd 与 /etc/shadow 里头的该账号取消即可！一般而言，如果该账号只是【暂时不启用】的话，那么将 /etc/shadow 里头账号失效日期 (第八字段) 设定为 0 就可以让该账号无法使用，但是所有跟该账号相关的数据都会留下来！使用 userdel 的时机通常是【你真的确定不要让该用户在主机上面使用任何数据了！】</p><h5 id="3、修改用户：usermod"><a href="#3、修改用户：usermod" class="headerlink" title="3、修改用户：usermod"></a>3、修改用户：usermod</h5><p>（注：usermod 就是用来微调 useradd 增加的使用者参数）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# usermod [-cdegGlsuLU] username</span><br><span class="line">选项与参数：</span><br><span class="line">    -c ：后面接账号的说明，即 /etc/passwd 第五栏的说明栏，可以加入一些账号的说明。</span><br><span class="line">    -d ：后面接账号的家目录，即修改 /etc/passwd 的第六栏；</span><br><span class="line">    -e ：后面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 内的第八个字段数据！</span><br><span class="line">    -f ：后面接天数，为 shadow 的第七字段。</span><br><span class="line">    -g ：后面接初始群组，修改 /etc/passwd 的第四个字段，亦即是 GID 的字段！</span><br><span class="line">    -G ：后面接次要群组，修改这个使用者能够支持的群组，修改的是 /etc/group ！</span><br><span class="line">    -a ：与 -G 合用，可【增加次要群组的支持】而非【设定】！</span><br><span class="line">    -l ：后面接账号名称。亦即是修改账号名称， /etc/passwd 的第一栏！</span><br><span class="line">    -s ：后面接 Shell 的实际档案，例如 /bin/bash 或 /bin/csh 等等。</span><br><span class="line">    -u ：后面接 UID 数字！即 /etc/passwd 第三栏的资料；</span><br><span class="line">    -L ：暂时将用户的密码冻结，让他无法登入。其实仅改 /etc/shadow 的密码栏。</span><br><span class="line">    -U ：将 /etc/shadow 密码栏的 ! 拿掉，解冻！</span><br></pre></td></tr></table></figure></p><h5 id="4、相关用户功能："><a href="#4、相关用户功能：" class="headerlink" title="4、相关用户功能："></a>4、相关用户功能：</h5><p>finger：查阅用户相关的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# finger [-s] username</span><br><span class="line">选项与参数：</span><br><span class="line">    -s ：仅列出用户的账号、全名、终端机代号与登入时间等等；</span><br><span class="line">    -m ：列出与后面接的账号相同者，而不是利用部分比对 (包括全名部分)</span><br></pre></td></tr></table></figure></p><p>id：查询某人或自己的相关 UID/GID 等信息<br><code>[root@www ~]# id [username]</code></p><h4 id="用户口令的管理：passwd"><a href="#用户口令的管理：passwd" class="headerlink" title="用户口令的管理：passwd"></a>用户口令的管理：passwd</h4><p>使用 useradd 建立了账号之后，在预设的情况下，该账号是暂时被封锁的，也就是说，该账号是无法登入的，你可以去瞧一瞧 /etc/shadow 内的第二个字段就知道了。那该如何是好？使用 passwd 设定密码之后就可使用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# passwd [--sdtin] &lt;==所有人均可使用来改自己的密码</span><br><span class="line">[root@www ~]# passwd [-l] [-u] [--sdtin] [-S] \</span><br><span class="line">&gt; [-n 日数] [-x 日数] [-w 日数] [-i 日期] 账号 &lt;==root 功能</span><br><span class="line">选项与参数：</span><br><span class="line">    --stdin ：可以透过来自前一个管线的数据，作为密码输入，对 shell script 有帮助！</span><br><span class="line">    -l ：是 Lock 的意思，会将 /etc/shadow 第二栏最前面加上 ! 使密码失效；</span><br><span class="line">    -u ：与 -l 相对，是 Unlock 的意思！</span><br><span class="line">    -S ：列出密码相关参数，亦即 shadow 档案内的大部分信息。</span><br><span class="line">    -n ：后面接天数，shadow 的第 4 字段，多久不可修改密码天数</span><br><span class="line">    -x ：后面接天数，shadow 的第 5 字段，多久内必须要更动密码</span><br><span class="line">    -w ：后面接天数，shadow 的第 6 字段，密码过期前的警告天数</span><br><span class="line">    -i ：后面接【日期】，shadow 的第 7 字段，密码失效日期</span><br></pre></td></tr></table></figure></p><p>理论上，你的密码最好符合如下要求：</p><ul><li>密码不能与账号相同；</li><li>密码尽量不要选用字典里面会出现的字符串；</li><li>密码需要超过 8 个字符；</li><li>密码不要使用个人信息，如身份证、手机号码、其他电话号码等；</li><li>密码不要使用简单的关系式，如 1+1=2， Iamben 等；</li><li>密码尽量使用大小写字符、数字、特殊字符($,_,-等)的组合。</li></ul><h4 id="用户组的管理：新增、删除与修改"><a href="#用户组的管理：新增、删除与修改" class="headerlink" title="用户组的管理：新增、删除与修改"></a>用户组的管理：新增、删除与修改</h4><p>每个用户都有一个用户组，系统能对一个用户组中的所有用户进行集中管理。不同Linux系统对用户组的规定有所不同，如Linux下的用户属于和他同名的用户组，这个用户组在创建用户时同时创建。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就对/etc/group文件的更新。<br>用户组（group）就是具有相同特征的用户（user）的集合体；比如有时我们要让多个用户具有相同的权限，比如查看、修改某一文件或执行某个命令，这时我们需要用户组，我们把用户都定义到同一用户组，我们通过修改文件或目录的权限，让用户组具有一定的操作权限，这样用户组下的用户对该文件或目录都具有相同的权限，这是我们通过定义组和修改文件的权限来实现的；</p><h5 id="1、新增群组：groupadd"><a href="#1、新增群组：groupadd" class="headerlink" title="1、新增群组：groupadd"></a>1、新增群组：groupadd</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# groupadd [-g gid] [-r] 组名</span><br><span class="line">选项与参数：</span><br><span class="line">    -g ：后面接某个特定的 GID ，用来直接给予某个 GID</span><br><span class="line">    -r ：建立系统群组！与 /etc/login.defs 内的 GID_MIN 有关。</span><br></pre></td></tr></table></figure><p>范例一：新建一个群组，名称为 group1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# groupadd group1</span><br><span class="line">[root@www ~]# grep group1 /etc/group /etc/gshadow</span><br><span class="line">/etc/group:group1:x:702:</span><br><span class="line">/etc/gshadow:group1:!::</span><br><span class="line"># 群组的 GID 也是会由 500 以上最大 GID+1 来决定！</span><br></pre></td></tr></table></figure></p><h5 id="2、修改群组：groupmod"><a href="#2、修改群组：groupmod" class="headerlink" title="2、修改群组：groupmod"></a>2、修改群组：groupmod</h5><p>跟 usermod 类似的，这个指令仅是在进行 group 相关参数的修改而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# groupmod [-g gid] [-n group_name] 群组名</span><br><span class="line">选项与参数：</span><br><span class="line">    -g ：修改既有的 GID 数字；</span><br><span class="line">    -n ：修改既有的组名</span><br></pre></td></tr></table></figure></p><p>范例一：将刚刚上个指令建立的 group1 名称改为 mygroup ， GID 为 201<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# groupmod -g 201 -n mygroup group1</span><br><span class="line">[root@www ~]# grep mygroup /etc/group /etc/gshadow</span><br><span class="line">/etc/group:mygroup:x:201:</span><br><span class="line">/etc/gshadow:mygroup:!::</span><br></pre></td></tr></table></figure></p><h5 id="3、删除群组：groupdel"><a href="#3、删除群组：groupdel" class="headerlink" title="3、删除群组：groupdel"></a>3、删除群组：groupdel</h5><p><code>[root@www ~]# groupdel [groupname]</code><br>范例一：将刚刚的 mygroup 删除！<br><code>[root@www ~]# groupdel mygroup</code><br>范例二：若要删除 ben1 这个群组的话？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# groupdel ben1</span><br><span class="line">groupdel: cannot remove user&apos;s primary group.</span><br></pre></td></tr></table></figure></p><p>为什么 mygroup 可以删除，但是 ben1 就不能删除呢？原因很简单，【有某个账号 (/etc/passwd)的 initial group 使用该群组！】如果查阅一下，你会发现在 /etc/passwd 内的 vbird1 第四栏的 GID 就是 /etc/group 内的 ben1 那个群组的 GID ，所以，无法删除！否则 ben1 这个用户登入系统后，就会找不到 GID ，那可是会造成很大的麻烦！那么如果硬要要删除 ben1 这个群组呢？你【必须要确认 /etc/passwd 内的账号没有任何人使用该群组作为 initial group 】才行。你可以：</p><ul><li>修改 ben1 的 GID ，或者是：</li><li>删除 ben1 这个使用者。</li></ul><h4 id="用户的身份切换"><a href="#用户的身份切换" class="headerlink" title="用户的身份切换"></a>用户的身份切换</h4><p>在 Linux 系统当中要作身份的变换？这是为啥？可能有底下几个原因！</p><blockquote><p><strong>使用一般账号：系统平日操作的好习惯</strong><br>事实上，为了安全的缘故，一些老人家都会建议你，尽量以一般身份使用者来操作 Linux 的日常作业！等到需要设定系统环境时，才变换身份成为 root 来进行系统管理，相对比较安全！避免作错一些严重的指令，例如恐怖的【 rm -rf / 】(千万作不得！)<br><strong>用较低权限启动系统服务</strong><br>相对于系统安全，有的时候，我们必须要以某些系统账号来进行程序的执行。举例来说，Linux 主机上面的一套软件，名称为 apache ，我们可以额外建立一个名为 apache 的用户来启动 apache 软件，如此一来，如果这个程序被攻破，至少系统还不至于就损毁了！<br><strong>软件本身的限制</strong><br>在远古时代的 telnet 程序中，该程序默认是不许使用 root 的身份登入的，telnet 会判断登入者的 UID，若 UID 为 0 的话，那就直接拒绝登入了。所以，你只能使用一般使用者来登入 Linux 服务器。此外，ssh 也可以设定拒绝 root 登入！那如果你有系统设定需求该如何是好？就变换身份！</p></blockquote><p>由于上述考虑，所以我们都是使用一般账号登入系统的，等有需要进行系统维护或软件更新时才转为 root 的身份来动作。那如何让一般使用者转变身份成为 root 呢？主要有两种方式：</p><ul><li>以【 su - 】直接将身份变成 root 即可，但是这个指令即需要 root 的密码，也就是说，如果你要以 su 变成 root 的话，你的一般使用者就必须要有 root 的密码才行；</li><li>以【 sudo 指令 】执行 root 的指令串，由于 sudo 需要事先设定妥当，且 sudo 需要输入用户自己的密码，因此多人共管同一部主机时，sudo 要比 su 来的好！至少 root 密码不会流出去！</li></ul><h5 id="1、su"><a href="#1、su" class="headerlink" title="1、su"></a>1、su</h5><p>su 是最简单的身份切换指令了，他可以进行任何身份的切换！方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# su [-lm] [-c 指令] [username]</span><br><span class="line">选项与参数：</span><br><span class="line">    - ：单纯使用 - 如【 su - 】代表使用 login-shell 的变量档案读取方式来登入系统；</span><br><span class="line">    若使用者名称没有加上去，则代表切换为 root 的身份。</span><br><span class="line">    -l ：与 - 类似，但后面需要加欲切换的使用者账号！也是 login-shell 的方式。</span><br><span class="line">    -m ：-m 与 -p 是一样的，表示【使用目前的环境设定，而不读取新使用者的配置文件】</span><br><span class="line">    -c ：仅进行一次指令，所以 -c 后面可以加上指令！</span><br></pre></td></tr></table></figure></p><h5 id="2、sudo"><a href="#2、sudo" class="headerlink" title="2、sudo"></a>2、sudo</h5><p>相对于 su 需要了解新切换的用户密码 (常常是需要 root 的密码)，sudo 的执行则仅需要自己的密码即可！甚至可以设定不需要密码即可执行 sudo ！由于 sudo 可以让你以其他用户的身份执行指令 (通常是使用 root 的身份来执行指令)，因此并非所有人都能够执行 sudo ，而是仅有规范到 /etc/sudoers 内的用户才能够执行 sudo 这个指令！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sudo [-b] [-u 新使用者账号]</span><br><span class="line">选项与参数：</span><br><span class="line">    -b ：将后续的指令放到背景中让系统自行执行，而不与目前的 shell 产生影响</span><br><span class="line">    -u ：后面可以接欲切换的使用者，若无此项则代表切换身份为 root 。</span><br></pre></td></tr></table></figure></p><p>范例一：你想要以 sshd 的身份在 /tmp 底下建立一个名为 mysshd 的档案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sudo -u sshd touch /tmp/mysshd</span><br><span class="line">[root@www ~]# ll /tmp/mysshd</span><br><span class="line">-rw-r--r-- 1 sshd sshd 0 Feb 28 17:42 /tmp/mysshd</span><br><span class="line"># 特别留意，这个档案的权限是由 sshd 所建立的情况！</span><br></pre></td></tr></table></figure></p><p>范例二：你想要以 ben1 的身份建立 ~ben/www 并于其中建立 index.html档案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sudo -u ben1 sh -c &quot;mkdir ~ben1/www; cd ben1/www; \</span><br><span class="line">&gt; echo &apos;This is index.html file&apos; &gt; index.html&quot;</span><br><span class="line">[root@www ~]# ll -a ~ben1/www</span><br><span class="line">drwxr-xr-x 2 ben1 ben1 4096 Feb 28 17:51 .</span><br><span class="line">drwx------ 5 ben1 ben1 4096 Feb 28 17:51 ..</span><br><span class="line">-rw-r--r-- 1 ben1 ben1 24 Feb 28 17:51 index.html</span><br><span class="line"># 要注意，建立者的身份是 ben1 ，且我们使用 sh -c &quot;一串指令&quot; 来执行的！</span><br></pre></td></tr></table></figure></p><p>sudo 可以让你切换身份来进行某项任务，例如上面的两个范例。</p><blockquote><p>sudo 的执行是这样的流程：<br>1.当用户执行 sudo 时，系统于 /etc/sudoers 档案中搜寻该使用者是否有执行 sudo 的权限；<br>2.若使用者具有可执行 sudo 的权限后，便让使用者【输入用户自己的密码】来确认；<br>3.若密码输入成功，便开始进行 sudo 后续接的指令(但 root 执行 sudo 时，不需要输入密码)；<br>4.若欲切换的身份与执行者身份相同，那也不需要输入密码。</p></blockquote><p>所以说，sudo 执行的重点是：【能否使用 sudo 必须要看 /etc/sudoers 的设定值，而可使用 sudo 者是透过输入用户自己的密码来执行后续的指令串】！由于能否使用与 /etc/sudoers 有关，所以我们当然要去编辑 sudoers 档案！不过，因为该档案的内容是有一定的规范的，因此直接使用 vi 去编辑是不好的。此时，我们得要透过 visudo 去修改这个档案！<br>（需要修改 /etc/sudoers 文件再查找……）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux是个多用户多任务的分时操作系统，所有一个要使用系统资源的用户都必须先向系统管理员申请一个账号，然后以这个账号的身份进入系统。用户的账号一方面能帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也能帮助用户组织文件，并为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和用户口令。用户在登录时键入正确的用户名和口令后，才能进入系统和自己的主目录。&lt;/p&gt;
&lt;p&gt;实现用户账号的管理，要完成的工作主要有如下几个方面：&lt;br&gt;a.用户账号的管理。&lt;br&gt;b.用户口令的管理。&lt;br&gt;c.用户组的管理。&lt;br&gt;d.用户切换&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 档案权限与目录配置</title>
    <link href="http://yoursite.com/2018/01/22/Linux-%E6%A1%A3%E6%A1%88%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/01/22/Linux-档案权限与目录配置/</id>
    <published>2018-01-22T08:01:07.000Z</published>
    <updated>2018-01-22T08:13:45.923Z</updated>
    
    <content type="html"><![CDATA[<p>Linux最优秀的地方之一，就在于他的多人多任务环境。而为了让各个使用者具有较保密的档案数据，因此档案的权限管理就变的很重要了。Linux一般将档案可存取的身份分为三个类别，分别是owner/group/others，且三种身份各有read/write/execute等权限<br><a id="more"></a></p><h4 id="1、身份类别"><a href="#1、身份类别" class="headerlink" title="1、身份类别"></a>1、身份类别</h4><ul><li>档案拥有者User</li><li>群组概念Group</li><li>其他人Others</li><li>root</li></ul><p>对应记录数据的档案：</p><ul><li>各种身份的相关信息：/etc/passwd</li><li>个人的密码：/etc/shadow</li><li>组名:/etc/group</li></ul><h4 id="2、权限的意义"><a href="#2、权限的意义" class="headerlink" title="2、权限的意义"></a>2、权限的意义</h4><h5 id="（1）对档案"><a href="#（1）对档案" class="headerlink" title="（1）对档案"></a>（1）对档案</h5><blockquote><p>r：可读取此档案的实际内容<br>w：可编辑，新增或者修改此档案的内容（但不含删除该档案）<br>x：该档案具有可以被系统执行的权限（Windows底下一个档案是否具有执行的能力是藉由【扩展名】来判断的，例如：.exe, .bat, .com等等，但是在Linux底下，我们的档案是否能被执行，则是藉由是否具有【x】这个权限来决定的）</p></blockquote><h5 id="（2）对目录"><a href="#（2）对目录" class="headerlink" title="（2）对目录"></a>（2）对目录</h5><blockquote><p>r：可读取目录结构列表，可查询该目录下的文件名数据，ls命令可显示它们<br>w：可新建目录与档案，可删除已存在的目录与档案，可更改他们的名字，可移动它们的位置<br>x：用户能进入该目录成为工作目录，cd命令可进入它，如果没有x权限，不能执行它下面的任何指令<br>（注：对目录的 w 权限要谨慎给予！）</p></blockquote><p>案例：账户为dmtai的家目录为/home/dmtai，账户dmtai对这个目录有rwx的权限。此目录下有一个档案叫the_root.data，它的权限为：<br><code>-rwx------ 1 root root 4356 Sep 19 20:20 the_root.data</code><br>分析：档案对于账户dmtai来说属于others身份，所以这个档案，dmtai无法读取，无法编辑也无法执行。但是dmtai对目录dmtai具有rwx的权限，也就是说dmtai账户可以删除这个档案！！</p><h4 id="3、Linux文件属性"><a href="#3、Linux文件属性" class="headerlink" title="3、Linux文件属性"></a>3、Linux文件属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br><span class="line">-rw-r--r--    1           root   root     42304        Sep 4 18:26     install.log</span><br><span class="line">[档案类型][档案类型权限][连接数][User][Group][档案容量bytes][档案最后修改时间][档案名]</span><br></pre></td></tr></table></figure><p>各栏详解如下：</p><blockquote><p>（1）第一栏表示档案类型权限：总共10个字符，<br>第一个字符代表这个档案类型：<br>　　① 正规档案[-]：纯文本档（ASCII），二进制文件（binary），数据格式文件（data）<br>　　② 目录[d]<br>　　③ 连结档[l]<br>　　④ 设备与装置文件<br>　　　　1）区块设备档[b]：可随机存取装置（比如硬盘，软盘）<br>　　　　2）字符设备文件[c]：一次性读取装置（比如键盘，鼠标）<br>　　⑤ 资料接口文件（sockets）[s]：称为数据接口文件<br>　　⑥ 数据输送文件（FIFO,pipe）[p]：特殊的文件类型<br>接下来9个字符3个一组，三组权限分别对应为：User，Group，Others<br>（2）第二栏表示有多少档名连结到此节点(i-node)：<br>每个档案都会将他的权限与属性记录到文件系统的 i-node 中，不过，我们使用的目录树却是使用文件名来记录，因此每个档名就会连结到一个 i-node ！这个属性记录的，就是有多少不同的档名连结到相同的一个 i-node 号码就是了。<br>（3）第三栏表示这个档案(或目录)的【拥有者账号】<br>（4）第四栏表示这个档案的所属群组<br>（5）第五栏为这个档案的容量大小，默认单位为bytes；<br>（6）第六栏为这个档案的建档日期或者是最近的修改日期：<br>（7）第七栏为这个档案的档名</p></blockquote><h4 id="4、如何改变文件属性与权限"><a href="#4、如何改变文件属性与权限" class="headerlink" title="4、如何改变文件属性与权限"></a>4、如何改变文件属性与权限</h4><h5 id="（1）chgrp：改变档案所属群组"><a href="#（1）chgrp：改变档案所属群组" class="headerlink" title="（1）chgrp：改变档案所属群组"></a>（1）chgrp：改变档案所属群组</h5><p>基本语法：chgrp [-R] groupname filename<br>选项与参数：<br>    -R：进行递归的持续变更，即目录下的所有档案，目录都更新为属于这个新群组<br>示例：<br>chgrp users install.log #users这个群组必须存在于/etc/group记录的群组里</p><h5 id="（2）chown：改变档案拥有者"><a href="#（2）chown：改变档案拥有者" class="headerlink" title="（2）chown：改变档案拥有者"></a>（2）chown：改变档案拥有者</h5><p>基本语法：chown [-R] ownername[:groupname] filename<br>选项与参数：<br>    -R：进行递归的持续变更，即目录下的所有档案，目录都更新为属于这个新拥有者<br>示例：<br>chown bin install.log #bin这个拥有者必须存在于/etc/passwd记录的拥有者里</p><p>#应用：cp 源档案 目标档案后，新的使用者可能无法使用copy后的档案，这时就需要赋予新档案一个新的拥有者和新的群组了。</p><h5 id="（3）chmod：改变档案的权限，SUID，SGID，SBIT等特性"><a href="#（3）chmod：改变档案的权限，SUID，SGID，SBIT等特性" class="headerlink" title="（3）chmod：改变档案的权限，SUID，SGID，SBIT等特性"></a>（3）chmod：改变档案的权限，SUID，SGID，SBIT等特性</h5><blockquote><p><strong>数字类型改变档案权限</strong><br>各权限的分数如下：r:4 w:2 x:1<br>每种身份各自的权限都是以上3个相加得到。如7=4+2+1,5=4+0+1（不可能是5=2+2+1哦，因为第一个肯定是r，数值要不是4要不是0，不能是2）<br>基本语法：chmod [-R] xyz 档案或目录<br>选项与参数：<br>　　xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。<br>　　-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有档案都会变更<br>示例：<br>chmod 770 .bashrc</p><p><strong>符号类型改变档案权限</strong><br><img src="/uploads/2018/01/linux_permission.JPG" alt=""><br>基本语法：chmod ugoa +-= rwx 档案或目录  #a代表all即全部的身份<br>示例：<br>chmod u=rwx,go=rx .bashrc   #u=rwx,go=rx是连在一起的，中间没有任何空格符</p></blockquote><h4 id="5、Linux-目录配置"><a href="#5、Linux-目录配置" class="headerlink" title="5、Linux 目录配置"></a>5、Linux 目录配置</h4><h5 id="（1）目录配置依据：FHS（Filesystem-Hierarchy-Standard）"><a href="#（1）目录配置依据：FHS（Filesystem-Hierarchy-Standard）" class="headerlink" title="（1）目录配置依据：FHS（Filesystem Hierarchy Standard）"></a>（1）目录配置依据：FHS（Filesystem Hierarchy Standard）</h5><p>亊实上，FHS 是根据过去的经验一直再持续的改版的，FHS 依据文件系统使用的频繁与否与是否允许使用者随意更动，而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样：<br><img src="/uploads/2018/01/linux_directory_fhs.JPG" alt=""></p><p>上表中的目录就是一些代表性的目录，该目录底下所放置的数据在底下会谈到，这里先略过不谈。我们要了解的是，什么是那四个类型？</p><ul><li>可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录；</li><li>不可分享的：自己机器上面运作的装置档案或者是与程序有关的 socket 档案等，由于仅与自身机器有关，所以当然就不适合分享给其他主机了。</li><li>不变的：有些数据是不会经常变动的，跟随着 distribution 而不变动。例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；</li><li>可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。</li></ul><p>亊实上，FHS 针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：</p><ul><li>/ (root, 根目录)：与开机系统有关；</li><li>/usr (unix software resource)：与软件安装/执行有关；</li><li>/var (variable)：与系统运作过程有关。</li></ul><h5 id="（2）根目录-的意义与内容："><a href="#（2）根目录-的意义与内容：" class="headerlink" title="（2）根目录 (/) 的意义与内容："></a>（2）根目录 (/) 的意义与内容：</h5><p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。由于系统开机时需要特定的开机软件、核心档案、开机所需程序、函式库等等档案数据，若系统出现错误时，根目录也必项要包含有能够修复文件系统的程序才行。因为根目录是这么的重要，所以在 FHS 的要求方面，他希服根目录不要放在非常大的分割槽内，因为越大的分割槽你会放入越多的数据，如此一来根目录所在分割槽就可能会有较多发生错误的机会。</p><p>因此 FHS 标准建议：根目录(/)所在分割槽应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分割槽内，保持根目录越小越好。如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。</p><p>有鉴于上述的说明，因此 FHS 定义出根目录(/)底下应该要有底下这些次目录的存在才好：<br><img src="/uploads/2018/01/linux_directory_root.JPG" alt=""></p><p>另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载，其他分割槽则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录，就不能够与根目录放到不同的分割槽去！那哪些目录不可与根目录分开呢？有底下这些：</p><ul><li>/etc：配置文件</li><li>/bin：重要执行档</li><li>/dev：所需要的装置档案</li><li>/lib：执行档所需的函式库不核心所需的模块</li><li>/sbin：重要的系统执行文件</li></ul><h5 id="（3）-usr-的意义与内容："><a href="#（3）-usr-的意义与内容：" class="headerlink" title="（3）/usr 的意义与内容："></a>（3）/usr 的意义与内容：</h5><p>依据FHS 的基本定义，/usr 里面放置的数据属于可分享的与不可变动的(shareable, static)，如果你知道如何透过网络进行分割槽的挂载，那么 /usr 确实可以分享给局域网络内的其他主机来使用！</p><p>很多读者都会误会 /usr 为 user 的缩写，其实 usr 是 Unix Software Resource 的缩写，也就是【Unix 操作系统软件资源】所放置的目录，而不是用户的数据！这点要注意。FHS 建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。</p><p>因为是所有系统默认的软件(distribution 发布者提供的软件)都会放置到 /usr 底下，因此这个目录有点类似 Windows 系统的【C:\Windows\ + C:\Program files\】这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说，/usr 的次目录建议有底下这些：<br><img src="/uploads/2018/01/linux_directory_usr.jpg" alt=""></p><p>（4）/var 的意义与内容：<br>如果 /usr 是安装时会占用较大硬盘容量的目录，那么 /var 就是在系统运作后才会渐渐占用硬盘容量的目录。因为 /var 目录主要针对常态性变动的档案，包括快取(cache)、登录档(log file)以及某些软件运作所产生的档案，包括程序档案(lock file, run file)，或者例如 MySQL 数据库的档案等等。常见的次目录有：<br><img src="/uploads/2018/01/linux_directory_var.JPG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux最优秀的地方之一，就在于他的多人多任务环境。而为了让各个使用者具有较保密的档案数据，因此档案的权限管理就变的很重要了。Linux一般将档案可存取的身份分为三个类别，分别是owner/group/others，且三种身份各有read/write/execute等权限&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>一些常用服务器概述</title>
    <link href="http://yoursite.com/2018/01/22/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2018/01/22/一些常用服务器概述/</id>
    <published>2018-01-22T05:28:35.000Z</published>
    <updated>2018-01-22T05:52:47.329Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NAT服务器"><a href="#NAT服务器" class="headerlink" title="NAT服务器"></a>NAT服务器</h4><p>NAT服务器可以说为是一个路由器的延伸服务器，简单地说，你可以称他为内部LAN主机的【IP分享器】。<br>NAT 的全名是 Network Address Translation，字面上的意思是【网络地址的转换】。下面来看一下，若内部 LAN 有任何一部主机想要传送封包出去时，那么这个封包要如何透过 Linux 主机而传送出去？他是这样的：</p><blockquote><p>1.先经过 NAT table 的 PREROUTING 链；<br>2.经由路由判断确定这个封包是要进入本机与否，若不进入本机，则下一步；<br>3.再经过 Filter table 的 FORWARD 链；<br>4.通过 NAT table 的 POSTROUTING 链，最后传送出去。</p></blockquote><a id="more"></a><p>NAT 服务器的重点就在于上面流程的第 1,4 步骤，也就是 NAT table 的两条重要的链：PREROUTING 与 POSTROUTING。那这两条链有什么重要的功能呢？重点在于修改 IP！但是这两条链修改的 IP 是不一样的！POSTROUTING 在修改来源 IP，PREROUTING 则在修改目标 IP。由于修改的 IP 不一样，所以就称为来源 NAT(Source NAT, SNAT) 及目标 NAT(Destination NAT, DNAT)。</p><h4 id="DHCP服务器"><a href="#DHCP服务器" class="headerlink" title="DHCP服务器"></a>DHCP服务器</h4><p>动态主机设定协议( Dynamic Host Configuration Protocol ，DHCP )，这个服务可以自动的分配 IP 与相关的网络参数给客户端，来提供客户端自动以服务器提供的参数来设定他们的网络。使用者只要将自己的笔电设定好经由 DHCP 协议来取得网络参数后，一插上网络线，马上就可以享受 Internet 的服务</p><p>要设定好一个网络的环境，使计算机可以顺利的连上 Internet ，那么你的计算机里面一定要有底下几个网络的参数才行，分别是：</p><blockquote><p>IP, netmask, network, broadcast, gateway, DNS IP</p></blockquote><p>其中，那个 IP, netmask, network, broadcast 与 gateway 都可以在 /etc/sysconfig/network-scripts/ifcfg-eth[0-n] 这档案里面设定，DNS 服务器的地址则是在 /etc/resolv.conf 里头设定。只要这几个项目设定正确，那么计算机应该就没问题的可以上网了！所以说，你家里面的 3, 4 部计算机，你都可以手动的来设定好你所需要的网络参数，然后利用 NAT 服务器的功能，就可以连上 Internet 了！</p><p>如果是管理的学生计算机大概有 100 部好了，那么你怎么设定好这 100 部的计算机呢？<br>这个就是 DHCP 服务器最主要的工作，就是自动的将网络参数正确的分配给网域中的每部计算机，让客户端的计算机可以在开机的时候就立即自动的设定好网络的参数值，这些参数值可以包括了 IP、netmask、network、gateway 与 DNS 的地址等等。如此一来，身为管理员的你，只要注意到这一部提供网络参数的主机有没有挂掉就好了，其他同学们的个人计算机！你想都不必想要怎么去帮忙！因为 DHCP 主机已经完全都帮你搞定了！</p><h4 id="SSH服务器"><a href="#SSH服务器" class="headerlink" title="SSH服务器"></a>SSH服务器</h4><p>什么是 SSH 呢？它有什么特异功能？简单的来说，SSH 是 Secure SHell protocol 的简写 (安全的壳程序协议)，它可以透过数据封包加密技术，将等待传输的封包加密后再传输到网络上，因此，数据讯息就比较安全！这个 SSH 可以用来取代较不安全的 finger, R Shell (rcp, rlogin, rsh等), talk 及 telnet 等联机模式。<br>特别注意：这个 SSH 协议，在预设的状态中，本身就提供两个服务器功能：</p><ol><li>一个就是类似 telnet 的远程联机使用 shell 的服务器，亦即是俗称的 ssh ；</li><li>另一个就是类似 FTP 服务的 sftp-server ！提供更安全的 FTP 服务。</li></ol><h4 id="FTP服务器"><a href="#FTP服务器" class="headerlink" title="FTP服务器"></a>FTP服务器</h4><p>FTP (File Transfer Protocol) 可说是最古老的协议之一了，主要是用来进行档案的传输，尤其是大型档案的传输使用 FTP 更是方便！不过，值得注意的是，使用 FTP 来传输时，其实是具有一定程度的【危险性】，因为数据在因特网上面是完全没有受到保护的【明码】传输方式！但是单纯的 FTP 服务还是有其必要性的，例如很多学校就有 FTP 服务器的架设需求等！想要使用更安全的 FTP 协议，就可选择 vsftpd（Very Secure FTP Daemon） 这个软件。</p><h4 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h4><p>目前的因特网世界使用的是所谓的 TCP/IP 协议，其中 IP 有第四版的 IPv4(32位) 及第六版的 IPv6(128位)。不过，这个 IPv4 为了人脑已经转成四组十进制的数字了，例如12.34.56.78 这样的格式。当我们利用 Internet 传送数据的时候，就需要这个 IP ，<br>否则数据封包就不知道要送到哪里。<br>那么四组十进制的数字仍然不容易记忆，因此就诞生了域名服务系统（Domain Name System,DNS），DNS 的作用就是将数字IP转换为人们容易记忆的域名。</p><h4 id="WWW服务器"><a href="#WWW服务器" class="headerlink" title="WWW服务器"></a>WWW服务器</h4><p>我们最常讲的【架站】其实就是架设一个 Web 网站！那么什么是 Web 呢？那就是全球信息广播的意思 (World Wide Web)，或者也可以称之为互连网吧！这个是我们目前的人类最常使用的 Internet 的协议之一！通常说的上网就是使用 WWW 来查询用户所需要的信息！目前在 Unix-Like 系统中的 WWW 服务器主要就是透过 Apache 这个服务器软件来达成的，而为了动态网站，于是 LAMP (Linux + Apache + MySQL + PHP) 就这么产生了。</p><h4 id="Proxy服务器"><a href="#Proxy服务器" class="headerlink" title="Proxy服务器"></a>Proxy服务器</h4><p>代理服务器 (Proxy Server) 的原理其实很简单！就是以类似代理人的身份去取得用户所需要的数据就是了！但是由于它的【代理】能力，使得我们可以透过代理服务器来达成防火墙功能与用户浏览数据的分析！此外，也可以藉由代理服务器来达成节省带宽的目的（代理服务器缓存常用数据），以及加快内部网络对因特网的 WWW 访问速度！总之，代理服务器对于企业来说，是一个非常不错的工具！<br>（注：代理服务器还能够再次代理服务器，即上层代理。上层代理服务器最大的功能就是分流，内部代理服务器( Local proxy )可代理多个外部上层代理服务器达到分流的目的，实现更快的速度访问 Internat 服务！）</p><p>同时，代理服务器可分为正向代理与反向代理。区分很简单，正向代理就是代理服务器位于客户端，用户主机都通过代理服务器访问 Internat 服务，可以实现内部主机的 IP 隐藏的功能，同时，也可起到 Local 端防火墙的目的。反向代理就是代理服务器位于服务端，所有的外部访问都通过代理服务器来向内部服务请求数据，可以实现过滤用户请求，缓存常用数据增加访问速度及降低带宽，隔绝用户直接访问服务器的请求，达到保护服务器的作用，实现服务端的防火墙功能。</p><h4 id="Postfix服务器"><a href="#Postfix服务器" class="headerlink" title="Postfix服务器"></a>Postfix服务器</h4><p>邮件服务器（Postfix Server）即发送与接受邮件的服务器。那么电子邮件是个啥玩意儿？它是利用网络传递一些信息给远程服务器的一种信息传递行为，虽然消息正文是很冷很硬的计算机文字，确实比不上手写信件来的让人觉得温暖，不过，对于具有时效性的信息来说，电子邮件可是起到很重要的作用啊！不管你在任何有网络的地方，连上 Internat 就可收取的你的信件。而相对的，也会有很多问题出现，例如夹带病毒的电子邮件问题、怪客透过邮件程序入侵、广告及垃圾信息和不实的信件内容等。因此，就出现了免费与付费一说，一般免费的即可满足个人使用，付费的可避免一些问题，免遭损失！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;NAT服务器&quot;&gt;&lt;a href=&quot;#NAT服务器&quot; class=&quot;headerlink&quot; title=&quot;NAT服务器&quot;&gt;&lt;/a&gt;NAT服务器&lt;/h4&gt;&lt;p&gt;NAT服务器可以说为是一个路由器的延伸服务器，简单地说，你可以称他为内部LAN主机的【IP分享器】。&lt;br&gt;NAT 的全名是 Network Address Translation，字面上的意思是【网络地址的转换】。下面来看一下，若内部 LAN 有任何一部主机想要传送封包出去时，那么这个封包要如何透过 Linux 主机而传送出去？他是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.先经过 NAT table 的 PREROUTING 链；&lt;br&gt;2.经由路由判断确定这个封包是要进入本机与否，若不进入本机，则下一步；&lt;br&gt;3.再经过 Filter table 的 FORWARD 链；&lt;br&gt;4.通过 NAT table 的 POSTROUTING 链，最后传送出去。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>网络安全之常见攻击方式及解决方案</title>
    <link href="http://yoursite.com/2018/01/18/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2018/01/18/网络安全之常见攻击方式及解决方案/</id>
    <published>2018-01-18T05:50:23.000Z</published>
    <updated>2018-01-18T06:59:09.807Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、网络封包联机进入主机的流程"><a href="#1、网络封包联机进入主机的流程" class="headerlink" title="1、网络封包联机进入主机的流程"></a>1、网络封包联机进入主机的流程</h4><p>当来自一个网络上的联机要求想进入我们的主机时，这个网络封包在进入主机实际取得数据的整个流程是如何？了解了整个流程之后，你才会发现：了解要如何保护你的主机安全！</p><p>我们要将该流程更细致化说明，因为，透过这个流程分析，你会知道为啥我们的主机需要进行过一些防护之后，系统才能够比较强壮。此外，了解了网络是双向的，那么就能知道服务器与客户端都得要有 IP:port 才能够让彼此的软件互相沟通。现在，假设你的主机是 WWW 服务器，透过底下的图标，网络封包如何进入你的主机呢？<br><a id="more"></a><br><img src="/uploads/2018/01/network_packet_translate.JPG" alt="" title="网络封包进入主机的流程"></p><h5 id="1-经过防火墙的分析："><a href="#1-经过防火墙的分析：" class="headerlink" title="1. 经过防火墙的分析："></a>1. 经过防火墙的分析：</h5><p>Linux 系统有内建的防火墙机制，因此你的联机能不能成功，得要先看防火墙的脸色才行。预设的 Linux 防火墙就有两个机制，这两个机制都是独立存在的，因此我们预设就有两层防火墙。第一层是封包过滤式的 netfilter 防火墙，另一个则是透过软件管控的 TCP Wrappers 防火墙。</p><ul><li><strong>封包过滤防火墙：IP Filtering 或 Net Filter</strong><br>   要进入 Linux 本机的封包都会先通过 Linux 核心的预设防火墙，就是称为 netfilter 的咚咚，简单的说，就是 iptables 这个软件所提供的防火墙功能。为何称为封包过滤呢？因为他主要是分析 TCP/IP 的封包表头来进行过滤的机制，主要分析的是 OSI 的第二、三、四层，主要控制的就是 MAC, IP, ICMP, TCP 与 UDP 的端口与状态 (SYN, ACK…) 等。</li><li><strong>第二层防火墙：TCP Wrappers</strong><br>   通过 netfilter 之后，网络封包会开始接受 Super daemons 及 TCP_Wrappers 的检验，那个是什么呢？说穿了就是 /etc/hosts.allow 与 /etc/hosts.deny 的配置文件功能。这个功能也是针对 TCP 的 Header 进行再次的分析，同样你可以设定一些机制来抵制某些 IP 或 Port ，好让来源端的封包被丢弃或通过检验；</li></ul><p>透过防火墙的管控，我们可以将大部分来自因特网的垃圾联机丢弃，只允许自己开放的服务的联机进入本机而已，可以达到最基础的安全防护。</p><h5 id="2-服务-daemon-的基本功能："><a href="#2-服务-daemon-的基本功能：" class="headerlink" title="2. 服务 (daemon) 的基本功能："></a>2. 服务 (daemon) 的基本功能：</h5><p>预设的防火墙是 Linux 的内建功能，但防火墙主要管理的是 MAC, IP, Port 等封包表头方面的信息，如果想要管控某些目录可以进入，某些目录则无法使用的功能，那就得要透过权限以及服务器软件提供的相关功能了。举例来说，你可以在 httpd.conf 这个配置文件之内规范某些 IP 来源不能使用 httpd 这个服务来取得主机的数据，那么即使该 IP 通过前面两层的过滤，他依旧无法取得主机的资源！但要注意的是，如果 httpd 这支程序本来就有问题的话，那么 client 端将可直接利用 httpd 软件的漏洞来入侵主机，而不需要取得主机内 root 的密码！因此，要小心这些启动在因特网上面的软件！</p><h5 id="3-SELinux-对网络服务的细部权限控制："><a href="#3-SELinux-对网络服务的细部权限控制：" class="headerlink" title="3. SELinux 对网络服务的细部权限控制："></a>3. SELinux 对网络服务的细部权限控制：</h5><p>为了避免前面一个步骤的权限误用，或者是程序有问题所造成的资安状况，因此 Security Enhanced Linux (安全强化 Linux) 就来发挥它的功能！简单的说，SELinux 可以针对网络服务的权限来设定一些规则 (policy) ，让程序能够进行的功能有限，因此即使使用者的档案权限设定错误，以及程序有问题时，该程序能够进行的动作还是被限制的，即使该程序使用的是 root 的权限也一样。举例来说，前一个步骤的 httpd 真的被 cracker 攻击而让对方取得 root 的使用权，由于 httpd 已经被 SELinux 控制在 /var/www/html 里面，且能够进行的功能已经被规范住了，因此 cracker 就无法使用该程序来进行系统的进一步破坏。</p><h5 id="4-使用主机的文件系统资源："><a href="#4-使用主机的文件系统资源：" class="headerlink" title="4. 使用主机的文件系统资源："></a>4. 使用主机的文件系统资源：</h5><p>想一想，你使用浏览器连接到 WWW 主机最主要的目的是什么？当然就是读取主机的 WWW 数据！那 WWW 资料是啥？就是档案啊！所以，最终网络封包其实是要向主机要求文件系统的数据。我们这里假设你要使用 httpd 这支程序来取得系统的档案数据，但 httpd 默认是由一个系统账号名称为 httpd 来启动的，所以：你的网页数据的权限当然就是要让 httpd 这支程序可以读取才行啊！如果你前面三关的设定都 OK ，最终权限设定错误，使用者依旧无法浏览你的网页数据的。</p><p>在这些步骤之外，我们的 Linux 以及相关的软件都可能还会支持登录文件记录的功能，为了记录历史历程，以方便管理者在未来的错误查询与入侵检测，良好的分析登录档的习惯是一定要建立的，尤其是 /var/log/messages 与 /var/log/secure 这些个档案！</p><h4 id="2、常见的攻击手法与相关保护"><a href="#2、常见的攻击手法与相关保护" class="headerlink" title="2、常见的攻击手法与相关保护"></a>2、常见的攻击手法与相关保护</h4><p>上面我们了解到数据传送到本机时所需要经过的几道防线，那个权限是最后的关键！那么 cracker 是如何透过上述的流程还能够攻击你的系统？底下就让我们来分析分析。</p><h5 id="1-取得帐户信息后猜密码"><a href="#1-取得帐户信息后猜密码" class="headerlink" title="1. 取得帐户信息后猜密码"></a>1. 取得帐户信息后猜密码</h5><p>由于很多人喜欢用自己的名字来作为帐户信息，因此账号的取得是很容易的！举例来说，如果你的朋友将你的 email address 不小心泄漏出去，例如：dmtsai@your.host.name 之类的样式，那么人家就会知道你有一部主机，名称为 your.host.name，且在这部主机上面会有一个使用者账号，账号名称为 dmtsai ，之后这个坏家伙再利用某些特殊软件例如 nmap 来进行你主机的 port scan 之后，他就可以开始透过你主机有启动的软件功能来猜你这个账号的密码了！</p><p>另外，如果你常常观察你的主机登录文件，那你也会发现如果你的主机有启动 Mail server 的服务时，你的登录档就会常常出现有些怪家伙尝试以一些奇怪的常见账号在试图猜测你的密码，举例来说像：admin, administrator, webmaster …. 之类的账号，尝试来窃取你的私人信件。如果你的主机真的有这类的账号，而且这类的账号还没有良好的密码规划，那就容易【中标】！所以我们常讲，系统账号千万不能给予密码，容易被猜密码啊！</p><p>这种猜密码的攻击方式算是最早期的入侵模式之一了，攻击者知道你的账号，或者是可以猜出来你的系统有哪些账号，欠缺的就只是密码而已，因此他会【很努力的】去猜你的密码，此时，你的密码规划如果不好的话，很容易就被攻击了！主机也很容易被绑架！所以，良好的密码设置习惯是很重要的。</p><p>不过这种攻击方式比较费时，因为目前很多软件都有密码输入次数的限制，如果连续输入三次密码还不能成功的登入，那该次联机就会被断线！所以，这种攻击方式日益减少，目前偶而还会看到就是！这也是初级 cracker 会使用的方式之一。那我们要如何保护呢？基本方式是这样的：</p><blockquote><p>（1）减少信息的曝光机会：例如不要将 Email Address 随意散布到 Internet 上头；<br>（2）建立较严格的密码设定规则：包括 /etc/shadow, /etc/login.defs 等档案的设定，如果主机够稳定且不会持续加入某些账号时，也可以考虑使用 chattr 来限制账号 (/etc/passwd, /etc/shadow) 的更改；<br>（3）完善的权限设定：由于这类的攻击方式会取得你的某个使用者账号的登入权限，所以如果你的系统权限设定得宜的话，那么攻击者也仅能取得一般使用者的权限而已，对于主机的伤害比较有限！所以说，权限设定是重要的；</p></blockquote><h5 id="2-利用系统的程序漏洞【主动】攻击"><a href="#2-利用系统的程序漏洞【主动】攻击" class="headerlink" title="2. 利用系统的程序漏洞【主动】攻击"></a>2. 利用系统的程序漏洞【主动】攻击</h5><p>由上图中的第二道防线，我们知道如果你的主机有开放网络服务时，就必须有启动某个网络软件！我们也知道由于软件可能撰写方式的问题，可能产生一些会被 cracker 乱用的臭虫程序代码，而这些臭虫程序代码由于产生问题的大小，有分为 bug (臭虫，可能会造成系统的不稳定或当机) 与 Security (安全问题，程序代码撰写方式会导致系统的权限被恶意者所掌握) 等问题。</p><p>当程序的问题被公布后，某些较高阶的 cracker 会尝试撰写一些针对这个漏洞的攻击程序代码，并且将这个程序代码放置到 cracker 常去的网站上面，藉以推销自己的【功力】….. 这种攻击模式是目前最常见的，因为攻击者只要拿到攻击程序就可以进行攻击了，【而且由攻击开始到取得你系统的 root 权限不需要猜密码，不需要两分钟，就能够立刻入侵成功】。但这个玩意儿本身是靠【你主机的程序漏洞】来攻击的，所以，如果你的主机随时保持在实时更新的阶段，或者是关闭大部分不需要的程序，那就可以躲避过这个问题。因此，你应该要这样做：</p><blockquote><p>（1）关闭不需要的网络服务：开的 port 越少，可以被入侵的管道越少，一部主机负责的服务越单纯，越容易找出问题点。<br>（2）随时保持更新：这个没话讲！一定要进行的！<br>（3）关闭不需要的软件功能：举例来说，后面会提到的远程登录服务器 SSH 可以提供 root 由远程登录，那么危险的事情当然要给他取消啊！</p></blockquote><h5 id="3-利用社交工程作欺骗"><a href="#3-利用社交工程作欺骗" class="headerlink" title="3. 利用社交工程作欺骗"></a>3. 利用社交工程作欺骗</h5><p>社交工程 (Social Engineering) 指的其实很简单，就是透过人与人的互动来达到【入侵】的目的！在大公司里面，或许你可能会接到这样的电话：【我是人事部门的经理，我的账号为何突然间不能登入了？你给我看一看，恩？干脆直接帮我另建一个账号，我告诉你我要的密码是….】。如果你一时不查给他账号密码的话，你的主机可能就这样被绑走了！</p><p>社交工程的欺骗方法多的是，包括使用【好心的 email 通知】、【警告信函】、【中奖单】等等，样样都是要欺骗你的账号密码，有的则利用钓鱼方式来欺骗你在某些恶意网站上面输入你的账号密码！举例来说，一般 email 会常常收到一些活动的信件，要我们用账号密码登录，这种的就要小心了！那要如何防范呢？</p><blockquote><p>（1）追踪对谈者：不要一味的相信对方，你必须要有信心的向上呈报，不要一时心慌就中了计！<br>（2）不要随意透露账号/密码等信息：最好不要随意在 Internet 上面填写这些数据，真的很危险！因为在 Internet 上面，你永远不知道对方屏幕前面坐着的是谁？</p></blockquote><h5 id="4-利用程序功能的【被动】攻击"><a href="#4-利用程序功能的【被动】攻击" class="headerlink" title="4. 利用程序功能的【被动】攻击"></a>4. 利用程序功能的【被动】攻击</h5><p>除了主动攻击之外，还有所谓的被动攻击！那就得要由【恶意网站】讲起了。如果你喜欢上网随意浏览的话，那么有的时候可能会连上一些广告很多，或者是一堆弹出式窗口的网站，这些网站有时还会很好心的【提供你很多好用的软件自动下载与安装】的功能，如果该网站是你所信任的，例如 Red Hat, CentOS, Windows 官网的话，那还好，如果是一个你也不清楚他是干嘛的网站，那你是否要同意下载安装该软件？</p><p>如果你常常在注意一些网络危机处理的相关新闻时，常会发现 Windows 的浏览器 (IE) 有问题，有时则是全部的浏览器 (Firefox, Netscap, IE…) 都会出现问题。那你会不会觉得奇怪啊，怎么【浏览器也会有问题？】这是因为很多浏览器会主动的答应对方 WWW 主机所提供的各项程序功能，或者是自动安装来自对方主机的软件，有时浏览器还可能由于程序发生安全问题，让对方 WWW 浏览器得以传送恶意代码给你的主机来执行！</p><p>那你又会想啊，那我干嘛浏览那样的恶意网站？总是会有些粗心大意的时候啊！如果你今天不小心收到一个 email ，里面告诉你你的银行账号有问题，希望你赶紧连上某个网页去看看你的账号是否在有问题的行列中，你会不会去？如果今天有个网络消息说某某网页在提供大特价商品，那你会不会去碰碰运气？都是可能的啊！不过，这也就很容易被对方攻击到了。</p><p>那如何防备啊？当然建立良好的习惯最重要了：</p><blockquote><p>（1）随时更新主机上的所有软件：如果你的浏览器是没有问题的，那对方传递恶意代码时，你的浏览器就不会执行，那自然安全的多了！<br>（2）较小化软件的功能：举例来说，让你的收信软件不要主动的下载文件，让你的浏览器在安装某些软件时，要通过你的确认后才安装，这样就比较容易克服一些小麻烦；<br>（3）不要连接到不明的主机：因为很多时候我们都用 google 在搜寻问题的解决之道，那你如何知道对方是否是骗人的？所以，前面两点防备还是很重要的！不要以为没有连接上恶意网站就不会有问题！</p></blockquote><h5 id="5-蠕虫或木马的-rootkit"><a href="#5-蠕虫或木马的-rootkit" class="headerlink" title="5. 蠕虫或木马的 rootkit"></a>5. 蠕虫或木马的 rootkit</h5><p>rootkit 意思是说可以取得 root 权限的一群工具组 (kit)，就如同前面主动攻击程序漏洞的方法一样，rootkit 主要也是透过主机的程序漏洞。不过，rootkit 也会透过社交工程让用户下载、安装 rootkit 软件，结果让 cracker 得以简单的绑架对方主机！</p><p>rootkit 除了可以透过上述的方法来进行入侵之外，rootkit 还会伪装或者是进行自我复制，举例来说，很多的 rootkit 本身就是蠕虫或者是木马间谍程序。蠕虫会让你的主机一直发送封包向外攻击，结果会让你的网络带宽被吃光光，例如 2001-2003年间的 Nimda, Code Red 等等；至于木马程序 (Trojan Horse) 则会对你的主机进行开启后门 (开一个 port 来让 cracker 主动的入侵)，结果就是….绑架、绑架、绑架！</p><p>rootkit 其实挺不好追踪的，因为很多时候他会主动的去修改系统观察的指令，包括 ls, top, netstat, ps, who, w, last, find 等等，让你看不到某些有问题的程序，如此一来，你的 Linux 主机就很容易被当成是跳板了！有够危险！那如何防备呢？</p><blockquote><p>（1）不要随意安装不明来源的档案或者是不明网站的档案数据；<br>（2）不要让系统有太多危险的指令：例如 SUID/SGID 的程序，这些程序很可能会造成用户不当的使用，而使得木马程序有机可趁！<br>（3）可以定时以 rkhunter 之类的软件来追查：有个网站提供 rootkit 程序的检查，你可以前往下载与分析你的主机：<a href="http://www.rootkit.nl/projects/rootkit_hunter.html" target="_blank" rel="noopener">http://www.rootkit.nl/projects/rootkit_hunter.html</a></p></blockquote><h5 id="6-DDoS-攻击法-Distributed-Denial-of-Service"><a href="#6-DDoS-攻击法-Distributed-Denial-of-Service" class="headerlink" title="6. DDoS 攻击法 (Distributed Denial of Service )"></a>6. DDoS 攻击法 (Distributed Denial of Service )</h5><p>这类型的攻击中文翻译成【分布式阻断服务攻击】，从字面上的意义来看，它就是透过分散在各地的僵尸计算机进行攻击，让你的系统所提供的服务被阻断而无法顺利的提供服务给其他用户的方式。这种攻击法也很要命，而且方法有很多，最常见的就属 SYN Flood 攻击法了！当主机接收了一个带有 SYN 的 TCP 封包之后，就会启用对方要求的 port 来等待联机，并且发送出回应封包(带有 SYN/ACK 旗目标 TCP 封包)，并等待 Client 端的再次回应。</p><p>好了，在这个步骤当中我们来想一想，如果 cient 端在发送出 SYN 的封包后，却将来自 Server 端的确认封包丢弃，那么你的 Server 端就会一直空等，而且 Client 端可以透过软件功能，在短短的时间内持续发送出这样的 SYN 封包，那么你的 Server 就会持续不断的发送确认封包，并且开启大量的 port 在空等！等到全部主机的 port 都启用完毕，那么…..系统就挂了！</p><p>更可怕的是，通常攻击主机的一方不会只有一部！他会透过 Internet 上面的僵尸网络 (已经成为跳板，但网站主却没有发现的主机) 发动全体攻击，让你的主机在短时间内就立刻挂点。这种 DDoS 的攻击手法比较类似【玉石俱焚】的手段，他不是入侵你的系统，而是要让你的系统无法正常提供服务！最常被用来作为阻断式服务的网络服务就是 WWW 了，因为 WWW 通常得对整个 Internet 开放服务。</p><p>这种攻击方法也是最难处理的，因为要嘛就得要系统核心有支持自动抵挡 DDoS 攻击的机制，要嘛你就得要自行撰写侦测软件来判断！而除非你的网站非常大，并且【得罪不少人】，否则应该不会被 DDoS 攻击！</p><h5 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h5><p>上面提到的都是比较常见的攻击方法，是还有一些高竿的攻击法，不过那些攻击法都需要有比较高的技术水准，例如 IP 欺骗。他可以欺骗你主机告知该封包来源是来自信任网域，而且透过封包传送的机制，由攻击的一方持续的主动发送出确认封包与工作指令。如此一来，你的主机可能就会误判该封包确实有响应，而且是来自内部的主机。</p><p>不过我们知道因特网是有路由的，而每部主机在每一个时段的 ACK 确认码都不相同，所以这个方式要达成可以登入，会比较麻烦，所以说，不太容易发生在我们这些小型主机上面！不过你还是得要注意一下说：</p><blockquote><p>（1）设定规则完善的防火墙：利用 Linux 内建的防火墙软件 iptables 建立较为完善的防火墙，可以防范部分的攻击行为；<br>（2）核心功能：这部份比较复杂，你必须要对系统核心有很深入的了解，才有办法设定好你的核心网络功能。<br>（3）登录文件与系统监控：你可以透过分析登录文件来了解系统的状况，另外也可以透过类似 MRTG 之类的监控软件来实时了解到系统是否有异常，这些工作都是很好的努力方向！</p></blockquote><h5 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h5><p>不要以为你的主机没有啥重要数据，被入侵或被植入木马也没有关系，因为我们的服务器通常会对内部来源的主机规范的较为宽松，如果你的主机在公司内部，但是不小心被入侵的话，那么贵公司的服务器是否就会暴露在危险的环境当中了？</p><p>所以啊，主机防护还是很重要的！不要小看了！提供几个方向给大家思考看看吧：</p><blockquote><p>1.建立完善的登入密码规则限制；<br>2.完善的主机权限设定；<br>3.设定自动升级与修补软件漏洞、及移除危险软件；<br>4.在每项系统服务的设定当中，强化安全设定的项目；<br>5.利用 iptables, TCP_Wrappers 强化网络防火墙；<br>6.利用主机监控软件如 MRTG 与 logwatch 来分析主机状况与登录文件；</p></blockquote><h4 id="3、关于Linux操作系统网络安全的有效应对措施"><a href="#3、关于Linux操作系统网络安全的有效应对措施" class="headerlink" title="3、关于Linux操作系统网络安全的有效应对措施"></a>3、关于Linux操作系统网络安全的有效应对措施</h4><h5 id="（1）安装防火墙、保证账号安全"><a href="#（1）安装防火墙、保证账号安全" class="headerlink" title="（1）安装防火墙、保证账号安全"></a>（1）安装防火墙、保证账号安全</h5><p>　　在互联网的安全防御中，每台计算机的系统都会自带安全防御工具及防火墙，其主要作用在于提供给用户审核、访问及防病毒等功能的同时，有效防止非授权用户进入系统，获取相关网络资源信息，并通过恰当地配置和调试，达到限制局域网非授权用户的访问，保护系统网络安全的目的，同时，对Linux操作系统用户账号的管理也要注意加密及口令安全的保护。 </p><h5 id="（2）关闭无需服务、重要文件需加密"><a href="#（2）关闭无需服务、重要文件需加密" class="headerlink" title="（2）关闭无需服务、重要文件需加密"></a>（2）关闭无需服务、重要文件需加密</h5><p>　　Linux操作系统本身会自带很多网络服务，其中有很多是没有必要的服务，用户应当及时进行关闭服务，以免因其造成严重的安全隐患，可以先找到 /etc/services 这个文件，对其所包含的网络服务数据库进行筛选，关闭不必要的网络服务，增强安全性。另外对系统中较为重要的文件也要进行加密，以保证一旦受到攻击可以不受到损害和窃取。 </p><h5 id="（3）阻止Ping命令请求以及Finger服务"><a href="#（3）阻止Ping命令请求以及Finger服务" class="headerlink" title="（3）阻止Ping命令请求以及Finger服务"></a>（3）阻止Ping命令请求以及Finger服务</h5><p>　　上文提到，TCP/IP 协议由于自身缺陷极易受到黑客的攻击，利用其漏洞从正常数据包通道传送数据，获得有利信息。如果将系统设置为Ping命令请求阻止，便会减少黑客攻击成功的几率，提高网络的安全性。而禁止Finger服务，删除 /usr/bin 中的Finger命令，则可以防止黑客借助此命令远程或本地侵入系统，得到用户的一切相关信息，进而保护了网络的安全。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、网络封包联机进入主机的流程&quot;&gt;&lt;a href=&quot;#1、网络封包联机进入主机的流程&quot; class=&quot;headerlink&quot; title=&quot;1、网络封包联机进入主机的流程&quot;&gt;&lt;/a&gt;1、网络封包联机进入主机的流程&lt;/h4&gt;&lt;p&gt;当来自一个网络上的联机要求想进入我们的主机时，这个网络封包在进入主机实际取得数据的整个流程是如何？了解了整个流程之后，你才会发现：了解要如何保护你的主机安全！&lt;/p&gt;
&lt;p&gt;我们要将该流程更细致化说明，因为，透过这个流程分析，你会知道为啥我们的主机需要进行过一些防护之后，系统才能够比较强壮。此外，了解了网络是双向的，那么就能知道服务器与客户端都得要有 IP:port 才能够让彼此的软件互相沟通。现在，假设你的主机是 WWW 服务器，透过底下的图标，网络封包如何进入你的主机呢？&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 防火墙的设定</title>
    <link href="http://yoursite.com/2018/01/17/Linux-%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E8%AE%BE%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/01/17/Linux-防火墙的设定/</id>
    <published>2018-01-17T10:45:23.000Z</published>
    <updated>2018-01-18T07:02:57.151Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Linux 的封包过滤软件：iptables</strong><br>《防火墙的认识》这篇文章说了那么多，主要就是说明防火墙是什么，能做什么，并且知道防火墙不是万能的。下面我说一下都使用什么来设定防火墙。<br>因为不同的核心使用的防火墙机制不同，且支持的软件指令与语法也不相同，所以在 Linux 上头设定属于你自己的防火墙规则时，要注意，先用 uname -r 追踪一下你的核心版本再说，目前大部分的核心都使用 kernel 2.6 版的核心，主要是使用 iptables 这个防火墙机制。<br><a id="more"></a></p><h4 id="1、封包进入流程：规则顺序的重要性！"><a href="#1、封包进入流程：规则顺序的重要性！" class="headerlink" title="1、封包进入流程：规则顺序的重要性！"></a>1、封包进入流程：规则顺序的重要性！</h4><p>因为 iptables 是利用封包过滤的机制，所以他会分析封包的表头数据。根据表头数据与定义的【规则】来决定该封包是否可以进入主机或者是被丢弃。意思就是说：【根据封包的分析资料”比对”你预先定义的规则内容，若封包数据与规则内容相同则进行动作，否则就继续下一条规则的比对！】重点在那个【比对与分析顺序】上。</p><p>举个简单的例子，假设我预先定义 10 条防火墙规则好了，那么当 Internet 来了一个封包想要进入我的主机，那么防火墙是如何分析这个封包的呢？我们以底下的图示来说明好了：<br><img src="/uploads/2018/01/network_iptables_rules.JPG" alt="" title="5-1 封包过滤的规则动作及分析流程"></p><p>当一个网络封包要进入到主机之前，会先经由 NetFilter 进行检查，那就是 iptables 的规则了。检查通过则接受 (ACCEPT) 进入本机取得资源，如果检查不通过，则可能予以丢弃 (DROP) ！上图中主要的目的在告知你：【规则是有顺序的】！例如当网络封包进入 Rule 1 的比对时，如果比对结果符合 Rule 1 ，此时这个网络封包就会进行 Action 1 的动作，而不会理会后续的 Rule 2, Rule 3…. 等规则的分析了。<br>而如果这个封包并不符合 Rule 1 的比对，那就会进入 Rule 2 的比对了！如此一个一个规则去进行比对就是了。那如果所有的规则都不符合怎办？此时就会透过预设动作 (封包政策, Policy) 来决定这个封包的去向。所以，当你的规则顺序排列错误时，就会产生很严重的错误了。（类比 rewrite 一致）</p><h4 id="2、iptables-的表格-table-与链-chain"><a href="#2、iptables-的表格-table-与链-chain" class="headerlink" title="2、iptables 的表格 (table) 与链 (chain)"></a>2、iptables 的表格 (table) 与链 (chain)</h4><p>事实上，上图 5-1 所列出的规则仅是 iptables 众多表格当中的一个链(chain) 而已。什么是链呢？这得由 iptables 的名称说起。为什么称为 ip”tables”呢？ 因为这个防火墙软件里面有多个表格 (table) ，每个表格都定义出自己的默认政策与规则，且每个表格的用途都不相同。我们可以使用底下这张图来稍微了解一下：<br><img src="/uploads/2018/01/network_iptables_chain.JPG" alt="" title="5-3 iptables 的表格与相关链示意图"></p><p>刚刚图 5-1 的规则内容仅只是图 5-3 内的某个 chain 而已！而预设的情况下，咱们 Linux 的 iptables 至少就有三个表格，包括管理本机进出的 filter 、管理后端主机 (防火墙内部的其他计算机) 的 nat 、管理特殊旗标使用的 mangle (较少使用) 。更有甚者，我们还可以自定义额外的链呢！真是很神奇吧！每个表格与其中链的用途分别是这样的：</p><ol><li><p>filter (过滤器)：主要跟进入 Linux 本机的封包有关，这个是预设的 table ！</p><ul><li>INPUT：主要与想要进入我们 Linux 本机的封包有关；</li><li>OUTPUT：主要与我们 Linux 本机所要送出的封包有关；</li><li>FORWARD：这个咚咚与 Linux 本机比较没有关系，他可以【转递封包】到后端的计算机中，与下列 nat table 相关性较高。</li></ul></li><li><p>nat (地址转换)：是 Network Address Translation 的缩写，这个表格主要在进行来源与目的之 IP 或 port 的转换，与 Linux 本机较无关，主要与 Linux 主机后的局域网络内计算机较有相关。</p><ul><li>PREROUTING：在进行路由判断之前所要进行的规则(DNAT/REDIRECT)</li><li>POSTROUTING：在进行路由判断之后所要进行的规则(SNAT/MASQUERADE)</li><li>OUTPUT：与发送出去的封包有关</li></ul></li><li><p>mangle (破坏者)：这个表格主要是与特殊的封包的路由旗标有关，早期仅有 PREROUTING 及 OUTPUT 链，不过从 kernel 2.4.18 之后加入了 INPUT 及FORWARD 链。由于这个表格与特殊旗标相关性较高，所以像咱们这种单纯的环境当中，较少使用 mangle 这个表格。</p></li></ol><p>所以说，如果你的 Linux 是作为 www 服务，那么要开放客户端对你的 www 要求有响应，就得要处理 filter 的 INPUT 链； 而如果你的 Linux 是作为局域网络的路由器，那么就得要分析 nat 的各个链以及 filter 的 FORWARD 链才行。</p><h4 id="3、本机的-iptables-语法"><a href="#3、本机的-iptables-语法" class="headerlink" title="3、本机的 iptables 语法"></a>3、本机的 iptables 语法</h4><p>防火墙的设定主要使用的就是 iptables 这个指令而已。而防火墙是系统管理员的主要任务之一，且对于系统的影响相当的大，因此【只能让 root 使用 iptables 】，不论是设定还是观察防火墙规则！</p><h5 id="（1）规则的观察与清除"><a href="#（1）规则的观察与清除" class="headerlink" title="（1）规则的观察与清除"></a>（1）规则的观察与清除</h5><p>如果你在安装的时候选择没有防火墙的话，那么 iptables 在一开始的时候应该是没有规则的，不过，可能因为你在安装的时候就有选择系统自动帮你建立防火墙机制，那系统就会有默认的防火墙规则了！无论如何，我们先来看看目前本机的防火墙规则是如何吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-t tables] [-L] [-nv]</span><br><span class="line">选项与参数：</span><br><span class="line">    -t ：后面接 table ，例如 nat 或 filter ，若省略此项目，则使用默认的filter</span><br><span class="line">    -L ：列出目前的 table 的规则</span><br><span class="line">    -n ：不进行 IP 与 HOSTNAME 的反查，显示讯息的速度会快很多！</span><br><span class="line">    -v ：列出更多的信息，包括通过该规则的封包总位数、相关的网络接口等</span><br><span class="line">范例：列出 filter table 三条链的规则</span><br><span class="line">[root@www ~]# iptables -L -n</span><br><span class="line">Chain INPUT (policy ACCEPT) &lt;==针对 INPUT 链，且预设政策为可接受</span><br><span class="line">target prot opt source destination &lt;==说明栏</span><br><span class="line">ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED</span><br><span class="line">&lt;==第 1 条规则</span><br><span class="line">ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0</span><br><span class="line">&lt;==第 2 条规则</span><br><span class="line">ACCEPT all -- 0.0.0.0/0 0.0.0.0/0</span><br><span class="line">&lt;==第 3 条规则</span><br><span class="line">ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22</span><br><span class="line">&lt;==以下类推</span><br><span class="line">REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited</span><br><span class="line">Chain FORWARD (policy ACCEPT) &lt;==针对 FORWARD 链，且预设政策为可接受</span><br><span class="line">target prot opt source destination</span><br><span class="line">REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited</span><br><span class="line">Chain OUTPUT (policy ACCEPT) &lt;==针对 OUTPUT 链，且预设政策为可接受</span><br><span class="line">target prot opt source destination</span><br></pre></td></tr></table></figure></p><blockquote><p>在上表中，每一个 Chain 就是前面提到的每个链。Chain 那一行里面括号的 policy 就是预设的政策，那底下的 target, prot 代表什么呢？<br><strong>target：</strong>代表进行的动作， ACCEPT 是放行，而 REJECT 则是拒绝，此外，尚有 DROP (丢弃) 的项目！<br><strong>prot：</strong>代表使用的封包协议，主要有 tcp, udp 及 icmp 三种封包格式；<br><strong>opt：</strong>额外的选项说明<br><strong>source ：</strong>代表此规则是针对哪个【来源 IP】进行限制？<br><strong>destination ：</strong>代表此规则是针对哪个【目标 IP】进行限制？</p></blockquote><p>在输出结果中，第一个范例因为没有加上 -t 的选项，所以默认就是 filter 这个表格内的 INPUT, OUTPUT, FORWARD 三条链的规则啰。若针对单机来说，INPUT 与 FORWARD 算是比较重要的管制防火墙链，所以你可以发现最后一条规则的政策是 REJECT (拒绝)！虽然 INPUT 与 FORWARD 的政策是放行 (ACCEPT)，不过在最后一条规则就已经将全部的封包都拒绝了！</p><p>不过这个指令的观察只是作个格式化的查阅，要详细解释每个规则会比较不容易解析。举例来说，我们将 INPUT 的 5 条规则依据输出结果来说明一下，结果会变成：</p><blockquote><ol><li>只要是封包状态为 RELATED,ESTABLISHED 就予以接受</li><li>只要封包协议是 icmp 类型的，就予以放行</li><li>无论任何来源 (0.0.0.0/0) 且要去任何目标的封包，不论任何封包格式(prot 为 all)，通通都接受</li><li>只要是传给 port 22 的主动式联机 tcp 封包就接受</li><li>全部的封包信息通通拒绝</li></ol></blockquote><p>最有趣的应该是第 3 条规则了，怎么会所有的封包信息都予以接受？如果都接受的话，那么后续的规则根本就不会有用嘛！其实那条规则是仅针对每部主机都有的内部循环测试网络 (lo) 接口！如果没有列出接口，那么我们就很容易搞错。所以，近来建议使用 iptables-save 这个指令来观察防火墙规则！因为 iptables-save 会列出完整的防火墙规则，只是并没有规格化输出而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables-save [-t table]</span><br><span class="line">选项与参数：</span><br><span class="line">-t ：可以仅针对某些表格来输出，例如仅针对 nat 或 filter 等等</span><br><span class="line">[root@www ~]# iptables-save</span><br><span class="line"># Generated by iptables-save v1.4.7 on Fri Jul 22 15:51:52 2011</span><br><span class="line">*filter &lt;==星号开头的指的是表格，这里为 filter</span><br><span class="line">:INPUT ACCEPT [0:0] &lt;==冒号开头的指的是链，三条内建的链</span><br><span class="line">:FORWARD ACCEPT [0:0] &lt;==三条内建链的政策都是 ACCEPT 啰！</span><br><span class="line">:OUTPUT ACCEPT [680:100461]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT &lt;==针对 INPUT的规则</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT &lt;==这条很重要！针对本机内部接口开放！</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited &lt;==针对FORWARD 的规则</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure></p><p>由上面的输出来看，有底线且内容含有 lo 的那条规则当中，【 -i lo 】指的就是由 lo 适配卡进来的封包！这样看就清楚多了！因为有写到接口的关系啊！不像之前的 <code>iptables -L -n</code>！既然这个规则不是我们想要的，那该如何修改规则呢？建议，先删除规则再慢慢建立各个需要的规则！那如何清除规则？这样做就对了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-t tables] [-FXZ]</span><br><span class="line">选项与参数：</span><br><span class="line">-F ：清除所有的已订定的规则；</span><br><span class="line">-X ：杀掉所有使用者 &quot;自定义&quot; 的 chain (应该说的是 tables ）；</span><br><span class="line">-Z ：将所有的 chain 的计数与流量统计都归零</span><br><span class="line">范例：清除本机防火墙 (filter) 的所有规则</span><br><span class="line">[root@www ~]# iptables -F</span><br><span class="line">[root@www ~]# iptables -X</span><br><span class="line">[root@www ~]# iptables -Z</span><br></pre></td></tr></table></figure></p><p>由于这三个指令会将本机防火墙的所有规则都清除，但却不会改变预设政策 (policy) ，所以如果你不是在本机下达这三行指令时，很可能你会被自己挡在家门外 (若 INPUT设定为 DROP 时)！要小心啊！</p><h5 id="2）定义预设政策-policy"><a href="#2）定义预设政策-policy" class="headerlink" title="(2）定义预设政策 (policy)"></a>(2）定义预设政策 (policy)</h5><p>清除规则之后，再接下来就是要设定规则的政策！还记得政策指的是什么吗？【 当你的封包不在你设定的规则之内时，则该封包的通过与否，是以 Policy 的设定为准】，在本机方面的预设政策中，假设你对于内部的使用者有信心的话，那么 filter 内的 INPUT 链方面可以定义的比较严格一点，而 FORWARD 与 OUTPUT 则可以订定的松一些！通常都是将 INPUT 的 policy 定义为 DROP ，其他两个则定义为 ACCEPT。至于 nat table 则暂时先不理会他。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-t nat] -P [INPUT,OUTPUT,FORWARD] [ACCEPT,DROP]</span><br><span class="line">选项与参数：</span><br><span class="line">-P ：定义政策( Policy )。注意，这个 P 为大写啊！</span><br><span class="line">ACCEPT ：该封包可接受</span><br><span class="line">DROP ：该封包直接丢弃，不会让 client 端知道为何被丢弃。</span><br><span class="line">范例：将本机的 INPUT 设定为 DROP ，其他设定为 ACCEPT</span><br><span class="line">[root@www ~]# iptables -P INPUT DROP</span><br><span class="line">[root@www ~]# iptables -P OUTPUT ACCEPT</span><br><span class="line">[root@www ~]# iptables -P FORWARD ACCEPT</span><br><span class="line">[root@www ~]# iptables-save</span><br><span class="line"># Generated by iptables-save v1.4.7 on Fri Jul 22 15:56:34 2011</span><br><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">COMMIT</span><br><span class="line"># Completed on Fri Jul 22 15:56:34 2011</span><br><span class="line"># 由于 INPUT 设定为 DROP 而又尚未有任何规则，所以上面的输出结果显示：</span><br><span class="line"># 所有的封包都无法进入你的主机！是不通的防火墙设定！(网络联机是双向的)</span><br></pre></td></tr></table></figure></p><p>看到输出的结果了吧？INPUT 被修改了设定！其他的 nat table 三条链的预设政策设定也是一样的方式，例如：<code>【 iptables -t nat -P PREROUTING ACCEPT 】</code>就设定了 nat table 的 PREROUTING 链为可接受的意思！预设政策设定完毕后，来谈一谈关于各规则的封包基础比对设定吧。</p><h5 id="（3）封包的基础比对：IP-网域及接口装置"><a href="#（3）封包的基础比对：IP-网域及接口装置" class="headerlink" title="（3）封包的基础比对：IP, 网域及接口装置"></a>（3）封包的基础比对：IP, 网域及接口装置</h5><p>开始来进行防火墙规则的封包比对设定吧！既然是因特网，那么我们就由最基础的 IP, 网域及端口，亦即是 OSI 的第三层谈起，再来谈谈装置 (网络卡) 的限制等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-AI 链名] [-io 网络接口] [-p 协议] \</span><br><span class="line">&gt; [-s 来源IP/网域] [-d 目标IP/网域] -j [ACCEPT|DROP|REJECT|LOG]</span><br><span class="line">选项与参数：</span><br><span class="line">-AI 链名：针对某的链进行规则的 &quot;插入&quot; 或 &quot;累加&quot;</span><br><span class="line">  -A ：新增加一条规则，该规则增加在原本规则的最后面。例如原本已经有四条规则，</span><br><span class="line">       使用 -A 就可以加上第五条规则！</span><br><span class="line">  -I ：插入一条规则。如果没有指定此规则的顺序，默认是插入变成第一条规则。例如原本有四条规则，</span><br><span class="line">       使用 -I 则该规则变成第一条，而原本四条变成 2~5 号</span><br><span class="line">  链 ：有 INPUT, OUTPUT, FORWARD 等，此链名称又与 -io 有关，请看底下。</span><br><span class="line">-io 网络接口：设定封包进出的接口规范</span><br><span class="line">  -i ：封包所进入的那个网络接口，例如 eth0, lo 等接口。需与 INPUT 链配合；</span><br><span class="line">  -o ：封包所传出的那个网络接口，需与 OUTPUT 链配合；</span><br><span class="line">-p 协定：设定此规则适用于哪种封包格式</span><br><span class="line">  主要的封包格式有： tcp, udp, icmp 及 all 。</span><br><span class="line">-s 来源 IP/网域：设定此规则之封包的来源项目，可指定单纯的 IP 或包括网域，例如：</span><br><span class="line">  IP ：192.168.0.100</span><br><span class="line">  网域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。</span><br><span class="line">  若规范为『不许』时，则加上 ! 即可，例如：</span><br><span class="line">  -s ! 192.168.100.0/24 表示不许 192.168.100.0/24 之封包来源；</span><br><span class="line">-d 目标 IP/网域：同 -s ，只不过这里指的是目标的 IP 或网域。</span><br><span class="line">-j ：后面接动作，主要的动作有接受(ACCEPT)、丢弃(DROP)、拒绝(REJECT)及记录(LOG)</span><br></pre></td></tr></table></figure></p><p>iptables 的基本参数就如同上面所示的，仅只谈到 IP 、网域与装置等等的信息。至于 TCP, UDP 封包特有的端口 (port number) 与状态 (如 SYN 旗标)，下面谈论。</p><p><strong>示例：</strong><br>先让我们来看看最基础的几个规则，例如开放 lo 这个本机的接口以及某个 IP 来源吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">范例：设定 lo 成为受信任的装置，亦即进出 lo 的封包都予以接受</span><br><span class="line">[root@www ~]# iptables -A INPUT -i lo -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>仔细看上面并没有列出 -s, -d 等等的规则，这表示：不论封包来自何处或去到哪里，只要是来自 lo 这个界面，就予以接受！这个观念挺重要的，就是【没有指定的项目，则表示该项目完全接受】的意思！例如这个案例当中，关于 -s, -d…等等的参数没有规定时，就代表不论什么值都会被接受。</p><h5 id="4）TCP-UDP-的规则比对：针对端口设定"><a href="#4）TCP-UDP-的规则比对：针对端口设定" class="headerlink" title="(4）TCP, UDP 的规则比对：针对端口设定"></a>(4）TCP, UDP 的规则比对：针对端口设定</h5><p>在谈到 TCP 与 UDP 时，比较特殊的就是那个端口 (port)，在 TCP 方面则另外有所谓的联机封包状态，包括最常见的 SYN 主动联机的封包格式。那么如何针对这两种封包格式进行防火墙规则的设定呢？你可以这样看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables [-AI 链] [-io 网络接口] [-p tcp,udp] \</span><br><span class="line">&gt; [-s 来源IP/网域] [--sport 埠口范围] \</span><br><span class="line">&gt; [-d 目标IP/网域] [--dport 埠口范围] -j [ACCEPT|DROP|REJECT]</span><br><span class="line">选项与参数：</span><br><span class="line">--sport 埠口范围：限制来源的端口口号码，端口口号码可以是连续的，例如1024:65535</span><br><span class="line">--dport 埠口范围：限制目标的端口口号码。</span><br></pre></td></tr></table></figure></p><p>事实上就是多了那个 –sport 及 –dport 这两个玩意儿，重点在那个 port 上面！不过你得要特别注意，因为仅有 tcp 与 udp 封包具有端口，因此你想要使用 –dport,–sport 时，得要加上 -p tcp 或 -p udp 的参数才会成功！底下让我们来进行几个小测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">范例：想要联机进入本机 port 21 的封包都抵挡掉：</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p tcp --dport 21 -j DROP</span><br><span class="line">范例：想连到我这部主机的网络 (upd port 137,138 tcp port 139,445) 就放行</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p udp --dport 137:138 -j ACCEPT</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p tcp --dport 139 -j ACCEPT</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p tcp --dport 445 -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>除了端口之外，在 TCP 还有特殊的旗标啊！最常见的就是那个主动联机的 SYN 旗标了。我们在 iptables 里面还支持【 –syn 】的处理方式，我们以底下的例子来说明好了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">范例：将来自任何地方来源 port 1:1023 的主动联机到本机端的 1:1023 联机丢弃</span><br><span class="line">[root@www ~]# iptables -A INPUT -i eth0 -p tcp --sport 1:1023 \</span><br><span class="line">&gt; --dport 1:1023 --syn -j DROP</span><br></pre></td></tr></table></figure></p><p>一般来说，client 端启用的 port 都是大于 1024 以上的端口，而 server 端则是启用小于 1023 以下的端口在监听的。所以我们可以让来自远程的小于 1023 以下的端口数据的主动联机都给他丢弃！但不适用在 FTP 的主动联机中！</p><h5 id="（5）iptables-外挂模块：mac-与-state"><a href="#（5）iptables-外挂模块：mac-与-state" class="headerlink" title="（5）iptables 外挂模块：mac 与 state"></a>（5）iptables 外挂模块：mac 与 state</h5><p>在 kernel 2.2 以前使用 ipchains 管理防火墙时，通常会让系统管理员相当头痛！因为 ipchains 没有所谓的封包状态模块，因此我们必须要针对封包的进、出方向进行管控。举例来说，如果你想要联机到远程主机的 port 22 时，你必须要针对两条规则来设定：</p><ul><li>本机端的 1024:65535 到远程的 port 22 必须要放行 (OUTPUT 链)；</li><li>远程主机 port 22 到本机的 1024:65535 必须放行 (INPUT 链)；</li></ul><p>这会很麻烦！因为如果你要联机到 10 部主机的 port 22 时，假设 OUTPUT 为预设开启 (ACCEPT)， 你依旧需要填写十行规则，让那十部远程主机的 port 22 可以联机到你的本地端主机上。那如果开启全部的 port 22 呢？又担心某些恶意主机会主动以 port 22 联机到你的机器上！同样的道理，如果你要让本地端主机可以连到外部的 port 80 (WWW 服务)，那就更不得了！这就是网络联机是双向的一个很重要的概念！</p><p>好在我们的 iptables 免除了这个困扰！他可以透过一个状态模块来分析 【这个想要进入的封包是否为刚刚我发出去的响应？】如果是刚刚我发出去的响应，那么就可以予以接受放行！这样就不用管远程主机是否联机进来的问题了！那如何达到呢？看看底下的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# iptables -A INPUT [-m state] [--state 状态]</span><br><span class="line">选项与参数：</span><br><span class="line">-m ：一些 iptables 的外挂模块，主要常见的有：</span><br><span class="line">  state ：状态模块</span><br><span class="line">  mac ：网络卡硬件地址 (hardware address)</span><br><span class="line">--state ：一些封包的状态，主要有：</span><br><span class="line">  INVALID ：无效的封包，例如数据破损的封包状态</span><br><span class="line">  ESTABLISHED：已经联机成功的联机状态；</span><br><span class="line">  NEW ：想要新建立联机的封包状态；</span><br><span class="line">  RELATED ：这个最常用！表示这个封包是与我们主机发送出去的封包有关</span><br><span class="line">范例：只要已建立或相关封包就予以通过，只要是不合法封包就丢弃</span><br><span class="line">[root@www ~]# iptables -A INPUT -m state \</span><br><span class="line">&gt; --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">[root@www ~]# iptables -A INPUT -m state --state INVALID -j DROP</span><br></pre></td></tr></table></figure></p><p>如此一来，我们的 iptables 就会主动分析出该封包是否为响应状态，若是的话，就直接予以接受。这样一来你就不需要针对响应的封包来撰写个别的防火墙规则了！这真是太棒了！底下我们继续谈一下 iptables 的另一个外挂，那就是针对网卡来进行放行与防御：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">范例：针对局域网络内的 aa:bb:cc:dd:ee:ff 主机开放其联机</span><br><span class="line">[root@www ~]# iptables -A INPUT -m mac --mac-source aa:bb:cc:dd:ee:ff -j ACCEPT</span><br><span class="line">选项与参数：</span><br><span class="line">--mac-source ：就是来源主机的 MAC ！</span><br></pre></td></tr></table></figure></p><p>如果你的区网当中有某些网络高手，老是可以透过修改 IP 去尝试透过路由器往外跑，那你该怎么办？难道将整个区网拒绝？并不需要的，你可以透过之前谈到的 ARP 相关概念，去捉到那部主机的 MAC ，然后透过上头的这个机制，将该主机整个 DROP 掉即可。不管他改了什么 IP ，除非他知道你是用网卡的 MAC 来管理，否则他就是出不去！</p><h5 id="（6）超阳春客户端防火墙设计与防火墙规则储存"><a href="#（6）超阳春客户端防火墙设计与防火墙规则储存" class="headerlink" title="（6）超阳春客户端防火墙设计与防火墙规则储存"></a>（6）超阳春客户端防火墙设计与防火墙规则储存</h5><p>经过上述的本机 iptables 语法分析后，接下来我们来想想，如果站在客户端且不提供网络服务的 Linux 本机角色时， 你应该要如何设计你的防火墙呢？老实说，你只要分析过 CentOS 默认的防火墙规则就会知道了，理论上， 应该要有的规则如下：</p><ol><li>规则归零：清除所有已经存在的规则 (iptables -F…)</li><li>预设政策：除了 INPUT 这个自定义链设为 DROP 外，其他为预设 ACCEPT；</li><li>信任本机：由于 lo 对本机来说是相当重要的，因此 lo 必须设定为信任装置；</li><li>回应封包：让本机主动向外要求而响应的封包可以进入本机(ESTABLISHED,RELATED)</li><li>信任用户：这是非必要的，如果你想要让区网的来源可用你的主机资源时</li></ol><p>这就是最最阳春的防火墙，你可以透过第二步骤抵挡所有远程的来源封包，而透过第四步骤让你要求的远程主机响应封包可以进入， 加上让本机的 lo 这个内部循环装置可以放行，嘿嘿！一部 client 专用的防火墙规则就 OK 了！你可以在某个 script 上面这样做即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# vim bin/firewall.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin; export PATH</span><br><span class="line"># 1. 清除规则</span><br><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -Z</span><br><span class="line"># 2. 设定政策</span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"># 3~5. 制订各项规则</span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">#iptables -A INPUT -i eth0 -s 192.168.1.0/24 -j ACCEPT</span><br><span class="line"># 6. 写入防火墙规则配置文件</span><br><span class="line">/etc/init.d/iptables save</span><br><span class="line">[root@www ~]# sh bin/firewall.sh</span><br><span class="line">iptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]</span><br></pre></td></tr></table></figure></p><p>其实防火墙也是一个服务，你可以透过<code>【chkconfig --list iptables】</code>去察看就知道了。因此，你这次修改的各种设定想要在下次开机还保存，那就得要进行<code>【 /etc/init.d/iptables save 】</code>这个指令加参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Linux 的封包过滤软件：iptables&lt;/strong&gt;&lt;br&gt;《防火墙的认识》这篇文章说了那么多，主要就是说明防火墙是什么，能做什么，并且知道防火墙不是万能的。下面我说一下都使用什么来设定防火墙。&lt;br&gt;因为不同的核心使用的防火墙机制不同，且支持的软件指令与语法也不相同，所以在 Linux 上头设定属于你自己的防火墙规则时，要注意，先用 uname -r 追踪一下你的核心版本再说，目前大部分的核心都使用 kernel 2.6 版的核心，主要是使用 iptables 这个防火墙机制。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>Linux 防火墙的认识</title>
    <link href="http://yoursite.com/2018/01/17/Linux-%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2018/01/17/Linux-防火墙的认识/</id>
    <published>2018-01-17T10:45:06.000Z</published>
    <updated>2018-01-18T07:02:45.878Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、认识防火墙"><a href="#1、认识防火墙" class="headerlink" title="1、认识防火墙"></a>1、认识防火墙</h4><p>网络安全除了随时注意相关软件的漏洞以及网络上的安全通报之外，你最好能够依据自己的环境来订定防火墙机制！这样对于你的网络环境，会比较有保障一点！那么什么是防火墙呢？其实防火墙就是透过订定一些有顺序的规则，并管制进入到我们网域内的主机 (或者可以说是网域) 数据封包的一种机制！更广义的来说，只要能够分析与过滤进出我们管理之网域的封包数据，就可以称为防火墙。</p><p>防火墙又可以分为硬件防火墙与本机的软件防火墙。硬件防火墙是由厂商设计好的主机硬件，这部硬件防火墙内的操作系统主要以提供封包数据的过滤机制为主，并将其他不必要的功能拿掉。因为单纯作为防火墙功能而已，因此封包过滤的效率较佳。至于软件防火墙呢？那就是我们主要研究的方向！软件防火墙本身就是在保护系统网络安全的一套软件(或称为机制)，例如 Netfilter 与 TCP Wrappers 都可以称为软件防火墙。<br><a id="more"></a></p><h4 id="2、为何需要防火墙"><a href="#2、为何需要防火墙" class="headerlink" title="2、为何需要防火墙"></a>2、为何需要防火墙</h4><p>封包进入本机时，会通过防火墙、服务器软件程序、SELinux 与文件系统等。所以基本上，如果你的系统 </p><ul><li>(1)已经关闭不需要而且危险的服务； </li><li>(2)已经将整个系统的所有软件都保持在最新的状态； </li><li>(3)权限设定妥当且定时进行备份工作； </li><li>(4)已经教育用户具有良好的网络、系统操作习惯。 </li></ul><p>那么你的系统实际上已经颇为安全了！要不要架设防火墙？那就见仁见智了。</p><p>不过，毕竟网络世界是很复杂的，而 Linux 主机也不是一个简单的东西，说不定哪一天你在进行某个软件的测试时，主机突然间就启动了一个网络服务，如果你没有管制该服务的使用范围，那么该服务就等于对所有 Internet 开放，那就麻烦了！因为该服务可能可以允许任何人登入你的系统，那不是挺危险？</p><p>所以，防火墙能作什么呢？防火墙最大的功能就是帮助你【限制某些服务的存取来源】！举例来说： </p><ul><li>(1)你可以限制文件传输服务 (FTP) 只在子域内的主机才能够使用，而不对整个 Internet 开放； </li><li>(2)你可以限制整部 Linux 主机仅可以接受客户端的 WWW 要求，其他的服务都关闭； </li><li>(3)你还可以限制整部主机仅能主动对外联机。</li></ul><p>反过来说，若有客户端对我们主机发送主动联机的封包状态(TCP 封包的 SYN flag)就予以抵挡等等。这些就是最主要的防火墙功能了！</p><p>所以，防火墙最重要的任务就是在规划出：</p><ol><li>切割被信任(如子域)与不被信任(如 Internet)的网段；</li><li>划分出可提供 Internet 的服务与必须受保护的服务；</li><li>分析出可接受与不可接受的封包状态；</li></ol><p>当然，咱们 Linux 的 iptables 防火墙软件还可以进行更细部深入的 NAT(Network Address Translation) 的设定，并进行更弹性的 IP 封包伪装功能，不过，对于单一主机的防火墙来说，最简单的任务还是上面那三项就是了！所以，你需不需要防火墙呢？理论上，当然需要！而且你必须要知道【你的系统哪些数据与服务需要保护】，针对需要受保护的服务来设定防火墙的规则吧！底下我们先来谈一谈，那在Linux 上头常见的防火墙类型有哪些？</p><h4 id="3、Linux-系统上防火墙的主要类别"><a href="#3、Linux-系统上防火墙的主要类别" class="headerlink" title="3、Linux 系统上防火墙的主要类别"></a>3、Linux 系统上防火墙的主要类别</h4><p>基本上，依据防火墙管理的范围，我们可以将防火墙区分为网域型与单一主机型的控管。在单一主机型的控管方面，主要的防火墙有封包过滤型的 Netfilter 与依据服务软件程序作为分析的 TCP Wrappers 两种。若以区域型的防火墙而言，由于此类防火墙都是当作路由器角色，因此防火墙类型主要则有封包过滤的 Netfilter 与利用代理服务器 (proxy server) 进行存取代理的方式了。</p><h5 id="（1）Netfilter-封包过滤机制"><a href="#（1）Netfilter-封包过滤机制" class="headerlink" title="（1）Netfilter (封包过滤机制)"></a>（1）Netfilter (封包过滤机制)</h5><p>所谓的封包过滤，亦即是分析进入主机的网络封包，将封包的表头数据捉出来进行分析，以决定该联机为放行或抵挡的机制。由于这种方式可以直接分析封包表头数据，所以包括硬件地址(MAC), 软件地址 (IP), TCP, UDP, ICMP 等封包的信息都可以进行过滤分析的功能，因此用途非常的广泛。(其实主要分析的是OSI 七层协议的 2, 3, 4 层)</p><p>在 Linux 上面我们使用核心内建的 Netfilter 这个机制，而 Netfilter 提供了 iptables 这个软件来作为防火墙封包过滤的指令。由于 Netfilter 是核心内建的功能，因此他的效率非常的高！非常适合于一般小型环境的设定！Netfilter 利用一些封包过滤的规则设定，来定义出什么资料可以接收，什么资料需要剔除，以达到保护主机的目的！</p><h5 id="（2）TCP-Wrappers-程序控管"><a href="#（2）TCP-Wrappers-程序控管" class="headerlink" title="（2）TCP Wrappers (程序控管)"></a>（2）TCP Wrappers (程序控管)</h5><p>另一种抵挡封包进入的方法，为透过服务器程序的外挂 (tcpd) 来处置的！与封包过滤不同的是，这种机制主要是分析谁对某程序进行存取，然后透过规则去分析该服务器程序谁能够联机、谁不能联机。由于主要是透过分析服务器程序来控管，因此与启动的端口无关，只与程序的名称有关。举例来说，我们知道 FTP 可以启动在非正规的 port 21 进行监听，当你透过 Linux 内建的 TCP wrappers 限制 FTP 时，那么你只要知道 FTP 的软件名称 (vsftpd) ，然后对他作限制，则不管 FTP 启动在哪个端口，都会被该规则管理的。</p><h5 id="（3）Proxy-代理服务器"><a href="#（3）Proxy-代理服务器" class="headerlink" title="（3）Proxy (代理服务器)"></a>（3）Proxy (代理服务器)</h5><p>其实代理服务器是一种网络服务，它可以【代理】用户的需求，而代为前往服务器取得相关的资料。就有点像底下这个图示吧：<br><img src="/uploads/2018/01/17/network_proxy.JPG" alt="" title="Proxy Server 的运作原理简介"></p><p>以上图为例，当 Client 端想要前往 Internet 取得 Google 的数据时，他取得数据的流程是这样的：</p><blockquote><p>1.client 会向 proxy server 要求数据，请 proxy 帮忙处理；<br>2.proxy 可以分析使用者的 IP 来源是否合法？使用者想要去的 Google 服务器是否合法？如果这个 client 的要求都合法的话，那么 proxy 就会主动的帮忙 client 前往 Google 取得资料；<br>3.Google 所回传的数据是传给 proxy server 的，所以 Google 服务器上面看到的是 proxy server 的 IP；<br>4.最后 proxy 将 Google 回传的数据送给 client。</p></blockquote><p>这样了解了吗？没错，client 并没有直接连上 Internet ，所以在实线部分(步骤 1, 4)只要 Proxy 与 Client 可以联机就可以了！此时 client 甚至不需要拥有 public IP ！而当有人想要攻击 client 端的主机时，除非他能够攻破 Proxy server ，否则是无法与 client 联机的！<br>另外，一般 proxy 主机通常仅开放 port 80, 21, 20 等 WWW 与 FTP 的端口而已，而且通常 Proxy 就架设在路由器上面，因此可以完整的掌控局域网络内的对外联机！让你的 LAN 变的更安全啊！</p><h4 id="4、防火墙的使用限制"><a href="#4、防火墙的使用限制" class="headerlink" title="4、防火墙的使用限制"></a>4、防火墙的使用限制</h4><p>从前面的分析中，我们已经知道过封包滤式防火墙主要在分析 OSI 七层协议当中的 2, 3, 4 层，既然如此的话，Linux 的 Netfilter 机制到底可以做些什么事情呢？其实可以进行的分析工作主要有：</p><h5 id="（1）拒绝让-Internet-的封包进入主机的某些端口"><a href="#（1）拒绝让-Internet-的封包进入主机的某些端口" class="headerlink" title="（1）拒绝让 Internet 的封包进入主机的某些端口"></a>（1）拒绝让 Internet 的封包进入主机的某些端口</h5><p>这个应该不难了解。例如你的 port 21 这个 FTP 相关的端口，若只想要开放给内部网络的话，那么当 Internet 来的封包想要进入你的 port 21 时，就可以将该数据封包丢掉！因为我们可以分析的到该封包表头的端口号码！</p><h5 id="（2）拒绝让某些来源-IP-的封包进入"><a href="#（2）拒绝让某些来源-IP-的封包进入" class="headerlink" title="（2）拒绝让某些来源 IP 的封包进入"></a>（2）拒绝让某些来源 IP 的封包进入</h5><p>例如你已经发现某个 IP 主要都是来自攻击行为的主机，那么只要来自该 IP 的数据封包，就将他丢弃！这样也可以达到基础的安全！</p><h5 id="（3）拒绝让带有某些特殊旗标-flag-的封包进入"><a href="#（3）拒绝让带有某些特殊旗标-flag-的封包进入" class="headerlink" title="（3）拒绝让带有某些特殊旗标 (flag) 的封包进入"></a>（3）拒绝让带有某些特殊旗标 (flag) 的封包进入</h5><p>最常拒绝的就是带有 SYN 的主动联机的旗标了！只要一经发现，你就可以将该封包丢弃！（因为都是一些攻击封包，占着茅坑不拉屎！）</p><h5 id="（4）分析硬件地址-MAC-来决定联机与否"><a href="#（4）分析硬件地址-MAC-来决定联机与否" class="headerlink" title="（4）分析硬件地址 (MAC) 来决定联机与否"></a>（4）分析硬件地址 (MAC) 来决定联机与否</h5><p>如果你的局域网络里面有比较捣蛋的但是又具有比较高强的网络功力的高手时，如果你使用 IP 来抵挡他使用网络的权限，而他却懂得反正换一个 IP 就好了，都在同一个网域内！同样还是在搞破坏！！怎么办？没关系，我们可以死锁他的网络卡硬件地址啊！因为 MAC 是焊在网络卡上面的，所以你只要分析到该使用者所使用的 MAC 之后，可以利用防火墙将该 MAC 锁住，除非他能够一换再换他的网络卡来取得新的 MAC，否则换 IP 是没有用的！</p><p>虽然 Netfilter 防火墙已经可以做到这么多的事情，不过，还是有很多事情没有办法透过 Netfilter 来完成！什么？设定防火墙之后还不安全啊！那当然啦！谁说设定了防火墙之后你的系统就一定安全？防火墙虽然可以防止不受欢迎的封包进入我们的网络当中，不过，某些情况下，他并不能保证我们的网络一定就很安全。举几个例子来谈一谈：<br><strong>（1）防火墙并不能很有效的抵挡病毒或木马程序</strong><br>假设你已经开放了 WWW 的服务，那么你的 WWW 主机上面，防火墙一定得要将 WWW 服务的 port 开放给 Client 端登入才行吧！否则你的 WWW 主机设定了等于没有用对吧！也就是说，只要进入你的主机的封包是要求 WWW 数据的，就可以通过你的防火墙。那好了，【万一你的 WWW 服务器软件有漏洞，或者本身向你要求 WWW 服务的该封包就是病毒在侦测你的系统】时，你的防火墙可是一点办法也没有啊！因为本来设定的规则就是会让他通过。<br><strong>（2）防火墙对于来自内部 LAN 的攻击较无承受力</strong><br>一般来说，我们对于 LAN 里面的主机都没有什么防火墙的设定，因为是我们自己的 LAN ，所以当然就设定为信任网域了！不过，LAN 里面总是可能有些网络小白，虽然他们不是故意要搞破坏，但是他们就是不懂！所以就乱用网络。这个时候就很糟糕，因为防火墙对于内部的规则设定通常比较少，所以就容易造成内部员工对于网络误用或滥用的情况。</p><p>所以，在你的 Linux 主机实地上网之前，还是得先：</p><ul><li>（1）关闭几个不安全的服务；</li><li>（2）升级几个可能有问题的套件；</li><li>（3）架设好最起码的安全防护–防火墙–</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、认识防火墙&quot;&gt;&lt;a href=&quot;#1、认识防火墙&quot; class=&quot;headerlink&quot; title=&quot;1、认识防火墙&quot;&gt;&lt;/a&gt;1、认识防火墙&lt;/h4&gt;&lt;p&gt;网络安全除了随时注意相关软件的漏洞以及网络上的安全通报之外，你最好能够依据自己的环境来订定防火墙机制！这样对于你的网络环境，会比较有保障一点！那么什么是防火墙呢？其实防火墙就是透过订定一些有顺序的规则，并管制进入到我们网域内的主机 (或者可以说是网域) 数据封包的一种机制！更广义的来说，只要能够分析与过滤进出我们管理之网域的封包数据，就可以称为防火墙。&lt;/p&gt;
&lt;p&gt;防火墙又可以分为硬件防火墙与本机的软件防火墙。硬件防火墙是由厂商设计好的主机硬件，这部硬件防火墙内的操作系统主要以提供封包数据的过滤机制为主，并将其他不必要的功能拿掉。因为单纯作为防火墙功能而已，因此封包过滤的效率较佳。至于软件防火墙呢？那就是我们主要研究的方向！软件防火墙本身就是在保护系统网络安全的一套软件(或称为机制)，例如 Netfilter 与 TCP Wrappers 都可以称为软件防火墙。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>基础网络概念（三）</title>
    <link href="http://yoursite.com/2018/01/16/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/16/基础网络概念（三）/</id>
    <published>2018-01-16T10:33:33.000Z</published>
    <updated>2018-01-18T06:58:16.163Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、网络"><a href="#1、网络" class="headerlink" title="1、网络"></a>1、网络</h4><p>网络是由节点和连线构成，表示诸多对象及其相互联系。在数学上，网络是一种图，一般认为专指加权图。网络除了数学定义外，还有具体的物理含义，即网络是从某种相同类型的实际问题中抽象出来的模型。在计算机领域中，网络是信息传输、接收、共享的虚拟平台，通过它把各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络是人类发展史来最重要的发明，提高了科技和人类社会的发展。<br><a id="more"></a></p><h4 id="2、网络类型："><a href="#2、网络类型：" class="headerlink" title="2、网络类型："></a>2、网络类型：</h4><p><strong>地理位置：</strong></p><ul><li>1.局域网（LAN）：一般限定在较小的区域内，小于10km的范围，通常采用有线的方式连接起来。</li><li>2.城域网（MAN）：规模局限在一座城市的范围内，10～100km的区域。</li><li>3.广域网（WAN）：网络跨越国界、洲界，甚至全球范围。<br>局域网和广域网是网络的热点。局域网是组成其他两种类型网络的基础，城域网一般都加入了广域网。广域网的典型代表是internet网。</li><li>4.个人网：个人局域网就是在个人工作地方把属于个人使用的电子设备（如便携电脑等）用无线技术连接起来的网络，因此也常称为无线个人局域网WPAN，其范围大约在10m左右。</li></ul><p><strong>传输介质：</strong></p><ul><li>1.有线网：采用同轴电缆和双绞线来连接的计算机网络。</li><li>2.光纤网：光纤网也是有线网的一种，但由于其特殊性而单独列出，光纤网采用光导纤维作传输介质。光纤传输距离长，传输率高，可达数千兆bps，抗干扰性强，不会受到电子监听设备的监听，是高安全性网络的理想选择。</li><li>3.无线网：用电磁波作为载体来传输数据。</li></ul><h4 id="3、互联网"><a href="#3、互联网" class="headerlink" title="3、互联网"></a>3、互联网</h4><p>互联网（英语：Internet），又称网际网络，或音译因特网(Internet)、英特网，互联网始于1969年美国的阿帕网。是网络与网络之间所串连成的庞大网络，这些网络以一组通用的协议相连，形成逻辑上的单一巨大国际网络。通常internet泛指互联网，而Internet则特指因特网。这种将计算机网络互相联接在一起的方法可称作“网络互联”，在这基础上发展出覆盖全世界的全球性互联网络称互联网，即是互相连接一起的网络结构。互联网并不等同万维网，万维网只是一建基于超文本相互链接而成的全球性系统，且是互联网所能提供的服务其中之一。</p><p><strong>互联网运行原理：</strong><br>计算机网络是由许多计算机组成的，要实现网络的计算机之间传输数据，必须要做两件事，数据传输目的地址和保证数据迅速可靠传输的措施，这是因为数据在传输　过程中很容易丢失或传错，Internet使用一种专门的计算机语言(协议)，以保证数据安全、可靠地到达指定的目的地，这种语言分两部TCP(Transmission Control Protocol　传输控制协议)和 IP (Internet Protocol网间协议)sure网络营销理论。　TCP/IP协议的数据传输过程：TCP/IP协议所采用的通信方式是分组交换方式。所谓分组交换，简单说就是数据　在传输时分成若干段，每个数据段称为一个数据包，TCP/IP协议的基本传输单位是数据包，TCP/IP协议主要包括两个主要的协议，即TCP协议和IP协议，这两个协议可以　联合使用，也可以与其他协议联合使用，它们在数据传输过程中主要完成以下功能：</p><ul><li>1) 首先由TCP协议把数据分成若干数据包，给每个数据包写上序号，以便接收端把数据还原成原来的格式。</li><li>2) IP协议给每个数据包写上发送主机和接收主机的地址，一旦写上源地址和目的地址，数据包就可以在物理网上传送数据了。IP协议还具有利用路由算法进行路由选择的功能。</li><li>3) 这些数据包可以通过不同的传输途径(路由)进行传输，由于路径不同，加上其它的原因，可能出现顺序颠倒、数据丢失、数据失真甚至重复的现象。这些问题都由TCP协议来处理，它具有检查和处理错误的功能， 必要时还可以请求发送端重发。简言之，IP协议负责数据的传输，而TCP协议负责数据的可靠传输。</li></ul><h4 id="4、因特网"><a href="#4、因特网" class="headerlink" title="4、因特网"></a>4、因特网</h4><p>因特网（Internet）是一组全球信息资源的总汇。有一种粗略的说法，认为INTERNET是由于许多小的网络（子网）互联而成的一个逻辑网，每个子网中连接着若干台计算机（主机）。Internet以相互交流信息资源为目的，基于一些共同的协议，并通过许多路由器和公共互联网而成，它是一个信息资源和资源共享的集合。</p><h4 id="5、万维网"><a href="#5、万维网" class="headerlink" title="5、万维网"></a>5、万维网</h4><p>WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为Web。 分为Web客户端和Web服务器程序。 WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。 是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。<br>万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</p><h4 id="6、三者之间的关系"><a href="#6、三者之间的关系" class="headerlink" title="6、三者之间的关系"></a>6、三者之间的关系</h4><p>互联网、因特网、万维网三者的关系是：互联网包含因特网，因特网包含万维网，凡是能彼此通信的设备组成的网络就叫互联网。所以，即使仅有两台机器，不论用何种技术使其彼此通信，也叫互联网。国际标准的互联网写法是Internet，因特网是互联网的一种。因特网可不是仅有两台机器组成的互联网，它是由上千万台设备组成的互联网。因特网使用TCP/IP协议让不同的设备可以彼此通信。但使用TCP/IP协议的网络并不一定是因特网，一个局域网也可以使用TCP/IP协议。判断自己是否接入的是因特网，首先是看自己电脑是否安装了 TCP/IP协议，其次看是否拥有一个公网地址（所谓公网地址，就是所有私网地址以外的地址）。<br>因特网是基于TCP/IP协议实现的，TCP/IP协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如FTP、SMTP、HTTP。只要应用层使用的是HTTP协议，就称为万维网（World Wide Web）。之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为您的个人浏览器和百度网的服务器之间使用的是HTTP协议在交流。</p><h4 id="7、网络预测"><a href="#7、网络预测" class="headerlink" title="7、网络预测"></a>7、网络预测</h4><p><strong>（1）语义网</strong><br>SirTim Berners-Lee（Web创始者）关于语义网的观点成为人们的重要关注已经很长一段时间了。事实上，它已经象大白鲸一样神乎其神了。总之，语义网关涉到机器之间的对话，它使得网络更加智能化，或者像Berners-Lee描述的那样，计算机“在网络中分析所有的数据—内容，链接以及人机之间的交易处理”。在另一个时候，Berners-Lee把它描述为“为数据设计的似网程序”，如对信息再利用的设计。<br>就象Alex在《通往语义网》中写道，语义网的核心是创建可以处理事物意义的元数据来描述数据，一旦电脑装备上语义网，它将能解决复杂的语义优化问题。<br>因此，什么时候语义网时代才会到来呢？创建语义网的组件已经出现：RDF，OWL，这些微格式只是众多组件之一.但是，Alex在他文章中指出，将需要一些时间来诠释世界的信息，然后再以某种合适的方式来捕获个人信息。一些公司，如Hakia，Powerset以及Alex自己的adaptive blue都正在积极的实现语义网，因此，未来我们将变得关系更亲密，但是我们还得等上好些年，才能看到语义网的设想实现。<br><strong>（2）人工智能</strong><br>人工智能可能会是计算机历史中的一个终极目标。从1950年，阿兰图灵提出的测试机器如人机对话能力的图灵测试开始，人工智能就成为计算机科学家们的梦想，<br>在接下来的网络发展中，人工智能使得机器更加智能化。在这个意义上来看，这和语义网在某些方面有些相同。<br>1997年5月，IBM公司研制的深蓝（DEEP BLUE）计算机战胜了国际象棋大师卡斯帕洛夫（KASPAROV）。大家或许不会注意到，在一些地方计算机帮助人进行其它原来只属于人类的工作，计算机以它的高速和准确为人类发挥着它的作用。人工智能始终是计算机科学的前沿学科，计算机编程语言和其它计算机软件都因为有了人工智能的进展而得以存在。相信以后人工智能会给人类的生活带来更大的改变，期待下一次的变革“智能时代”的到来！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、网络&quot;&gt;&lt;a href=&quot;#1、网络&quot; class=&quot;headerlink&quot; title=&quot;1、网络&quot;&gt;&lt;/a&gt;1、网络&lt;/h4&gt;&lt;p&gt;网络是由节点和连线构成，表示诸多对象及其相互联系。在数学上，网络是一种图，一般认为专指加权图。网络除了数学定义外，还有具体的物理含义，即网络是从某种相同类型的实际问题中抽象出来的模型。在计算机领域中，网络是信息传输、接收、共享的虚拟平台，通过它把各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络是人类发展史来最重要的发明，提高了科技和人类社会的发展。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统服务之端口（port）</title>
    <link href="http://yoursite.com/2018/01/15/Linux-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%AB%AF%E5%8F%A3%EF%BC%88port%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/15/Linux-系统服务之端口（port）/</id>
    <published>2018-01-15T07:50:37.000Z</published>
    <updated>2018-01-18T07:02:32.243Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、什么是-port-？"><a href="#1、什么是-port-？" class="headerlink" title="1、什么是 port ？"></a>1、什么是 port ？</h4><p>当你启动一个网络服务，这个服务会依据 TCP/IP 的相关通讯协议启动一个端口在进行监听，那就是 TCP/UDP 封包的 port (端口)了。我们知道网络联机是双向的，服务器端得要启动一个监听的端口，客户端得要随机启动一个端口来接收响应的数据才行。那么服务器端的服务是否需要启动在固定的端口？客户端的端口是否又是固定的呢？我们将与 port 有关的资料给她汇整一下，如下：<br><a id="more"></a></p><blockquote><p><strong>1、服务器端启动的监听端口所对应的服务是固定的：</strong><br>例如 WWW 服务开启在 port 80 ，FTP 服务开启在 port 21，email 传送开启在port 25 等等，都是通讯协议上面的规范！<br><strong>2、客户端启动程序时，随机启动一个大于 1024 以上的端口：</strong><br>客户端启动的 port 是随机产生的，主要是开启在大于 1024 以上的端口。这个 port 也是由某些软件所产生的，例如浏览器、Filezilla 这个 FTP 客户端程序等等。<br><strong>3、一部服务器可以同时提供多种服务：</strong><br>所谓的【监听】是某个服务程序会一直常驻在内存当中，所以该程序启动的 port 就会一直存在。只要服务器软件激活的端口不同，那就不会造成冲突。当客户端连接到此服务器时，透过不同的端口，就可以取得不同的服务数据。所以，一部主机上面当然可以同时启动很多不同的服务！<br><strong>4、共 65536 个 port：</strong><br>由 TCP/UDP 表头数据中，就知道 port 占用 16 个位，因此一般主机会有 65536 个 port，而这些 port 又分成两个部分，以 port 1024 作区隔：</p><ul><li>只有 root 才能启动的保留的 port：<br>在小于 1024 的端口，都是需要以 root 的身份才能启动的，这些 port 主要是用于一些常见的通讯服务，在 Linux 系统下，常见的协议与 port 的对应是记录在 /etc/services 里面的。</li><li>大于 1024 用于 client 端的 port：<br>在大于 1024 以上的 port 主要是作为 client 端的软件激活的 port。</li></ul><p><strong>5、是否需要三向交握：</strong><br>建立可靠的联机服务需要使用到 TCP 协议，也就需要所谓的三向交握了，如果是非面向连接的服务，例如 DNS 与视讯系统，那只要使用 UDP 协议即可。<br><strong>6、通讯协议可以启用在非正规的 port：</strong><br>我们知道浏览器默认会连接到 WWW 主机的 port 80，那么你的 WWW 是否可以启动在非 80 的其他端口？当然可以！你可以透过 WWW 软件的设定功能将该软件使用的 port 启动在非正规的端口，只是如此一来，您的客户端要连接到你的主机时，就得要在浏览器的地方额外指定你所启用的非正规的端口才行。这个启动在非正规的端口功能，常常被用在一些所谓的地下网站！另外，某些软件默认就启动在大于 1024 以上的端口，如 MySQL 数据库软件就启动在 3306。<br><strong>7、所谓的 port 的安全性：</strong><br>事实上，没有所谓的 port 的安全性！因为【Port 的启用是由服务软件所造成的】，也就是说，真正影响网络安全的并不是 port ，而是启动 port 的那个软件 (程序)！或许你偶而会听到：【没有修补过漏洞的 bind 8.x 版，很容易被黑客所入侵，请尽快升级到 bind 9.x 以后版本】，所以，对安全真正有危害的是【某些不安全的服务】而不是【开了哪些 port 】才是！因此，没有必要的服务就将他关闭吧！尤其某些网络服务还会启动一些 port ！另外，那些已启动的软件也需要持续的保持更新！</p></blockquote><p>附属：一些系统必备的软件服务说明</p><table><thead><tr><th>服务名称</th><th>服务内容</th></tr></thead><tbody><tr><td>acpid</td><td>新版的电源管理模块，通常建议开启，不过，某些笔记本电脑可能不支持此项服务，那就得关闭</td></tr><tr><td>atd</td><td>在管理单一预约命令执行的服务，应该要启动的</td></tr><tr><td>crond</td><td>在管理工作排程的重要服务，请务必要启动啊！</td></tr><tr><td>haldaemon</td><td>作系统硬件变更侦测的服务，与 USB 设备关系很大</td></tr><tr><td>iptables</td><td>Linux 内建的防火墙软件，这个也可以启动！</td></tr><tr><td>network</td><td>这个重要了吧？要网络就要有他啊！</td></tr><tr><td>postfix</td><td>系统内部邮件传递服务，不要随便关闭他！</td></tr><tr><td>rsyslog</td><td>系统的登录文件记录，很重要的，务必启动啊！</td></tr><tr><td>sshd</td><td>这是系统默认会启动的，可以让你在远程以文字型态的终端机登入！</td></tr><tr><td>xinetd</td><td>就是那个 super daemon ！所以也要启动！</td></tr></tbody></table><p>上面列出的是主机需要的重点服务，请您不要关闭他！除非你知道作了之后会有什么后果。举例来说，你如果不需要管理电源，那么将 acpid 关闭也没有关系啊！如果你不需要提供远程联机功能，那么 sshd 也可以关闭啊！那其他你不知道的服务怎办？没关系，只要不是网络服务，你都可以保留他！如果是网络服务呢？那…建议你不知道的服务就先关闭他！</p><h4 id="2、端口的观察：netstat-nmap"><a href="#2、端口的观察：netstat-nmap" class="headerlink" title="2、端口的观察：netstat, nmap"></a>2、端口的观察：netstat, nmap</h4><p>现在，我们知道 port 是什么东西了，再来就是要来了解一下，我们的主机到底是开了多少的 port 呢？由于 port 的启动与服务有关，那么【服务】跟【 port 】对应的档案是哪一个？是【 /etc/services 】！而常用来观察 port 的则有底下两个程序：</p><ul><li>1.netstat：在本机上面以自己的程序监测自己的 port；</li><li>2.nmap：透过网络的侦测软件辅助，可侦测非本机上的其他网络主机，但有违法之虞（此处略过）。<br><em>（注：为什么使用nmap会违法？由于 nmap 的功能太强大了，所以很多 cracker 会直接以他来侦测别人的主机，这个时候就可能造成违法）</em></li></ul><p>底下我们来说一说 netstat 命令：<br>在做为服务器的 Linux 系统中，开启的网络服务越少越好！因为较少的服务可以较容易除错 (debug) 与了解安全漏洞，并可避免不必要的入侵管道！所以，这个时候请了解一下您的系统当中有没有哪些服务被开启了呢？要了解自己的系统当中的服务项目，最简便的方法就是使用 netstat ！这个东西不但简单，而且功能也是很不错的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">基本语法：</span><br><span class="line">[root@www ~]# netstat -[rn] &lt;==与路由有关的参数</span><br><span class="line">[root@www ~]# netstat -[antulpc] &lt;==与网络接口有关的参数</span><br><span class="line">选项与参数：</span><br><span class="line">与路由 (route) 有关的参数说明：</span><br><span class="line">    -r ：列出路由表(route table)，功能如同 route 这个指令；</span><br><span class="line">    -n ：不使用主机名与服务名称，使用 IP 与 port number ，如同 route -n与网络接口有关的参数：</span><br><span class="line">    -a ：列出所有的联机状态，包括 tcp/udp/unix socket 等；</span><br><span class="line">    -t ：仅列出 TCP 封包的联机；</span><br><span class="line">    -u ：仅列出 UDP 封包的联机；</span><br><span class="line">    -l ：仅列出有在 Listen (监听) 的服务之网络状态；</span><br><span class="line">    -p ：列出 PID 与 Program 的檔名；</span><br><span class="line">    -c ：可以设定几秒钟后自动更新一次，例如 -c 5 每五秒更新一次网络状态的显示；</span><br><span class="line">    （netstat -rn 与 route -n 是相同的。）</span><br></pre></td></tr></table></figure></p><blockquote><p>我们先来谈一谈关于网络联机状态的输出部分，他主要是分为底下几个大项：<br><strong>Proto：</strong>该联机的封包协议，主要为 TCP/UDP 等封包；<br><strong>Recv-Q：</strong>非由用户程序连接所复制而来的总 bytes 数；<br><strong>Send-Q：</strong>由远程主机所传送而来，但不具有 ACK 标志的总 bytes 数，意指主动联机 SYN 或其他标志的封包所占的 bytes 数；<br><strong>Local Address：</strong>本地端的地址，可以是 IP (-n 参数存在时)，也可以是完整的主机名。使用的格是就是『 IP:port 』只是 IP 的格式有 IPv4 及 IPv6 的差异。 如上所示，在 port 22 的接口中，使用的 :::22 就是针对 IPv6 的显示，事实上他就相同于 0.0.0.0:22 的意思。至于 port 25 仅针对 lo 接口开放，意指 Internet 基本上是无法连接到我本机的 25 埠口啦！<br><strong>Foreign Address：</strong>远程的主机 IP 与 port number<br><strong>stat：</strong>状态栏，主要的状态含有：</p><ul><li>ESTABLISED：已建立联机的状态；</li><li>SYN_SENT：发出主动联机 (SYN 标志) 的联机封包；</li><li>SYN_RECV：接收到一个要求联机的主动联机封包；</li><li>FIN_WAIT1：该插槽服务(socket)已中断，该联机正在断线当中；</li><li>FIN_WAIT2：该联机已挂断，但正在等待对方主机响应断线确认的封包；</li><li>TIME_WAIT：该联机已挂断，但 socket 还在网络上等待结束；</li><li>LISTEN：通常用在服务的监听 port ！可使用【 -l 】参数查阅。</li></ul></blockquote><p>基本上，我们常常谈到的 netstat 的功能，就是在观察网络的联机状态了，而网络联机状态中，又以观察【我目前开了多少的 port 在等待客户端的联机】以及 【目前我的网络联机状态中，有多少联机已建立或产生问题】最常见。<br>示例：<br><strong>1.列出在监听的网络服务：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# netstat -tunl</span><br><span class="line">ctive Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State</span><br><span class="line">tcp 0 0 0.0.0.0:111 0.0.0.0:* LISTEN</span><br><span class="line">tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN</span><br><span class="line">tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN</span><br><span class="line">....(底下省略)....</span><br></pre></td></tr></table></figure></p><p>上面说明了我的主机至少有启动 port 111, 22, 25 等，而且观察各联机接口，可发现 25 为 TCP 端口，但只针对 lo 内部循环测试网络提供服务，因特网是连不到该端口的。至于 port 22 则有提供因特网的联机功能。</p><p><strong>2.列出已联机的网络联机状态：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# netstat -tun</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State</span><br><span class="line">tcp 0 52 192.168.1.100:22 192.168.1.101:2162 ESTABLISHED</span><br></pre></td></tr></table></figure></p><p>从上面的数据来看，我的本地端服务器 (Local Address, 192.168.1.100) 目前仅有一条已建立的联机，那就是与 192.168.1.101 那部主机连接的联机，并且联机方向是由对方连接到我主机的 port 22 来取用我服务器的服务！</p><p><strong>3.删除已建立或在监听当中的联机：</strong><br>如果想要将已经建立，或者是正在监听当中的网络服务关闭的话，最简单的方法当然就是找出该联机的 PID，然后将他 kill 掉即可！例如下面的范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# netstat -tunp</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address Foreign Address State PID/P name</span><br><span class="line">tcp 0 52 192.168.1.100:22 192.168.1.101:2162 ESTABLISHED 1342/0</span><br></pre></td></tr></table></figure></p><p>如上面的范例，我们可以找出来该联机是由 sshd 这个程序来启用的，并且他的 PID 是 1342，希望你不要心急的用 killall 这个指令，否则容易删错人 (因为你的主机里面可能会有多个 sshd 存在)，应该要使用 kill 这个指令才对！<br><code>[root@www ~]# kill -9 1342</code></p><h4 id="3、端口与服务的启动-关闭及开机时状态设定"><a href="#3、端口与服务的启动-关闭及开机时状态设定" class="headerlink" title="3、端口与服务的启动/关闭及开机时状态设定"></a>3、端口与服务的启动/关闭及开机时状态设定</h4><p>其实 port 是由执行某些软件之后被软件激活的。所以要关闭某些 port 时，那就直接将某个程序给他关闭就是了！关闭的方法你当然可以使用 kill，不过这毕竟不是正统的解决之道，因为 kill 这个指令通常具有强制关闭某些程序的功能，但我们想要正常的关闭该程序！所以，就利用系统给我们的 script 来关闭就好了。一般传统的服务有哪几种类型？</p><p><strong>stand alone 与 super daemon</strong><br>    在一般正常的 Linux 系统环境下，服务的启动与管理主要有两种方式：</p><ol><li>Stand alone<br>顾名思义，stand alone 就是直接执行该服务的执行档，让该执行文件直接加载到内存当中运作，用这种方式来启动可以让该服务具有较快速响应的优点。一般来说，这种服务的启动 script 都会放置到 /etc/init.d/ 这个目录底下，所以你通常可以使用：【 /etc/init.d/sshd restart 】之类的方式来重新启动这种服务；</li><li>Super daemon<br>用一个超级服务作为总管，来统一管理某些特殊的服务。在 CentOS 6.x 里面使用的则是 xinetd 这个 super daemon ！这种方式启动的网络服务虽然在响应上速度会比较慢，不过，可以透过 super daemon 额外提供一些控管，例如控制何时启动、何时可以进行联机、那个 IP 可以连进来、是否允许同时联机等等。通常个别服务的配置文件放置在 /etc/xinetd.d/ 当中，但设定完毕后需要重新以【 /etc/init.d/xinetd restart 】重新来启动才行！</li></ol><blockquote><p>例题：<br>我们知道系统的 Telnet 服务通常是以 super daemon 来控管的，请您启动您系统的 telnet 试看看。<br>答：<br>1、要启动 telnet 首先必须要已经安装了 telnet 的服务器才行，所以请先以 rpm 查询看看是否有安装 telnet-server 呢？【rpm -qa | grep telnet-server】如果没有安装的话，请利用原版光盘来安装，或者使用【yum install telnet-server】安装一下先；<br>2、由于是 super daemon 控管，所以请编辑 /etc/xinetd.d/telnet 这个档案，将其中的【disable = yes】改成【disable = no】之后以【/etc/init.d/xinetd restart】重新启动 super daemon 吧！<br>3、利用 netstat -tnlp 察看是否有启动 port 23 呢？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、什么是-port-？&quot;&gt;&lt;a href=&quot;#1、什么是-port-？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是 port ？&quot;&gt;&lt;/a&gt;1、什么是 port ？&lt;/h4&gt;&lt;p&gt;当你启动一个网络服务，这个服务会依据 TCP/IP 的相关通讯协议启动一个端口在进行监听，那就是 TCP/UDP 封包的 port (端口)了。我们知道网络联机是双向的，服务器端得要启动一个监听的端口，客户端得要随机启动一个端口来接收响应的数据才行。那么服务器端的服务是否需要启动在固定的端口？客户端的端口是否又是固定的呢？我们将与 port 有关的资料给她汇整一下，如下：&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用网络指令</title>
    <link href="http://yoursite.com/2018/01/12/Linux-%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/01/12/Linux-常用网络指令/</id>
    <published>2018-01-12T09:41:44.000Z</published>
    <updated>2018-01-18T07:02:19.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、网络参数设定使用的指令"><a href="#一、网络参数设定使用的指令" class="headerlink" title="一、网络参数设定使用的指令"></a>一、网络参数设定使用的指令</h3><p><strong>ifconfig ：</strong>查询、设定网络卡与 IP 网域等相关参数；<br><strong>ifup, ifdown：</strong>这两个档案是 script，透过更简单的方式来启动网络接口；<br><strong>route ：</strong>查询、设定路由表 (route table)<br><strong>ip ：</strong>复合式的指令，可以直接修改上述提到的功能；<br><em>（先会使用 ifconfig, ifup , ifdown 与 route 即可，等以后有经验了之后，再继续回来玩 ip 这个好玩的指令。）</em><br><a id="more"></a></p><h4 id="1、手动-自动设定与启动-关闭-IP-参数：-ifconfig-ifup-ifdown"><a href="#1、手动-自动设定与启动-关闭-IP-参数：-ifconfig-ifup-ifdown" class="headerlink" title="1、手动/自动设定与启动/关闭 IP 参数： ifconfig, ifup, ifdown"></a>1、手动/自动设定与启动/关闭 IP 参数： ifconfig, ifup, ifdown</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法如下：</span><br><span class="line">[root@www ~]# ifconfig &#123;interface&#125; &#123;up|down&#125; &lt;== 观察与启动接口</span><br><span class="line">[root@www ~]# ifconfig interface &#123;options&#125; &lt;== 设定与修改接口</span><br><span class="line">选项与参数：</span><br><span class="line">interface：网络卡接口代号，包括 eth0, eth1, ppp0 等等</span><br><span class="line">options ：可以接的参数，包括如下：</span><br><span class="line">    up, down ：启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)</span><br><span class="line">    mtu ：可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)</span><br><span class="line">    netmask ：就是子屏蔽网络；</span><br><span class="line">    broadcast：就是广播地址啊！</span><br></pre></td></tr></table></figure><p><strong>范例一：观察所有的网络接口(直接输入 ifconfig)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr FA:16:3E:C9:BF:42  </span><br><span class="line">          inet addr:10.99.192.224  Bcast:10.99.192.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:671391959 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:629925596 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:202240418477 (188.3 GiB)  TX bytes:161760425688 (150.6 GiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:19514029692 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:19514029692 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:4097035202575 (3.7 TiB)  TX bytes:4097035202575 (3.7 TiB)</span><br></pre></td></tr></table></figure></p><blockquote><p>至于上表出现的各项数据是这样的(数据排列由上而下、由左而右)：<br><strong>eth0：</strong>就是网络卡的代号，也有 lo 这个 loopback ；<br><strong>HWaddr：</strong>就是网络卡的硬件地址，俗称的 MAC 是也；<br><strong>inet addr：</strong>IPv4 的 IP 地址，后续的 Bcast, Mask 分别代表的是 Broadcast 与 netmask！<br><strong>inet6 addr：</strong>是 IPv6 的版本的 IP ，我们没有使用，所以略过；<br><strong>MTU：</strong>最大传输单位<br><strong>RX：</strong>那一行代表的是网络由启动到目前为止的封包接收情况，packets 代表封包数、errors 代表封包发生错误的数量、dropped 代表封包由于有问题而遭丢弃的数量等等<br><strong>TX：</strong>与 RX 相反，为网络由启动到目前为止的传送情况；<br><strong>collisions：</strong>代表封包碰撞的情况，如果发生太多次，表示你的网络状况不太好；<br><strong>txqueuelen：</strong>代表用来传输数据的缓冲区的储存长度；<br><strong>RX bytes, TX bytes：</strong>总接收、发送字节总量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifup/ifdown 语法如下：</span><br><span class="line">[root@www ~]# ifup &#123;interface&#125;</span><br></pre></td></tr></table></figure><h4 id="2、路由修改：-route"><a href="#2、路由修改：-route" class="headerlink" title="2、路由修改： route"></a>2、路由修改： route</h4><p>主机之间一定要有路由才能够互通 TCP/IP 的协议，否则就无法进行联机啊！一般来说，只要有网络接口，该接口就会产生一个路由，所以我们安装的主机有一个 eth0 的接口，看起来就会是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# route [-nee]</span><br><span class="line">[root@www ~]# route add [-net|-host] [网域或主机] netmask [mask] [gw|dev]</span><br><span class="line">[root@www ~]# route del [-net|-host] [网域或主机] netmask [mask] [gw|dev]</span><br><span class="line">观察的参数：</span><br><span class="line">    -n ：不要使用通讯协议或主机名，直接使用 IP 或 port number；</span><br><span class="line">    -ee ：使用更详细的信息来显示</span><br><span class="line">增加 (add) 与删除 (del) 路由的相关参数：</span><br><span class="line">    -net ：表示后面接的路由为一个网域；</span><br><span class="line">    -host ：表示后面接的为连接到单部主机的路由；</span><br><span class="line">    netmask ：与网域有关，可以设定 netmask 决定网域的大小；</span><br><span class="line">    gw ：gateway 的简写，后续接的是 IP 的数值，与 dev 不同；</span><br><span class="line">    dev ：如果只是要指定由那一块网络卡联机出去，则使用这个设定，后面接 eth0 等</span><br></pre></td></tr></table></figure></p><p><strong>范例一：单纯的观察路由状态</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.99.192.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line">0.0.0.0         10.99.192.1     0.0.0.0         UG    0      0        0 eth0</span><br></pre></td></tr></table></figure></p><blockquote><p>上面的信息需要知道的一些参数含义：<br><strong>Destination, Genmask：</strong>这两个玩意儿就是分别是 network 与 netmask ！所以这两个咚咚就组合成为一个完整的网域！<br><strong>Gateway：</strong>该网域是通过哪个 gateway 连接出去的？如果显示 0.0.0.0 表示该路由是直接由本机传送，亦即可以透过局域网络的 MAC 直接传讯；如果有显示 IP 的话，表示该路由需要经过路由器 (通讯闸) 的帮忙才能够传送出去。<br><strong>Flags：</strong>总共有多个旗标，代表的意义如下：<br>    U (route is up)：该路由是启动的；<br>    H (target is a host)：目标是一部主机 (IP) 而非网域；<br>    G (use gateway)：需要透过外部的主机 (gateway) 来转递封包；<br>    R (reinstate route for dynamic routing)：使用动态路由时，恢复路由信息的旗标；<br>    D (dynamically installed by daemon or redirect)：已经由服务或转 port 功能设定为动态路由<br>    M (modified from routing daemon or redirect)：路由已经被修改了；<br>    ! (reject route)：这个路由将不会被接受(用来抵挡不安全的网域！)<br><strong>Iface：</strong>这个路由传递封包的接口。</p></blockquote><h4 id="3、网络参数综合指令：-ip"><a href="#3、网络参数综合指令：-ip" class="headerlink" title="3、网络参数综合指令： ip"></a>3、网络参数综合指令： ip</h4><p>他就是整合了 ifconfig 与 route 这两个指令。ifup 就是利用 ip 这个指令来达成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ip [option] [动作] [指令]</span><br><span class="line">选项与参数：</span><br><span class="line">option ：设定的参数，主要有：</span><br><span class="line">    -s ：显示出该装置的统计数据(statistics)，例如总接受封包数等；</span><br><span class="line">动作：亦即是可以针对哪些网络参数进行动作，包括有：</span><br><span class="line">    link ：关于装置 (device) 的相关设定，包括 MTU, MAC 地址等等</span><br><span class="line">    addr/address ：关于额外的 IP 协议，例如多 IP 的达成等等；</span><br><span class="line">    route ：与路由有关的相关设定</span><br></pre></td></tr></table></figure></p><p>由上面的语法我们可以知道， ip 除了可以设定一些基本的网络参数之外，还能够进行额外的 IP 协议，包括多 IP 的达成，真是太完美了！底下我们就分三个部分 (link,addr, route) 来介绍这个 ip 指令吧！</p><p><strong>（1）关于装置接口 (device) 的相关设定： ip link</strong><br>ip link 可以设定与装置 (device) 有关的相关参数，包括 MTU 以及该网络接口的 MAC 等等，当然也可以启动 (up) 或关闭 (down) 某个网络接口啦！整个语法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ip [-s] link show &lt;== 单纯的查阅该装置相关的信息</span><br><span class="line">[root@www ~]# ip link set [device] [动作与参数]</span><br><span class="line">选项与参数：</span><br><span class="line">show：仅显示出这个装置的相关内容，如果加上 -s 会显示更多统计数据；</span><br><span class="line">set ：可以开始设定项目， device 指的是 eth0, eth1 等等界面代号；</span><br><span class="line">动作与参数：包括有底下的这些动作：</span><br><span class="line">up|down ：启动 (up) 或关闭 (down) 某个接口，其他参数使用默认的以太网络；</span><br><span class="line">address ：如果这个装置可以更改 MAC 的话，用这个参数修改！</span><br><span class="line">name ：给予这个装置一个特殊的名字；</span><br><span class="line">mtu ：就是最大传输单元啊！</span><br><span class="line">（使用 ip link show 可以显示出整个装置接口的硬件相关信息，如上所示，包括网卡地址(MAC)、MTU 等等）</span><br></pre></td></tr></table></figure></p><p><strong>（2）关于额外的 IP 相关设定： ip address</strong><br>如果说 ip link 是与 OSI 七层协定 的第二层资料连阶层有关的话，那么 ip address (ip addr) 就是与第三层网络层有关的参数啦！ 主要是在设定与 IP 有关的各项参数，包括 netmask, broadcast 等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ip address show &lt;==就是查阅 IP 参数啊！</span><br><span class="line">[root@www ~]# ip address [add|del] [IP 参数] [dev 装置名] [相关参数]</span><br><span class="line">选项与参数：</span><br><span class="line">show ：单纯的显示出接口的 IP 信息啊；</span><br><span class="line">add|del ：进行相关参数的增加 (add) 或删除 (del) 设定，主要有：</span><br><span class="line">IP 参数：主要就是网域的设定，例如 192.168.100.100/24 之类的设定；</span><br><span class="line">dev ：这个 IP 参数所要设定的接口，例如 eth0, eth1 等等；</span><br><span class="line">相关参数：主要有底下这些：</span><br><span class="line">    broadcast：设定广播地址，如果设定值是 + 表示『让系统自动计算』</span><br><span class="line">    label ：亦即是这个装置的别名，例如 eth0:0 就是了！</span><br><span class="line">    scope ：这个界面的领域，通常是这几个大类：</span><br><span class="line">    global ：允许来自所有来源的联机；</span><br><span class="line">    site ：仅支持 IPv6 ，仅允许本主机的联机；</span><br><span class="line">    link ：仅允许本装置自我联机；</span><br><span class="line">    host ：仅允许本主机内部的联机；</span><br><span class="line">    所以当然是使用 global ！预设也是 global ！</span><br></pre></td></tr></table></figure></p><p><strong>（3）关于路由的相关设定： ip route</strong><br>这个项目当然就是路由的观察与设定啰！事实上， ip route 的功能几乎与 route 这个指令差不多，但是，他还可以进行额外的参数设计，例如 MTU 的规划等等，相当的强悍啊！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ip route show &lt;==单纯的显示出路由的设定而已</span><br><span class="line">[root@www ~]# ip route [add|del] [IP 或网域] [via gateway] [dev 装置]</span><br><span class="line">选项与参数：</span><br><span class="line">show ：单纯的显示出路由表，也可以使用 list ；</span><br><span class="line">add|del ：增加 (add) 或删除 (del) 路由的意思。</span><br><span class="line">IP 或网域：可使用 192.168.50.0/24 之类的网域或者是单纯的 IP ；</span><br><span class="line">via ：从那个 gateway 出去，不一定需要；</span><br><span class="line">dev ：由那个装置连出去，这就需要了！</span><br><span class="line">mtu ：可以额外的设定 MTU 的数值喔！</span><br></pre></td></tr></table></figure></p><h3 id="二、网络侦错与观察指令"><a href="#二、网络侦错与观察指令" class="headerlink" title="二、网络侦错与观察指令"></a>二、网络侦错与观察指令</h3><h4 id="1、两部主机两点沟通：-ping"><a href="#1、两部主机两点沟通：-ping" class="headerlink" title="1、两部主机两点沟通： ping"></a>1、两部主机两点沟通： ping</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ping [选项与参数] IP</span><br><span class="line">选项与参数：</span><br><span class="line">-c 数值：后面接的是执行 ping 的次数，例如 -c 5 ；</span><br><span class="line">-n ：在输出数据时不进行 IP 与主机名的反查，直接使用 IP 输出(速度较快)；</span><br><span class="line">-s 数值：发送出去的 ICMP 封包大小，预设为 56bytes，不过你可以放大此一数值；</span><br><span class="line">-t 数值：TTL 的数值，预设是 255，每经过一个节点就会少一；</span><br><span class="line">-W 数值：等待响应对方主机的秒数。</span><br><span class="line">-M [do|dont] ：主要在侦测网络的 MTU 数值大小，两个常见的项目是：</span><br><span class="line">    do ：代表传送一个 DF (Don&apos;t Fragment) 旗标，让封包不能重新拆包与打包；</span><br><span class="line">    dont：代表不要传送 DF 旗标，表示封包可以在其他主机上拆包与打包</span><br></pre></td></tr></table></figure><p><strong>范例一：侦测一下 172.24.170.43 这部 DNS 主机是否存在？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ping -c 3 172.24.170.43</span><br><span class="line">PING 172.24.170.43 (172.24.170.43) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.24.170.43: icmp_seq=0 ttl=118 time=3.59 ms</span><br><span class="line">64 bytes from 172.24.170.43: icmp_seq=1 ttl=118 time=4.41 ms</span><br><span class="line">64 bytes from 172.24.170.43: icmp_seq=2 ttl=118 time=2.48 ms</span><br><span class="line"></span><br><span class="line">--- 172.24.170.43 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</span><br><span class="line">rtt min/avg/max/mdev = 2.485/3.495/4.411/0.792 ms, pipe 2</span><br></pre></td></tr></table></figure></p><blockquote><p>ping 最简单的功能就是传送 ICMP 封包去要求对方主机回应是否存在于网络环境中，上面的响应消息当中，几个重要的项目是这样的：<br><strong>64 bytes：</strong>表示这次传送的 ICMP 封包大小为 64 bytes 这么大，这是默认值，在某些特殊场合中，例如要搜索整个网络内最大的 MTU 时，可以使用 -s 2000 之类的数值来取代；<br><strong>icmp_seq=0：</strong>ICMP 所侦测进行的次数，第一次编号为 0 ；<br><strong>ttl=118：</strong>TTL 与 IP 封包内的 TTL 是相同的，每经过一个带有 MAC 的节点 (node) 时，例如 router, bridge 时， TTL 就会减少一，预设的 TTL 为 255 ，你可以透过 -t 150 之类的方法来重新设定预设 TTL 数值；<br><strong>time=3.59 ms：</strong>响应时间，单位有 ms(0.001 秒)及 us(0.000001 秒)，一般来说，越小的响应时间，表示两部主机之间的网络联机越良好！<br><strong>（注：如果你忘记加上 -c 3 这样的规定侦测次数，那就得要使用 [ctrl]-c 将他结束掉了！）</strong></p></blockquote><p><strong>用 ping 追踪路径中的最大 MTU 数值</strong><br>现在我们知道网络卡的 MTU 修改可以透过 ifconfig 或者是 ip 等指令来达成，那么追踪整个网络传输的最大 MTU 时，又该如何查询？最简单的方法当然是透过 ping 传送一个大封包， 并且不许中继的路由器或 switch 将该封包重组，那就能够处理啦！没错！可以这样的：<br><strong>范例二：找出最大的 MTU 数值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ping -c 2 -s 1000 -M do 172.24.170.43</span><br><span class="line">PING 172.24.170.43 (172.24.170.43) 1000(1028) bytes of data.</span><br><span class="line">1008 bytes from 172.24.170.43: icmp_seq=0 ttl=118 time=2.28 ms</span><br><span class="line">1008 bytes from 172.24.170.43: icmp_seq=1 ttl=118 time=3.40 ms</span><br><span class="line"></span><br><span class="line">--- 172.24.170.43 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 2.281/2.843/3.406/0.565 ms, pipe 2</span><br><span class="line"># 如果有响应，那就是可以接受这个封包，如果无响应，那就表示这个 MTU 太大了。</span><br><span class="line">[root@www ~]# ping -c 2 -s 8000 -M do 172.24.170.43</span><br><span class="line">PING 172.24.170.43 (172.24.170.43) 8000(8028) bytes of data.</span><br><span class="line">From 10.99.192.224 icmp_seq=0 Frag needed and DF set (mtu = 1500)</span><br><span class="line">From 10.99.192.224 icmp_seq=0 Frag needed and DF set (mtu = 1500)</span><br><span class="line"></span><br><span class="line">--- 172.24.170.43 ping statistics ---</span><br><span class="line">0 packets transmitted, 0 received, +2 errors</span><br><span class="line"># 这个错误讯息是说，本地端的 MTU 才到 1500 而已，你要侦测 8000 的 MTU</span><br><span class="line"># 根本就是无法达成的！那要如何是好？用前一小节介绍的 ip link 来进行MTU 设定吧！</span><br></pre></td></tr></table></figure></p><p>不过，你需要知道的是，由于 IP 封包表头 (不含 options) 就已经占用了 20bytes ，再加上 ICMP 的表头有 8 bytes ，所以当然你在使用 -s size 的时候，那个封包的大小就得要先扣除 (20+8=28) 的大小了。 因此如果要使用 MTU 为 1500 时，就得要下达【 ping -s 1472 -M do xx.yy.zz.ip 】才行啊！</p><p>另外，由于本地端的网络卡 MTU 也会影响到侦测，所以如果想要侦测整个传输媒体的 MTU 数值，那么每个可以调整的主机就得要先使用 ifcofig 或 ip 先将 MTU 调大，然后再去进行侦测， 否则就会出现像上面提供的案例一样，可能会出现错误讯息的！</p><p>如果是要连上 Internet 的主机，注意不要随便调整 MTU ，因为我们无法知道 Internet 上面的每部机器能够支持的 MTU 到多大，因为……不是我们能够管的到的。</p><h4 id="2、两主机间各节点分析：-traceroute"><a href="#2、两主机间各节点分析：-traceroute" class="headerlink" title="2、两主机间各节点分析： traceroute"></a>2、两主机间各节点分析： traceroute</h4><p>我们前面谈到的指令大多数都是针对主机的网络参数设定所需要的，而 ping 是两部主机之间的回声与否判断， 那么有没有指令可以追踪两部主机之间通过的各个节点(node) 通讯状况的好坏呢？举例来说，如果我们联机到 yahoo 的速度比平常慢，你觉得是 (1)自己的网络环境有问题？ (2)还是外部的 Internet 有问题？如果是 (1)的话，我们当然需要检查自己的网络环境啊，看看是否又有谁中毒了？但如果是 Internet的问题呢？那只有『等等等』啊！ 判断是 (1) 还是 (2) 就得要使用 traceroute 这个指令！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# traceroute [选项与参数] IP</span><br><span class="line">选项与参数：</span><br><span class="line">-n ：可以不必进行主机的名称解析，单纯用 IP ，速度较快！</span><br><span class="line">-U ：使用 UDP 的 port 33434 来进行侦测，这是预设的侦测协议；</span><br><span class="line">-I ：使用 ICMP 的方式来进行侦测；</span><br><span class="line">-T ：使用 TCP 来进行侦测，一般使用 port 80 测试</span><br><span class="line">-w ：若对方主机在几秒钟内没有回声就宣告不治...预设是 5 秒</span><br><span class="line">-p 端号：若不想使用 UDP 与 TCP 的预设埠号来侦测，可在此改变埠号。</span><br><span class="line">-i 装置：用在比较复杂的环境，如果你的网络接口很多很复杂时，才会用到这个参数；</span><br><span class="line">    举例来说，你有两条 ADSL 可以连接到外部，那你的主机会有两个ppp，</span><br><span class="line">    你可以使用 -i 来选择是 ppp0 还是 ppp1 </span><br><span class="line">-g 路由：与 -i 的参数相仿，只是 -g 后面接的是 gateway 的 IP 就是了。</span><br></pre></td></tr></table></figure></p><p><strong>范例一：侦测本机到 yahoo 去的各节点联机状态</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# traceroute -n tw.yahoo.com</span><br><span class="line">traceroute to tw.yahoo.com (119.160.246.241), 30 hops max, 40 byte</span><br><span class="line">packets</span><br><span class="line">1 192.168.1.254 0.279 ms 0.156 ms 0.169 ms</span><br><span class="line">2 172.20.168.254 0.430 ms 0.513 ms 0.409 ms</span><br><span class="line">3 10.40.1.1 0.996 ms 0.890 ms 1.042 ms</span><br><span class="line">4 203.72.191.85 0.942 ms 0.969 ms 0.951 ms</span><br><span class="line">5 211.20.206.58 1.360 ms 1.379 ms 1.355 ms</span><br><span class="line">6 203.75.72.90 1.123 ms 0.988 ms 1.086 ms</span><br><span class="line">7 220.128.24.22 11.238 ms 11.179 ms 11.128 ms</span><br><span class="line">8 220.128.1.82 12.456 ms 12.327 ms 12.221 ms</span><br><span class="line">9 220.128.3.149 8.062 ms 8.058 ms 7.990 ms</span><br><span class="line">10 * * *</span><br><span class="line">11 119.160.240.1 10.688 ms 10.590 ms 119.160.240.3 10.047 ms</span><br><span class="line">12 * * * &lt;==可能有防火墙装置等情况发生所致</span><br></pre></td></tr></table></figure></p><p>这个 traceroute 挺有意思的，这个指令会针对欲连接的目的地之所有 node 进行 UDP 的逾时等待，例如上面的例子当中，由鸟哥的主机连接到 Yahoo 时，他会经过 12 个节点以上，traceroute 会主动的对这 12 个节点做 UDP 的回声等待，并侦测回复的时间，每节点侦测三次，最终回传像上头显示的结果。 你可以发现每个节点其实回复的时间大约在 50 ms 以内，算是还可以的 Internet 环境了。</p><p>比较特殊的算是第 10/12 个，会回传星号的，代表该 node 可能设有某些防护措施，让我们发送的封包信息被丢弃所致。 因为我们是直接透过路由器转递封包，并没有进入路由器去取得路由器的使用资源，所以某些路由器仅支持封包转递，并不会接受来自客户端的各项侦测啦！此时就会出现上述的问题。</p><h4 id="3、察看本机的网络联机与后门：-netstat"><a href="#3、察看本机的网络联机与后门：-netstat" class="headerlink" title="3、察看本机的网络联机与后门： netstat"></a>3、察看本机的网络联机与后门： netstat</h4><p>如果你觉得你的某个网络服务明明就启动了，但是就是无法造成联机的话，那么应该怎么办？首先你应该要查询一下自己的网络接口所监听的端口 (port) 来看看是否真的有启动，因为有时候屏幕上面显示的 [OK] 并不一定是 OK 啊！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# netstat -[rn] &lt;==与路由有关的参数</span><br><span class="line">[root@www ~]# netstat -[antulpc] &lt;==与网络接口有关的参数</span><br><span class="line">选项与参数：</span><br><span class="line">与路由 (route) 有关的参数说明：</span><br><span class="line">-r ：列出路由表(route table)，功能如同 route 这个指令；</span><br><span class="line">-n ：不使用主机名与服务名称，使用 IP 与 port number ，如同 route -n</span><br><span class="line">与网络接口有关的参数：</span><br><span class="line">-a ：列出所有的联机状态，包括 tcp/udp/unix socket 等；</span><br><span class="line">-t ：仅列出 TCP 封包的联机；</span><br><span class="line">-u ：仅列出 UDP 封包的联机；</span><br><span class="line">-l ：仅列出有在 Listen (监听) 的服务之网络状态；</span><br><span class="line">-p ：列出 PID 与 Program 的檔名；</span><br><span class="line">-c ：可以设定几秒钟后自动更新一次，例如 -c 5 每五秒更新一次网络状态的显示；</span><br><span class="line">（netstat -rn 与 route -n 是相同的。）</span><br></pre></td></tr></table></figure></p><blockquote><p>我们先来谈一谈关于网络联机状态的输出部分，他主要是分为底下几个大项：<br><strong>Proto：</strong>该联机的封包协议，主要为 TCP/UDP 等封包；<br><strong>Recv-Q：</strong>非由用户程序连接所复制而来的总 bytes 数；<br><strong>Send-Q：</strong>由远程主机所传送而来，但不具有 ACK 标志的总 bytes 数，意指主动联机 SYN 或其他标志的封包所占的 bytes 数；<br><strong>Local Address：</strong>本地端的地址，可以是 IP (-n 参数存在时)，也可以是完整的主机名。使用的格是就是『 IP:port 』只是 IP 的格式有 IPv4 及 IPv6 的差异。 如上所示，在 port 22 的接口中，使用的 :::22 就是针对 IPv6 的显示，事实上他就相同于 0.0.0.0:22 的意思。至于 port 25 仅针对 lo 接口开放，意指 Internet 基本上是无法连接到我本机的 25 埠口啦！<br><strong>Foreign Address：</strong>远程的主机 IP 与 port number<br><strong>stat：</strong>状态栏，主要的状态含有：<br>      ESTABLISED：已建立联机的状态；<br>      SYN_SENT：发出主动联机 (SYN 标志) 的联机封包；<br>      SYN_RECV：接收到一个要求联机的主动联机封包；<br>      FIN_WAIT1：该插槽服务(socket)已中断，该联机正在断线当中；<br>      FIN_WAIT2：该联机已挂断，但正在等待对方主机响应断线确认的封包；<br>      TIME_WAIT：该联机已挂断，但 socket 还在网络上等待结束；<br>      LISTEN：通常用在服务的监听 port ！可使用『 -l 』参数查阅。</p></blockquote><p>基本上，我们常常谈到的 netstat 的功能，就是在观察网络的联机状态了，而网络联机状态中，又以观察【我目前开了多少的 port 在等待客户端的联机】以及 【目前我的网络联机状态中，有多少联机已建立或产生问题】最常见。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、网络参数设定使用的指令&quot;&gt;&lt;a href=&quot;#一、网络参数设定使用的指令&quot; class=&quot;headerlink&quot; title=&quot;一、网络参数设定使用的指令&quot;&gt;&lt;/a&gt;一、网络参数设定使用的指令&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;ifconfig ：&lt;/strong&gt;查询、设定网络卡与 IP 网域等相关参数；&lt;br&gt;&lt;strong&gt;ifup, ifdown：&lt;/strong&gt;这两个档案是 script，透过更简单的方式来启动网络接口；&lt;br&gt;&lt;strong&gt;route ：&lt;/strong&gt;查询、设定路由表 (route table)&lt;br&gt;&lt;strong&gt;ip ：&lt;/strong&gt;复合式的指令，可以直接修改上述提到的功能；&lt;br&gt;&lt;em&gt;（先会使用 ifconfig, ifup , ifdown 与 route 即可，等以后有经验了之后，再继续回来玩 ip 这个好玩的指令。）&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>基础网络概念（二）</title>
    <link href="http://yoursite.com/2018/01/10/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/10/基础网络概念（二）/</id>
    <published>2018-01-10T10:42:25.000Z</published>
    <updated>2018-01-18T06:58:20.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、TCP-IP-的链结层相关协议"><a href="#一、TCP-IP-的链结层相关协议" class="headerlink" title="一、TCP/IP 的链结层相关协议"></a>一、TCP/IP 的链结层相关协议</h2><p>TCP/IP 最底层的链结层主要与硬件比较有关系，因此底下我们主要介绍一些 WAN 与 LAN 的硬件。同时会开始介绍那重要的 CSMA/CD 的以太网络协议，以及相关的硬件与 MAC 讯框格式等。<br><a id="more"></a></p><h3 id="（1）广域网使用的设备"><a href="#（1）广域网使用的设备" class="headerlink" title="（1）广域网使用的设备"></a>（1）广域网使用的设备</h3><p>广域网使用的设备价格较为低廉。不过广域网使用到的设备非常的多，一般用户通常会接触到的主要是 ADSL 调制解调器或者是光纤到大厦，以及第四台的 Cable 宽带等。在这里我们先介绍一些比较常见的设备，如果以后你有机会接触到其他设备，再请依据需求自行查阅相关书籍！</p><p><strong>1. 传统电话拨接：透过 ppp 协议</strong><br>早期网络大概都只能透过调制解调器加上电话线以及计算机的九针串行端口(以前接鼠标或游戏杆的插孔)，然后透过 Point-to-Point Protocol (PPP 协议)配合拨接程序来取得网络 IP 参数，这样就能够上网了。不过这样的速度非常慢，而且当电话拨接后， 就不能够讲电话了！因为 PPP 支持 TCP/IP, NetBEUI,IPX/SPX 等通讯协议，所以使用度非常广！<br><strong>2. 整合服务数字网络 (Integrated Services Digital Network, ISDN)</strong><br>也是利用现有的电话线路来达成网络联机的目的，只是联机的两端都需要有 ISDN 的调制解调器来提供联机功能。ISDN 的传输有多种通道可供使用，并且可以将多个信道整合应用，因此速度可以成倍成长。基本的 B 信道速度约为 64Kbps， 但如美国规格使用 23 个以上的通道来达成联机，此时速度可达1.5Mbps 左右。<br><strong>3. 非对称数位用路回路 (Asymmetric Digital Subscriber Line, ADSL)：透过 pppoe 协议</strong><br>也是透过电话线来拨接后取得 IP 的一个方法，只不过这个方式使用的是电话的高频部分，与一般讲电话的频率不同。 因此妳可以一边使用 ADSL 上网同时透过同一个电话号码来打电话聊天。在台湾，由于上传/下载的带宽不同， 因此才称为非对称的回路。ADSL 同样使用调制解调器，只是他透过的是 PPPoE (PPP over Ethernet) 的方法！ 将 PPP 仿真在以太网络卡上，因此你的主机需要透过一张网络卡来连接到调制解调器，并透过拨接程序来取得新的接口 (ppp0)！<br><strong>4. 电缆调制解调器 (Cable modem)</strong><br>主要透过有线电视 (台湾所谓的第四台) 使用的缆线作为网络讯号媒体，同样需要具备调制解调器来连接到 ISP，以取得网络参数来上网。 Cable modem 的带宽主要是分享型的，所以通常具有区域性，并不是你想装就能装的哩！</p><h3 id="（2）局域网络使用的设备-以太网络"><a href="#（2）局域网络使用的设备-以太网络" class="headerlink" title="（2）局域网络使用的设备-以太网络"></a>（2）局域网络使用的设备-以太网络</h3><p>在局域网络的环境中，我们最常使用的就是以太网络。当然啦，在某些超高速网络应用的环境中， 还可能会用到价格相当昂贵的光纤信道哩。只是如同前面提到的，以太网络因为已经标准化了，设备设置费用相对低廉， 所以一般你会听到什么网络线或者是网络媒体，几乎都是使用以太网络来架设的环境！ 只是这里还是要提醒您，整个网络世界并非仅有以太网络这个硬件接口！</p><h4 id="1-以太网络的速度与标准"><a href="#1-以太网络的速度与标准" class="headerlink" title="1. 以太网络的速度与标准"></a>1. 以太网络的速度与标准</h4><p>以太网络的流行主要是它成为国际公认的标准所致。早先 IEEE 所制订的以太网络标准为 802.3 的 IEEE 10BASE5 ，这个标准主要的定义是：【10 代表传输速度为10Mbps，BASE 表示采用基频信号来进行传输，至于 5 则是指每个网络节点之间最长可达 500 公尺。】由于网络的传输信息就是 0 与 1 啊，因此，数据传输的单位为每秒多少 bit ，亦即是 M bits/second, Mbps 的意思。那么为何制订成为 10Mbps 呢？ 这是因为早期的网络线压制的方法以及相关的制作方法，还有以太网络卡制作的技术并不是很好，加上当时的数据传输需求并没有像现在这么高，所以 10Mbps 已经可以符合大多数人的需求了。<br><strong>（注：我们看到的网络提供者 (Internet Services Provider, ISP) 所宣称他们的 ADSL 传输速度可以达到 下行/上行 2Mbps/128Kbps(Kbits per second) 时，那个 Kb 指的可不是 bytes 而是 bits！所以 2M/128K 在实际的档案大小传输速度上面，最大理论的传输为 256KBps/16 KBps(KBytes per second)，所以正常下载的速度约在每秒 100~200 KBytes 之间吶！同样的道理，在网络卡或者是一些网络媒体的广告上面，他们都会宣称自己的产品可以自动辨识传输速度为 10/100 Mbps ( Mega-bits per second)，该数值还是得再除以 8 才是我们一般常用的档案容量计算的单位bytes！）</strong></p><p>早期的网络线使用的是旧式的同轴电缆线，这种线路在现在几乎已经看不到了。取而代之的是类似传统电话线的双绞线 (Twisted Pair Ethernet) ，IEEE 并将这种线路的以太网络传输方法制订成为 10BASE-T 的标准。 10BASE-T 使用的是 10 Mbps 全速运作且采用无遮蔽式双绞线 (UTP) 的网络线。此外， 10BASE-T 的 UTP 网络线可以使用星形联机(star)， 也就是以一个集线器为中心来串连各网络设备的一个方法。<br>不同于早期以一条同轴电缆线链接所有的计算机的 bus 联机，透过星形联机的帮助，我们可以很简单的加装其他的设备或者是移除其他设备，而不会受到其他装置的影响，这对网络设备的扩充性与除错来说， 都是一项相当棒的设计！也因此 10BASE-T 让以太网络设备的销售额大幅提升！</p><p>后来 IEEE 更制订了 802.3u 这个支持到 100Mbps 传输速度的 100BASE-T 标准，这个标准与 10BASE-T 差异不大， 只是双绞线线材制作需要更精良，同时也已经支持使用了四对绞线的网络线了，也就是目前很常见的八蕊网络线！这种网络线我们常称为等级五 (Category 5, CAT5) 的网络线。 这种传输速度的以太网络就被称为 Fastethernet 。至于目前我们常常听到的 Gigabit 网络速度 1000 Mbps 又是什么吶？那就是 Gigabit ethernet ！只是 Gigabit ethernet 的网络线就需要更加的精良。</p><p>为什么每当传输速度增加时，网络线的要求就更严格呢？这是因为当传输速度增加时，线材的电磁效应相互干扰会增强， 因此在网络线的制作时就得需要特别注意线材的质料以及内部线蕊心之间的缠绕情况配置等，以使电子流之间的电磁干扰降到最小，才能使传输速度提升到应有的 Gigabit 。所以说，在以太网络世界当中，如果你想要提升原有的 fast ethernet 到 gigabit ethernet 的话，除了网络卡需要升级之外，主机与主机之间的网络线，以及连接主机线路的集线器/交换器等，都必须要提升到可以支持 gigabit 速度等级的设备才行！</p><h4 id="2-以太网络的网络线接头-跳线-并行线"><a href="#2-以太网络的网络线接头-跳线-并行线" class="headerlink" title="2.以太网络的网络线接头 (跳线/并行线)"></a>2.以太网络的网络线接头 (跳线/并行线)</h4><p>前面提到，网络的速度与线材是有一定程度的相关性的，那么线材的接头又是怎样呢？目前在以太网络上最常见到的接头就是 RJ-45 的网络接头，共有八蕊的接头，有点像是胖了的电话线接头， 如下所示：<br><img src="/uploads/2018/01/network_ethernet_joint.JPG" alt=""><br>而 RJ-45 接头又因为每条蕊线的对应不同而分为 568A 与 568B 接头，这两款接头内的蕊线对应如下表：<br><img src="/uploads/2018/01/network_ethernet_joint_rj45.png" alt=""><br>事实上，虽然目前的以太网络线有八蕊且两两成对，但实际使用的只有 1,2,3,6 蕊而已，其他的则是某些特殊用途的场合才会使用到。但由于主机与主机的联机以及主机与集线器的联机时，所使用的网络线脚位定义并不相同，因此由于接头的不同网络线又可分为两种：</p><ul><li>跳线：一边为 568A 一边为 568B 的接头时称为跳线，用在直接链接两部主机的网络卡。</li><li>并行线：两边接头同为 568A 或同为 568B 时称为并行线，用在链接主机网络卡与集线器之间的线材；</li></ul><h3 id="（3）以太网络的传输协议：CSMA-CD"><a href="#（3）以太网络的传输协议：CSMA-CD" class="headerlink" title="（3）以太网络的传输协议：CSMA/CD"></a>（3）以太网络的传输协议：CSMA/CD</h3><p>整个以太网络的重心就是以太网络卡！所以说，以太网络的传输主要就是网络卡对网络卡之间的数据传递而已。每张以太网络卡出厂时，就会赋予一个独一无二的卡号，那就是所谓的 MAC (Media Access Control)！理论上，网卡卡号是不能修改的，不过某些笔记本电脑的网卡卡号是能够修改的！那么以太网络的网卡之间数据是如何传输的呢？那就得要谈一下 IEEE 802.3 的标准 CSMA/CD (Carrier SenseMultiple Access with Collision Detection) 了！我们以下图来作为简介，下图内的中心点为集线器，各个主机都是联机到集线器，然后透过集线器的功能向所有主机发起联机的。<br><img src="/uploads/2018/01/network_csma_cd.JPG" alt="" title="CSMA/CD 联机示意图，由 A 发送资料给 D 时，注意箭头方向"></p><p>集线器是一种网络共享媒体，什么是网络共享媒体啊？想象一下上述的环境就像一个十字路口，而集线器就是那个路口！ 这个路口一次只允许一辆车通过，如果两辆车同时使用这个路口，那么就会发生碰撞的车祸事件啊！那就是所谓的共享媒体。 也就是说，网络共享媒体在单一时间点内， 仅能被一部主机所使用。</p><p>理解了共享媒体的意义后，再来，我们就得要讨论，那么以太网络的网卡之间是如何传输的呢？我们以上图中的 A 要发给 D 网卡为例好了，简单的说， CSMA/CD 搭配上述的环境，它的传输情况需要有以下的流程：</p><blockquote><p>1.监听媒体使用情况 (Carrier Sense)：A 主机要发送网络封包前，需要先对网络媒体进行监听，确认没有人在使用后， 才能够发送出讯框；<br>2.多点传输 (Multiple Access)：A 主机所送出的数据会被集线器复制一份，然后传送给所有连接到此集线器的主机！ 也就是说， A 所送出的数据， B, C, D 三部计算机都能够接收的到！但由于目标是 D 主机，因此 B 与 C 会将此讯框数据丢弃，而 D 则会抓下来处理；<br>3.碰撞侦测 (Collision Detection)：该讯框数据附有检测能力，若其他主机例如 B 计算机也刚好在同时间发送讯框数据时， 那么 A 与 B 送出的数据碰撞在一块 (出车祸) ，此时这些讯框就是损毁，那么 A 与 B 就会各自随机等待一个时间， 然后重新透过第一步再传送一次该讯框数据。</p></blockquote><p>了解这个程序很重要吗？我们就来谈谈：</p><ol><li><strong>网络忙碌时，集线器灯号闪个不停，但我的主机明明没有使用网络：</strong><br>透过上述的流程我们会知道，不管哪一部主机发送出讯框，所有的计算机都会接收到！因为集线器会复制一份该数据给所有计算机。 因此，虽然只有一部主机在对外联机，但是在集线器上面的所有计算机灯号就都会闪个不停！</li><li><strong>我的计算机明明没有被入侵，为何我的数据会被隔壁的计算机窃取：</strong><br>透过上述的流程，我们只要在 B 计算机上面安装一套监听软件，这套软件将原本要丢弃的讯框数据捉下来分析，并且加以重组， 就能够知道原本 A 所送出的讯息了。这也是为什么我们都建议重要数据在因特网上面得要【加密】后再传输！</li><li><strong>既然共享媒体只有一个主机可以使用，为何大家可以同时上网：</strong>这个问题就有趣了，既然共享媒体一次只能被一个主机所使用，那么万一我传输100MB 的档案，集线器就得被我使用 80 秒 (以 10Mbps 传输时)，在这期间其他人都不可以使用吗？不是的，由于标准的讯框数据在网络卡与其他以太网络媒体一次只能传输 1500bytes，因此我的 100MB 档案就得要拆成多个小数据报，然后一个一个的传送，每个数据报传送前都要经过 CSMA/CD 的机制。 所以，这个集线器的使用权是大家抢着用的！即使只有一部主机在使用网络媒体时，那么这部主机在发送每个封包间， 也都是需要等待一段时间的 (96 bit time)！</li><li><strong>讯框要多大比较好？能不能修改讯框？：</strong><br>如上所述，那么讯框的大小能不能改变呢？因为如果讯框的容量能够增大，那么小数据报的数量就会减少， 那每个讯框传送间的等待就可以减少了！是这样没错，但是以太网络标准讯框确实定义在 1500 bytes， 但近来的超高速以太网络媒体有支持 Jumbo frame (巨型讯框,注10) 的话，那么就能够将讯框大小改为9000bytes 哩！但不是很建议大家随便修改！</li></ol><h3 id="（4）MAC-的封装格式"><a href="#（4）MAC-的封装格式" class="headerlink" title="（4）MAC 的封装格式"></a>（4）MAC 的封装格式</h3><p>上面提到的 CSMA/CD 传送出去的讯框数据，其实就是 MAC 啦！MAC 其实就是我们上面一直讲到的讯框 (frame) 啰！ 只是这个讯框上面有两个很重要的数据，就是目标与来源的网卡卡号，因此我们又简称网卡卡号为 MAC 而已。 简单的说，你可以把 MAC想成是一个在网络线上面传递的包裹，而这个包裹是整个网络硬件上面传送数据的最小单位了。 也就是说，网络线可想成是一条【一次仅可通过一个人】的独木桥， 而 MAC就是在这个独木桥上面动的人啦！接下来，来看一看 MAC 这个讯框的内容吧！<br><img src="/uploads/2018/01/network_mac_frame.JPG" alt="" title="以太网络的 MAC 讯框"></p><p>上图中的目的地址与来源地址指的就是网卡卡号 (hardware address, 硬件地址)，我们前面提到，每一张网卡都有一个独一无二的卡号， 那个卡号的目的就在这个讯框的表头数据使用到啦！硬件地址最小由 00:00:00:00:00:00 到 FF:FF:FF:FF:FF:FF(16 进位法)， 这 6 bytes 当中，前 3bytes 为厂商的代码，后 3bytes 则是该厂商自行设定的装置码了。</p><p>在 Linux 当中，你可以使用 ifconfig 这个指令来查阅你的网络卡卡号喔！特别注意，在这个 MAC 的传送中，他仅在局域网络内生效，如果跨过不同的网域 (这个后面 IP 的部分时会介绍)，那么来源与目的的硬件地址就会跟着改变了。 这是因为变成不同网络卡之间的交流了嘛！所以卡号当然不同了！如下所示：<br><img src="/uploads/2018/01/network_mac_frame_trans.JPG" alt="" title="同一讯框在不同网域的主机间传送时，讯框的表头变化"></p><p>例如上面的图标，我的数据要由计算机 A 通过 B 后才送达 C ，而 B 计算机有两块网络卡，其中 MAC-2 与 A 计算机的 MAC-1 互通，至于 MAC-3 则与 C 计算机的MAC-4 互通。但是 MAC-1 不能与 MAC-3 与 MAC-4 互通，为啥？因为 MAC-1 这块网络卡并没有与 MAC-3 及 MAC-4 使用同样的 switch/hub 相接嘛！所以，数据的流通会变成：</p><blockquote><p>1.先由 MAC-1 传送到 MAC-2 ，此时来源是 MAC-1 而目的地是 MAC-2；<br>2.B 计算机接收后，察看该讯框，发现目标其实是 C 计算机，而为了与 C 计算机沟通， 所以他会将讯框内的来源 MAC 改为 MAC-3 ，而目的改为 MAC-4 ，如此就可以直接传送到 C 计算机了。</p></blockquote><p>也就是说，只要透过 B (就是路由器) 才将封包送到另一个网域去的时候，那么讯框内的硬件地址就会被改变，然后才能够在同一个网域里面直接进行讯框的流通！<br><em>（注：局域网内是mac地址寻址，网域中是通过IP寻址。）</em></p><h3 id="（5）集线器、交换器与相关机制"><a href="#（5）集线器、交换器与相关机制" class="headerlink" title="（5）集线器、交换器与相关机制"></a>（5）集线器、交换器与相关机制</h3><p>共不共享很重要，集线器还是交换器？<br>当一个很忙碌的网络在运作时，集线器 (hub) 这个网络共享媒体就可能会发生碰撞的情况， 这是因为 CSMA/CD 的缘故。那有没有办法避免这种莫名其妙的封包碰撞情况呢？有的，那就使用非共享媒体的交换器即可！</p><p>交换器 (switch) 等级非常多，我们这里仅探讨支持 OSI 第二层的交换器。交换器与集线器最大的差异，在于交换器内有一个特别的内存， 这个内存可以记录每个 switch port 与其连接的 PC 的 MAC 地址，所以，当来自 switch 两端的 PC 要互传数据时，每个讯框将直接透过交换器的内存数据而传送到目标主机上！ 所以 switch 不是共享媒体，且 switch 的每个端口 (port) 都具有独立的带宽！</p><h2 id="二、TCP-IP-的网络层相关封包与数据"><a href="#二、TCP-IP-的网络层相关封包与数据" class="headerlink" title="二、TCP/IP 的网络层相关封包与数据"></a>二、TCP/IP 的网络层相关封包与数据</h2><p>我们现在知道要有网络的话，必须要有网络相关的硬件，而目前最常见的网络硬件接口为以太网络，包括网络线、网络卡、Hub/Switch 等等。而以太网络上面的传输使用网络卡卡号为基准的 MAC 讯框，配合 CSMA/CD 的标准来传送讯框，这就是硬件部分。在软件部分，我们知道 Internet 其实就是 TCP/IP 这个通讯协议的通称，Internet 是由 InterNIC 所统一管理的， 但其实他仅是负责分配 Internet 上面的 IP 以及提供相关的 TCP/IP 技术文件而已。不过 Internet 最重要的就是 IP ！所以，这个小节就让我们来讲讲网络层的 IP 与路由！</p><h3 id="1、IP-封包的封装"><a href="#1、IP-封包的封装" class="headerlink" title="1、IP 封包的封装"></a>1、IP 封包的封装</h3><p>目前因特网社会的 IP 有两种版本，一种是目前使用最广泛的 IPv4 (Internet Protocol version 4, 因特网协定第四版)， 一种则是预期未来会热门的 IPv6 。IPv4记录的地址由于仅有 32 位，预计在 2020 年前后就会分发完毕，如此一来，新兴国家或者是新的网络公司，将没有网络可以使用。为了避免这个问题发生，因此就有 IPv6的产生。IPv6 的地址可以达到 128 位，可以多出 2 的 96 次方倍的网址数量，这样的 IP 数量几乎用不完！虽然 IPv6 具有前瞻性，但目前主流媒体大多还是使用IPv4 ，因此本文主要谈到的 IP 都指 IPv4 而言。</p><p>我们在前一小节谈到 MAC 的封装，那么 IP 封包的封装也得要来了解一下，才能知道 IP 到底是如何产生的啊！ IP 封包可以达到 65535 bytes 这么大，在比 MAC 大的情况下，我们的操作系统会对 IP 进行拆解的动作。至于 IP 封装的表头资料绘制如下：(下图第一行为每个字段的 bit 数)<br><img src="/uploads/2018/01/network_ip_01.png" alt="" title="IP 封包的表头资料"></p><p>在上面的图示中有个地方要注意，那就是【每一行所占用的位数为 32 bits】，各个表头的内容分别介绍如下：</p><blockquote><p><strong>Version(版本)</strong><br>宣告这个 IP 封包的版本，例如目前惯用的还是 IPv4 这个版本就在这里宣告。<br><strong>IHL(Internet Header Length, IP 表头的长度)</strong><br>告知这个 IP 封包的表头长度，使用的单位应该是字组 (word) ，一个字组为 4bytes 大小。<br><strong>Type of Service(服务类型)</strong><br>这个项目的内容为【PPPDTRUU】，表示这个 IP 封包的服务类型，主要分为：<br>　　PPP：表示此 IP 封包的优先度，目前很少使用；<br>　　D：若为 0 表示一般延迟(delay)，若为 1 表示为低延迟；<br>　　T：若为 0 表示为一般传输量 (throughput)，若为 1 表示为高传输量；<br>　　R：若为 0 表示为一般可靠度(reliability)，若为 1 表示高可靠度。<br>　　UU：保留尚未被使用。<br>举例来说，gigabit 以太网络的种种相关规格可以让这个 IP 封包加速且降低延迟，某些特殊的标志就是在这里说明的。<br><strong>Total Length(总长度)</strong><br>指这个 IP 封包的总容量，包括表头与内容 (Data) 部分。最大可达 65535bytes。<br><strong>Identification(辨别码)</strong><br>我们前面提到 IP 袋子必须要放在 MAC 袋子当中。不过，如果 IP 袋子太大的话，就得先要将 IP 再重组成较小的袋子然后再放到 MAC 当中。而当 IP 被重组时，每个来自同一个 IP 的小袋子就得要有个标识符以告知接收端这些小袋子其实是来自同一个 IP 封包才行。也就是说，假如 IP 封包其实是 65536 那么大 (前一个 Total Length 有规定)，那么这个 IP 就得要再被分成更小的 IP 分段后才能塞进 MAC 讯框中。那么每个小 IP 分段是否来自同一个 IP 资料，这就是该标识符的作用！<br><strong>Flags(特殊旗标)</strong><br>这个地方的内容为【0DM】，其意义为：<br>　　D：若为 0 表示可以分段，若为 1 表示不可分段<br>　　M：若为 0 表示此 IP 为最后分段，若为 1 表示非最后分段。<br><strong>Fragment Offset(分段偏移)</strong><br>表示目前这个 IP 分段在原始的 IP 封包中所占的位置。就有点像是序号，有这个序号才能将所有的小 IP 分段组合成为原本的 IP 封包大小！透过 Total Length, Identification, Flags 以及这个 Fragment Offset 就能够将小 IP 分段在收受端组合起来了！<br><strong>Time To Live(TTL, 存活时间)</strong><br>表示这个 IP 封包的存活时间，范围为 0-255。当这个 IP 封包通过一个路由器时，TTL 就会减一，当 TTL 为 0 时，这个封包将会被直接丢弃。说实在的，要让 IP 封包通过 255 个路由器，还挺难的！<br><strong>Protocol Number(协定代码)</strong><br>来自传输层与网络层本身的其他数据都是放置在 IP 封包当中的，我们可以在 IP 表头记载这个 IP 封包内的数据是啥，在这个字段就是记载每种数据封包的内容！在这个字段记载的代码与相关的封包协议名称如下所示：<br><img src="/uploads/2018/01/network_ip_frame_protocol.png" alt="" title="常见的有 TCP, UDP"><br><strong>Header Checksum(表头检查码)</strong><br>用来检查这个 IP 表头的错误检验之用。<br><strong>Source Address</strong><br>来源的 IP 地址，从这里我们也知道 IP 是 32 位。<br><strong>Destination Address</strong><br>有来源还需要有目标才能传送，这里就是目标的 IP 地址。<br><strong>Options (其他参数)</strong><br>这个是额外的功能，提供包括安全处理机制、路由纪录、时间戳、严格与宽松之来源路由等。<br><strong>Padding(补齐项目)</strong><br>由于 Options 的内容不一定有多大，但是我们知道 IP 每个数据都必须要是 32bits，所以，若 Options 的数据不足 32 bits 时，则由 padding 主动补齐。</p></blockquote><p>你只要知道 IP 表头里面含有：TTL, Protocol, 来源地址与目标地址也就够了！而这个 IP 表头的来源与目标 IP ，以及那个判断通过多少路由器的 TTL ，就能了解到这个 IP 将被如何传送到目的端的。后续各小节我们将介绍 IP 的组成与范围，还有IP 封包如何传送的机制 (路由) 等等。</p><h3 id="2、IP-地址的组成与分级"><a href="#2、IP-地址的组成与分级" class="headerlink" title="2、IP 地址的组成与分级"></a>2、IP 地址的组成与分级</h3><p>现在我们知道 IP (Internet Protocol) 其实是一种网络封包，而这个封包的表头最重要的就是那个 32 位的来源与目标地址！ 为了方便记忆，所以我们也称这个 32bits 的数值为 IP 网络地址就是了。因为网络是人类发明的，所以很多概念与邮务系统类似！ 那这个 IP 其实就类似所谓的【门牌号码】！那么这个 IP 有哪些重要的地方需要了解的呢？底下我们就来谈一谈吧！</p><p>既然 IP 的组成是 32 bits 的数值，也就是由 32 个 0 与 1 组成的一连串数字！那么当我们思考所有跟 IP 有关的参数时，你就应该要将该参数想成是 32 位的数据！不过，因为人类对于二进制实在是不怎么熟悉，所以为了顺应人们对于十进制的依赖性，因此，就将 32 bits 的 IP 分成四小段，每段含有 8 个 bits ，将 8 个 bits 计算成为十进制，并且每一段中间以小数点隔开，那就成了目前大家所熟悉的 IP 的书写模样了。如下所示：<br><img src="/uploads/2018/01/network_ip_show.png" alt=""></p><p>所以 IP 最小可以由 0.0.0.0 一直到 255.255.255.255 ！但在这一串数字中，其实还可以分为两个部分！主要分为 Net_ID (网域号码)与 Host_ID (主机号码) 两部份。我们先以 192.168.0.0 ~ 192.168.0.255 这个 Class C 的网域当作例子来说明好了：<br><img src="/uploads/2018/01/network_ip_explain.png" alt=""></p><p>在上面的范例当中，前面三组数字 (192.168.0) 就是网域号码，最后面一组数字则称为主机号码。至于同一个网域的定义是【在同一个物理网段内，主机的 IP 具有相同的 Net_ID ，并且具有独特的 Host_ID】，那么这些 IP 群就是同一个网域内的 IP 网段！<br><em>（注：什么是物理网段呢？当所有的主机都是使用同一个网络媒体串在一起，这个时候这些主机在实体装置上面其实是联机在一起的，那么就可以称为这些主机在同一个物理网段内了！同时并请注意，同一个物理网段之内，可以依据不同的 IP 的设定，而设定成多个【IP 网段】！）</em><br><strong>（请注意，同一个 Net_ID 内，不能具有相同的 Host_ID ，否则就会发生IP冲突，可能会造成两部主机都没有办法使用网络的问题！）</strong></p><p><strong>（1）IP 在同一网域的意义</strong><br>那么同一个网域该怎么设定，与将 IP 设定在同一个网域之内有什么好处呢？</p><blockquote><p><strong>1.Net_ID 与 Host_ID 的限制：</strong><br>在同一个网段内，Net_ID 是不变的，而 Host_ID 则是不可重复，此外，Host_ID在二进制的表示法当中，不可同时为 0 也不可同时为 1 ，因为全为 0 表示整个网段的地址 (Network IP)，而全为 1 则表示为广播的地址 (Broadcast IP)。<br><strong>2.在区网内透过 IP 广播传递数据</strong><br>在同物理网段的主机如果设定相同的网域 IP 范围 (不可重复)，则这些主机都可以透过 CSMA/CD 的功能直接在区网内用广播进行网络的联机，亦即可以直接网卡对网卡传递数据 (透过 MAC 讯框)；<br><strong>3.设定不同区网在同物理网段的情况</strong><br>在同一个物理网段之内，如果两部主机设定成不同的 IP 网段，则由于广播地址的不同，导致无法透过广播的方式来进行联机。 此时得要透过路由器 (router)来进行沟通才能将两个网域连结在一起。<br><strong>4.网域的大小</strong><br>当 Host_ID 所占用的位越大，亦即 Host_ID 数量越多时，表示同一个网域内可用以设定主机的 IP 数量越多。</p></blockquote><p><strong>（2）IP 的分级</strong><br>为了 IP 管理与发放注册的方便性，InterNIC 将整个 IP 网段分为五种等级， 每种等级的范围主要与 IP 那 32 bits 数值的前面几个位有关，基本定义如下：<br><img src="/uploads/2018/01/network_ip_class.png" alt=""><br>五种分级在十进制的表示：<br>Class A : 0.xx.xx.xx ~ 127.xx.xx.xx<br>Class B : 128.xx.xx.xx ~ 191.xx.xx.xx<br>Class C : 192.xx.xx.xx ~ 223.xx.xx.xx<br>Class D : 224.xx.xx.xx ~ 239.xx.xx.xx<br>Class E : 240.xx.xx.xx ~ 255.xx.xx.xx</p><p>根据上表的说明，我们可以知道，你只要知道 IP 的第一个十进制数，就能够约略了解到该 IP 属于哪一个等级，以及同网域 IP 数量有多少。这也是为啥我们上头选了 192.168.0.0 这一 IP 网段来说明时，会将巷子定义到第三个数字之故。不过，上表中你只要记忆三种等级，亦即是 Class A, B, C 即可，因为 Class D 是用来作为群播(multicast) 的特殊功能之用 (最常用在大批计算机的网络还原)，至于 Class E 则是保留没有使用的网段。因此，能够用来设定在一般系统上面的，就只有 Class A, B, C三种等级的 IP！</p><p><strong>（3）IP 的种类与取得方式</strong><br>接下来要跟大家谈一谈也是很容易造成大家困扰的一个部分，那就是 IP 的种类！很多朋友常常听到什么【真实IP, 实体 IP, 虚拟 IP, 假的 IP….】实际上，在 IPv4 里面就只有两种 IP 的类别，分别是：</p><ul><li>Public IP : 公共 IP ，经由 INTERNIC 所统一规划的 IP，有这种 IP 才可以连上 Internet ；</li><li>Private IP : 私有 IP 或保留 IP，不能直接连上 Internet 的 IP ，主要用于局域网络内的主机联机规划。</li></ul><p>早在 IPv4 规划的时候就担心 IP 会有不足的情况，而且为了应付某些企业内部的网络设定，于是就有了私有 IP (Private IP) 的产生了。私有 IP 也分别在 A, B, C 三个 Class 当中各保留一段作为私有 IP 网段，那就是：<br>　　Class A：10.0.0.0 - 10.255.255.255<br>　　Class B：172.16.0.0 - 172.31.255.255<br>　　Class C：192.168.0.0 - 192.168.255.255<br>由于这三段 Class 的 IP 是预留使用的，所以并不能直接作为 Internet 上面的连接之用，不然的话，到处就都有相同的 IP ！那怎么行！网络岂不混乱？所以，这三个 IP 网段就只做为内部私有网域的 IP 沟通之用。简单的说，他有底下的几个限制：</p><ul><li>私有 IP 的路由信息不能对外散播 (只能存在内部网络)；</li><li>使用私有 IP 作为来源或目的地址的封包，不能透过 Internet 来转送 (不然网络会混乱)；</li><li>关于私有 IP 的参考纪录(如 DNS)，只能限于内部网络使用 (一样的原理)</li></ul><p>这个私有 IP 有什么好处呢？由于他的私有路由不能对外直接提供信息，所以，你的内部网络将不会直接被 Internet 上面的 Cracker 所攻击！但是，你也就无法以私有 IP 来【直接上网】！因此相当适合一些尚未具有 Public IP 的企业内部用来规划其网络之设定！否则当你随便指定一些可能是 Public IP 的网段来规划你企业内部的网络设定时，万一哪一天真的连上 Internet 了，那么岂不是可能会造成跟 Internet上面的 Public IP 相同了吗？</p><p>此外，在没有可用的公开网络情况下，如果你想要跟同学玩联机游戏怎办？也就是说，在区网内自己玩自己的联机游戏， 此时你只要规范好所有同学在同一段私有 IP 网段中，就能够顺利的玩你的网络啦！就这么简单呢！</p><p>那么万一你又要将这些私有 IP 送上 Internet 呢？这个简单，设定一个简单的防火墙加上 NAT (Network Address Transfer) 服务，你就可以透过 IP 伪装 (不要急，这个在后面也会提到) 来使你的私有 IP 的计算机也可以连上 Internet ！</p><p><strong>特殊的 loopback IP 网段</strong><br>还有一个奇怪的 Class A 的网域，那就是 lo 这个奇怪的网域啦 (注意：是小写的 o 而不是零喔)！这个 lo 的网络是当初被用来作为测试操作系统内部循环所用的一个网域，同时也能够提供给系统内部原本就需要使用网络接口的服务 (daemon) 所使用。</p><p>简单的说，如果你没有安装网络卡在的机器上面， 但是你又希望可以测试一下在你的机器上面设定的服务器环境到底可不可以顺利运作，这个时候怎么办，就是利用这个所谓的内部循环网络啦！这个网段在 127.0.0.0/8 这个 Class A，而且默认的主机 (localhost) 的 IP 是 127.0.0.1 ！所以，当你启动了你的 WWW 服务器，然后在你的主机的 X-Window 上面执行 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 就可以直接看到你的主页！而且不需要安装网络卡！测试很方便的！</p><p><strong>IP 的取得方式</strong><br>基本上，主机的 IP 与相关网域的设定方式主要有：</p><blockquote><p>1.直接手动设定(static)： 你可以直接向你的网管询问可用的 IP 相关参数，然后直接编辑配置文件 (或使用某些软件功能) 来设定你的网络。 常见于校园网络的环境中，以及向 ISP 申请固定 IP 的联机环境；<br>2.透过拨接取得： 向你的 ISP 申请注册，取得账号密码后，直接拨接到 ISP ，你的 ISP 会透过他们自己的设定，让你的操作系统取得正确的网络参数。<br>3.自动取得网络参数 (DHCP)： 在局域网络内会有一部主机负责管理所有计算机的网络参数，你的网络启动时就会主动向该服务器要求 IP 参数， 若取得网络相关参数后，你的主机就能够自行设定好所有服务器给你的网络参数了。最常使用于企业内部、IP 分享器后端、 校园网络与宿舍环境，及缆线宽带等联机方式。</p></blockquote><p>不管是使用上面哪种方式取得的 IP ，你的 IP 都只有所谓的【 Public 与Private IP 】而已！而其他什么浮动式、固定制、 动态式等等有的没有的，就只是告诉你这个 IP 取得的方式而已。</p><h3 id="（4）Netmask-子网与-CIDR-Classless-Interdomain-Routing"><a href="#（4）Netmask-子网与-CIDR-Classless-Interdomain-Routing" class="headerlink" title="（4）Netmask, 子网与 CIDR (Classless Interdomain Routing)"></a>（4）Netmask, 子网与 CIDR (Classless Interdomain Routing)</h3><p>前面我们提到 IP 这个 32 位的数值中分为网域号码与主机号码，其中 Class C的网域号码占了 24 位，而其实我们还可以将这样的网域切的更细，就是让第一个Host_ID 被拿来作为 Net_ID ，所以，整个 Net_ID 就有 25 bits ，至于 Host_ID 则减少为 7 bits 。在这样的情况下，原来的一个 Class C 的网域就可以被切分为两个子域，而每个子域就有【 256/2 - 2 = 126 】个可用的 IP 了！这样一来，就能够将原本的一个网域切为两个较细小的网域，方便分门别类的设计。</p><p><strong>Netmask, 或称为 Subnet mask (子网掩码)</strong><br>那到底是什么参数来达成子网的切分呢？那就是 Netmask (子网掩码) 的用途！这个 Netmask 是用来定义出网域的最重要的一个参数。<br>Netmask 的表示就成为：<br><img src="/uploads/2018/01/network_ip_netmask.png" alt=""></p><h2 id="三、TCP-IP-的传输层相关封包与数据"><a href="#三、TCP-IP-的传输层相关封包与数据" class="headerlink" title="三、TCP/IP 的传输层相关封包与数据"></a>三、TCP/IP 的传输层相关封包与数据</h2><p>网络层的 IP 封包只负责将数据送到正确的目标主机去，但这个封包到底会不会被接受，或者是有没有被正确的接收，那就不是 IP 的任务啦！那是传送层的任务之一。其中连接导向的 TCP 封包与非连接导向的 UDP 封包，这两个封包很重要！资料能不能正确的被送达目的，与这两个封包有关！</p><h3 id="1、可靠联机的-TCP-协议"><a href="#1、可靠联机的-TCP-协议" class="headerlink" title="1、可靠联机的 TCP 协议"></a>1、可靠联机的 TCP 协议</h3><p>TCP 封包的表头资料：<br><img src="/uploads/2018/01/network_ip_frame_tcp.png" alt=""><br>上图就是一个 TCP 封包的表头数据，各个项目以 Source Port, Destination Port及 Code 算是比较重要的项目，底下我们就分别来谈一谈各个表头数据的内容吧！</p><blockquote><p><strong>Source Port &amp; Destination Port (来源端口 &amp; 目标端口)</strong><br>什么是端口(port)？我们知道 IP 封包的传送主要是藉由 IP 地址连接两端，但是到底这个联机的通道是连接到哪里去呢？就是连接到 port 上头！举例来说，有的网站开放 WWW 服务器，这表示主机必须要启动一个可以让 client 端连接的端口，这个端口就是 port 。同样的，客户端想要连接到 WWW 服务器时，就必须要在 client 主机上面启动一个 port ，这样这两个主机才能够利用这条【通道】来传递封包数据！这个目标与来源 port 的纪录，可以说是 TCP 封包上最重要的参数了！<br><strong>Sequence Number (封包序号)</strong><br>由于 TCP 封包必须要带入 IP 封包当中，所以如果 TCP 数据太大时(大于 IP封包的容许程度)，就得要进行分段。这个 Sequence Number 就是记录每个封包的序号，可以让收受端重新将 TCP 的数据组合起来。<br><strong>Acknowledge Number (回应序号)</strong><br>为了确认主机端确实有收到我们 client 端所送出的封包数据，我们 client 端当然希望能够收到主机方面的响应，那就是这个 Acknowledge Number 的用途了。当 client 端收到这个确认码时，就能够确定之前传递的封包已经被正确的收下了。<br><strong>Data Offset (资料补偿)</strong><br>在图中倒数第二行有个 Options 字段！那个 Options 的字段长度是非固定的，而为了要确认整个 TCP 封包的大小，就需要这个标志来说明整个封包区段的起始位置。<br><strong>Reserved (保留)</strong><br>未使用的保留字段。<br><strong>Code (Control Flag, 控制标志码)</strong><br>当我们在进行网络联机的时候，必须要说明这个联机的状态，好让接收端了解这个封包的主要动作。这可是一个非常重要的句柄！这个字段共有 6 个 bits ，分别代表 6 个句柄，若为 1 则为启动。分别说明如下：<br>　　URG(Urgent)：若为 1 则代表该封包为紧急封包，接收端应该要紧急处理，且图当中的 Urgent Pointer 字段也会被启用。<br>　　ACK(Acknowledge)：若为 1 代表这个封包为响应封包，则与上面提到的 Acknowledge Number 有关。<br>　　PSH(Push function)：若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无须等待缓冲区满了才送。<br>　　RST(Reset)：如果 RST 为 1 的时候，表示联机会被马上结束，而无需等待终止确认手续。这也就是说，这是个强制结束的联机，且发送端已断线。<br>　　SYN(Synchronous)：若为 1，表示发送端希望双方建立同步处理，也就是要求建立联机。通常带有 SYN 标志的封包表示【主动】要连接到对方的意思。<br>　　FIN(Finish)：若为 1 ，表示传送结束，所以通知对方数据传毕，是否同意断线，只是发送者还在等待对方的响应而已。<br>其实每个项目都很重要，不过我们这里仅对 ACK/SYN 有兴趣而已，这样未来在谈到防火墙的时候，你才会比较清楚为啥每个 TCP 封包都有所谓的【状态】条件！那就是因为联机方向的不同所致啊。<br><strong>Window (滑动窗口)</strong><br>主要是用来控制封包的流量的，可以告知对方目前本身有的缓冲器容量(Receive Buffer) 还可以接收封包。当 Window=0 时，代表缓冲器已经额满，所以应该要暂停传输数据。 Window 的单位是 byte。<br><strong>Checksum(确认检查码)</strong><br>当数据要由发送端送出前，会进行一个检验的动作，并将该动作的检验值标注在这个字段上；而接收者收到这个封包之后，会再次的对封包进行验证，并且比对原发送的 Checksum 值是否相符，如果相符就接受，若不符就会假设该封包已经损毁，进而要求对方重新发送此封包！<br><strong>Urgent Pointer(紧急资料)</strong><br>这个字段是在 Code 字段内的 URG = 1 时才会产生作用。可以告知紧急数据所在的位置。<br><strong>Options(任意资料)</strong><br>目前此字段仅应用于表示接收端可以接收的最大数据区段容量，若此字段不使用，表示可以使用任意数据区段的大小。这个字段较少使用。<br><strong>Padding(补足字段)</strong><br>如同 IP 封包需要有固定的 32bits 表头一样， Options 由于字段为非固定，所以也需要 Padding 字段来加以补齐才行。同样也是 32 bits 的整数。</p></blockquote><h3 id="2、通讯端口"><a href="#2、通讯端口" class="headerlink" title="2、通讯端口"></a>2、通讯端口</h3><p>谈完了 TCP 表头数据后，再来让我们了解一下这个表头里面最重要的端口信息吧！<br>在上图的 TCP 表头数据中，最重要的就属那 16 位的两个咚咚，亦即来源与目标的端口。由于是 16 位，因此目标与来源端口最大可达 65535 号 (2 的 16 次方)！那这个埠口有什么用途呢？上面稍微提到过，网络是双向的，服务器与客户端要达成联机的话，两边应该要有一个对应的端口来达成联机信道，好让数据可以透过这个信道来进行沟通。</p><p>那么这个端口怎么打开呢？就是透过程序的执行！举例来说，网站上必须要启动一个 WWW 服务器软件，这个服务器软件会主动的唤起 port 80 来等待客户端的联机。你想要看我网站上的数据，就得要利用浏览器，填入网址，然后浏览器也会启动一个端口，并将 TCP 的表头填写目标端口为 80 ，而来源端口是你主机随机启动的一个端口，然后将 TCP 封包封装到 IP 后，送出到网络上。等 WWW 网站主机接收到你这个封包后，再依据你的端口给予回应。<br><em>（注：曾经有一个朋友问过我说：【一部主机上面这么多服务，那我们跟这部主机进行联机时，该主机怎么知道我们要的数据是 WWW 还是FTP 啊？】就是透过埠口啊！因为每种 Client 软件他们所需要的数据都不相同，例如上面提到的浏览器所需要的数据是 WWW ，所以该软件默认就会向服务器的 port 80 索求数据；而如果你是使用 filezilla 来进行与服务器的 FTP 数据索求时， filezilla 当然预设就是向服务器的 FTP 相关埠口 (预设就是 port 21) 进行连接的动作啦！所以当然就可以正确无误的取得 Client 端所需要的数据了）</em></p><p><strong>特权端口 (Privileged Ports)</strong><br>Internet 上面已经有很多规范好的固定 port (well-known port)，这些 port number 通常小于 1024 ，且是提供给许多知名的网络服务软件用的。在我们的 Linux 环境下，各网络服务与 port number 的对应默认给他写在 /etc/services档案内。底下列出几个常见的 port number 与网络服务的对应：<br><img src="/uploads/2018/01/network_port_for_service.png" alt=""></p><p>另外一点比较值得注意的是，小于 1024 以下的埠口要启动时， 启动者的身份必须要是 root 才行，所以才叫做特权埠口嘛！这个限制挺重要的，大家不要忘记了！不过如果是 client 端的话，由于 client 端都是主动向 server 端要数据，所以client 端的 port number 就使用随机取一个大于 1024 以上且没有在用的 port number。</p><p><strong>Socket Pair</strong><br>由于网络是双向的，要达成联机的话得要服务器与客户端均提供了 IP 与埠口才行。因此，我们常常将这个成对的数据称之为 Socket Pair 了！</p><ul><li>来源 IP + 来源埠口 (Source Address + Source Port)</li><li>目的 IP + 目的埠口 (Destination Address + Destination Port)</li></ul><p>由于 IP 与埠口常常连在一起说明，因此网络寻址常常使用【 IP:port 】来说明，例如想要连上网站时，正确的鸟哥网站写法应该是：【 linux.vbird.org:80 】才对！</p><h3 id="3、TCP-的三向交握"><a href="#3、TCP-的三向交握" class="headerlink" title="3、TCP 的三向交握"></a>3、TCP 的三向交握</h3><p>TCP 被称为可靠的联机封包，主要是透过许多机制来达成的，其中最重要的就是三向交握的功能。我们以底下的图示来作为说明。<br><img src="/uploads/2018/01/network_tcp_connect.png" alt=""></p><p>在上面的封包连接模式当中，在建立联机之前都必须要通过三个确认的动作，所以这种联机方式也就被称为三向交握(Three-way handshake)。 那么我们将整个流程依据上面的 A, B, C, D 四个阶段来说明一下：</p><blockquote><p><strong>A:封包发起</strong><br>当客户端想要对服务器端联机时，就必须要送出一个要求联机的封包，此时客户端必须随机取用一个大于 1024 以上的端口口来做为程序沟通的接口。然后在 TCP 的表头当中，必须要带有 SYN 的主动联机(SYN=1)，并且记下发送出联机封包给服务器端的序号 (Sequence number = 10001) 。<br><strong>B:封包接收与确认封包传送</strong><br>当服务器接到这个封包，并且确定要接收这个封包后，就会开始制作一个同时带有 SYN=1, ACK=1 的封包，其中那个 acknowledge 的号码是要给 client 端确认用的，所以该数字会比(A 步骤)里面的 Sequence 号码多一号 (ack = 10001+1= 10002)， 那我们服务器也必须要确认客户端确实可以接收我们的封包才行，所以也会发送出一个 Sequence (seq=20001) 给客户端，并且开始等待客户端给我们服务器端的回应！<br><strong>C:回送确认封包</strong><br>当客户端收到来自服务器端的 ACK 数字后 (10002) 就能够确认之前那个要求封包被正确的收受了， 接下来如果客户端也同意与服务器端建立联机时，就会再次的发送一个确认封包 (ACK=1) 给服务器，亦即是 acknowledge = 20001+1 =20002 。<br><strong>D:取得最后确认</strong><br>若一切都顺利，在服务器端收到带有 ACK=1 且 ack=20002 序号的封包后，就能够建立起这次的联机了。</p></blockquote><p>也就是说，你必须要了解【网络是双向的】这个事实！所以不论是服务器端还是客户端，都必须要透过一次 SYN 与 ACK 来建立联机，所以总共会进行三次的交谈！在设定防火墙或者是追踪网络联机的问题时，这个【双向】的概念最容易被忽略， 而常常导致无法联机成功的问题啊！切记切记！</p><h2 id="四、非连接导向的-UDP-协议"><a href="#四、非连接导向的-UDP-协议" class="headerlink" title="四、非连接导向的 UDP 协议"></a>四、非连接导向的 UDP 协议</h2><p>UDP 的全名是：【User Datagram Protocol, 用户数据流协议】，UDP 与 TCP 不一样，UDP 不提供可靠的传输模式，因为他不是面向连接的一个机制，这是因为在 UDP的传送过程中，接受端在接受到封包之后，不会回复响应封包 (ACK) 给发送端，所以封包并没有像 TCP 封包有较为严密的检查机制。至于 UDP 的表头资料如下表所示：<br><img src="/uploads/2018/01/network_ip_frame_udp.png" alt=""></p><p>TCP 封包确实是比较可靠的，因为通过三向交握嘛！不过，也由于三向交握的缘故，TCP 封包的传输速度会较慢。至于 UDP 封包由于不需要确认对方是否有正确的收到数据，故表头数据较少，所以 UDP 就可以在 Data 处填入更多的数据了。同时 UDP 比较适合需要实时反应的一些数据流，例如影像实时传送软件等，就可以使用这类的封包传送。也就是说，UDP 传输协议并不考虑联机要求、联机终止与流量控制等特性，所以使用的时机是当数据的正确性不很重要的情况，例如网络摄影机！</p><p>另外，很多的软件其实是同时提供 TCP 与 UDP 的传输协议的，举例来说，查询主机名的 DNS 服务就同时提供了 UDP/TCP 协议。由于 UDP 较为快速，所以我们 client 端可以先使用 UDP 来与服务器联机。 但是当使用 UDP 联机却还是无法取得正确的数据时，便转换为较为可靠的 TCP 传输协议来进行数据的传输啰。 这样可以同时兼顾快速与可靠的传输说！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、TCP-IP-的链结层相关协议&quot;&gt;&lt;a href=&quot;#一、TCP-IP-的链结层相关协议&quot; class=&quot;headerlink&quot; title=&quot;一、TCP/IP 的链结层相关协议&quot;&gt;&lt;/a&gt;一、TCP/IP 的链结层相关协议&lt;/h2&gt;&lt;p&gt;TCP/IP 最底层的链结层主要与硬件比较有关系，因此底下我们主要介绍一些 WAN 与 LAN 的硬件。同时会开始介绍那重要的 CSMA/CD 的以太网络协议，以及相关的硬件与 MAC 讯框格式等。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>基础网络概念（一）</title>
    <link href="http://yoursite.com/2018/01/10/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/10/基础网络概念（一）/</id>
    <published>2018-01-10T10:34:11.000Z</published>
    <updated>2018-01-18T06:57:52.810Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、计算机网络组成组件"><a href="#1、计算机网络组成组件" class="headerlink" title="1、计算机网络组成组件"></a>1、计算机网络组成组件</h3><p>我们以底下这张联机示意图来解释好了：<br><img src="/uploads/2018/01/network_component.JPG" alt=""><br><a id="more"></a><br>在上图中，我们主要需要注意到的硬件有哪些呢？大致有底下这些啦：</p><ul><li><strong>节点 (node)：</strong>节点主要是具有网络地址 (IP) 的设备之称，因此上面图示中的一般PC、Linux 服务器、ADSL 调制解调器与网络打印机等，个别都可以称为一个 node！那中间那个集线器 (hub) 是不是节点呢？因为他不具有 IP ，因此 hub 不是节点。</li><li><strong>服务器主机 (server)：</strong>就网络联机的方向来说，提供数据以【响应】给用户的主机，都可以被称为是一部服务器。举例来说，Yahoo 是个 WWW 服务器，昆山的 FTP (<a href="http://ftp.ksu.edu.tw/" target="_blank" rel="noopener">http://ftp.ksu.edu.tw/</a>) 是个文件服务器等等。</li><li><strong>工作站 (workstation) 或客户端 (client)：</strong>任何可以在计算机网络输入的设备都可以是工作站，若以联机发起的方向来说，主动发起联机去【要求】数据的，就可以称为是客户端 (client)。举例来说，一般 PC 打开浏览器对 Yahoo 要求新闻数据，那一般 PC 就是客户端。</li><li><strong>网络卡 (Network Interface Card, NIC)：</strong>内建或者是外插在主机上面的一个设备，主要提供网络联机的卡片，目前大都使用具有 RJ-45 接头的以太网络卡。一般 node 上都具有一个以上的网络卡，以达成网络联机的功能。</li><li><strong>网络接口：</strong>利用软件设计出来的网络接口，主要在提供网络地址 (IP) 的任务。一张网卡至少可以搭配一个以上的网络接口；而每部主机内部其实也都拥有一个内部的网络接口，那就是 loopback (lo) 这个循环测试接口！</li><li><strong>网络形态或拓朴 (topology)：</strong>各个节点在网络上面的链接方式，一般讲的是物理连接方式。举例来说，上图中显示的是一种被称为星形联机 (star) 的方式，主要是透过一个中间连接设备，以放射状的方式连接各个节点的一种形态，这就是一种拓朴。</li><li><strong>网关 (route) 或通讯闸 (gateway)：</strong>具有两个以上的网络接口，可以连接两个以上不同的网段的设备，例如 IP 分享器就是一个常见的网关设备。那上面的 ADSL 调制解调器算不算网关呢？其实不太能算，因为调制解调器通常视为一个在主机内的网卡设备，我们可以在一般 PC 上面透过拨号软件， 将调制解调器仿真成为一张实体网卡 (ppp) ，因此他不太能算是网关设备！</li></ul><p>网络设备其实非常多也非常复杂，不过如果以小型企业角度来看，我们能够了解上述图示内各设备的角色，那应该也足够了！接下来，让我们继续来讨论一下网络范围的大小吧！</p><h3 id="2、计算机网络区域范围"><a href="#2、计算机网络区域范围" class="headerlink" title="2、计算机网络区域范围"></a>2、计算机网络区域范围</h3><p>由于各个节点的距离不同，联机的线材与方式也有所差异，由于线材的差异也导致网络速度的不同，让网络的应用方向也不一样。 根据这些差异，早期我们习惯将网络的大小范围定义如下：</p><blockquote><ol><li>局域网络 (Local Area Network, LAN)：<br>节点之间的传输距离较近，例如一栋大楼内，或一个学校的校区内。可以使用较为昂贵的联机材料， 例如光纤或是高质量网络线 (CAT 6) 等。网络速度较快，联机质量较佳且可靠，因此可应用于科学运算的丛集式系统、 分布式系统、云端负荷分担系统等。</li><li>广域网 (Wide Area Network, WAN)：<br>传输距离较远，例如城市与城市之间的距离，因此使用的联机媒体需要较为便宜的设备，例如经常使用的电话线就是一例。 由于线材质量较差，因此网络速度较慢且可靠性较低一些，网络应用方面大多为类似 email, FTP, WWW 浏览等功能。</li></ol></blockquote><p>除了这两个之外，还有所谓的都会网络 (Metropolitan Area Network, MAN)，不过近来比较少提及，因此你只要知道有 LAN 及 WAN 即可。这两个名词在很多地方你都可以看的到。改天你回家看看你家的 ADSL 调制解调器或 IP 分享器后面的插孔看看，你就能够看到有 WAN 与 LAN 的插孔，现在你就知道为啥有这两个灯号与插孔了吧。</p><h3 id="3、计算机网络协议：-OSI-七层协定"><a href="#3、计算机网络协议：-OSI-七层协定" class="headerlink" title="3、计算机网络协议： OSI 七层协定"></a>3、计算机网络协议： OSI 七层协定</h3><p>我们可以将整个网络连接过程分成数个阶层 (layer)，每个阶层都有特别的独立的功能，而且每个阶层的程序代码可以独立撰写，因为每个阶层之间的功能并不会互相干扰的。 如此一来，当某个小环节出现问题时，只要将该层级的程序代码重新撰写即可。所以程序撰写也容易，整个网络概念也就更清晰！ 那就是目前你常听到的 OSI 七层协议 (Open System Interconnection) 的概念。<br>依据定义来说，越接近硬件的阶层为底层 (layer 1)，越接近应用程序的则是高层 (layer 7) 。不论是接收端还是发送端，每个一阶层只认识对方的同一阶层数据。</p><p><img src="/uploads/2018/01/network_osi_01.JPG" alt=""><br>上图中仔细看每个数据报的部分，上层的包裹是放入下层的数据中，而数据前面则是这个数据的表头。其中比较特殊的是第二层，因为第二层 (数据链结层) 主要是位于软件封包 (packet) 以及硬件讯框 (frame) 中间的一个阶层，他必须要将软件包装的包裹放入到硬件能够处理的包裹中，因此这个阶层又分为两个子层在处理相对应的数据。因为比较特殊，所以第二层的数据格式比较不一样，尾端还出现一个检查码.<br>简单的说，每一层负责的任务如下：</p><style type="text/css">table th:first-of-type {    width: 150px;}</style><table><thead><tr><th>分层</th><th>负责任务</th></tr></thead><tbody><tr><td>Layer 1<br>物理层<br>Physical Layer</td><td>由于网络媒体只能传送 0 与 1 这种位串，因此物理层必须定义所使用的媒体设备之电压与讯号等， 同时还必须了解数据讯框转成位串的编码方式，最后连接实体媒体并传送/接收位串。</td></tr><tr><td>Layer 2<br>数据链结层<br>Data-Link Layer</td><td>这一层是比较特殊的一个阶层，因为底下是实体的定义，而上层则是软件封装的定义。因此第二层又分两个子层在进行数据的转换动作。 在偏硬件媒体部分，主要负责的是 MAC(Media Access Control) ，我们称这个数据报裹为 MAC 讯框 (frame)， MAC 是网络媒体所能处理的主要数据报裹，这也是最终被物理层编码成位串的数据。MAC 必须要经由通讯协议来取得媒体的使用权， 目前最常使用的则是 IEEE802.3 的以太网络协议。详细的 MAC 与以太网络请参考下节说明。<br>至于偏向软件的部分则是由逻辑链接层 (logical linkcontrol, LLC) 所控制，主要在多任务处理来自上层的封包数据 (packet) 并转成 MAC 的格式， 负责的工作包括讯息交换、流量控制、失误问题的处理等等。</td></tr><tr><td>Layer 3<br>网络层<br>Network Layer</td><td>这一层是我们最感兴趣的啰，因为我们提及的 IP (Internet Protocol) 就是在这一层定义的。 同时也定义出计算机之间的联机建立、终止与维持等，数据封包的传输路径选择等等，因此这个层级当中最重要的除了 IP 之外，就是封包能否到达目的地的路由 (route) 概念了！</td></tr><tr><td>Layer 4<br>传送层<br>Transport Layer</td><td>这一个分层定义了发送端与接收端的联机技术(如 TCP, UDP技术)， 同时包括该技术的封包格式，数据封包的传送、流程的控制、传输过程的侦测检查与复原重新传送等等， 以确保各个资料封包可以正确无误的到达目的端。</td></tr><tr><td>Layer 5<br>会谈层<br>Session Layer</td><td>在这个层级当中主要定义了两个地址之间的联机信道之连接与挂断，此外，亦可建立应用程序之对谈、 提供其他加强型服务如网络管理、签到签退、对谈之控制等等。如果说传送层是在判断资料封包是否可以正确的到达目标， 那么会谈层则是在确定网络服务建立联机的确认。</td></tr><tr><td>Layer 6<br>表现层<br>Presentation Layer</td><td>我们在应用程序上面所制作出来的数据格式不一定符合网络传输的标准编码格式的！ 所以，在这个层级当中，主要的动作就是：将来自本地端应用程序的数据格式转换(或者是重新编码)成为网络的标准格式， 然后再交给底下传送层等的协议来进行处理。所以，在这个层级上面主要定义的是网络服务(或程序)之间的数据格式的转换， 包括数据的加解密也是在这个分层上面处理。</td></tr><tr><td>Layer 7<br>应用层<br>Application Layer</td><td>应用层本身并不属于应用程序所有，而是在定义应用程序如何进入此层的沟通接口，以将数据接收或传送给应用程序，最终展示给用户。</td></tr></tbody></table><p>事实上，OSI 七层协议只是一个参考的模型 (model)，目前的网络社会并没有什么很知名的操作系统在使用 OSI 七层协议的联网程序代码。那…讲这么多干嘛？这是因为 OSI 所定义出来的七层协议在解释网络传输的情况来说，可以解释的非常棒，因此大家都拿 OSI 七层协议来做为网络的教学与概念的理解。至于实际的联网程序代码，那就交给 TCP/IP 了！</p><h3 id="4、计算机网络协议：-TCP-IP"><a href="#4、计算机网络协议：-TCP-IP" class="headerlink" title="4、计算机网络协议： TCP/IP"></a>4、计算机网络协议： TCP/IP</h3><p>虽然 OSI 七层协议的架构非常严谨，是学习网络的好材料。但是也就是因为太过严谨了，因此程序撰写相当不容易，所以造成它在发展上面些许的困扰。而由 ARPANET 发展而来的 TCP/IP 又如何呢？其实 TCP/IP 也是使用 OSI 七层协议的观念，所以同样具有分层的架构，只是将它简化为四层，在结构上面比较没有这么严谨，程序撰写会比较容易些。后来在 1990 年代由于 email, WWW 的流行，造成 TCP/IP 这个标准为大家所接受，这也造就目前我们的网络社会！</p><p>既然 TCP/IP 是由 OSI 七层协议简化而来，那么这两者之间有没有什么相关性呢？它们的相关性可以图示如下， 同时这里也列出目前在这架构底下常见的通讯协议、封包格式与相关标准：<br><img src="/uploads/2018/01/network_osi_tcpip.JPG" alt=""></p><p>从上图中，我们可以发现 TCP/IP 将应用、表现、会谈三层整合成一个应用层，在应用层上面可以实作的程序协议有 HTTP, SMTP, DNS 等等。 传送层则没有变，不过依据传送的可靠性又将封包格式分为连接导向的 TCP 及非连接导向的 UDP 封包格式。网络层也没有变，主要内容是提供了 IP 封包，并可选择最佳路由来到达目标 IP 地址。数据链结层与物理层则整合成为一个链结层，包括定义硬件讯号、 讯框转位串的编码等等，因此主要与硬件 (不论是区网还是广域网) 有关。</p><p>那 TCP/IP 是如何运作的呢？我们就拿妳常常连上的 Yahoo 入口网站来做个说明好了，整个联机的状态可以这样看：</p><blockquote><p>1.应用程序阶段：妳打开浏览器，在浏览器上面输入网址列，按下 [Enter]。此时网址列与相关数据会被浏览器包成一个数据， 并向下传给 TCP/IP 的应用层；<br>2.应用层：由应用层提供的 HTTP 通讯协议，将来自浏览器的数据报起来，并给予一个应用层表头，再向传送层丢去；<br>3.传送层：由于 HTTP 为可靠联机，因此将该数据丢入 TCP 封包内，并给予一个 TCP 封包的表头，向网络层丢去；<br>4.网络层：将 TCP 包裹包进 IP 封包内，再给予一个 IP 表头 (主要就是来源与目标的 IP)，向链结层丢去；<br>5.链结层：如果使用以太网络时，此时 IP 会依据 CSMA/CD 的标准，包裹到MAC 讯框中，并给予 MAC 表头，再转成位串后， 利用传输媒体传送到远程主机上。</p></blockquote><p>等到 Yahoo 收到你的包裹后，在依据相反方向拆解开来，然后交给对应的层级进行分析，最后就让 Yahoo 的 WWW 服务器软件得到你所想要的数据，该服务器软件再根据你的要求，取得正确的资料后，又依循上述的流程，一层一层的包装起来， 最后传送到你的手上！就是这样！</p><p>根据这样的流程，我们就得要知道每个分层所需要了解的基础知识，这样才算学习网络基础.所以下面一节我们会依据 TCP/IP 的链结层、网络层、传送层来进行说明，应用层的协议则在以后对应的协定再来谈！</p><h3 id="5、Linux-网络相关配置文件案"><a href="#5、Linux-网络相关配置文件案" class="headerlink" title="5、Linux 网络相关配置文件案"></a>5、Linux 网络相关配置文件案</h3><p>我们知道 TCP/IP 的重要参数主要是： IP, Netmask, Gateway, DNS IP ，而且千万不要忘记你这部主机也应该要有主机名 (hostname)！此外，我们也知道 IP 的取得有手动设定、DHCP 处理等。那么这些参数主要是写在哪些配置文件？如何对应呢？底下就让我们来处理一番！</p><table><thead><tr><th>所需网络参数</th><th>主要配置文件档名</th><th>重要参数</th></tr></thead><tbody><tr><td>IP、Netmask、DHCP 与 Gateway 等<br></td><td>/etc/sysconfig/network-scripts/ifcfg-eth0</td><td>DEVICE=网卡的代号<br>BOOTPROTO=是否使用 dhcp<br>HWADDR=是否加入网卡卡号(MAC)<br>IPADDR=就是IP 地址<br>NETMASK=指网络屏蔽<br>ONBOOT=要不要默认启动此接口<br>GATEWAY=就是通讯闸<br>NM_CONTROLLED=额外的网管软件</td></tr><tr><td>主机名</td><td>/etc/sysconfig/network</td><td>NETWORKING=要不要有网络<br>NETWORKING_IPV6=支援IPv6 否？<br>HOSTNAME=你的主机名</td></tr><tr><td>DNS IP</td><td>/etc/resolv.conf</td><td>nameserver DNS 的IP</td></tr><tr><td>私有IP对应的主机名</td><td>/etc/hosts</td><td>私有IP 主机名 别名</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、计算机网络组成组件&quot;&gt;&lt;a href=&quot;#1、计算机网络组成组件&quot; class=&quot;headerlink&quot; title=&quot;1、计算机网络组成组件&quot;&gt;&lt;/a&gt;1、计算机网络组成组件&lt;/h3&gt;&lt;p&gt;我们以底下这张联机示意图来解释好了：&lt;br&gt;&lt;img src=&quot;/uploads/2018/01/network_component.JPG&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜服务器架设篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux之定时任务详解</title>
    <link href="http://yoursite.com/2018/01/04/Linux%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/04/Linux之定时任务详解/</id>
    <published>2018-01-04T06:17:53.000Z</published>
    <updated>2018-01-18T07:01:55.911Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Linux-工作排程的种类：-at-cron"><a href="#1、Linux-工作排程的种类：-at-cron" class="headerlink" title="1、Linux 工作排程的种类： at, cron"></a>1、Linux 工作排程的种类： at, cron</h3><ol><li>at ：at 是个可以处理仅执行一次就结束排程的指令，不过要执行 at 时，必须要有 atd 这个服务的支援才行。在某些新版的 distributions 中，atd 可能预设并没有启动，那么 at 这个指令就会失效！不过我们的 CentOS 预设是启动的。</li><li>crontab ：crontab 这个指令所设定的工作将会循环的一直进行下去！可循环的时间为分钟、小时、每周、每月或每年等。crontab 除了可以使用指令执行外，亦可编辑 /etc/crontab 来支持。至于让 crontab 可以生效的服务则是 crond 这个服务。<a id="more"></a></li></ol><h3 id="2、atd-的启动与-at-运作的方式"><a href="#2、atd-的启动与-at-运作的方式" class="headerlink" title="2、atd 的启动与 at 运作的方式"></a>2、atd 的启动与 at 运作的方式</h3><p>要使用单一工作排程时，我们的 Linux 系统上面必须要有负责这个排程的服务，那就是 atd ！不过并非所有的 Linux distributions 都预设会把他打开的，所以，某些时刻我们必须要手动将他启用才行。启用的方法很简单，就是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# /etc/init.d/atd restart</span><br><span class="line">正在停止 atd: [ 确定 ]</span><br><span class="line">正在激活 atd: [ 确定 ]</span><br><span class="line"># 再设定一下开机时就启动这个服务，免得每次重新启动都得再来一次！</span><br><span class="line">[root@www ~]# chkconfig atd on</span><br></pre></td></tr></table></figure></p><h4 id="（1）at-的运作方式"><a href="#（1）at-的运作方式" class="headerlink" title="（1）at 的运作方式"></a>（1）at 的运作方式</h4><p>既然是工作排程，那么应该会有产生工作的方式，并且将这些工作排进行程表中！那么产生工作的方式是怎么进行的？事实上，我们使用 at 这个指令来产生所要运作的工作，并将这个工作以文本文件的方式写入 /var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与执行了。就这么简单。<br>不过，并不是所有的人都可以进行 at 工作排程！为什么？因为安全的理由，很多主机被所谓的【绑架】后，最常发现的就是他们的系统当中多了很多的怪客程序 (cracker program)， 这些程序非常可能运用工作排程来执行或搜集系统信息，并定时的回报给怪客团体！所以，除非是你认可的账号，否则先不要让他们使用 at ！那怎么达到使用 at 的列管呢？<br>我们可以利用 /etc/at.allow 与 /etc/at.deny 这两个档案来进行 at 的使用限制！加上这两个档案后，at 的工作情况其实是这样的：</p><ol><li>先找寻 /etc/at.allow 这个档案，写在这个档案中的使用者才能使用 at ，没有在这个档案中的使用者则不能使用 at (即使没有写在 at.deny 当中)；</li><li>如果 /etc/at.allow 不存在，就寻找 /etc/at.deny 这个档案，若写在这个 at.deny 的使用者则不能使用at ，而没有在这个 at.deny 档案中的使用者，就可以使用 at ；</li><li>如果两个档案都不存在，那么只有 root 可以使用 at 这个指令。</li></ol><p>透过这个说明，我们知道 /etc/at.allow 是管理较为严格的方式，而 /etc/at.deny 则较为松散 (因为账号没有在该档案中，就能够执行 at 了)。在一般的 distributions 当中，由于假设系统上的所有用户都是可信任的，因此系统通常会保留一个空的 /etc/at.deny 档案，意思是允讲所有人使用 at 指令的意思 (您可以自行检查一下该档案)。不过，万一你不希望有某些使用者使用 at 的话，将那个使用者的账号写入 /etc/at.deny 即可！一个账号写一行。</p><h4 id="（2）实际运作单一工作排程"><a href="#（2）实际运作单一工作排程" class="headerlink" title="（2）实际运作单一工作排程"></a>（2）实际运作单一工作排程</h4><p>基本的语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# at [-mldv] TIME</span><br><span class="line">[root@www ~]# at -c 工作号码</span><br><span class="line">选项与参数：</span><br><span class="line">-m ：当 at 的工作完成后，即使没有输出讯息，亦以 email 通知使用者该工作已完成。</span><br><span class="line">-l ：at -l 相当于 atq，列出目前系统上面的所有该用户的 at 排程；</span><br><span class="line">-d ：at -d 相当于 atrm ，可以取消一个在 at 排程中的工作；</span><br><span class="line">-v ：可以使用较明显的时间格式栏出 at 排程中的任务栏表；</span><br><span class="line">-c ：可以列出后面接的该项工作的实际指令内容。</span><br><span class="line">TIME：时间格式，这里可以定义出【什么时候要进行 at 这项工作】的时间，格式有：</span><br><span class="line">HH:MM ex&gt; 04:00</span><br><span class="line">在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此工作。</span><br><span class="line">HH:MM YYYY-MM-DD ex&gt; 04:00 2009-03-17</span><br><span class="line">强制规定在某年某月的某一天的特殊时刻进行该工作！</span><br><span class="line">HH:MM[am|pm] [Month] [Date] ex&gt; 04pm March 17</span><br><span class="line">也是一样，强制在某年某月某日的某时刻进行！</span><br><span class="line">HH:MM[am|pm] + number [minutes|hours|days|weeks]</span><br><span class="line">ex&gt; now + 5 minutes ex&gt; 04pm + 3 days</span><br><span class="line">就是说，在某个时间点【再加几个时间后】才进行。</span><br></pre></td></tr></table></figure></p><p>老实说，这个 at 指令的下达最重要的地方在于【时间】的指定了！一般使用【 now + … 】的方式来定义现在过多少时间再进行工作，但有时也需要定义特定的时间点来进行！底下的范例先看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">范例一：再过五分钟后，将 /root/.bashrc 寄给 root 自己</span><br><span class="line">[root@www ~]# at now + 5 minutes &lt;==记得单位要加 s</span><br><span class="line">at&gt; /bin/mail root -s &quot;testing at job&quot; &lt; /root/.bashrc</span><br><span class="line">at&gt; &lt;EOT&gt; &lt;==这里输入 [ctrl] + d 就会出现 &lt;EOF&gt; 的字样！代表结束！</span><br><span class="line">job 4 at 2009-03-14 15:38</span><br><span class="line"># 上面这行信息在说明，第 4 个 at 工作将在 2009/03/14 的 15:38 进行！</span><br><span class="line"># 而执行 at 会进入所谓的 at shell 环境，让你下达多重指令等待运作！</span><br><span class="line">范例二：将上述的第 4 项工作内容列出来查阅</span><br><span class="line">[root@www ~]# at -c 4</span><br><span class="line">#!/bin/sh &lt;==就是透过 bash shell </span><br><span class="line"># atrun uid=0 gid=0</span><br><span class="line"># mail root 0</span><br><span class="line">umask 22</span><br><span class="line">....(中间省略许多的环境变量项目)....</span><br><span class="line">cd /root || &#123; &lt;==可以看出，会到下达 at 时的工作目录去执行指令</span><br><span class="line">echo &apos;Execution directory inaccessible&apos; &gt;&amp;2</span><br><span class="line">exit 1</span><br><span class="line">&#125;</span><br><span class="line">/bin/mail root -s &quot;testing at job&quot; &lt; /root/.bashrc</span><br><span class="line"># 你可以看到指令执行的目录 (/root)，还有多个环境变量与实际的指令内容</span><br><span class="line">范例三：由于机房预计于 2009/03/18 停电，我想要在 2009/03/17 23:00 关机？</span><br><span class="line">[root@www ~]# at 23:00 2009-03-17</span><br><span class="line">at&gt; /bin/sync</span><br><span class="line">at&gt; /bin/sync</span><br><span class="line">at&gt; /sbin/shutdown -h now</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 5 at 2009-03-17 23:00</span><br><span class="line"># at 还可以在一个工作内输入多个指令</span><br></pre></td></tr></table></figure></p><p>事实上，当我们使用 at 时会进入一个 at shell 的环境来让用户下达工作指令，此时，建议你最好使用绝对路径来下达你的指令，比较不会有问题！由于指令的下达与 PATH 变量有关，同时与当时的工作目录也有关连(如果有牵涉到档案的话)，因此使用绝对路径来下达指令，会是比较一劳永逸的方法。</p><p>at 有另外一个很棒的优点，那就是【背景执行】的功能！由于 at 工作排程的使用上，系统会将该项 at 工作独立出你的 bash 环境中，直接交给系统的 atd 程序来接管，因此，当你下达了 at 的工作之后就可以立刻脱机了，剩下的工作就完全交给 Linux 管理即可！所以，如果有长时间的网络工作时，使用 at 可以让你免除网络断线后的困扰！</p><h3 id="3、循环执行的例行性工作排程"><a href="#3、循环执行的例行性工作排程" class="headerlink" title="3、循环执行的例行性工作排程"></a>3、循环执行的例行性工作排程</h3><p>相对于 at 是仅执行一次的工作，循环执行的例行性工作排程则是由 cron (crond) 这个系统服务来控制的。刚刚谈过 Linux 系统上面原本就有非常多的例行性工作，因此这个系统服务是默认启动的。另外，由于使用者自己也可以进行例行性工作排程，所以，Linux 也提供使用者控制例行性工作排程的指令(crontab)。底下我们分别来聊一聊：</p><h4 id="（1）使用者的设定"><a href="#（1）使用者的设定" class="headerlink" title="（1）使用者的设定"></a>（1）使用者的设定</h4><p>使用者想要建立循环型工作排程时，使用的是 crontab 这个指令。不过，为了安全性的问题，与 at 同样的，我们可以限制使用 crontab 的使用者账号！使用的限制数据有：</p><ul><li>/etc/cron.allow：将可以使用 crontab 的账号写入其中，若不在这个档案内的使用者则不可使用 crontab；</li><li>/etc/cron.deny：将不可以使用 crontab 的账号写入其中，若未记录到这个档案当中的使用者，就可以使用crontab 。</li></ul><p>与 at 很像。同样的，以优先级来说，/etc/cron.allow 比 /etc/cron.deny 要优先，而判断上面，这两个档案只选择一个来限制而已，因此，建议你只要保留一个即可，免得影响自己在设定上面的判断！一般来说，系统默认是保留 /etc/cron.deny，你可以将不想让他执行 crontab 的那个使用者写入 /etc/cron.deny 当中，一个账号一行！</p><p>当用户使用 crontab 这个指令来建立工作排程之后，该项工作就会被记录到 /var/spool/cron/ 里面去，而且是以账号来作为判别的。举例来说，dmtsai 使用 crontab 后，他的工作会被记录到 /var/spool/cron/dmtsai 里头去！但请注意，不要使用 vi 直接编辑该档案，因为可能由于输入语法错误，会导致无法执行 cron 。另外，cron 执行的每一项工作都会被记录到 /var/log/cron 这个登录档中，所以，如果你的 Linux 不知道有否被植入木马时，也可以搜寻一下 /var/log/cron 这个登录档！</p><h4 id="（2）crontab-的语法："><a href="#（2）crontab-的语法：" class="headerlink" title="（2）crontab 的语法："></a>（2）crontab 的语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# crontab [-u username] [-l|-e|-r]</span><br><span class="line">选项与参数：</span><br><span class="line">-u ：只有 root 才能进行这个任务，亦即帮其他使用者建立/移除 crontab 工作排程；</span><br><span class="line">-e ：编辑 crontab 的工作内容</span><br><span class="line">-l ：查阅 crontab 的工作内容</span><br><span class="line">-r ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。</span><br><span class="line">范例一：用 dmtsai 的身份在每天的 12:00 发信给自己</span><br><span class="line">[dmtsai@www ~]$ crontab -e</span><br><span class="line"># 此时会进入 vi 的编辑画面让您编辑工作！注意到，每项工作都是一行。</span><br><span class="line">0 12 * * * mail dmtsai -s &quot;at 12:00&quot; &lt; /home/dmtsai/.bashrc</span><br><span class="line">#分 时 日 月 周 |&lt;==============指令串========================&gt;|</span><br></pre></td></tr></table></figure><p>预设情况下，任何使用者只要不被列入 /etc/cron.deny 当中，那么他就可以直接下达【 crontab -e 】去编辑自己的例行性命令。整个过程就如同上面提到的，会进入 vi 的编辑画面，然后以一个工作一行来编辑，编辑完毕之后输入【 :wq 】储存后离开 vi 就可以了。而每项工作 (每行) 的格式都是具有六个字段，这六个字段的意义为：<br><img src="/uploads/2018/01/linux_crontab_01.png" alt=""><br>比较有趣的是那个【周】，周的数字为 0 或 7 时，都代表【星期天】的意思！另外，还有一些辅助的字符，大概有底下这些：<br><img src="/uploads/2018/01/linux_crontab_02.png" alt=""><br><strong>（注：那个 crontab 每个人都只有一个档案存在，就是在 /var/spool/cron 里面！还有建议：【指令下达时，最好使用绝对路径，这样比较不会找不到执行档。】）</strong></p><h4 id="（3）系统的配置文件：-etc-crontab"><a href="#（3）系统的配置文件：-etc-crontab" class="headerlink" title="（3）系统的配置文件： /etc/crontab"></a>（3）系统的配置文件： /etc/crontab</h4><p>如果是【系统的例行性任务】时，你只要编辑 /etc/crontab 这个档案就可以。有一点需要特别注意！那就是 crontab -e 这个 crontab 其实是 /usr/bin/crontab 这个执行档，但是 /etc/crontab 可是一个【纯文本档】。你可以 root 的身份编辑一下这个档案。<br>基本上， cron 这个服务的最低侦测限制是【分钟】，所以【 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron 里面的数据内容 】，因此，只要你编辑完 /etc/crontab 这个档案，并且将他储存之后，那么 cron 的设定就自动的会来执行了。</p><p>下面是 /etc/crontab 的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat /etc/crontab</span><br><span class="line">SHELL=/bin/bash &lt;==使用哪种 shell 接口</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin &lt;==执行文件搜寻路径</span><br><span class="line">MAILTO=root &lt;==若有额外STDOUT，以 email 将数据送给谁</span><br><span class="line">HOME=/ &lt;==默认此 shell 的家目录所在</span><br><span class="line"># run-parts</span><br><span class="line">01 * * * * root run-parts /etc/cron.hourly &lt;==每小时</span><br><span class="line">02 4 * * * root run-parts /etc/cron.daily &lt;==每天</span><br><span class="line">22 4 * * 0 root run-parts /etc/cron.weekly &lt;==每周日</span><br><span class="line">42 4 1 * * root run-parts /etc/cron.monthly &lt;==每个月 1 号</span><br><span class="line">分 时 日 月 周 执行者身份 指令串</span><br></pre></td></tr></table></figure></p><p>看到这个档案的内容你大概就了解了吧。这个档案与将刚刚我们下达 crontab -e 的内容几乎完全一模一样！只是有几个地方不太相同：</p><blockquote><p><strong>MAILTO=root：</strong><br>    这个项目是说，当 /etc/crontab 这个档案中的例行性工作的指令发生错误时，或者是该工作的执行结果有 STDOUT/STDERR 时，会将错误讯息或者是屏幕显示的讯息传给谁？默认当然是由系统直接寄发一封 mail 给 root。不过，由于 root 并无法在客户端中以 POP3 之类的软件收信，因此，通常都将这个 e-mail 改成自己的账号，好随时了解系统的状况！例如：MAILTO=dmtsai@my.host.name<br><strong>PATH=….：</strong><br>    在 BASH 当中一直提到的执行文件路径问题。这里就是输入执行文件的搜寻路径！使用默认的路径设定就已经很足够了。<br><strong>01 <em> </em> <em> </em> root run-parts /etc/cron.hourly：</strong><br>    这个 /etc/crontab 里面默认定义出四项工作任务，分别是每小时、每天、每周及每个月分别进行一次的工作！但是在五个字段后面接的并不是挃令，而是一个新的字段，那就是【执行后面那串指令的身份】为何。这不使用者的 crontab -e 不相同。由于使用者自己的 crontab 并不需要指定身份，但 /etc/crontab 里面当然要指定身份。以上表的内容来说，系统默认的例行性工作是以 root 的身份来进行的。<br>    那么后面那串指令是什么呢？你可以使用【 which run-parts 】搜寻看看，其实那是一个 bash script！如果你直接进入 /usr/bin/run-parts 去看看，会发现这支指令会将后面接的【目录】内的所有档案捉出来执行！这也就是说【如果你想让系统每小时主动帮你执行某个指令，将该指令写成 script，并将该档案放置到 /etc/cron.hourly/ 目录下即可】的意思。<br>    现在你知道系统是如何进行他默认的一堆例行性工作排程了吗？如果你下达【 ll /etc/cron.daily 】就可以看到一堆档案，那些档案就是系统提供的 script ，而这堆 scripts 将会在每天的凌晨 4:02 开始运作！这也是为啥如果你是夜猫族，就会发现奇怪的是，Linux 系统为何早上 4:02 开始会很忙碌的发出一些硬盘跑动的声音！因为他必须要进行 makewhatis,pdatedb, rpm rebuild 等等的任务。</p></blockquote><p>由于 CentOS 提供的 run-parts 这个 script 的辅助，因此 /etc/crontab 这个档案里面支持两种下达指令的方式，一种是直接下达指令，一种则是以目录来规划，例如：</p><blockquote><p><strong>指令型态</strong><br><code>01 * * * * dmtsai mail -s &quot;testing&quot; kiki &lt; /home/dmtsai/test.txt</code><br>以 dmtsai 这个使用者的身份，在每小时执行一次 mail 指令。<br><strong>目录规划</strong><br><code>*/5 * * * * root run-parts /root/runcron</code><br>建立一个 /root/runcron 的目录，将要每隔五分钟执行的【可执行文件】都写到该目录下，就可以让系统每五分钟执行一次该目录下的所有可执行文件。</p></blockquote><h3 id="4、一些注意事项："><a href="#4、一些注意事项：" class="headerlink" title="4、一些注意事项："></a>4、一些注意事项：</h3><h4 id="（1）资源分配不均的问题"><a href="#（1）资源分配不均的问题" class="headerlink" title="（1）资源分配不均的问题"></a>（1）资源分配不均的问题</h4><p>如果每个流程都在同一个时间启动的话，那么在某个时段时，我的系统会变的相当的繁忙，所以，这个时候就必须要分别设定。我可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# vi /etc/crontab</span><br><span class="line">1,6,11,16,21,26,31,36,41,46,51,56 * * * * root CMD1</span><br><span class="line">2,7,12,17,22,27,32,37,42,47,52,57 * * * * root CMD2</span><br><span class="line">3,8,13,18,23,28,33,38,43,48,53,58 * * * * root CMD3</span><br><span class="line">4,9,14,19,24,29,34,39,44,49,54,59 * * * * root CMD4</span><br></pre></td></tr></table></figure></p><p>看到了没？那个【 , 】分隔的时候，请注意，不要有空格符！（连续的意思）如此一来，则可以将每五分钟工作的流程分别在不同的时刻来工作！则可以让系统的执行较为顺畅！</p><h4 id="（2）取消不要的输出项目"><a href="#（2）取消不要的输出项目" class="headerlink" title="（2）取消不要的输出项目"></a>（2）取消不要的输出项目</h4><p>另外一个困扰发生在【 当有执行成果或者是执行的项目中有输出的数据时，该数据将会 mail 给 MAILTO 设定的账号 】，那么当有一个排程一直出错（例如 DNS 的侦测系统当中，若 DNS 上层主机挂掉，那么你就会一直收到错误讯息！）怎么办？可以使用数据流重导向直接以【命令重导向】将输出的结果输出到 /dev/null 这个垃圾桶当中就好了！</p><h4 id="（3）安全的检验"><a href="#（3）安全的检验" class="headerlink" title="（3）安全的检验"></a>（3）安全的检验</h4><p>很多时候被植入木马都是以例行命令的方式植入的，所以可以藉由检查 /var/log/cron 的内容来视察是否有【非您设定的 cron 被执行了？】这个时候就需要小心一点！</p><h4 id="（4）周与日月不可同时并存"><a href="#（4）周与日月不可同时并存" class="headerlink" title="（4）周与日月不可同时并存"></a>（4）周与日月不可同时并存</h4><p>另一个需要注意的地方在于：【你可以分别以周或者是日月为单位作为循环，但你不可使用「几月几号且为星期几」的模式工作】。这个意思是说，你不可以这样编写一个工作排程：<br>    30 12 11 9 5 root echo “just test” &lt;==这是错诨癿写法<br>本来你以为九月十一号且为星期五才会进行这项工作，无奈的是，系统可能会判定每个星期五作一次，或每年的 9 月 11 号分别进行，如此一来与你当初的规划就不一样了。所以，得要注意这个地方！上述的写法是不对的！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、Linux-工作排程的种类：-at-cron&quot;&gt;&lt;a href=&quot;#1、Linux-工作排程的种类：-at-cron&quot; class=&quot;headerlink&quot; title=&quot;1、Linux 工作排程的种类： at, cron&quot;&gt;&lt;/a&gt;1、Linux 工作排程的种类： at, cron&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;at ：at 是个可以处理仅执行一次就结束排程的指令，不过要执行 at 时，必须要有 atd 这个服务的支援才行。在某些新版的 distributions 中，atd 可能预设并没有启动，那么 at 这个指令就会失效！不过我们的 CentOS 预设是启动的。&lt;/li&gt;
&lt;li&gt;crontab ：crontab 这个指令所设定的工作将会循环的一直进行下去！可循环的时间为分钟、小时、每周、每月或每年等。crontab 除了可以使用指令执行外，亦可编辑 /etc/crontab 来支持。至于让 crontab 可以生效的服务则是 crond 这个服务。
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Crontab" scheme="http://yoursite.com/tags/Crontab/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之Shell Scripts</title>
    <link href="http://yoursite.com/2018/01/03/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8BShell-Scripts/"/>
    <id>http://yoursite.com/2018/01/03/认识与学习BASH之Shell-Scripts/</id>
    <published>2018-01-03T09:14:14.000Z</published>
    <updated>2018-01-24T10:43:34.145Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是Shell-Script"><a href="#一、什么是Shell-Script" class="headerlink" title="一、什么是Shell Script"></a>一、什么是Shell Script</h3><p>什么是 shell script (程序化脚本) 呢？就字面上的意义，我们将他分为两部份。在【 shell 】部分，我们在 BASH 当中已经提过了，那是一个文字接口底下让我们与系统沟通的一个工具接口。那么【 script 】是啥？字面上的意义，script 是【脚本、剧本】的意思。整句话是说，shell script 是针对 shell 所写的【剧本！】</p><p>什么东西啊？其实，shell script 是利用 shell 的功能所写的一个【程序 (program)】，这个程序是使用纯文本文件，将一些 shell 的语法与指令(含外部指令)写在里面，搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的。<br><a id="more"></a><br>所以，简单的说，shell script 就像是早期 DOS 年代的批处理文件 (.bat) ，最简单的功能就是将许多指令汇整写在一起，让使用者很轻易的就能够 one touch 的方法去处理复杂的动作 (执行一个档案”shell script” ，就能够一次执行多个指令)。而且 shell script 更提供数组、循环、条件与逻辑判断等重要功能，让用户也可以直接以 shell 来撰写程序，而不必使用类似 C 程序语言等传统程序撰写的语法。shell script 可以简单的被看成是批处理文件，也可以被说成是一个程序语言，且这个程序语言由于都是利用 shell 与相关工具指令，所以不需要编译即可执行，且拥有不错的除错 (debug) 工具，所以，他可以帮助系统管理员快速的管理好主机。</p><p>shell script 号称是程序 (program) ，但实际上，shell script 处理数据的速度上是不太够的。因为 shell script 用的是外部的指令与 bash shell 的一些默认工具，所以，他常常会去呼叫外部的函式库，因此，指令周期上面当然比不上传统的程序语言。所以，shell script 用在系统管理上面是很好的一项工具，但是用在处理大量数值运算上，就不够好了，因为 Shell scripts 的速度较慢，且使用的 CPU 资源较多，造成主机资源的分配不良。我们通常利用 shell script 来处理服务器的侦测，倒是没有进行大量运算的需求！所以不必担心。</p><h4 id="Shell执行及注意事项"><a href="#Shell执行及注意事项" class="headerlink" title="Shell执行及注意事项"></a>Shell执行及注意事项</h4><p>在 shell script 的撰写中还需要用到底下的注意事项：</p><ol><li>指令的执行是从上而下、从左而右的分析与执行；</li><li>指令的下达就是： 指令、选项与参数间的多个空白都会被忽略掉；</li><li>空白行也将被忽略掉，并且 [tab] 按键所推开的空白同样视为空格键；</li><li>如果读取到一个 Enter 符号 (CR) ，就尝试开始执行该行 (或该串) 命令；</li><li>至于如果一行的内容太多，则可以使用【 [Enter] 】来延伸至下一行；</li><li>【 # 】可做为批注！任何加在 # 后面的资料将全部被视为批注文字而被忽略！</li></ol><p>如此一来，我们在 script 内所撰写的程序，就会被一行一行的执行。现在我们假设你写的这个程序文件名是 /home/dmtsai/shell.sh 好了，那如何执行这个档案？很简单，可以有底下几个方法：</p><ul><li>直接指令下达： shell.sh 档案必须要具备可读与可执行 (rx) 的权限，然后：<ul><li>绝对路径：使用 /home/dmtsai/shell.sh 来下达指令；</li><li>相对路径：假设工作目录在 /home/dmtsai/ ，则使用 ./shell.sh 来执行</li><li>变量【PATH】功能：将 shell.sh 放在 PATH 指定的目录内，例如： ~/bin/(目录需要自行设定) 。此时，若 shell.sh 在 ~/bin 内且具有 rx 的权限，那就直接输入 shell.sh 即可执行该脚本程序！</li></ul></li><li>以 bash 程序来执行：透过【 bash shell.sh 】或【 sh shell.sh 】来执行</li></ul><p>反正重点就是要让那个 shell.sh 内的指令可以被执行的意思。</p><h3 id="二、简单的shell-script练习"><a href="#二、简单的shell-script练习" class="headerlink" title="二、简单的shell script练习"></a>二、简单的shell script练习</h3><h4 id="（1）撰写第一支-script：输出Hello-World！"><a href="#（1）撰写第一支-script：输出Hello-World！" class="headerlink" title="（1）撰写第一支 script：输出Hello World！"></a>（1）撰写第一支 script：输出Hello World！</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# mkdir scripts; cd scripts</span><br><span class="line">[root@www scripts]# vi sh01.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"># Program:</span><br><span class="line"># This program shows &quot;Hello World!&quot; in your screen.</span><br><span class="line"># History:</span><br><span class="line"># 2005/08/23 VBird First release</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line">echo -e &quot;Hello World! \a \n&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>在本章当中，请将所有撰写的 script 放置到你家目录的 ~/scripts 这个目录内，未来比较好管理。<br>上面的写法当中，主要将整个程序的撰写分成数段，大致是这样：</p><blockquote><p>1.第一行 #!/bin/bash 在宣告这个 script 使用的 shell 名称：<br>因为我们使用的是 bash ，所以，必须要以【 #!/bin/bash 】来宣告这个档案内的语法使用 bash 的语法！那么当这个程序被执行时，他就能够加载 bash 的相关环境配置文件 (一般来说就是 non-login shell 的 ~/.bashrc)， 并且执行 bash 来使我们底下的指令能够执行！这很重要！(在很多状况中，如果没有设定好这一行，那么该程序很可能会无法执行，因为系统可能无法判断该程序需要使用什么 shell 来执行！)<br>2.程序内容的说明：<br>整个 script 当中，除了第一行的【 #! 】是用来宣告 shell 的之外，其他的 # 都是【批注】用途！所以上面的程序当中，第二行以下就是用来说明整个程序的基本数据。一般来说，建议你一定要养成说明该 script 的：1. 内容与功能； 2. 版本信息； 3. 作者与联绚方式； 4. 建檔日期；5. 历史纪录 等等。这将有助于未来程序的改写与 debug。<br>3.主要环境变量的宣告：<br>建议务必要将一些重要的环境变量设定好，PATH 与 LANG (如果有使用到输出相关的信息时) 是当中最重要的！如此一来，则可让我们这支程序在进行时，可以直接下达一些外部指令，而不必写绝对路径！<br>4.主要程序部分<br>就将主要的程序写好即可！在这个例子当中，就是 echo 那一行！<br>5.执行成果告知 (定义回传值)<br>是否记得我们在讨论一个指令的执行成功与否，可以使用 $? 这个变量来观察。那么我们也可以利用 exit 这个指令来让程序中断，并且回传一个数值给系统。在我们这个例子当中，使用 exit 0 ，这代表离开 script 并且回传一个 0 给系统，所以我执行完这个 script 后，若接着下达 echo $? 则可得到 0 的值！更聪明的读者应该也知道，利用这个 exit n (n 是数字) 的功能，我们还可以自定义错误讯息，让这支程序发得更加的 smart ！接下来透过刚刚上头介绍的执行方法来执行看看结果吧。</p></blockquote><h4 id="（2）简单范例"><a href="#（2）简单范例" class="headerlink" title="（2）简单范例"></a>（2）简单范例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">（1）对谈式脚本：变量内容由用户决定</span><br><span class="line">[root@www scripts]# vi sh02.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"># Program:</span><br><span class="line"># User inputs his first name and last name. Program shows his full</span><br><span class="line">name.</span><br><span class="line"># History:</span><br><span class="line"># 2005/08/23 VBird First release</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line">read -p &quot;Please input your first name: &quot; firstname # 提示使用者输入</span><br><span class="line">read -p &quot;Please input your last name: &quot; lastname # 提示使用者输入</span><br><span class="line">echo -e &quot;\nYour full name is: $firstname $lastname&quot; # 结果由屏幕输出</span><br><span class="line"></span><br><span class="line">（2）随日期变化：利用date进行档案的建立</span><br><span class="line">[root@www scripts]# vi sh03.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"># Program:</span><br><span class="line"># Program creates three files, which named by user&apos;s input</span><br><span class="line"># and date command.</span><br><span class="line"># History:</span><br><span class="line"># 2005/08/23 VBird First release</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"># 1. 让使用者输入文件名，并取得 fileuser 这个变量；</span><br><span class="line">echo -e &quot;I will use &apos;touch&apos; command to create 3 files.&quot; # 纯粹显示信息</span><br><span class="line">read -p &quot;Please input your filename: &quot; fileuser # 提示使用者输入</span><br><span class="line"># 2. 为了避免使用者随意按 Enter ，利用变量功能分析档名是否有设定？</span><br><span class="line">filename=$&#123;fileuser:-&quot;filename&quot;&#125; # 开始判断有否配置文件名</span><br><span class="line"># 3. 开始利用 date 指令来取得所需要的档名；</span><br><span class="line">date1=$(date --date=&apos;2 days ago&apos; +%Y%m%d) # 前两天的日期</span><br><span class="line">date2=$(date --date=&apos;1 days ago&apos; +%Y%m%d) # 前一天的日期</span><br><span class="line">date3=$(date +%Y%m%d) # 今天的日期</span><br><span class="line">file1=$&#123;filename&#125;$&#123;date1&#125; # 底下三行在配置文件名</span><br><span class="line">file2=$&#123;filename&#125;$&#123;date2&#125;</span><br><span class="line">file3=$&#123;filename&#125;$&#123;date3&#125;</span><br><span class="line"># 4. 将档名建立</span><br><span class="line">touch &quot;$file1&quot; # 底下三行在建立档案</span><br><span class="line">touch &quot;$file2&quot;</span><br><span class="line">touch &quot;$file3&quot;</span><br><span class="line"></span><br><span class="line">（3）数值运算：简单的加减乘除</span><br><span class="line">[root@www scripts]# vi sh04.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"># Program:</span><br><span class="line"># User inputs 2 integer numbers; program will cross these two</span><br><span class="line">numbers.</span><br><span class="line"># History:</span><br><span class="line"># 2005/08/23 VBird First release</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line">echo -e &quot;You SHOULD input 2 numbers, I will cross them! \n&quot;</span><br><span class="line">read -p &quot;first number: &quot; firstnu</span><br><span class="line">read -p &quot;second number: &quot; secnu</span><br><span class="line">total=$(($firstnu*$secnu))</span><br><span class="line">echo -e &quot;\nThe result of $firstnu x $secnu is ==&gt; $total&quot;</span><br><span class="line"># 在数值的运算上，我们可以使用【 declare -i total=$firstnu*$secnu 】</span><br><span class="line"># 也可以使用上面的方式来进行。基本上，比较建议使用这样的方式来进行运算：</span><br><span class="line">var=$((运算内容))</span><br><span class="line"># 不但容易记忆，而且也比较方便的多，因为两个小括号内可以加上空格符！</span><br><span class="line"># 未来你可以使用这种方式来计算。至于数值运算上的处理，则有：【 +, -, *, /, % 】等等。</span><br></pre></td></tr></table></figure><h3 id="三、判断式"><a href="#三、判断式" class="headerlink" title="三、判断式"></a>三、判断式</h3><h4 id="（1）利用-test-指令的测试功能"><a href="#（1）利用-test-指令的测试功能" class="headerlink" title="（1）利用 test 指令的测试功能"></a>（1）利用 test 指令的测试功能</h4><p><img src="/uploads/2018/01/linux_shell_test_01.png" alt=""><br><img src="/uploads/2018/01/linux_shell_test_02.png" alt=""><br><img src="/uploads/2018/01/linux_shell_test_03.png" alt=""><br><img src="/uploads/2018/01/linux_shell_test_04.png" alt=""><br><img src="/uploads/2018/01/linux_shell_test_05.png" alt=""></p><p>OK！现在我们就利用 test 来帮我们写几个简单的例子。首先，判断一下，让使用者输入一个档名，我们判断：</p><ol><li>这个档案是否存在，若不存在则给予一个【Filename does not exist】的讯息，并中断程序；</li><li>若这个档案存在，则判断他是个档案或目录，结果输出【Filename is regular file】或【Filename is directory】</li><li>判断一下，执行者的身份对这个档案或目录所拥有的权限，并输出权限数据！<br><strong>（注意利用 test 与 &amp;&amp; 还有 || 等标志！）</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@www scripts]# vi sh05.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"># Program:</span><br><span class="line"># User input a filename, program will check the flowing:</span><br><span class="line"># 1.) exist? 2.) file/directory? 3.) file permissions</span><br><span class="line"># History:</span><br><span class="line"># 2005/08/25 VBird First release</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"># 1. 讥使用者输入档名，幵且刞断使用者是否真的有输入字符串？</span><br><span class="line">echo -e &quot;Please input a filename, I will check the filename&apos;s type and \</span><br><span class="line">permission. \n\n&quot;</span><br><span class="line">read -p &quot;Input a filename : &quot; filename</span><br><span class="line">test -z $filename &amp;&amp; echo &quot;You MUST input a filename.&quot; &amp;&amp; exit 0</span><br><span class="line"># 2. 刞断档案是否存在？若丌存在则显示讯息幵结束脚本</span><br><span class="line">test ! -e $filename &amp;&amp; echo &quot;The filename &apos;$filename&apos; DO NOT exist&quot; &amp;&amp;</span><br><span class="line">exit 0</span><br><span class="line"># 3. 开始刞断文件类型不属性</span><br><span class="line">test -f $filename &amp;&amp; filetype=&quot;regulare file&quot;</span><br><span class="line">test -d $filename &amp;&amp; filetype=&quot;directory&quot;</span><br><span class="line">test -r $filename &amp;&amp; perm=&quot;readable&quot;</span><br><span class="line">test -w $filename &amp;&amp; perm=&quot;$perm writable&quot;</span><br><span class="line">test -x $filename &amp;&amp; perm=&quot;$perm executable&quot;</span><br><span class="line"># 4. 开始输出信息！</span><br><span class="line">echo &quot;The filename: $filename is a $filetype&quot;</span><br><span class="line">echo &quot;And the permissions are : $perm&quot;</span><br></pre></td></tr></table></figure><h4 id="（2）利用判断符号"><a href="#（2）利用判断符号" class="headerlink" title="（2）利用判断符号 [ ]"></a>（2）利用判断符号 [ ]</h4><p>除了我们很喜欢使用的 test 之外，其实，我们还可以利用判断符号【 [ ] 】(就是中括号) 来进行数据的判断。举例来说，如果我想要知道 $HOME 这个变量是否为空的，可以这样做：<br><code>[root@www ~]# [ -z &quot;$HOME&quot; ] ; echo $?</code><br>使用中括号必须要特别注意，因为中括号用在很多地方，包括通配符与正规表示法等等，所以如果要在 bash 的语法当中使用中括号作为 shell 的判断式时，必须要注意中括号的两端需要有空格符来分隔。<br>最好要注意：</p><ul><li>在中括号 [] 内的每个组件都需要有空格键来分隔；</li><li>在中括号内的变数，最好都以双引号括号起来；</li><li>在中括号内的常数，最好都以单或双引号括号起来。</li></ul><p>举例来说，假如我设定了 <code>name=&quot;VBird Tsai&quot;</code> ，然后这样判定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# name=&quot;VBird Tsai&quot;</span><br><span class="line">[root@www ~]# [ $name == &quot;VBird&quot; ]</span><br><span class="line">bash: [: too many arguments</span><br></pre></td></tr></table></figure></p><p>怎么会发生错误？bash 还跟我说错误是由于【太多参数 (arguments)】所致。为什么呢？<br>因为 $name 如果没有使用双引号刮起来，那么上面的判定式会变成：<br>    <code>[ VBird Tsai == &quot;VBird&quot; ]</code><br>上面肯定不对了。因为一个判断式仅能有两个数据的比对，上面 VBird 与 Tsai 还有 “VBird” 就有三个资料。这不是我们要的，我们要的应该是底下这个样子：<br>    <code>[ &quot;VBird Tsai&quot; == &quot;VBird&quot; ]</code><br>这可是差很多。另外，中括号的使用方法与 test 几乎一模一样。</p><h3 id="四、条件判断式"><a href="#四、条件判断式" class="headerlink" title="四、条件判断式"></a>四、条件判断式</h3><h4 id="（1）利用if…then判断式"><a href="#（1）利用if…then判断式" class="headerlink" title="（1）利用if…then判断式"></a>（1）利用if…then判断式</h4><p>（1）单层、简单条件判断式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]; then</span><br><span class="line">当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line">fi &lt;==将 if 反过来写，就成为 fi ！结束 if 之意！</span><br><span class="line"></span><br><span class="line">括号与括号之间，则以 &amp;&amp; 或 || 来隔开，他们的意义是：</span><br><span class="line">&amp;&amp; 代表 AND ；</span><br><span class="line">|| 代表 or ；</span><br><span class="line">例如：[ &quot;$yn&quot; == &quot;Y&quot; -o &quot;$yn&quot; == &quot;y&quot; ] 可替换为：[ &quot;$yn&quot; == &quot;Y&quot; ] || [ &quot;$yn&quot; == &quot;y&quot; ]</span><br></pre></td></tr></table></figure></p><p>（2）多重、复杂条件判断式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 一个条件判断，分成功进行与失败进行 (else)</span><br><span class="line">if [ 条件判断式 ]; then</span><br><span class="line">当条件判断式成立时，可以进行的指令工作内容；</span><br><span class="line">else</span><br><span class="line">当条件判断式不成立时，可以进行的指令工作内容；</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 多个条件判断 (if ... elif ... elif ... else) 分多种不同情况执行</span><br><span class="line">if [ 条件判断式一 ]; then</span><br><span class="line">当条件判断式一成立时，可以进行的指令工作内容；</span><br><span class="line">elif [ 条件判断式二 ]; then</span><br><span class="line">当条件判断式二成立时，可以进行的指令工作内容；</span><br><span class="line">else</span><br><span class="line">当条件判断式一与二均不成立时，可以进行的指令工作内容；</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h4 id="（2）利用-case-…-esac-判断"><a href="#（2）利用-case-…-esac-判断" class="headerlink" title="（2）利用 case ….. esac 判断"></a>（2）利用 case ….. esac 判断</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case $变量名称 in &lt;==关键词为 case ，还有变数前有钱字号</span><br><span class="line">&quot;第一个变量内容&quot;) &lt;==每个变量内容建议用双引号括起来，关键词则为小括号 )</span><br><span class="line">程序段</span><br><span class="line">;; &lt;==每个类别结尾使用两个连续的分号来处理！</span><br><span class="line">&quot;第二个变量内容&quot;)</span><br><span class="line">程序段</span><br><span class="line">;;</span><br><span class="line">*) &lt;==最后一个变量内容都会用 * 来代表所有其他值，不包含第一个变量内容与第二个变量内容的其他程序执行段</span><br><span class="line">exit 1</span><br><span class="line">;;</span><br><span class="line">esac &lt;==最终的 case 结尾！【反过来写】思考一下！</span><br></pre></td></tr></table></figure><p>一般来说，使用【 case $变量 in 】这个语法中，当中的那个【 $变量 】大致有两种取得的方式：</p><ul><li>直接下达式：例如上面提到的，利用【 script.sh variable 】的方式来直接给予 $1 这个变量的内容，这也是在 /etc/init.d 目录下大多数程序的设计方式。</li><li>交互式：透过 read 这个指令来让用户输入变量的内容。</li></ul><h3 id="五、循环"><a href="#五、循环" class="headerlink" title="五、循环"></a>五、循环</h3><h4 id="（1）while-do-done-until-do-done-不定循环"><a href="#（1）while-do-done-until-do-done-不定循环" class="headerlink" title="（1）while do done, until do done (不定循环)"></a>（1）while do done, until do done (不定循环)</h4><p>一般来说，不定循环最常见的就是底下这两种状态了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ condition ] &lt;==中括号内的状态就是判断式</span><br><span class="line">do &lt;==do 是循环的开始！</span><br><span class="line">程序段落</span><br><span class="line">done &lt;==done 是循环的结束</span><br></pre></td></tr></table></figure></p><p>while 的中文是【当….时】，所以，这种方式说的是【当 condition 条件成立时，就进行循环，直到condition 的条件不成立才停止】的意思。还有另外一种不定循环的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ condition ]</span><br><span class="line">do</span><br><span class="line">程序段落</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>这种方式恰恰与 while 相反，它说的是【当 condition 条件成立时，就终止循环，否则就持续进行循环的程序段。】</p><h4 id="（2）for…do…done-固定循环"><a href="#（2）for…do…done-固定循环" class="headerlink" title="（2）for…do…done (固定循环)"></a>（2）for…do…done (固定循环)</h4><p>相对于 while, until 的循环方式是必须要【符合某个条件】的状态，for 这种语法，则是【 已经知道要进行几次循环】的状态！他的语法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in con1 con2 con3 ...</span><br><span class="line">do</span><br><span class="line">程序段</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><blockquote><p>以上面的例子来说，这个 $var 的变量内容在循环工作时：</p><pre><code>1. 第一次循环时， $var 的内容为 con1 ；2. 第二次循环时， $var 的内容为 con2 ；3. 第三次循环时， $var 的内容为 con3 ；4. ....</code></pre></blockquote><h4 id="（3）for…do…done-的数值处理"><a href="#（3）for…do…done-的数值处理" class="headerlink" title="（3）for…do…done 的数值处理"></a>（3）for…do…done 的数值处理</h4><p>除了上述的方法之外，for 循环还有另外一种写法！语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值; 限制值; 执行步阶 ))</span><br><span class="line">do</span><br><span class="line">程序段</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>这种语法适合于数值方式的运算当中，在 for 后面的括号内的三串内容意义为：</p><ul><li>初始值：某个变量在循环当中的起始值，直接以类似 i=1 设定好；</li><li>限制值：当变量的值在这个限制值的范围内，就继续进行循环。例如 i&lt;=100；</li><li>执行步阶：每作一次循环时，变量的变化量。例如 i=i+1。</li></ul><p>值得注意的是，在【执行步阶】的设定上，如果每次增加 1 ，则可以使用类似【i++】的方式，亦即是 i 每次循环都会增加一的意思。</p><h3 id="六、shell-script的追踪与debug"><a href="#六、shell-script的追踪与debug" class="headerlink" title="六、shell script的追踪与debug"></a>六、shell script的追踪与debug</h3><p>scripts 在执行之前，最怕的就是出现语法错误的问题了！那么我们如何 debug 呢？有没有办法不需要透过直接执行该 scripts 就可以来判断是否有问题呢？当然是有的，我们就直接以 bash 的相关参数来进行判断！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sh [-nvx] scripts.sh</span><br><span class="line">选项与参数：</span><br><span class="line">-n ：不要执行 script，仅查询语法的问题；</span><br><span class="line">-v ：再执行 sccript 前，先将 scripts 的内容输出到屏幕上；</span><br><span class="line">-x ：将使用到的 script 内容显示到屏幕上，这是很有用的参数！</span><br><span class="line">范例一：测试 sh16.sh 有无语法的问题？</span><br><span class="line">[root@www ~]# sh -n sh16.sh</span><br><span class="line"># 若语法没有问题，则不会显示任何信息！</span><br><span class="line">范例二：将 sh15.sh 的执行过程全部列出来～</span><br><span class="line">[root@www ~]# sh -x sh15.sh</span><br></pre></td></tr></table></figure></p><p>熟悉 sh 的用法，将可以使你在管理 Linux 的过程中得心应手！至于在 Shell scripts 的学习方法上面，需要【多看、多模仿、并加以修改成自己的样式！】是最快的学习手段了！网络上有相当多的朋友在<br>开发一些相当有用的 scripts ，若是你可以将对方的 scripts 拿来，并且改成适合自己主机的样子！那么学习的效果会是最快的！</p><p>另外，我们 Linux 系统本来就有很多的服务启动脚本，如果你想要知道每个 script 所代表的功能是什么？可以直接以 vim 进入该 script 去查阅一下，通常立刻就知道该 script 的目的了。 举例来说，我们之前一直提到的 /etc/init.d/syslog ，这个 script 是干嘛用的？ 利用 vi 去查阅最前面的几行字，他出现如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># description: Syslog is the facility by which many daemons use to log \</span><br><span class="line"># messages to various system log files. It is a good idea to always \</span><br><span class="line"># run syslog.</span><br><span class="line">### BEGIN INIT INFO</span><br><span class="line"># Provides: $syslog</span><br><span class="line">### END INIT INFO</span><br></pre></td></tr></table></figure></p><p>简单的说，这个脚本在启动一个名为 syslog 的常驻程序 (daemon)，这个常驻程序可以帮助很多系统服务记载她们的登录文件 (log file)，我们的 Linux 建议你一直启动 syslog 是个好主意！简单的看看您就知道啥是啥啦！</p><h3 id="附属：Shell-Script中的特殊变量："><a href="#附属：Shell-Script中的特殊变量：" class="headerlink" title="附属：Shell Script中的特殊变量："></a>附属：Shell Script中的特殊变量：</h3><p>Shell script 的默认变数($0, $1…)<br>一些较为特殊的变量可以在 script 内使用来呼叫这些参数：</p><ul><li>$# ：代表后接的参数【个数】，以上表为例这里显示为【 4 】；</li><li>$@ ：代表【 “$1” “$2” “$3” “$4” 】之意，每个变量是独立的(用双引号括起来)；</li><li>$* ：代表【 “$1c$2c$3c$4” 】，其中 c 为分隔字符，默认为空格键，所以本例中代表【 “$1 $2 $3 $4” 】之意。</li><li>$0 ：代表执行的脚本档名</li><li>$n ：代表对应输入的变量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、什么是Shell-Script&quot;&gt;&lt;a href=&quot;#一、什么是Shell-Script&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Shell Script&quot;&gt;&lt;/a&gt;一、什么是Shell Script&lt;/h3&gt;&lt;p&gt;什么是 shell script (程序化脚本) 呢？就字面上的意义，我们将他分为两部份。在【 shell 】部分，我们在 BASH 当中已经提过了，那是一个文字接口底下让我们与系统沟通的一个工具接口。那么【 script 】是啥？字面上的意义，script 是【脚本、剧本】的意思。整句话是说，shell script 是针对 shell 所写的【剧本！】&lt;/p&gt;
&lt;p&gt;什么东西啊？其实，shell script 是利用 shell 的功能所写的一个【程序 (program)】，这个程序是使用纯文本文件，将一些 shell 的语法与指令(含外部指令)写在里面，搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="BASH" scheme="http://yoursite.com/tags/BASH/"/>
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>认识与学习BASH之awk命令</title>
    <link href="http://yoursite.com/2017/12/29/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0BASH%E4%B9%8Bawk%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2017/12/29/认识与学习BASH之awk命令/</id>
    <published>2017-12-29T09:56:49.000Z</published>
    <updated>2018-01-24T10:43:19.593Z</updated>
    
    <content type="html"><![CDATA[<h4 id="awk：好用的数据处理工具"><a href="#awk：好用的数据处理工具" class="headerlink" title="awk：好用的数据处理工具"></a>awk：好用的数据处理工具</h4><p>awk 也是一个非常棒的数据处理工具。相较于 sed 常常作用于一整个行的处理，awk 则比较倾向于一行当中分成数个【字段】来处理。因此，awk 相当的适合处理小型的数据数据处理。awk 通常运作的模式是这样的：<br><code>[root@www ~]# awk &#39;条件类型1{动作1} 条件类型2{动作2} ...&#39; filename</code></p><p>awk 后面接两个单引号并加上大括号 {} 来设定想要对数据进行的处理动作。awk 可以处理后续接的档案，也可以读取来自前个指令的 standard output 。但如前面说的，awk 主要是处理【每一行的字段内的数据】，而默认的【字段的分隔符为 “空格键” 或 “[tab]键”】。<br><a id="more"></a><br>举例来说，我们用 last 可以将登入者的数据取出来，结果如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# last -n 5 &lt;==仅取出前五行</span><br><span class="line">root pts/1 192.168.1.100 Tue Feb 10 11:21 still logged in</span><br><span class="line">root pts/1 192.168.1.100 Tue Feb 10 00:46 - 02:28 (01:41)</span><br><span class="line">root pts/1 192.168.1.100 Mon Feb 9 11:41 - 18:30 (06:48)</span><br><span class="line">dmtsai pts/1 192.168.1.100 Mon Feb 9 11:41 - 11:41 (00:00)</span><br><span class="line">root tty1 Fri Sep 5 14:09 - 14:10 (00:01)</span><br></pre></td></tr></table></figure></p><p>若我想要取出账号与登入者的 IP ，且账号与 IP 之间以 [tab] 隔开，则会变成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# last -n 5 | awk &apos;&#123;print $1 &quot;\t&quot; $3&#125;&apos;</span><br><span class="line">root 192.168.1.100</span><br><span class="line">root 192.168.1.100</span><br><span class="line">root 192.168.1.100</span><br><span class="line">dmtsai 192.168.1.100</span><br><span class="line">root Fri</span><br></pre></td></tr></table></figure></p><p>上表是 awk 最常使用的动作。透过 print 的功能将字段数据列出来，字段的分隔则以空格键或 [tab] 按键来隔开。因为不论哪一行我都要处理，因此，就不需要有 “条件类型” 的限制。我所想要的是第一栏以及第三栏，但是，第五行的内容怪怪的，这是因为数据格式的问题。所以，使用 awk 的时候，请先确认一下你的数据当中，如果是连续性的数据，请不要有空格或 [tab] 在内，否则，就会像这个例子这样，会发生误判。</p><p>另外，由上面这个例子你也会知道，在每一行的每个字段都是有变量名称的，那就是 $1, $2… 等变量名称。以上面的例子来说，root 是 $1 ，因为他是第一栏。至于 192.168.1.100 是第三栏，所以他就是 $3，后面以此类推。还有个变数，那就是 $0 ，$0 代表【一整列资料】的意思。以上面的例子来说，第一行的 $0 代表的就是【root ….】那一行。 由此可知，刚刚上面五行当中，整个 awk 的处理流程是：</p><pre><code>1. 读入第一行，并将第一行的资料填入 $0, $1, $2.... 等变数当中；2. 依据 &quot;条件类型&quot; 的限制，判断是否需要进行后面的 &quot;动作&quot;；3. 做完所有的动作与条件类型；4. 若还有后续的【行】的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。</code></pre><p>经过这样的步骤，你会晓得，awk 是【以行为一次处理的单位】，而【以字段为最小的处理单位】。那么 awk 怎么知道我到底这个数据有几行？有几栏？这就需要 awk 的内建变量的帮忙了。</p><table><thead><tr><th>变量名称</th><th>代表意义</th></tr></thead><tbody><tr><td>NF</td><td>每一行 ($0) 拥有的字段总数</td></tr><tr><td>NR</td><td>目前 awk 所处理的是【第几行】数据</td></tr><tr><td>FS</td><td>目前的分隔字符，默认是空格键</td></tr></tbody></table><p>我们继续以上面 last -n 5 的例子来做说明，如果我想要：</p><ul><li>列出每一行的账号(就是 $1)；</li><li>列出目前处理的行数(就是 awk 内的 NR 变量)</li><li>并且说明，该行有多少字段(就是 awk 内的 NF 变量)</li></ul><p><em>（注：awk 后续的所有动作是以单引号【 ‘ 】括住的，由于单引号与双引号都必须是成对的，所以，awk的格式内容如果想要以print打印时，记得非变量的文字部分，包含printf的格式中，都需要使用双引号来定义出来。因为单引号已经是 awk 的指令固定用法了！）</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# last -n 5| awk &apos;&#123;print $1 &quot;\t lines: &quot; NR &quot;\t columes: &quot; NF&#125;&apos;</span><br><span class="line">root lines: 1 columes: 10</span><br><span class="line">root lines: 2 columes: 10</span><br><span class="line">root lines: 3 columes: 10</span><br><span class="line">dmtsai lines: 4 columes: 10</span><br><span class="line">root lines: 5 columes: 9</span><br><span class="line"># 注意，在 awk 内的 NR, NF 等变量要用大写，且不需要有钱字号 $</span><br></pre></td></tr></table></figure><h4 id="awk-的逻辑运算字符"><a href="#awk-的逻辑运算字符" class="headerlink" title="awk 的逻辑运算字符"></a>awk 的逻辑运算字符</h4><p>既然有需要用到 “条件” 的类别，自然就需要一些逻辑运算。例如底下这些：<br><img src="/uploads/2017/12/linux_shell_awk_01.png" alt=""><br>值得注意的是那个【 == 】的符号，因为：    </p><ul><li>逻辑运算上面亦即所谓的大于、小于、等于等判断式上面，习惯上是以【 == 】来表示；</li><li>如果是直接给予一个值，例如变量设定时，就直接使用 = 而已。</li></ul><p>举例来说，在 /etc/passwd 当中是以冒号 “:” 来作为字段的分隔，该档案中第一字段为账号，第三字段则是UID。那假设我要查阅，第三栏小于 10 以下的数据，并且仅列出账号与第三栏，那么可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat /etc/passwd | awk &apos;&#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&apos;</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin 1</span><br><span class="line">daemon 2</span><br><span class="line">....(以下省略)....</span><br></pre></td></tr></table></figure></p><p>另外，如果要用 awk 来进行【计算功能】呢？以底下的例子来看，假设我有一个薪资数据表档名为 pay.txt ，内容是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name 1st 2nd 3th</span><br><span class="line">VBird 23000 24000 25000</span><br><span class="line">DMTsai 21000 20000 23000</span><br><span class="line">Bird2 43000 42000 41000</span><br></pre></td></tr></table></figure></p><p>如何帮我计算每个人的总额呢？而且我还想要格式化输出。我们可以这样考虑：</p><ul><li>第一行只是说明，所以第一行不要进行加总 (NR==1 时处理)；</li><li>第二行以后就会有加总的情况出现 (NR&gt;=2 以后处理)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat pay.txt | \</span><br><span class="line">&gt; awk &apos;NR==1&#123;printf</span><br><span class="line">&quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot; &#125;</span><br><span class="line">NR&gt;=2&#123;total = $2 + $3 + $4</span><br><span class="line">printf &quot;%10s %10d %10d %10d %10.2f\n&quot;, $1, $2, $3, $4, total&#125;&apos;</span><br><span class="line">Name 1st 2nd 3th Total</span><br><span class="line">VBird 23000 24000 25000 72000.00</span><br><span class="line">DMTsai 21000 20000 23000 64000.00</span><br><span class="line">Bird2 43000 42000 41000 126000.00</span><br></pre></td></tr></table></figure><p>上面的例子有几个重要事项应该要先说明的：</p><ul><li>awk 的指令间隔：所有 awk 的动作，亦即在 {} 内的动作，如果有需要多个指令辅助时，可利用分号【;】间隔，或者直接以 [Enter] 按键来隔开每个指令</li><li>逻辑运算当中，如果是【等于】的情况，则务必使用两个等号【==】！</li><li>格式化输出时，在 printf 的格式设定当中，务必加上 \n ，才能进行分行！</li><li>与 bash shell 的变量不同，在 awk 当中，变量可以直接使用，不需加上 $ 符号。</li></ul><p>利用 awk 这个玩意儿，就可以帮我们处理很多日常工作了呢！真是好用的很。此外，awk 的输出格式当中，常常会以 printf 来辅助，所以，最好你对 printf 也稍微熟悉一下比较好。另外，awk 的动作内 {} 也是支持 if (条件) 的。举例来说，上面的指令可以修订成为这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat pay.txt | \</span><br><span class="line">&gt; awk &apos;&#123;if(NR==1) printf</span><br><span class="line">&quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot;&#125;</span><br><span class="line">NR&gt;=2&#123;total = $2 + $3 + $4</span><br><span class="line">printf &quot;%10s %10d %10d %10d %10.2f\n&quot;, $1, $2, $3, $4, total&#125;&apos;</span><br></pre></td></tr></table></figure></p><h4 id="格式化打印：printf"><a href="#格式化打印：printf" class="headerlink" title="格式化打印：printf"></a>格式化打印：printf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# printf &apos;打印格式&apos; 实际内容</span><br><span class="line">选项与参数：</span><br><span class="line">关于格式方面的几个特殊样式：</span><br><span class="line">\a 警告声音输出</span><br><span class="line">\b 退格键(backspace)</span><br><span class="line">\f 清除屏幕 (form feed)</span><br><span class="line">\n 输出新的一行</span><br><span class="line">\r 亦即 Enter 按键</span><br><span class="line">\t 水平的 [tab] 按键</span><br><span class="line">\v 垂直的 [tab] 按键</span><br><span class="line">\xNN NN 为两位数的数字，可以转换数字成为字符。</span><br><span class="line">关于 C 程序语言内，常见的变数格式</span><br><span class="line">%ns 那个 n 是数字， s 代表 string ，亦即多少个字符；</span><br><span class="line">%ni 那个 n 是数字， i 代表 integer ，亦即多少整数字数；</span><br><span class="line">%N.nf 那个 n 与 N 都是数字， f 代表 floating (浮点)，如果有小数字数，假设我共要十个位数，但小数点有两位，即为 %10.2f</span><br></pre></td></tr></table></figure><p><strong>（注：printf 不是管线命令）</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;awk：好用的数据处理工具&quot;&gt;&lt;a href=&quot;#awk：好用的数据处理工具&quot; class=&quot;headerlink&quot; title=&quot;awk：好用的数据处理工具&quot;&gt;&lt;/a&gt;awk：好用的数据处理工具&lt;/h4&gt;&lt;p&gt;awk 也是一个非常棒的数据处理工具。相较于 sed 常常作用于一整个行的处理，awk 则比较倾向于一行当中分成数个【字段】来处理。因此，awk 相当的适合处理小型的数据数据处理。awk 通常运作的模式是这样的：&lt;br&gt;&lt;code&gt;[root@www ~]# awk &amp;#39;条件类型1{动作1} 条件类型2{动作2} ...&amp;#39; filename&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;awk 后面接两个单引号并加上大括号 {} 来设定想要对数据进行的处理动作。awk 可以处理后续接的档案，也可以读取来自前个指令的 standard output 。但如前面说的，awk 主要是处理【每一行的字段内的数据】，而默认的【字段的分隔符为 “空格键” 或 “[tab]键”】。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="《鸟哥的Linux私房菜基础篇（第三版）》" scheme="http://yoursite.com/categories/%E4%B9%A6%E7%B1%8D/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E3%80%8B/"/>
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="BASH" scheme="http://yoursite.com/tags/BASH/"/>
    
  </entry>
  
</feed>
