<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-28T10:54:32.631Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 相关知识点整理</title>
    <link href="http://yoursite.com/2018/03/28/Redis-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/03/28/Redis-相关知识点整理/</id>
    <published>2018-03-28T10:48:18.000Z</published>
    <updated>2018-03-28T10:54:32.631Z</updated>
    
    <content type="html"><![CDATA[<p>首先，要知道redis是一个key-value内存存储系统，且是单线程模型。<br>与其他key-value缓存相比有以下特点：</p><ol><li>支持数据持久化，可以将内存中的数据保存到磁盘，重启机器后可再次加载进来</li><li>不仅仅支持key-value类型数据，还有哈希、列表、集合数据结构类型</li><li>支持数据的备份，master-slave模式的数据备份</li></ol><p>并且，redis的所有操作都具有原子性。<br><a id="more"></a></p><h4 id="1、redis-的数据类型介绍"><a href="#1、redis-的数据类型介绍" class="headerlink" title="1、redis 的数据类型介绍"></a>1、redis 的数据类型介绍</h4><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p><strong>常用命令：</strong><br>set,get,decr,incr,mget 等。<br><strong>应用场景：</strong><br>String是最常用的一种数据类型，普通的key/value存储都可以归为此类，这里就不所做解释了。<br><strong>实现方式：</strong><br>String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</p><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p><strong>常用命令：</strong><br>hget,hset,hgetall 等。<br><strong>应用场景：</strong><br>我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：<br>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：</p><ul><li>第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。</li><li>第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。</li></ul><p>那么Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口。</p><p>也就是说，Key仍然是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的 Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。</p><p>这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部Map的成员很多，那么涉及到遍历整 个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。</p><p>上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。</p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p><strong>常用命令：</strong><br>lpush,rpush,lpop,rpop,lrange等。<br><strong>应用场景：</strong><br>Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现，比较好理解，这里不再重复。<br><strong>实现方式：</strong><br>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p><strong>常用命令：</strong><br>sadd,spop,smembers,sunion 等。<br><strong>应用场景：</strong><br>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。<br><strong>实现方式：</strong><br>set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p><h5 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h5><p><strong>常用命令：</strong><br>zadd,zrange,zrem,zcard等<br><strong>使用场景：</strong><br>Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么 可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。<br><strong>实现方式：</strong><br>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的 是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p><h4 id="redis支持持久化的原理"><a href="#redis支持持久化的原理" class="headerlink" title="redis支持持久化的原理"></a>redis支持持久化的原理</h4><p>Redis由于支持非常丰富的内存数据结构类型，如何把这些复杂的内存组织方式持久化到磁盘上是一个难题，所以Redis的持久化方式与传统数据库的方式有比较多的差别，Redis一共支持四种持久化方式，分别是：</p><blockquote><p>定时快照方式(snapshot)<br>基于语句追加文件的方式(aof)<br>虚拟内存(vm)<br>Diskstore方式</p></blockquote><p>redis支持小量数据落地功能，后两种种方式并不成熟，下面分别介绍下这几种持久化方式：</p><p><strong>定时快照方式(snapshot)：</strong><br>该持久化方式实际是在Redis内部一个定时器事件，每隔固定时间去检查当前数据发生的改变次数与时间是否满足配置的持久化触发的条件<font color="red">（注：需要配置）</font>，如果满足则 通过操作系统fork调用来创建出一个子进程，这个子进程默认会与父进程共享相同的地址空间，这时就可以通过子进程来遍历整个内存来进行存储操作，而主进 程则仍然可以提供服务，当有写入时由操作系统按照内存页(page)为单位来进行copy-on-write保证父子进程之间不会互相影响。<br>该持久化的主要缺点是定时快照只是代表一段时间内的内存映像，所以系统重启会丢失上次快照与重启之间所有的数据。</p><p><strong>基于语句追加方式(aof)：</strong><br>aof方式实际类似mysql的基于语句的binlog方式，即每条会使Redis内存数据发生改变的命令都会追加到一个log文件中，也就是说这个log文件就是Redis的持久化数据。<br>aof的方式的主要缺点是追加log文件可能导致体积过大，当系统重启恢复数据时如果是aof的方式则加载数据会非常慢，几十G的数据可能需要几小时才能加载完，当然这个耗时并不是因为磁盘文件读取速度慢，而是由于读取的所有命令都要在内存中执行一遍。另外由于每条命令都要写log,所以使用aof 的方式，Redis的读写性能也会有所下降。</p><p><strong>虚拟内存方式：</strong><br>虚拟内存方式是Redis来进行用户空间的数据换入换出的一个策略，此种方式在实现的效果上比较差，主要问题是代码复杂，重启慢，复制慢等等，目前已经被作者放弃。</p><p><strong>diskstore方式：</strong><br>diskstore方式是作者放弃了虚拟内存方式后选择的一种新的实现方式，也就是传统的B-tree的方式，目前仍在实验阶段，后续是否可用我们可以拭目以待。</p><p><strong>Redis持久化磁盘IO方式及其带来的问题</strong><br>有Redis线上运维经验的人会发现Redis在物理内存使用比较多，但还没有超过实际物理内存总容量时就会发生不稳定甚至崩溃的问题，有人认为是 基于快照方式持久化的fork系统调用造成内存占用加倍而导致的，这种观点是不准确的，因为fork 调用的copy-on-write机制是基于操作系统页这个单位的，也就是只有有写入的脏页会被复制，但是一般你的系统不会在短时间内所有的页都发生了写 入而导致复制，那么是什么原因导致Redis崩溃的呢？</p><p>答案是Redis的持久化使用了Buffer IO造成的，所谓Buffer IO是指Redis对持久化文件的写入和读取操作都会使用物理内存的Page Cache,而大多数数据库系统会使用Direct IO来绕过这层Page Cache并自行维护一个数据的Cache，而当Redis的持久化文件过大(尤其是快照文件)，并对其进行读写时，磁盘文件中的数据都会被加载到物理内 存中作为操作系统对该文件的一层Cache,而这层Cache的数据与Redis内存中管理的数据实际是重复存储的，虽然内核在物理内存紧张时会做 Page Cache的剔除工作，但内核很可能认为某块Page Cache更重要，而让你的进程开始Swap ,这时你的系统就会开始出现不稳定或者崩溃了。我们的经验是当你的Redis物理内存使用超过内存总容量的3/5时就会开始比较危险了。<br><em>（注：Redis的复制功能是完全建立在基于内存快照的持久化策略基础上的，也就是说无论你的持久化策略选择的是什么，只要用到了 Redis的复制功能，就一定会有内存快照发生。）</em></p><h4 id="3、redis备份原理"><a href="#3、redis备份原理" class="headerlink" title="3、redis备份原理"></a>3、redis备份原理</h4><p>由上面持久化的原理可知道，目前使用的是RDB和AOF。<br>默认情况下60秒刷新到disk一次[save 60 10000 当有1w条keys数据被改变时]，Redis的数据集保存在叫dump.rdb一个二进制文件，这种策略被称为快照。</p><p>快照易恢复，文件也小，但是如果遇到宕机等情况的时候快照的数据可能会不完整。此时可能需要启用另一种持久化方式AOF，在配置文件中打开[appendonly yes]。</p><blockquote><p>AOF刷新日志到disk的规则：<br>appendfsync always #always 表示每次有写操作都进行同步，非常慢，非常安全。<br>appendfsync everysec #everysec表示对写操作进行累积，每秒同步一次<br>官方的建议的everysec，安全，就是速度不够快，如果是机器出现问题可能会丢失1秒的数据。</p></blockquote><p>我们现在的做法是一主(Master)多从(Slave)，主库不开启AOF持久化，只是每天备份一下RDB[官方给的建议是每小时备份RDB文件，看你的策略了]，而在从库上开启AOF备份，并且会用脚本将相应的备份文件推送到备份服务器。<br>当redis服务器挂掉时，重启时将按照以下优先级恢复数据到内存：</p><ul><li>如果只配置AOF,重启时加载AOF文件恢复数据；</li><li>如果同时 配置了RBD和AOF,启动是只加载AOF文件恢复数据;</li><li>如果只配置RBD,启动是讲加载dump文件恢复数据。</li></ul><font color="red">恢复时需要注意，要是主库挂了不能直接重启主库，否则会直接覆盖掉从库的AOF文件，一定要确保要恢复的文件都正确才能启动，否则会冲掉原来的文件。</font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，要知道redis是一个key-value内存存储系统，且是单线程模型。&lt;br&gt;与其他key-value缓存相比有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持数据持久化，可以将内存中的数据保存到磁盘，重启机器后可再次加载进来&lt;/li&gt;
&lt;li&gt;不仅仅支持key-value类型数据，还有哈希、列表、集合数据结构类型&lt;/li&gt;
&lt;li&gt;支持数据的备份，master-slave模式的数据备份&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;并且，redis的所有操作都具有原子性。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 底层索引原理【摘】</title>
    <link href="http://yoursite.com/2018/03/28/MySQL-%E5%BA%95%E5%B1%82%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E3%80%90%E6%91%98%E3%80%91/"/>
    <id>http://yoursite.com/2018/03/28/MySQL-底层索引原理【摘】/</id>
    <published>2018-03-28T10:47:37.000Z</published>
    <updated>2018-03-28T10:57:00.985Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><p>本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。本文将只关注于BTree索引。</p><p>文章主要内容分为三个部分。<br>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。<br>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。<br>第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。<br><a id="more"></a></p><h3 id="数据结构及算法基础"><a href="#数据结构及算法基础" class="headerlink" title="数据结构及算法基础"></a>数据结构及算法基础</h3><h4 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h4><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是一种数据结构。</p><p>数据库查询是数据库的主要功能之一，最基本的查询算法是顺序查找（linear search）时间复杂度为O(n)，显然在数据量很大时效率很低。优化的查找算法如二分查找（binary search）、二叉树查找（binary tree search）等，虽然查找效率提高了。但是各自对检索的数据都有要求：二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织）。所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构。这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。</p><p>看一个例子：<br><img src="/uploads/2018/03/mysql_index_01.png" alt=""><br>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p><p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p><h4 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h4><p>关于B树和B+树请参考关于<a href="http://www.cnblogs.com/tgycoder/p/5077017.html" target="_blank" rel="noopener">B树的一些总结</a>，这篇文章介绍的比较详细，同时容易理解。</p><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p><p>未完【待续】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL索引背后的数据结构及算法原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。本文将只关注于BTree索引。&lt;/p&gt;
&lt;p&gt;文章主要内容分为三个部分。&lt;br&gt;第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。&lt;br&gt;第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。&lt;br&gt;第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 存储引擎详解</title>
    <link href="http://yoursite.com/2018/03/28/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/28/MySQL-存储引擎详解/</id>
    <published>2018-03-28T10:47:23.000Z</published>
    <updated>2018-03-28T10:58:26.417Z</updated>
    
    <content type="html"><![CDATA[<p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySql的核心就是存储引擎。</p><h4 id="存储引擎查看"><a href="#存储引擎查看" class="headerlink" title="存储引擎查看"></a>存储引擎查看</h4><p>MySQL给开发者提供了查询存储引擎的功能，我这里使用的是 10.1.28-MariaDB，可以使用：<br><code>show engines;</code><br><a id="more"></a></p><table><thead><tr><th>Engine</th><th>Suppert</th><th>Comment</th><th>Transactions</th><th>XA</th><th>Savepoints</th></tr></thead><tbody><tr><td>CSV</td><td>YES</td><td>CSV storage engine</td><td>No</td><td>No</td><td>No</td></tr><tr><td>InnoDB</td><td>DEFAULT</td><td>Comment: Percona-XtraDB, Supports transactions, row-level locking, foreignkeys and encryption for tables</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>MEMORY</td><td>YES</td><td>Hash based, stored in memory, useful for temporary tables</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>MyISAM</td><td>YES</td><td>MyISAM storage engine</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>MRG_MyISAM</td><td>YES</td><td>Collection of identical MyISAM tables</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>Aria</td><td>YES</td><td>Crash-safe tables with MyISAM heritage</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>PERFORMANCE_SCHEMA</td><td>YES</td><td>Performance Schema</td><td>NO</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>SEQUENCE</td><td>YES</td><td>Generated tables filled with sequential values</td><td>YES</td><td>NO</td><td>YES</td></tr></tbody></table><p>看到MySQL给用户提供了这么多存储引擎，包括处理事务安全表的引擎和出来了非事物安全表的引擎。</p><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，上图也看到了，InnoDB是默认的MySQL引擎。<br>InnoDB存储表和索引有一下两种方式：</p><ol><li>使用共享表空间存储，这种方式创建的表的表结构保存在.frm文件中，数据和索引保存在innodb_data_home_dir和innodb_data_file_path定义的表空间中，可以是多个文件。</li><li>使用多表空间存储，这种方式创建的表的表结构仍然保存在.frm文件中，但是每个表的数据和索引单独保存在.ibd中，如果是个分区表，则每个分区对应单独的.ibd文件，文件名是”表名+分区名”，可以在创建分区的时候指定每个分区的数据文件位置，以此来将表的IO均匀分布在多个磁盘上。</li></ol><p><strong>选择理由：</strong><br>用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据一致性，数据操作除了插入和查询意外，还包括很多的更新删除操作，那么InnoDB比较合适。InnoDB存储引擎除了有效的降低由于删除和更新操作导致的锁定，还可以确保事务的完整提交和回滚。</p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事物。<br>每个MyISAM在磁盘上存储成3个文件，文件名都和表名相同，但是扩展名不同，扩展名分别是：</p><ol><li>.frm（存储表定义）；</li><li>.MYD（MYData，存储数据）；</li><li>.MYI（MYIndex，存储索引）；</li></ol><p>MyISAM的表还支持3种不同的存储格式，分别是：</p><ol><li>静态（固定长度）表；</li><li>动态表；</li><li>压缩表；</li></ol><p><strong>选择理由：</strong><br>如果应用是以读写操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高可选用此种存储引擎。</p><h4 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h4><p>MEMORY存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。<br>MEMORY存储引擎使用存在于内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件，格式.frm。MEMORY类型的表访问非常快，因为它的数据是存放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失。</p><p><strong>选择理由：</strong><br>将所有的数据保存在RAM中，在需要快速定位记录和其他类似数据的环境下，可提供极快的访问。MEMORY的缺陷是对表的大小有限制，太大的表无法缓存在内存中，其次要确保表数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。</p><h4 id="下面对一些常用的引擎的特点进行汇总"><a href="#下面对一些常用的引擎的特点进行汇总" class="headerlink" title="下面对一些常用的引擎的特点进行汇总"></a>下面对一些常用的引擎的特点进行汇总</h4><table><thead><tr><th>功  能</th><th>MYISAM</th><th>Memory</th><th>InnoDB</th><th>Archive</th></tr></thead><tbody><tr><td>存储限制</td><td>256TB</td><td>RAM</td><td>64TB</td><td>None</td></tr><tr><td>支持事物</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>支持全文索引</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>支持数索引</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>支持哈希索引</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>支持数据缓存</td><td>No</td><td>N/A</td><td>Yes</td><td>No</td></tr><tr><td>支持外键</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr></tbody></table><p><strong>存储引擎的选择：</strong><br>如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个好的选择</p><p>如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率</p><p>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果</p><p>如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archive</p><p>使用哪一种引擎需要灵活选择，一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求，使用合适的存储引擎，将会提高整个数据库的性能</p><h4 id="MyISAM与InnoDB的区别"><a href="#MyISAM与InnoDB的区别" class="headerlink" title="MyISAM与InnoDB的区别"></a>MyISAM与InnoDB的区别</h4><p>1、InnoDB支持事务处理，而MyISAM不支持<br>2、InnoDB支持外键，而MyISAM不支持<br>3、InnoDB是行锁，而MyISAM是表锁（行锁开销大，高并发；表锁开销小，并发低）<br>4、MyISAM支持全文索引，而InnoDB不支持</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySql的核心就是存储引擎。&lt;/p&gt;
&lt;h4 id=&quot;存储引擎查看&quot;&gt;&lt;a href=&quot;#存储引擎查看&quot; class=&quot;headerlink&quot; title=&quot;存储引擎查看&quot;&gt;&lt;/a&gt;存储引擎查看&lt;/h4&gt;&lt;p&gt;MySQL给开发者提供了查询存储引擎的功能，我这里使用的是 10.1.28-MariaDB，可以使用：&lt;br&gt;&lt;code&gt;show engines;&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 的事务处理以及隔离级别</title>
    <link href="http://yoursite.com/2018/03/28/MySQL-%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/28/MySQL-的事务处理以及隔离级别/</id>
    <published>2018-03-28T10:47:09.000Z</published>
    <updated>2018-03-28T11:10:04.627Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容出自《高性能MySQL》第三版，了解事务的ACID及四种隔离级有助于我们更好的理解事务运作。<br>下面举一个银行应用是解释事务必要性的一个经典例子。假如一个银行的数据库有两张表：支票表（checking）和储蓄表（savings）。现在要从用户Jane的支票账户转移200美元到她的储蓄账户，那么至少需要三个步骤：</p><blockquote><p>1、检查支票账户的余额高于或者等于200美元。<br>2、从支票账户余额中减去200美元。<br>3、在储蓄帐户余额中增加200美元。</p></blockquote><p>上述三个步骤的操作必须打包在一个事务中，任何一个步骤失败，则必须回滚所有的步骤。<br><a id="more"></a></p><h4 id="1、事务处理的基本语法"><a href="#1、事务处理的基本语法" class="headerlink" title="1、事务处理的基本语法"></a>1、事务处理的基本语法</h4><p>可以用START TRANSACTION语句开始一个事务，然后要么使用COMMIT提交将修改的数据持久保存，要么使用ROLLBACK撤销所有的修改。事务SQL的样本如下：</p><blockquote><p>1.start transaction;<br>2.select balance from checking where customer_id = 10233276;<br>3.update checking set balance = balance - 200.00 where customer_id = 10233276;<br>4.update savings set balance = balance + 200.00 where customer_id = 10233276;<br>5.commit;</p></blockquote><h4 id="2、事务处理的特性"><a href="#2、事务处理的特性" class="headerlink" title="2、事务处理的特性"></a>2、事务处理的特性</h4><p>ACID表示原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。一个很好的事务处理系统，必须具备这些标准特性：</p><h5 id="原子性（atomicity）"><a href="#原子性（atomicity）" class="headerlink" title="原子性（atomicity）"></a>原子性（atomicity）</h5><p>　　一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性</p><h5 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h5><p>　　数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）</p><h5 id="隔离性（isolation）"><a href="#隔离性（isolation）" class="headerlink" title="隔离性（isolation）"></a>隔离性（isolation）</h5><p>　　通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）</p><h5 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h5><p>　　一旦事务提交，则其所做的修改不会永久保存到数据库。（此时即使系统崩溃，修改的数据也不会丢失。持久性是个有占模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必，而且不可能有能做到100%的持久性保证的策略。）</p><h4 id="3、事务处理的隔离级别"><a href="#3、事务处理的隔离级别" class="headerlink" title="3、事务处理的隔离级别"></a>3、事务处理的隔离级别</h4><h5 id="READ-UNCOMMITTED（未提交读）"><a href="#READ-UNCOMMITTED（未提交读）" class="headerlink" title="READ UNCOMMITTED（未提交读）"></a>READ UNCOMMITTED（未提交读）</h5><p>　　在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。</p><h5 id="READ-COMMITTED（提交读）"><a href="#READ-COMMITTED（提交读）" class="headerlink" title="READ COMMITTED（提交读）"></a>READ COMMITTED（提交读）</h5><p>　　大多数数据库系统的默认隔离级别都是READ COMMTTED（但MySQL不是）。READ COMMITTED满足前面提到的隔离性的简单定义：一个事务开始时，只能”看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候叫做不可重复读（nonrepeatble read），因为两次执行同样的查询，可能会得到不一样的结果</p><h5 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE READ(可重复读)"></a>REPEATABLE READ(可重复读)</h5><p>　　REPEATABLE READ解决了脏读的问题。该隔离级别保证了在同一个事务中多次读取同样记录结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。</p><h5 id="SERIALIZABLE（可串行化）"><a href="#SERIALIZABLE（可串行化）" class="headerlink" title="SERIALIZABLE（可串行化）"></a>SERIALIZABLE（可串行化）</h5><p>　　SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE会在读取每一行数据都加锁，所以可能导致大量的超时和锁争用问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。</p><p>下面对隔离级别进行汇总，如下表：<br><img src="/uploads/2018/03/mysql_transaction_character.png" alt=""></p><h4 id="4、事务处理的相关语法总结"><a href="#4、事务处理的相关语法总结" class="headerlink" title="4、事务处理的相关语法总结"></a>4、事务处理的相关语法总结</h4><h5 id="1、查询当前这个点的下一个事务隔离级别："><a href="#1、查询当前这个点的下一个事务隔离级别：" class="headerlink" title="1、查询当前这个点的下一个事务隔离级别："></a>1、查询当前这个点的下一个事务隔离级别：</h5><p><code>select @@tx_isolation;</code><br><img src="/uploads/2018/03/mysql_transaction_level_01.png" alt=""></p><h5 id="2、查询全局事务隔离级别，也就是从这个点开始的下一个事务起所有的事务都采用设置的该隔离级别："><a href="#2、查询全局事务隔离级别，也就是从这个点开始的下一个事务起所有的事务都采用设置的该隔离级别：" class="headerlink" title="2、查询全局事务隔离级别，也就是从这个点开始的下一个事务起所有的事务都采用设置的该隔离级别："></a>2、查询全局事务隔离级别，也就是从这个点开始的下一个事务起所有的事务都采用设置的该隔离级别：</h5><p><code>select @@global.tx_isolation;</code><br><img src="/uploads/2018/03/mysql_transaction_level_02.png" alt=""></p><h5 id="3、查询当前所在的事务的隔离级别："><a href="#3、查询当前所在的事务的隔离级别：" class="headerlink" title="3、查询当前所在的事务的隔离级别："></a>3、查询当前所在的事务的隔离级别：</h5><p><code>select @@session.tx_isolation;</code><br><img src="/uploads/2018/03/mysql_transaction_level_03.png" alt=""></p><h5 id="4、设置事务隔离级别"><a href="#4、设置事务隔离级别" class="headerlink" title="4、设置事务隔离级别"></a>4、设置事务隔离级别</h5><p>1.在my.cnf文件中的mysqld中进行更改。可供更改的leve 【READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE】<br>如：<code>transaction_isolation = SERIALIZABLE</code></p><p>2.用mysql语句进行更改，语法 <code>set tx_isolation= level</code>   level级别【READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE】</p><p>注：可通过上述语法查询是否更改。</p><h4 id="5、事务隔离级别示例详解"><a href="#5、事务隔离级别示例详解" class="headerlink" title="5、事务隔离级别示例详解"></a>5、事务隔离级别示例详解</h4><h5 id="1、脏读："><a href="#1、脏读：" class="headerlink" title="1、脏读："></a>1、<strong>脏读：</strong></h5><p>脏读指的是一个事务修改本事务的数据，但没有提交的情况下，本事务可以查看到更改了却没有提交的数据。这种情况只可能发生在未提交读readuncommitted的隔离级别里。</p><blockquote><p>首先设置事务隔离级别为read-uncommited<br>事务一：给t表添加数据a=1但并不提交！查询t表的结果里本事务是可以看到未提交的操作结果的。<br><img src="/uploads/2018/03/mysql_transaction_example_01.png" alt=""><br>事务二：查询t表的数据，这个时候事务一是没有提交的!要确保事务二的隔离级别是read-uncommited。<br><img src="/uploads/2018/03/mysql_transaction_example_02.png" alt=""></p></blockquote><p>这个情况就是所谓的脏读！只可能出现在read-uncommit隔离级别里！自己可尝试其他级别试试</p><h5 id="2、不重复读："><a href="#2、不重复读：" class="headerlink" title="2、不重复读："></a>2、<strong>不重复读：</strong></h5><p>指的是一个事务多次读取同一个数据，但此过程中第二个事务对第一个事务进行了修改，这就造成了第一个事务的多次读取过程中的结果出现了前后不一致的情况，这就是不可重复读！这个情况可以出现在read-uncommited和read-committed两个隔离级别里！</p><blockquote><p>先看反例repeatable-read隔离级别下的情况，这种级别下只会读取首次select的点的数据结果，以避免出现不重复读的情况：<br>事务一：查询t表a=5，然后update进行修改a=22，查看修改后的结果最后提交<br><img src="/uploads/2018/03/mysql_transaction_example_03.png" alt=""><br>事务二：在事务一开始后select操作时同时也进行两次查询，查询结果和事务一的结果一致，都是5，等到事务一update操作后事务二进行第三次查询，查询结果依旧为5，事务一提交后，事务二进行第四次查询，结果依旧是5，没有任何改变，所以repeatable-read的隔离级别解决了重复读的问题。<br><img src="/uploads/2018/03/mysql_transaction_example_04.png" alt=""></p></blockquote><p><strong>下面我们再来看read-commit隔离级别下的情况：</strong><br>事务一：<br><img src="/uploads/2018/03/mysql_transaction_example_05.png" alt=""><br>事务二：<br><img src="/uploads/2018/03/mysql_transaction_example_06.png" alt=""></p><h5 id="3、幻读："><a href="#3、幻读：" class="headerlink" title="3、幻读："></a>3、<strong>幻读：</strong></h5><p>在repeatable-read级别下解决了不可重复读的问题，但是还有没有解决的地方，那就是幻读，幻读是指在一个事务中，事务一对数据进行了更改并提交了，而事务二也对该数据进行了更改，但是更改的情况可能会受到事务一更改的影响，从而引起更改仿佛不存在，这就是幻读！这是由于repeatable-read的隔离措施只读取初次select的点导致的。</p><blockquote><p>t表的有一行数据，a=5<br>事务一：首先读取t表，发现有一个a=5的数据，然后更改该数据为25并提交<br><img src="/uploads/2018/03/mysql_transaction_example_07.png" alt=""><br>事务二：首先读取t表，发现有一个a=5的数据，这个时候事务一已经删除数据并期间了，但是由于隔离级别是repeatable-read导致读取的结果是a=5的数据还在，这个时候如果事务二对该数据进行更改，改为26，提交后发现之前的更改无效，该行数据a=25，这是因为事务一已经对a=5的数据进行了更改，改为了25，这个时候a=5的数据已经不存在了，因此这次更改无效，等同于幻影，这就是幻读！<br><img src="/uploads/2018/03/mysql_transaction_example_08.png" alt=""></p></blockquote><p>可以从这里看出，提交读解决了脏读问题，而重复读解决了不重复读的问题，串行化解决幻读的问题，但是也会造成锁竞争，可能造成大量的超时问题，因为串行化是给每个读的数据行加上共享锁，通过强制事务进行排序，以此防止相互冲突，具体原理以后再做说明。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容出自《高性能MySQL》第三版，了解事务的ACID及四种隔离级有助于我们更好的理解事务运作。&lt;br&gt;下面举一个银行应用是解释事务必要性的一个经典例子。假如一个银行的数据库有两张表：支票表（checking）和储蓄表（savings）。现在要从用户Jane的支票账户转移200美元到她的储蓄账户，那么至少需要三个步骤：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、检查支票账户的余额高于或者等于200美元。&lt;br&gt;2、从支票账户余额中减去200美元。&lt;br&gt;3、在储蓄帐户余额中增加200美元。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述三个步骤的操作必须打包在一个事务中，任何一个步骤失败，则必须回滚所有的步骤。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>windows 7设置WiFi热点</title>
    <link href="http://yoursite.com/2018/03/27/windows-7%E8%AE%BE%E7%BD%AEWiFi%E7%83%AD%E7%82%B9/"/>
    <id>http://yoursite.com/2018/03/27/windows-7设置WiFi热点/</id>
    <published>2018-03-27T08:04:35.000Z</published>
    <updated>2018-03-27T08:09:47.827Z</updated>
    
    <content type="html"><![CDATA[<p>点击可查看…<br><a id="more"></a></p><h4 id="1、查看是否支持并开启"><a href="#1、查看是否支持并开启" class="headerlink" title="1、查看是否支持并开启"></a>1、查看是否支持并开启</h4><p>首先打开自己的网络连接，看一下有没有上述网卡图标，若有则进行下一步，若没有则打开设备管理器，找到网卡选项，右击选择更新网卡驱动，若此时出现说明你的电脑支持此功能，若没有出现，则说明电脑不支持。<br><img src="/uploads/2018/03/network_wifi_01.jpg" alt=""></p><h4 id="2、设置WiFi热点"><a href="#2、设置WiFi热点" class="headerlink" title="2、设置WiFi热点"></a>2、设置WiFi热点</h4><p>点击 开始， 选择 附件，找到命令提示符，右击选择以管理员方式运行<br>输入：<code>netsh wlan set hostednetwork mode=allow ssid=&quot;无线热点的名字&quot; key=“w ifi的密码”</code>，然后回车，如果出现如下的信息，则表示设置成功：<br><img src="/uploads/2018/03/network_wifi_02.jpg" alt=""><br><img src="/uploads/2018/03/network_wifi_03.jpg" alt=""></p><h4 id="3、开启WiFi"><a href="#3、开启WiFi" class="headerlink" title="3、开启WiFi"></a>3、开启WiFi</h4><p>至此wifi已经设置完成，现在就是开始运行问题，输入：netsh wlan start hostednetwork 然后回车，则启动wifi<br>以后，每次重启电脑后都需要运行netsh wlan start hostednetwork命令来启动<br><img src="/uploads/2018/03/network_wifi_04.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击可查看…&lt;br&gt;
    
    </summary>
    
      <category term="Windows" scheme="http://yoursite.com/categories/Windows/"/>
    
    
      <category term="Windows" scheme="http://yoursite.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>算法概述及效率的度量</title>
    <link href="http://yoursite.com/2018/03/26/%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F/"/>
    <id>http://yoursite.com/2018/03/26/算法概述及效率的度量/</id>
    <published>2018-03-26T02:39:43.000Z</published>
    <updated>2018-03-26T02:45:14.977Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、算法的定义"><a href="#1、算法的定义" class="headerlink" title="1、算法的定义"></a>1、算法的定义</h4><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><h4 id="2、算法具有的武哥基本特性"><a href="#2、算法具有的武哥基本特性" class="headerlink" title="2、算法具有的武哥基本特性"></a>2、算法具有的武哥基本特性</h4><ul><li><strong>有穷性：</strong> 指算法在执行有限的步骤之后，自动结束而不会出现无线循环，并且每一个步骤在可接受的时间内完成。</li><li><strong>确定性：</strong> 算法的每一步骤都具有确定的含义，不会出现二义性。</li><li><strong>可行性：</strong> 算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</li><li><strong>输入：</strong> 一个算法有零个或多个的输入，这些输入取自于某个特定的对象的集合。</li><li><strong>输出：</strong> 一个算法有一个或多个的输出，这些输出是同输入有着某些特定关系的量。</li></ul><a id="more"></a><h4 id="3、算法设计的要求"><a href="#3、算法设计的要求" class="headerlink" title="3、算法设计的要求"></a>3、算法设计的要求</h4><p>设计算法时，通常应考虑达到以下目标：</p><ul><li><strong>正确性：</strong> 算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。</li><li><strong>可读性：</strong> 算法设计的另一个目的是为了便于阅读、理解和交流。另一方面，晦涩难懂的程序易于隐藏较多错误而难以调试。</li><li><strong>健壮性：</strong> 当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</li><li><strong>高效率与低存储量：</strong> 通常，效率指的是算法执行时间；存储量指的是算法执行过程中所需的最大存储空间，两者都与问题的规模相关。</li></ul><h4 id="4、算法效率的度量方法："><a href="#4、算法效率的度量方法：" class="headerlink" title="4、算法效率的度量方法："></a>4、算法效率的度量方法：</h4><ul><li><strong>事后统计方法：</strong> 这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</li><li><strong>事前分析估算法：</strong> 在计算机程序编制前，依据统计方法对算法进行估算。一个程序的运行时间，依赖于算法的好坏和问题的输入规模。（所谓问题输入规模是指输入量的多少。）</li></ul><h4 id="5、算法的时间复杂度"><a href="#5、算法的时间复杂度" class="headerlink" title="5、算法的时间复杂度"></a>5、算法的时间复杂度</h4><p>算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。他表示岁问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为<strong>时间复杂度</strong>。</p><blockquote><p>推导大O阶：<br>1.用常数1取代运行时间中的所有加法常数。<br>2.在修改后的运行次数函数中，只保留最高阶项。<br>3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。<br>得到的结果就是大O阶。</p></blockquote><table><thead><tr><th>执行次数函数</th><th>阶</th><th>非正式术语</th></tr></thead><tbody><tr><td>12</td><td>O(1)</td><td>常数阶</td></tr><tr><td>2n+3</td><td>O(n)</td><td>线性阶</td></tr><tr><td>3n^2+2n+1</td><td>O(n^2)</td><td>平方阶</td></tr><tr><td>5log2n+20</td><td>O(logn)</td><td>对数阶</td></tr><tr><td>2n+3nlog2n+19</td><td>O(nlogn)</td><td>nlogn阶</td></tr><tr><td>6n^3+2n^2+3n+4</td><td>O(n^3)</td><td>立方阶</td></tr><tr><td>2^n</td><td>O(2^n)</td><td>指数阶</td></tr></tbody></table><p><strong>常用的时间复杂度所耗费的时间从小到大依次是：</strong><br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</p><h4 id="6、算法空间复杂度"><a href="#6、算法空间复杂度" class="headerlink" title="6、算法空间复杂度"></a>6、算法空间复杂度</h4><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p><p><strong>（注：一般在没有特殊说明的情况下，都是指最坏时间复杂度。）</strong></p><h4 id="7、算法的时间复杂度推导公式"><a href="#7、算法的时间复杂度推导公式" class="headerlink" title="7、算法的时间复杂度推导公式"></a>7、算法的时间复杂度推导公式</h4><p>待补充…</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、算法的定义&quot;&gt;&lt;a href=&quot;#1、算法的定义&quot; class=&quot;headerlink&quot; title=&quot;1、算法的定义&quot;&gt;&lt;/a&gt;1、算法的定义&lt;/h4&gt;&lt;p&gt;算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。&lt;/p&gt;
&lt;h4 id=&quot;2、算法具有的武哥基本特性&quot;&gt;&lt;a href=&quot;#2、算法具有的武哥基本特性&quot; class=&quot;headerlink&quot; title=&quot;2、算法具有的武哥基本特性&quot;&gt;&lt;/a&gt;2、算法具有的武哥基本特性&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有穷性：&lt;/strong&gt; 指算法在执行有限的步骤之后，自动结束而不会出现无线循环，并且每一个步骤在可接受的时间内完成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确定性：&lt;/strong&gt; 算法的每一步骤都具有确定的含义，不会出现二义性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可行性：&lt;/strong&gt; 算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输入：&lt;/strong&gt; 一个算法有零个或多个的输入，这些输入取自于某个特定的对象的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出：&lt;/strong&gt; 一个算法有一个或多个的输出，这些输出是同输入有着某些特定关系的量。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下二进制文件命令存放目录区别</title>
    <link href="http://yoursite.com/2018/03/20/Linux-%E4%B8%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E5%AD%98%E6%94%BE%E7%9B%AE%E5%BD%95%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/20/Linux-下二进制文件命令存放目录区别/</id>
    <published>2018-03-20T10:48:21.000Z</published>
    <updated>2018-03-20T10:50:35.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二进制文件命令：</p><ul><li>/bin　　# 系统的一些指令</li><li>/sbin　　# 一般是指超级用户指令</li><li>/usr/bin　　# 后期安装的一些软件的运行脚本</li><li>/usr/sbin　　# 一些用户安装的系统管理的必备程序</li><li>/usr/local/bin　　# 通常是源码编译的软件</li><li>/usr/local/sbin　　# 通常是源码编译的软件，用来管理系统的程序</li></ul></blockquote><a id="more"></a><p><strong>首先看下PATH变量在不同用户下的值：</strong><br><strong>root用户：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos /]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure></p><p><strong>普通用户：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ben@VM_0_7_centos ~]$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/ben/.local/bin:/home/ben/bin</span><br></pre></td></tr></table></figure></p><p>（注：bin是binary的缩写，二进制。sbin意义为system binary。）</p><blockquote><p>由上面可知道 root权限都没有 /bin、/sbin 的目录使用权。为什么呢？<br>原因就是，/bin以及/sbin是和/在同一文件系统，在挂载其他文件系统之前就可以使用/bin以及/sbin下的命令。<br>/usr/bin，/usr/sbin，/usr/local/bin，/usr/local/sbin可能与根文件系统不在同一文件系统之中，可能是在其他文件系统中后挂载上去的。<br>而我的服务器是 腾讯云，因此也是挂载上去的。</p></blockquote><p>从命令功能来看，/sbin 下的命令属于基本的系统命令，如shutdown，reboot，用于启动系统，修复系统，/bin下存放一些普通的基本命令，如ls,chmod等，这些命令在Linux系统里的配置文件脚本里经常用到。</p><p>从用户权限的角度看，/sbin目录下的命令通常只有管理员才可以运行，/bin下的命令管理员和一般的用户都可以使用。</p><p>从可运行时间角度看，/sbin,/bin能够在挂载其他文件系统前就可以使用。</p><p><strong>下面来说一下常用的目录：</strong></p><blockquote><p><strong>/bin 是系统的一些指令。</strong><br>bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。<br><strong>/sbin 一般是指超级用户指令。</strong><br>主要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。<br><strong>/usr/bin 是你在后期安装的一些软件的运行脚本。</strong><br>主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome<em>、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb</em>、wget等。<br><strong>/usr/sbin 放置一些用户安装的系统管理的必备程式</strong><br>例如:dhcpd、httpd、imap、in.<em>d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等。<br><strong>/usr/local/bin </strong><br>很多时候我们自己安装的软件，可能在此处建立一个软连接（符号链接），指向实际的可执行文件。<br><em>*/usr/local/sbin</em></em><br>也是我们自己安装的软件，一般用来管理系统的程序</p></blockquote><p>（注：以上所说的并不是绝对的，例如ifconfig在/sbin下，但是普通用户一般具有可执行权限。）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;二进制文件命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/bin　　# 系统的一些指令&lt;/li&gt;
&lt;li&gt;/sbin　　# 一般是指超级用户指令&lt;/li&gt;
&lt;li&gt;/usr/bin　　# 后期安装的一些软件的运行脚本&lt;/li&gt;
&lt;li&gt;/usr/sbin　　# 一些用户安装的系统管理的必备程序&lt;/li&gt;
&lt;li&gt;/usr/local/bin　　# 通常是源码编译的软件&lt;/li&gt;
&lt;li&gt;/usr/local/sbin　　# 通常是源码编译的软件，用来管理系统的程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7修改yum源</title>
    <link href="http://yoursite.com/2018/03/20/CentOS-7%E4%BF%AE%E6%94%B9yum%E6%BA%90/"/>
    <id>http://yoursite.com/2018/03/20/CentOS-7修改yum源/</id>
    <published>2018-03-20T10:48:03.000Z</published>
    <updated>2018-03-20T10:49:09.568Z</updated>
    
    <content type="html"><![CDATA[<p>官方的yum源在国内访问效果不佳。<br>需要改为国内比较好的阿里云或者网易的yum源。</p><p>1、配置 yum源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 备份当前的yum源</span><br><span class="line">cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS.Base.repo.bak</span><br><span class="line"></span><br><span class="line"># 下载阿里云的yum配置源</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure></p><p>2、然后更新缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官方的yum源在国内访问效果不佳。&lt;br&gt;需要改为国内比较好的阿里云或者网易的yum源。&lt;/p&gt;
&lt;p&gt;1、配置 yum源&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git 源码安装升级CentOS 7中版本</title>
    <link href="http://yoursite.com/2018/03/19/Git-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E5%8D%87%E7%BA%A7CentOS-7%E4%B8%AD%E7%89%88%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/03/19/Git-源码安装升级CentOS-7中版本/</id>
    <published>2018-03-19T05:49:30.000Z</published>
    <updated>2018-03-19T06:07:19.817Z</updated>
    
    <content type="html"><![CDATA[<p>服务器上报个漏洞警告：</p><blockquote><p><strong>漏洞名称：</strong>Git 远程代码执行漏洞 (CVE-2016-2315)<br><strong>漏洞描述：</strong>Git小于2.7.1的全版本中存在一个由于整数溢出导致的缓冲区边界溢出的远程代码执行漏洞，可使攻击者远程执行任意代码</p></blockquote><p>因此，才有了这篇升级安装Git，使用源码编译安装指定版本。</p><h4 id="1、下载-Git最新版的源码包"><a href="#1、下载-Git最新版的源码包" class="headerlink" title="1、下载 Git最新版的源码包"></a>1、下载 Git最新版的源码包</h4><p>登录<a href="https://github.com/git/git/releases查看git的最新版。不要下载带有-rc的，因为它代表了一个候选发布版本。" target="_blank" rel="noopener">https://github.com/git/git/releases查看git的最新版。不要下载带有-rc的，因为它代表了一个候选发布版本。</a><br>安装指令：<br><code>wget https://www.kernel.org/pub/software/scm/git/git-2.16.2.tar.gz</code><br><a id="more"></a><br><img src="/uploads/2018/03/git_releases_download.png" alt=""></p><h4 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h4><p><code>tar -xvf git-2.16.2</code></p><h4 id="3、进行目录配置"><a href="#3、进行目录配置" class="headerlink" title="3、进行目录配置"></a>3、进行目录配置</h4><p><code>cd git-2.16.2</code><br><code>./configure --prefix=/usr/local/git</code><br>结果显示没有 configure 文件，尴尬了！<br>根据网上搜索才了解到查找解压包中没有对应的 configure 文件，因此应该找README 或者 INSTALL 之类的文档。</p><p>通过 INSTALL安装文档可知，执行如下命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make configure ;# as yourself</span><br><span class="line">$ ./configure --prefix=/usr ;# as yourself</span><br><span class="line">$ make all doc ;# as yourself</span><br><span class="line"># make install install-doc install-html;# as root</span><br></pre></td></tr></table></figure></p><p>① 执行 <code>make configure</code>：报错</p><blockquote><p>[root@VM_0_7_centos git-2.16.2]# make configure<br>GIT_VERSION = 2.16.2<br>    GEN configure<br>/bin/sh: autoconf: command not found<br>make: <strong>* [configure] Error 127</strong>解决方法：**<br><code>[root@VM_0_7_centos git-2.16.2]# yum install -y autoconf</code></p></blockquote><p>② <code>./configure --prefix=/usr/local/git</code> 成功执行</p><p>③ <code>make</code>：报错</p><blockquote><p>Can’t locate ExtUtils/MakeMaker.pm in @INC (@INC contains: /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .) at Makefile.PL line 3.<br>BEGIN failed–compilation aborted at Makefile.PL line 3.<br>make[1]: <strong><em> [perl.mak] Error 2<br>make: </em></strong> [perl/perl.mak] Error 2<br><strong>解决方法：</strong><br><code>[root@VM_0_7_centos git-2.16.2]# yum install -y perl-ExtUtils-MakeMaker</code></p></blockquote><p>④ <code>make install</code> 成功执行，安装完成。<br>（注：如何确认是否安装完成，只要看 <code>make</code> 执行后的结果没有报错，基本都是ok的。）</p><h4 id="4、配置全局路径"><a href="#4、配置全局路径" class="headerlink" title="4、配置全局路径"></a>4、配置全局路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/usr/local/git/bin:$PATH&quot; </span><br><span class="line">source /etc/profile# 使/etc/profile 文件中的环境变量立即生效</span><br></pre></td></tr></table></figure><p>（注：此配置全局路径只是对当前生效，重启后就会失效。）<br>可使用软连接的形式，来使命令长久生效：<br><code>ln -s /usr/local/git/bin/git /usr/local/bin/git</code></p><h4 id="5、查看Git版本"><a href="#5、查看Git版本" class="headerlink" title="5、查看Git版本"></a>5、查看Git版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos git-2.16.2]# git --version</span><br><span class="line">git version 2.16.2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务器上报个漏洞警告：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;漏洞名称：&lt;/strong&gt;Git 远程代码执行漏洞 (CVE-2016-2315)&lt;br&gt;&lt;strong&gt;漏洞描述：&lt;/strong&gt;Git小于2.7.1的全版本中存在一个由于整数溢出导致的缓冲区边界溢出的远程代码执行漏洞，可使攻击者远程执行任意代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，才有了这篇升级安装Git，使用源码编译安装指定版本。&lt;/p&gt;
&lt;h4 id=&quot;1、下载-Git最新版的源码包&quot;&gt;&lt;a href=&quot;#1、下载-Git最新版的源码包&quot; class=&quot;headerlink&quot; title=&quot;1、下载 Git最新版的源码包&quot;&gt;&lt;/a&gt;1、下载 Git最新版的源码包&lt;/h4&gt;&lt;p&gt;登录&lt;a href=&quot;https://github.com/git/git/releases查看git的最新版。不要下载带有-rc的，因为它代表了一个候选发布版本。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/git/git/releases查看git的最新版。不要下载带有-rc的，因为它代表了一个候选发布版本。&lt;/a&gt;&lt;br&gt;安装指令：&lt;br&gt;&lt;code&gt;wget https://www.kernel.org/pub/software/scm/git/git-2.16.2.tar.gz&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>FTP 客户端报错集锦</title>
    <link href="http://yoursite.com/2018/03/19/FTP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8A%A5%E9%94%99%E9%9B%86%E9%94%A6/"/>
    <id>http://yoursite.com/2018/03/19/FTP-客户端报错集锦/</id>
    <published>2018-03-19T03:19:53.000Z</published>
    <updated>2018-03-19T03:24:34.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、ftp-客户端连接报错，如下："><a href="#1、ftp-客户端连接报错，如下：" class="headerlink" title="1、ftp 客户端连接报错，如下："></a>1、ftp 客户端连接报错，如下：</h4><blockquote><p><img src="/uploads/2018/03/ftp_connect_error.png" alt="" title="ftp连接超时"></p></blockquote><p>经查看是因为 服务器端对应的 21号端口未开启，开启即可，命令如下：<br><code>iptables -I INPUT 4 -p tcp -m tcp --dport 21 -j ACCEPT</code><br><a id="more"></a></p><h4 id="2、ftp-客户端连接成功，而读取目录失败，如下："><a href="#2、ftp-客户端连接成功，而读取目录失败，如下：" class="headerlink" title="2、ftp 客户端连接成功，而读取目录失败，如下："></a>2、ftp 客户端连接成功，而读取目录失败，如下：</h4><blockquote><p><img src="/uploads/2018/03/ftp_writedir_error.png" alt="" title="ftp读取目录失败"></p></blockquote><p>经过查找，发现是因为ftp数据连接模式的问题，ftp连接模式有两种：PORT（主动模式）和PASV（被动模式）。两者的前面文章中已经说明两者的区别，在这里我选择“主动模式”，只开放ftp服务端20端口传输数据，客户端随机产生大于1024端口号。<br>然后，开启服务端20端口权限即可，命令如下：<br><code>iptables -I INPUT 4 -p tcp -m tcp --dport 20 -j ACCEPT</code></p><h4 id="3、ftp-客户端能够下载数据，却不能上传数据，如下："><a href="#3、ftp-客户端能够下载数据，却不能上传数据，如下：" class="headerlink" title="3、ftp 客户端能够下载数据，却不能上传数据，如下："></a>3、ftp 客户端能够下载数据，却不能上传数据，如下：</h4><blockquote><p><img src="/uploads/2018/03/ftp_trans_error.png" alt="" title="ftp文件传输错误"></p></blockquote><p>经过一番查找，发现应该是我本身一堆错误导致的。包括ftp 用户组使用但未创建，ftp用户根目录权限未给予正确的ftp用户组（注：根目录创建是root用户，因此所有者及所属组都是root。所以其他用户都不能操作）。因此，我做了如下修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 首先，创建用户组</span><br><span class="line">groupadd ftpgroup</span><br><span class="line"># 将用户添加进用户组</span><br><span class="line">usermod -g ftpgroup ftp1</span><br><span class="line"># 更改用户根目录所属组</span><br><span class="line">chown -R :ftpgroup ceshi/</span><br><span class="line"># 更改用户根目录所属组权限为可写</span><br><span class="line">chmod -R g+w ceshi/</span><br></pre></td></tr></table></figure></p><h4 id="4、ftp-拒绝登陆，如下："><a href="#4、ftp-拒绝登陆，如下：" class="headerlink" title="4、ftp 拒绝登陆，如下："></a>4、ftp 拒绝登陆，如下：</h4><blockquote><p><img src="/uploads/2018/03/ftp_refuse_error.png" alt="" title="ftp拒绝登陆"></p></blockquote><p>原因是配置文件中 <code>allow_writeable_chroot=YES</code> 不存在，而<code>chroot_local_user=YES</code>已经开启。所以导致 ftp 拒绝登陆。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、ftp-客户端连接报错，如下：&quot;&gt;&lt;a href=&quot;#1、ftp-客户端连接报错，如下：&quot; class=&quot;headerlink&quot; title=&quot;1、ftp 客户端连接报错，如下：&quot;&gt;&lt;/a&gt;1、ftp 客户端连接报错，如下：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/2018/03/ftp_connect_error.png&quot; alt=&quot;&quot; title=&quot;ftp连接超时&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经查看是因为 服务器端对应的 21号端口未开启，开启即可，命令如下：&lt;br&gt;&lt;code&gt;iptables -I INPUT 4 -p tcp -m tcp --dport 21 -j ACCEPT&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="FTP" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/"/>
    
    
      <category term="FTP" scheme="http://yoursite.com/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>FTP 服务器配置流程详解</title>
    <link href="http://yoursite.com/2018/03/19/FTP-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/19/FTP-服务器配置流程详解/</id>
    <published>2018-03-19T03:19:06.000Z</published>
    <updated>2018-03-19T03:31:29.475Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、修改-FTP服务器配置文件"><a href="#1、修改-FTP服务器配置文件" class="headerlink" title="1、修改 FTP服务器配置文件"></a>1、修改 FTP服务器配置文件</h4><p>① 安装完之后在/etc/vsftpd/路径下会存在三个配置文件。</p><blockquote><p><strong>vsftpd.conf：</strong> 主配置文件<br><strong>ftpusers：</strong> 指定哪些用户不能访问FTP服务器,这里的用户包括root在内的一些重要用户。<br><strong>user_list：</strong> 指定的用户是否可以访问ftp服务器，通过vsftpd.conf文件中的userlist_deny的配置来决定配置中的用户是否可以访问，userlist_enable=YES ，userlist_deny=YES ，userlist_file=/etc/vsftpd/user_list 这三个配置允许文件中的用户访问FTP。（<font color="red">注：文件中用户名一行一个</font>）</p></blockquote><a id="more"></a><blockquote><blockquote><ul><li>userlist_enable=YES, userlist_deny=NO(或缺省), user_list文件中的用户允许登陆，未出现在此文件中的用户不允许（默认）</li><li>userlist_enable=NO(或缺省), userlist_deny=YES, user_list文件中的用户不允许登陆，未出现再次文件中的用户允许</li><li>userlist_enable=YES, userlist_deny=YES, user_list文件中的用户不能访问FTP<br>（<font color="red">注：ftpusers文件中的用户为禁止登陆用户，此文件的权限大于user_list文件的权限</font>）</li></ul></blockquote></blockquote><p>② vsftpd.conf 默认配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# cat /etc/vsftpd/vsftpd.conf.bak | grep &apos;^[^#]&apos;</span><br><span class="line">anonymous_enable=YES</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">local_umask=022</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">xferlog_std_format=YES</span><br><span class="line">listen=NO</span><br><span class="line">listen_ipv6=YES</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">userlist_enable=YES</span><br><span class="line">tcp_wrappers=YES</span><br></pre></td></tr></table></figure></p><p>③ 设置 chroot 来限制用户根目录（一般此处是为了限制FTP用户到网站根目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>选项 <code>chroot_local_user=YES</code> 意味着本地用户将进入 chroot 环境，当登录以后默认情况下是其 home 目录。</li><li>选项 <code>chroot_list_file=/etc/vsftpd/chroot_list</code> 指定在此文件中的用户被限制在根目录中。（此文件缺省时，表示所有用户都被限制）</li><li>选项 <code>allow_writeable_chroot=YES</code> 可以允许 chroot 目录具有可写权限。（注：vsftpd默认是不允许chroot目录有可写权限）</li></ul></blockquote><h4 id="2、创建-FTP用户"><a href="#2、创建-FTP用户" class="headerlink" title="2、创建 FTP用户"></a>2、创建 FTP用户</h4><p>① 增加 FTP组<br><code>groupadd ftpgroup</code></p><p>② 增加用户并设置其目录为 /data/www/ceshi<br><code>useradd -g ftpgroup -d /data/www/ceshi -M ftp1</code></p><p>③ 设置用户口令<br><code>passwd ftp1</code></p><p>④ 更改用户根目录所属组及权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R :ftpgroup /data/www/ceshi</span><br><span class="line">chmod -R g+w /data/www/ceshi</span><br></pre></td></tr></table></figure></p><p>⑤ 将用户添加进 chroot_list文件：（即设置用户根目录）<br><code>vi /etc/vsftpd/chroot_list</code><br>（注：一行一个用户名）</p><p>⑥ 重启vsftpd<br><code>systemctl restart vsftpd.service</code></p><h4 id="3、测试-FTP"><a href="#3、测试-FTP" class="headerlink" title="3、测试 FTP"></a>3、测试 FTP</h4><p>可通过 FileZilla 连接FTP服务器<br><img src="/uploads/2018/03/ftp_filezilla_setting.png" alt="" title="FileZilla设置"></p><blockquote><p>① 点击‘文件’，打开站点管理器<br>② 如果有跳过此步，如果没有设置新站点<br>③ 协议选择“FTP文件传输协议”即可<br>④ 加密选择“普通FTP”即可<br>⑤ 传输设置 选择主动模式（即PORT模式）<br>⑥ 其它信息填写完整，点击连接</p></blockquote><p>如果报错，请看另一篇《FTP 客户端报错集锦》。</p><h4 id="4、常用-FTP命令总结"><a href="#4、常用-FTP命令总结" class="headerlink" title="4、常用 FTP命令总结"></a>4、常用 FTP命令总结</h4><h5 id="（1）建立用户账号"><a href="#（1）建立用户账号" class="headerlink" title="（1）建立用户账号"></a>（1）建立用户账号</h5><blockquote><p>useradd<br>　-c（备注）    加上备注文字<br>　-d（登入目录）        指定用户登入时的起始目录<br>　-g（群组）    指定用户所属的群组<br>　-s         指定用户登入后所使用的shell<br>例如：<code>useradd -d /alidata/www81/ceshi -g ftp -s /sbin/nologin ftp3</code></p></blockquote><h5 id="（2）删除用户账号"><a href="#（2）删除用户账号" class="headerlink" title="（2）删除用户账号"></a>（2）删除用户账号</h5><blockquote><p>userdel<br>语法： <code>userdel [-r] [用户账号]</code><br>补充说明：userdel 可删除用户账号与相关的文件。若不加参数，则仅删除用户账号，而不删除相关文件。<br>例如：<code>userdel -r ftp3</code></p></blockquote><h5 id="（3）修改用户账号"><a href="#（3）修改用户账号" class="headerlink" title="（3）修改用户账号"></a>（3）修改用户账号</h5><blockquote><p>usermod<br>语法： <code>usermod [-LU][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-g &lt;群组&gt;][-s ]</code><br>补充说明：可用来修改用户账号的各项设定<br>例如：<code>usermod -s /sbin/nologin tes</code></p></blockquote><h4 id="5、附本人配置的-vsftpd-conf"><a href="#5、附本人配置的-vsftpd-conf" class="headerlink" title="5、附本人配置的 vsftpd.conf"></a>5、附本人配置的 vsftpd.conf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=YES</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">local_umask=022</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">xferlog_std_format=YES</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line">listen=NO</span><br><span class="line">listen_ipv6=YES</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">userlist_enable=YES</span><br><span class="line">tcp_wrappers=YES</span><br><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、修改-FTP服务器配置文件&quot;&gt;&lt;a href=&quot;#1、修改-FTP服务器配置文件&quot; class=&quot;headerlink&quot; title=&quot;1、修改 FTP服务器配置文件&quot;&gt;&lt;/a&gt;1、修改 FTP服务器配置文件&lt;/h4&gt;&lt;p&gt;① 安装完之后在/etc/vsftpd/路径下会存在三个配置文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;vsftpd.conf：&lt;/strong&gt; 主配置文件&lt;br&gt;&lt;strong&gt;ftpusers：&lt;/strong&gt; 指定哪些用户不能访问FTP服务器,这里的用户包括root在内的一些重要用户。&lt;br&gt;&lt;strong&gt;user_list：&lt;/strong&gt; 指定的用户是否可以访问ftp服务器，通过vsftpd.conf文件中的userlist_deny的配置来决定配置中的用户是否可以访问，userlist_enable=YES ，userlist_deny=YES ，userlist_file=/etc/vsftpd/user_list 这三个配置允许文件中的用户访问FTP。（&lt;font color=&quot;red&quot;&gt;注：文件中用户名一行一个&lt;/font&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="FTP" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/"/>
    
    
      <category term="FTP" scheme="http://yoursite.com/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>FTP 服务器概述及安装、卸载</title>
    <link href="http://yoursite.com/2018/03/19/FTP-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%AE%89%E8%A3%85%E3%80%81%E5%8D%B8%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/03/19/FTP-服务器概述及安装、卸载/</id>
    <published>2018-03-19T03:18:10.000Z</published>
    <updated>2018-03-19T03:32:18.747Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、FTP概述"><a href="#1、FTP概述" class="headerlink" title="1、FTP概述"></a>1、FTP概述</h4><p>FTP（文件传输协议）是一个较老且最常用的标准网络协议，用于在两台计算机之间通过网络上传/下载文件。<br>FTP采用客户/服务器模式，客户机与服务器之间利用TCP建立连接，客户可以从服务器上下载文件，也可以把本地文件上传至服务器。<br>FTP服务器有匿名的和授权的两种。匿名的FTP服务器向公众开放，用户可以用“ftp”或“anonymous”为帐号，用电子邮箱地址为密码登录服务器；授权的FTP服务器必须用授权的账户名和密码才能登录服务器。通常匿名的用户权限较低，只能下载文件，不能上传文件。<br>客户机访问FTP服务器通常有两种方法：用FTP命令访问和用FTP客户端软件访问。</p><p>然而， FTP 最初的时候并不安全，因为它仅通过用户凭证（用户名和密码）传输数据，没有进行加密。如果你打算使用 FTP，需要考虑通过 SSL/TLS 配置 FTP 连接。否则，使用安全 FTP，比如 SFTP 会更好一些。<br><a id="more"></a></p><h4 id="2、知识点介绍"><a href="#2、知识点介绍" class="headerlink" title="2、知识点介绍"></a>2、知识点介绍</h4><h5 id="（1）FTP采用双TCP-连接方式"><a href="#（1）FTP采用双TCP-连接方式" class="headerlink" title="（1）FTP采用双TCP 连接方式"></a>（1）FTP采用双TCP 连接方式</h5><blockquote><p><strong>控制连接-使用TCP端口号21</strong><br>　　用于在FTP客户端和FTP服务器之间传输FTP控制命令及命令执行信息。控制连接在整个FTP会话期间一直保持打开。<br><strong>数据连接-使用TCP端口号20</strong><br>　　用于传输数据，包括数据上传、下载、文件列表发送等。数据传输结束后数据连接将终止。</p></blockquote><h5 id="（2）FTP传输方式"><a href="#（2）FTP传输方式" class="headerlink" title="（2）FTP传输方式"></a>（2）FTP传输方式</h5><blockquote><p>FTP主动数据传输方式<br>主动方式也称为PORT方式，是FTP协议最初定义的数据传输连接方式，主要特点是：</p><ul><li>FTP客户端通过向FTP服务器发送PORT命令，告诉服务器该客户端用于传输数据的临时端口号（大于1024的随机端口）</li><li>当需要传送数据时，<font color="red">服务器通过TCP端口号20与客户端的临时端口建立数据传输通道</font>，完成数据传输</li></ul></blockquote><p>在建立数据连接的过程中，由服务器主动发起连接，因此被称为主动方式。</p><blockquote><p>FTP被动数据传输方式<br>被动方式也称为PASV方式，被动方式的主要特点是：</p><ul><li>FTP客户端通过向FTP服务器发送PASV命令，告诉服务器进入被动方式。<font color="red">服务器选择临时端口号(1024~5000之间的随机端口)并告知客户端</font></li><li>当需要传送数据时，客户端主动与服务器的临时端口号建立数据传输通道，完成数据传输。</li></ul></blockquote><p>在整个过程中，由于服务器总是被动接收客户端的数据连接，因此被称为被动方式。</p><h5 id="（3）FTP用户的类型"><a href="#（3）FTP用户的类型" class="headerlink" title="（3）FTP用户的类型"></a>（3）FTP用户的类型</h5><p><strong>匿名用户：</strong>anonymous或ftp<br><strong>本地用户：</strong><br>　　帐号名称、密码等信息保存在passwd、shadow文件中<br><strong>虚拟用户：</strong><br>　　使用独立的帐号/密码数据文件<br>　　user_list zhangsan 123456 /var/pub</p><h4 id="3、在Centos-7中安装FTP-服务器"><a href="#3、在Centos-7中安装FTP-服务器" class="headerlink" title="3、在Centos 7中安装FTP 服务器"></a>3、在Centos 7中安装FTP 服务器</h4><p>非常简单，使用 yum只需要一条命令即可。<br><code>yum -y install vsftpd</code></p><h4 id="4、卸载FTP-服务器"><a href="#4、卸载FTP-服务器" class="headerlink" title="4、卸载FTP 服务器"></a>4、卸载FTP 服务器</h4><p>① 查看当前服务器中的vsftpd 包<br><code>rpm -qa|grep vsftpd</code><br>例如结果为：vsftpd-2.2.2-13.el6_6.1.x86_64</p><p>② 执行卸载<br><code>rpm -e vsftpd-2.2.2-13.el6_6.1.x86_64</code><br>返回：卸载时自动备份vsftp的用户列表文件</p><blockquote><p>warning: /etc/vsftpd/vsftpd.conf saved as /etc/vsftpd/vsftpd.conf.rpmsave<br>warning: /etc/vsftpd/user_list saved as /etc/vsftpd/user_list.rpmsave</p></blockquote><p>③ 删除上面的文件<br><code>rm -rf /etc/vsftpd</code></p><p>④ 查看vsftpd是否还在开机启动项中<br><code>chkconfig --list</code></p><p>⑤ 查看vsftpd运行状态<br><code>service vsftpd status</code></p><blockquote><p>返回：vsftpd: unrecognized service（无法识别vsftpd，说明卸载了vsftpd了）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、FTP概述&quot;&gt;&lt;a href=&quot;#1、FTP概述&quot; class=&quot;headerlink&quot; title=&quot;1、FTP概述&quot;&gt;&lt;/a&gt;1、FTP概述&lt;/h4&gt;&lt;p&gt;FTP（文件传输协议）是一个较老且最常用的标准网络协议，用于在两台计算机之间通过网络上传/下载文件。&lt;br&gt;FTP采用客户/服务器模式，客户机与服务器之间利用TCP建立连接，客户可以从服务器上下载文件，也可以把本地文件上传至服务器。&lt;br&gt;FTP服务器有匿名的和授权的两种。匿名的FTP服务器向公众开放，用户可以用“ftp”或“anonymous”为帐号，用电子邮箱地址为密码登录服务器；授权的FTP服务器必须用授权的账户名和密码才能登录服务器。通常匿名的用户权限较低，只能下载文件，不能上传文件。&lt;br&gt;客户机访问FTP服务器通常有两种方法：用FTP命令访问和用FTP客户端软件访问。&lt;/p&gt;
&lt;p&gt;然而， FTP 最初的时候并不安全，因为它仅通过用户凭证（用户名和密码）传输数据，没有进行加密。如果你打算使用 FTP，需要考虑通过 SSL/TLS 配置 FTP 连接。否则，使用安全 FTP，比如 SFTP 会更好一些。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="FTP" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/"/>
    
    
      <category term="FTP" scheme="http://yoursite.com/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>iptables 防火墙的规则设置</title>
    <link href="http://yoursite.com/2018/03/19/iptables-%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E8%A7%84%E5%88%99%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/03/19/iptables-防火墙的规则设置/</id>
    <published>2018-03-19T03:00:07.000Z</published>
    <updated>2018-03-19T03:14:46.082Z</updated>
    
    <content type="html"><![CDATA[<h4 id="iptables-常用命令及参数注释："><a href="#iptables-常用命令及参数注释：" class="headerlink" title="iptables 常用命令及参数注释："></a>iptables 常用命令及参数注释：</h4><blockquote><p>主要包含：<br><strong>命令表</strong><br>　　用来增加(-A、-I)删除(-D)修改(-R)查看(-L)规则等；<br><strong>常用参数</strong><br>　　用来指定协议(-p)、源地址(-s)、源端口(--sport)、目的地址(-d)、目的端口(--dport)、进入网卡(-i)、出去网卡(-o)等设定包信息（即什么样的包）；用来描述要处理包的信息。<br><strong>常用处理动作</strong><br>　　用 -j 来指定对包的处理(ACCEPT、DROP、REJECT、REDIRECT等)。</p></blockquote><a id="more"></a><p><strong>常用参数注释：</strong></p><p><font color="red">命令 -P, --policy</font><br>范例 <code>iptables -P INPUT DROP</code><br>说明 定义过滤政策。 也就是未符合过滤条件之封包，预设的处理方式。</p><p><font color="red">参数 --line-numbers</font><br>范例 <code>iptables -nL --line-numbers</code><br>说明 查询规则链表的number号。</p><p><font color="red">参数 -m state --state</font><br>范例 <code>iptables -A INPUT -m state --state RELATED,ESTABLISHED</code><br>说明 用来比对联机状态，联机状态共有四种：INVALID、ESTABLISHED、NEW 和 RELATED。</p><blockquote><p><strong>INVALID</strong> 表示该封包的联机编号（Session ID）无法辨识或编号不正确。<br><strong>ESTABLISHED</strong> 表示该封包属于某个已经建立的联机。<br><strong>NEW</strong> 表示该封包想要起始一个联机（重设联机或将联机重导向）。<br><strong>RELATED</strong> 表示该封包是属于某个已经建立的联机，所建立的新联机。例如：FTP-DATA 联机必定是源自某个 FTP 联机。</p></blockquote><h4 id="常用规则总结"><a href="#常用规则总结" class="headerlink" title="常用规则总结"></a>常用规则总结</h4><h5 id="（1）启动、停止和重启-iptables"><a href="#（1）启动、停止和重启-iptables" class="headerlink" title="（1）启动、停止和重启 iptables"></a>（1）启动、停止和重启 iptables</h5><p><code>systemctl start/stop/restart/status iptables.service</code></p><h5 id="（2）查看iptables-现有规则"><a href="#（2）查看iptables-现有规则" class="headerlink" title="（2）查看iptables 现有规则"></a>（2）查看iptables 现有规则</h5><p><code>iptables -L -n</code><br><code>iptables -Ln --line-numbers</code> #查看对应的规则numbers<br><code>iptables-save</code></p><h5 id="（3）屏蔽某个-IP"><a href="#（3）屏蔽某个-IP" class="headerlink" title="（3）屏蔽某个 IP"></a>（3）屏蔽某个 IP</h5><p><code>iptables -A INPUT -s xxx.xxx.xxx.xxx -j DROP</code><br>如果你只想屏蔽 TCP 流量，可以使用 -p 参数的指定协议，例如：<br><code>iptables -A INPUT -p tcp -s xxx.xxx.xxx.xxx -j DROP</code></p><h5 id="（4）解封某个-IP地址（即删除）"><a href="#（4）解封某个-IP地址（即删除）" class="headerlink" title="（4）解封某个 IP地址（即删除）"></a>（4）解封某个 IP地址（即删除）</h5><p><code>iptables -D INPUT -s xxx.xxx.xxx.xxx -j DROP</code><br>或<br><code>iptables -D INPUT numbers</code></p><h5 id="（5）关闭指定端口"><a href="#（5）关闭指定端口" class="headerlink" title="（5）关闭指定端口"></a>（5）关闭指定端口</h5><p>阻止特定的传出连接：<br><code>iptables -A OUTPUT -p tcp --dport xxx -j DROP</code><br>阻止特定的传入连接：<br><code>iptables -A INPUT -p tcp --dport xxx -j ACCEPT</code></p><h5 id="（6）使用Multiport控制多端口"><a href="#（6）使用Multiport控制多端口" class="headerlink" title="（6）使用Multiport控制多端口"></a>（6）使用Multiport控制多端口</h5><p>使用 multiport 我们可以一次性在单条规则中写入多个端口，例如：<br><code>iptables -A INPUT  -p tcp -m multiport --dports 22,80,443 -j ACCEPT</code><br><code>iptables -A OUTPUT -p tcp -m multiport --sports 22,80,443 -j ACCEPT</code></p><h5 id="（7）在规则中使用-IP-地址范围"><a href="#（7）在规则中使用-IP-地址范围" class="headerlink" title="（7）在规则中使用 IP 地址范围"></a>（7）在规则中使用 IP 地址范围</h5><p>在 IPtables 中 IP 地址范围是可以直接使用 CIDR 进行表示的，例如：<br><code>iptables -A OUTPUT -p tcp -d 192.168.100.0/24 --dport 22 -j ACCEPT</code></p><h5 id="（8）禁止PING"><a href="#（8）禁止PING" class="headerlink" title="（8）禁止PING"></a>（8）禁止PING</h5><p>对 Linux 禁 PING 可以使用如下规则屏蔽 ICMP 传入连接：<br><code>iptables -A INPUT -p icmp -i eth0 -j DROP</code></p><h5 id="（9）允许访问回环网卡"><a href="#（9）允许访问回环网卡" class="headerlink" title="（9）允许访问回环网卡"></a>（9）允许访问回环网卡</h5><p>环回访问（127.0.0.1）是比较重要的，建议大家都开放：<br><code>iptables -A INPUT -i lo -j ACCEPT</code><br><code>iptables -A OUTPUT -o lo -j ACCEPT</code></p><h5 id="（10）丢弃无效数据包"><a href="#（10）丢弃无效数据包" class="headerlink" title="（10）丢弃无效数据包"></a>（10）丢弃无效数据包</h5><p>很多网络攻击都会尝试用黑客自定义的非法数据包进行尝试，我们可以使用如下命令来丢弃无效数据包：<br><code>iptables -A INPUT -m conntrack --ctstate INVALID -j DROP</code></p><h5 id="（11）插入指定位置一条规则"><a href="#（11）插入指定位置一条规则" class="headerlink" title="（11）插入指定位置一条规则"></a>（11）插入指定位置一条规则</h5><p><code>iptables -I INPUT number -p tcp -m tcp --dport 21 -j ACCEPT</code><br>（<font color="red">注：插入对应的number位置，原number位置往后移</font>）</p><h4 id="常用端口总结"><a href="#常用端口总结" class="headerlink" title="常用端口总结"></a>常用端口总结</h4><table><thead><tr><th>服务</th><th>端口</th><th>是否开启</th><th>协议类型</th><th>描述</th></tr></thead><tbody><tr><td>HTTP</td><td>80</td><td>建议开启</td><td>tcp</td><td>Web服务</td></tr><tr><td>HTTPS</td><td>443</td><td>建议开启</td><td>tcp</td><td>Web加密服务</td></tr><tr><td>POP3</td><td>110</td><td>不建议开启</td><td>tcp</td><td>POP邮局协议</td></tr><tr><td>SMTP</td><td>25</td><td>不建议开启</td><td>tcp</td><td>SMTP邮件传输协议</td></tr><tr><td>FTP</td><td>21</td><td>不建议开启</td><td>tcp</td><td>FTP服务</td></tr><tr><td>SFTP</td><td>115</td><td>不建议开启</td><td>tcp</td><td>SFTP安全文本传输协议</td></tr><tr><td>SSH</td><td>22</td><td>必须开启</td><td>tcp</td><td>SSH服务</td></tr><tr><td>Telnet</td><td>23</td><td>不建议开启</td><td>tcp</td><td>不安全的文本传送</td></tr><tr><td>DNS</td><td>53</td><td>建议开启</td><td>tcp</td><td>DNS域名服务</td></tr><tr><td>TOMCAT</td><td>8080</td><td>不建议开启</td><td>tcp</td><td>tomcat服务器端口</td></tr><tr><td>MySQL</td><td>3306</td><td>不建议开启</td><td>tcp</td><td>MySQL服务器端口</td></tr></tbody></table><h4 id="附本人主机iptables规则脚本"><a href="#附本人主机iptables规则脚本" class="headerlink" title="附本人主机iptables规则脚本"></a>附本人主机iptables规则脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">iptables -F  # 清空所有默认规则</span><br><span class="line">iptables -X  # 清空所有自定义规则</span><br><span class="line">iptables -Z  # 所有封包计数器归0</span><br><span class="line"></span><br><span class="line"># 设置默认的访问规则</span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line"># 允许接受本机请求之后的返回数据（ESTABLISHED 是已经建立连接的状态）；RELATED 是为了FTP设置的</span><br><span class="line">iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A INPUT -p icmp -j ACCEPT  # 允许 ping</span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT    # 允许访问回环网卡</span><br><span class="line"></span><br><span class="line"># 自定义开启一些端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 3690 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 定义对应规则没有仍返回相应信息</span><br><span class="line">iptables -A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">iptables -A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line"># 保存更改并重启服务</span><br><span class="line">service iptables save</span><br><span class="line">systemctl restart iptables.service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;iptables-常用命令及参数注释：&quot;&gt;&lt;a href=&quot;#iptables-常用命令及参数注释：&quot; class=&quot;headerlink&quot; title=&quot;iptables 常用命令及参数注释：&quot;&gt;&lt;/a&gt;iptables 常用命令及参数注释：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;主要包含：&lt;br&gt;&lt;strong&gt;命令表&lt;/strong&gt;&lt;br&gt;　　用来增加(-A、-I)删除(-D)修改(-R)查看(-L)规则等；&lt;br&gt;&lt;strong&gt;常用参数&lt;/strong&gt;&lt;br&gt;　　用来指定协议(-p)、源地址(-s)、源端口(--sport)、目的地址(-d)、目的端口(--dport)、进入网卡(-i)、出去网卡(-o)等设定包信息（即什么样的包）；用来描述要处理包的信息。&lt;br&gt;&lt;strong&gt;常用处理动作&lt;/strong&gt;&lt;br&gt;　　用 -j 来指定对包的处理(ACCEPT、DROP、REJECT、REDIRECT等)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>系统服务管理详解</title>
    <link href="http://yoursite.com/2018/03/16/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/16/系统服务管理详解/</id>
    <published>2018-03-16T07:51:56.000Z</published>
    <updated>2018-03-16T08:32:00.661Z</updated>
    
    <content type="html"><![CDATA[<h4 id="透过systemctl-管理服务"><a href="#透过systemctl-管理服务" class="headerlink" title="透过systemctl 管理服务"></a>透过systemctl 管理服务</h4><p>基本上，systemd 这个启动服务的机制，主要是透过一只名为systemctl 的指令来处理的！跟以前systemV 需要service / chkconfig / setup / init 等指令来协助不同，systemd 就是仅有systemctl 这个指令来处理而已！所以全部的行为都得要使用systemctl。 </p><h5 id="1、单一服务-service-unit-的启动-开机启动与观察状态"><a href="#1、单一服务-service-unit-的启动-开机启动与观察状态" class="headerlink" title="1、单一服务(service unit) 的启动/开机启动与观察状态"></a>1、单一服务(service unit) 的启动/开机启动与观察状态</h5><p><font color="red">一般来说，服务的启动有两个阶段，一个是『开机的时候设定要不要启动这个服务』，以及『你现在要不要启动这个服务』</font>，这两者之间有很大的差异。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# systemctl [command] [unit]</span><br><span class="line">command主要有：</span><br><span class="line">start ：立刻启动后面接的unit</span><br><span class="line">stop ：立刻关闭后面接的unit</span><br><span class="line">restart ：立刻关闭后启动后面接的unit，亦即执行stop 再start 的意思</span><br><span class="line">reload ：不关闭后面接的unit 的情况下，重新载入设定档，让设定生效</span><br><span class="line">enable ：设定下次开机时，后面接的unit 会被启动</span><br><span class="line">disable ：设定下次开机时，后面接的unit 不会被启动</span><br><span class="line">status ：目前后面接的这个unit 的状态，会列出有没有正在执行、开机预设执行否、登录等资讯等！</span><br><span class="line">is-active ：目前有没有正在运作中</span><br><span class="line">is-enabled：开机时有没有预设要启用这个unit</span><br><span class="line"></span><br><span class="line">范例一：看看目前atd这个服务的状态为何？</span><br><span class="line">[root@study ~]# systemctl status atd.service</span><br><span class="line">atd.service - Job spooling tools</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled)</span><br><span class="line">   Active: active (running) since Mon 2015-08-10 19:17:09 CST; 5h 42min ago</span><br><span class="line"> Main PID: 1350 (atd)</span><br><span class="line">   CGroup: /system.slice/atd.service</span><br><span class="line">           └─1350 /usr/sbin/atd -f</span><br><span class="line"></span><br><span class="line">Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.</span><br><span class="line"></span><br><span class="line"># 重点在第二、三行喔～</span><br><span class="line"># Loaded：这行在说明，开机的时候这个unit 会不会启动，enabled 为开机启动，disabled 开机不会启动</span><br><span class="line"># Active：现在这个unit 的状态是正在执行(running) 或没有执行(dead)</span><br><span class="line"># 后面几行则是说明这个unit 程序的PID 状态以及最后一行显示这个服务的登录档资讯！</span><br><span class="line"># 登录档资讯格式为：『时间』 『讯息发送主机』 『哪一个服务的讯息』 『实际讯息内容』</span><br><span class="line"># 所以上面的显示讯息是：这个atd 预设开机就启动，而且现在正在运作的意思！</span><br><span class="line"></span><br><span class="line">范例二：正常关闭这个atd服务 </span><br><span class="line">[root@study ~]# systemctl stop atd.service</span><br><span class="line">[root@study ~]# systemctl status atd.service</span><br><span class="line">atd.service - Job spooling tools</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled )</span><br><span class="line">    Active: inactive (dead) since Tue 2015-08-11 01:04:55 CST; 4s ago</span><br><span class="line">  Process: 1350 ExecStart=/usr/sbin/atd -f $OPTS (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 1350 (code=exited, status=0/SUCCESS)</span><br><span class="line"></span><br><span class="line">Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.</span><br><span class="line">Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopping Job spooling tools...</span><br><span class="line">Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopped Job spooling tools.</span><br><span class="line"></span><br><span class="line">#目前这个unit下次开机还是会启动，但是现在是没在运作的状态中！同时，</span><br><span class="line"># 最后两行为新增加的登录讯息，告诉我们目前的系统状态喔！</span><br></pre></td></tr></table></figure></p><p>上面的范例中，我们已经关掉了atd ！这样作才是对的！不应该使用kill 的方式来关掉一个正常的服务！否则systemctl 会无法继续监控该服务的！那就比较麻烦。而使用systemtctl status atd 的输出结果中，第2, 3 两行很重要，因为那个是告知我们该unit 下次开机会不会预设启动，以及目前启动的状态！相当重要！最底下是这个unit 的登录档。如果你的这个unit 曾经出错过，观察这个地方也是相当重要的！</p><p>再回到systemctl status atd.service 的第三行，不是有个Active 的daemon 现在状态吗？除了running 跟dead 之外， 有没有其他的状态呢？有的，基本上有几个常见的状态：</p><ul><li><strong>active (running)：</strong>正有一只或多只程序正在系统中执行的意思，举例来说，正在执行中的vsftpd就是这种模式。</li><li><strong>active (exited)：</strong>仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行。举例来说，开机或者是挂载时才会进行一次的quotaon功能，就是这种模式！quotaon不须一直执行～只须执行一次之后，就交给档案系统去自行处理啰！通常用bash shell写的小型服务，大多是属于这种类型(无须常驻记忆体)。</li><li><strong>active (waiting)：</strong>正在执行当中，不过还再等待其他的事件才能继续处理。举例来说，列印的伫列相关服务就是这种状态！虽然正在启动中，不过，也需要真的有伫列进来(列印工作)这样他才会继续唤醒印表机服务来进行下一步列印的功能。</li><li><strong>inactive：</strong>这个服务目前没有运作的意思。</li></ul><p>既然daemon 目前的状态就有这么多种了，那么daemon 的预设状态有没有可能除了enable/disable 之外，还有其他的情况呢？当然有！</p><ul><li><strong>enabled：</strong>这个daemon将在开机时被执行</li><li><strong>disabled：</strong>这个daemon在开机时不会被执行</li><li><strong>static：</strong>这个daemon不可以自己启动(enable不可)，不过可能会被其他的enabled的服务来唤醒(相依属性的服务)</li><li><strong>mask：</strong>这个daemon无论如何都无法被启动！因为已经被强制注销(非删除)。可透过systemctl unmask方式改回原本状态</li></ul><h5 id="2、服务启动-关闭与观察的练习"><a href="#2、服务启动-关闭与观察的练习" class="headerlink" title="2、服务启动/关闭与观察的练习"></a>2、服务启动/关闭与观察的练习</h5><p>我们直接使用指令的方式来查询与设定看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 1.观察一下状态，确认是否为关闭/未启动呢？</span><br><span class="line">[root@study ~]# systemctl status chronyd.service</span><br><span class="line">hronyd.service - NTP client/server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/chronyd.service; enabled )</span><br><span class="line">   Active: active (running) since Mon 2015-08-10 19:17:07 CST; 24h ago</span><br><span class="line"> .....(底下省略).....</span><br><span class="line"></span><br><span class="line"># 2.由上面知道目前是启动的，因此立刻将他关闭，同时开机不会启动才行！</span><br><span class="line">[root@study ~]# systemctl stop chronyd.service</span><br><span class="line">[root@study ~]# systemctl disable chronyd.service</span><br><span class="line">rm &apos;/etc/systemd/system/multi-user.target.wants/chronyd.service&apos;</span><br><span class="line"># 看得很清楚～其实就是从/etc/systemd/system 底下删除一条连结档案而已～</span><br><span class="line"></span><br><span class="line">[root@study ~]# systemctl status chronyd.service</span><br><span class="line">chronyd.service - NTP client/server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/chronyd.service; disabled )</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">#如此则将chronyd这个服务完整的关闭了！</span><br></pre></td></tr></table></figure></p><p>上面是一个很简单的练习，妳先不要知道chronyd 是啥东西，只要知道透过这个方式，可以将一个服务关闭就是了！</p><h5 id="3、强迫服务注销-mask-的练习"><a href="#3、强迫服务注销-mask-的练习" class="headerlink" title="3、强迫服务注销(mask) 的练习"></a>3、强迫服务注销(mask) 的练习</h5><p>透过mask 的方式来将服务注销：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 1.保持刚刚的状态，关闭cups.service，启动cups.socket，然后注销cups.servcie </span><br><span class="line">[root@study ~]# systemctl stop cups.service</span><br><span class="line">[root@study ~]# systemctl mask cups.service</span><br><span class="line">ln -s &apos;/dev/null&apos; &apos;/etc/systemd/system/cups.service&apos;</span><br><span class="line"># 喔耶～其实这个mask 注销的动作，只是让启动的脚本变成空的装置而已！</span><br><span class="line"></span><br><span class="line">[root@study ~]# systemctl status cups.service</span><br><span class="line">cups.service</span><br><span class="line">   Loaded: masked (/dev/null)</span><br><span class="line">   Active: inactive (dead) since Tue 2015-08-11 23:14:16 CST; 52s ago</span><br><span class="line"></span><br><span class="line">[root@study ~]# systemctl start cups.service</span><br><span class="line">Failed to issue method call: Unit cups.service is masked.   #再也无法唤醒</span><br></pre></td></tr></table></figure></p><p>上面的范例你可以仔细推敲一下～原来整个启动的脚本设定档被连结到/dev/null 这个空装置～因此，无论如何你是再也无法启动这个cups.service 了！透过这个mask 功能，你就可以不必管其他相依服务可能会启动到这个想要关闭的服务了！虽然是非正规，不过很有效！</p><p>那如何取消注销呢？当然就是unmask 即可啊！</p><h5 id="4、透过systemctl-观察系统上所有的服务"><a href="#4、透过systemctl-观察系统上所有的服务" class="headerlink" title="4、透过systemctl 观察系统上所有的服务"></a>4、透过systemctl 观察系统上所有的服务</h5><p>上面谈到的是单一服务的启动/关闭/观察，以及相依服务要注销的功能。那系统上面有多少的服务存在呢？这个时候就得要透过list-units 及list-unit-files 来观察了！细部的用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# systemctl [command] [--type=TYPE] [--all]</span><br><span class="line">command:</span><br><span class="line">    list-units ：依据unit 列出目前有启动的unit。若加上--all 才会列出没启动的。</span><br><span class="line">    list-unit-files ：依据/usr/lib/systemd/system/ 内的档案，将所有档案列表说明。</span><br><span class="line">--type=TYPE：就是之前提到的unit type，主要有service, socket, target 等</span><br><span class="line"></span><br><span class="line">范例一：列出系统上面有启动的unit </span><br><span class="line">[root@study ~]# systemctl</span><br><span class="line">UNIT LOAD ACTIVE SUB DESCRIPTION</span><br><span class="line">proc-sys-fs-binfmt_mis... loaded active waiting Arbitrary Executable File Formats File System</span><br><span class="line">sys-devices-pc...:0:1:... loaded active plugged QEMU_HARDDISK</span><br><span class="line">sys-devices-pc...0:1-0... loaded active plugged QEMU_HARDDISK</span><br><span class="line">sys-devices-pc...0:0-1... loaded active plugged QEMU_DVD-ROM</span><br><span class="line">.....(中间省略).....</span><br><span class="line">vsftpd.service loaded active running Vsftpd ftp daemon</span><br><span class="line">.....(中间省略).....</span><br><span class="line">cups.socket loaded failed failed CUPS Printing Service Sockets</span><br><span class="line">.....(中间省略).....</span><br><span class="line">LOAD = Reflects whether the unit definition was properly loaded.</span><br><span class="line">ACTIVE = The high-level unit activation state, ie generalization of SUB.</span><br><span class="line">SUB = The low-level unit activation state, values depend on unit type.</span><br><span class="line"></span><br><span class="line">141 loaded units listed. Pass --all to see loaded but inactive units, too.</span><br><span class="line">To show all installed unit files use &apos;systemctl list-unit-files&apos;.</span><br><span class="line">#列出的项目中，主要的意义是：</span><br><span class="line"># UNIT ：项目的名称，包括各个unit 的类别(看副档名)</span><br><span class="line"># LOAD ：开机时是否会被载入，预设systemctl 显示的是有载入的项目而已喔！</span><br><span class="line"># ACTIVE ：目前的状态，须与后续的SUB 搭配！就是我们用systemctl status 观察时，active 的项目！</span><br><span class="line"># DESCRIPTION ：详细描述啰</span><br><span class="line"># cups 比较有趣，因为刚刚被我们玩过，所以ACTIVE 竟然是failed 的喔！被玩死了！^_^</span><br><span class="line"># 另外，systemctl 都不加参数，其实预设就是list-units 的意思！</span><br><span class="line"></span><br><span class="line">范例二：列出所有已经安装的unit有哪些？</span><br><span class="line">[root@study ~]# systemctl list-unit-files</span><br><span class="line">UNIT FILE STATE</span><br><span class="line">proc-sys-fs-binfmt_misc.automount static</span><br><span class="line">dev-hugepages.mount static</span><br><span class="line">dev-mqueue.mount static</span><br><span class="line">proc-fs-nfsd.mount static</span><br><span class="line">.....(中间省略).....</span><br><span class="line">systemd-tmpfiles-clean.timer static</span><br><span class="line"></span><br><span class="line">336 unit files listed.</span><br><span class="line"></span><br><span class="line">范例三：假设我不想要知道这么多的unit 项目，我只想要知道service 这种类别的daemon 而已，而且不论是否已经启动，通通要列出来！那该如何是好？</span><br><span class="line">[root@study ~]# systemctl list-units --type=service --all </span><br><span class="line">#只剩下*.service的项目才会出现喔！</span><br><span class="line"></span><br><span class="line">范例四：查询系统上是否有以cpu为名的服务？</span><br><span class="line">[root@study ~]# systemctl list-units --type=service --all | grep cpu</span><br><span class="line">cpupower.service loaded inactive dead Configure CPU power related settings</span><br><span class="line"># 确实有喔！可以改变CPU 电源管理机制的服务哩！</span><br></pre></td></tr></table></figure></p><p>使用systemctl list-unit-files 会将系统上所有的服务通通列出来～而不像list-units 仅以unit 分类作大致的说明。至于STATE 状态就是前两个小节谈到的开机是否会载入的那个状态项目啰！主要有enabled / disabled / mask / static 等等。</p><h5 id="5、与systemd-的daemon-运作过程相关的目录简介"><a href="#5、与systemd-的daemon-运作过程相关的目录简介" class="headerlink" title="5、与systemd 的daemon 运作过程相关的目录简介"></a>5、与systemd 的daemon 运作过程相关的目录简介</h5><p>我们在前几小节曾经谈过比较重要的systemd 启动脚本设定档在/usr/lib/systemd/system/, /etc/systemd/system/ 目录下，那还有哪些目录跟系统的daemon 运作有关呢？基本上是这样的：</p><ul><li><strong>/usr/lib/systemd/system/：</strong><br>使用CentOS官方提供的软体安装后，预设的启动脚本设定档都放在这里，这里的资料尽量不要修改～要修改时，请到/etc/systemd/system底下修改较佳！</li><li><strong>/run/systemd/system/：</strong><br>系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/lib/systemd/system/高！</li><li><strong>/etc/systemd/system/：</strong><br>管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能！执行优先序又比/run/systemd/system/高喔！</li><li><strong>/etc/sysconfig/*：</strong><br>几乎所有的服务都会将初始化的一些选项设定写入到这个目录下，举例来说，mandb所要更新的man page索引中，需要加入的参数就写入到此目录下的man-db当中喔！而网路的设定则写在/etc/sysconfig/network-scripts/这个目录内。所以，这个目录内的档案也是挺重要的；</li><li><strong>/var/lib/：</strong><br>一些会产生资料的服务都会将他的资料写入到/var/lib/目录中。举例来说，资料库管理系统Mariadb的资料库预设就是写入/var/lib/mysql/这个目录下啦！</li><li><strong>/run/：</strong><br>放置了好多daemon的暂存档，包括lock file以及PID file等等。</li></ul><p>我们知道systemd 里头有很多的本机会用到的socket 服务，里头可能会产生很多的socket file ～那你怎么知道这些socket file 放置在哪里呢？很简单！还是透过systemctl 来管理！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# systemctl list-sockets</span><br><span class="line">LISTEN UNIT ACTIVATES</span><br><span class="line">/dev/initctl systemd-initctl.socket systemd-initctl.service</span><br><span class="line">/dev/log systemd-journald.socket systemd-journald.service</span><br><span class="line">/run/dmeventd-client dm-event.socket dm-event.service</span><br><span class="line">/run/dmeventd-server dm-event.socket dm-event.service</span><br><span class="line">/run/lvm/lvmetad.socket lvm2-lvmetad.socket lvm2-lvmetad.service</span><br><span class="line">/run/systemd/journal/socket systemd-journald.socket systemd-journald.service</span><br><span class="line">/run/systemd/journal/stdout systemd-journald.socket systemd-journald.service</span><br><span class="line">/run/systemd/shutdownd systemd-shutdownd.socket systemd-shutdownd.service</span><br><span class="line">/run/udev/control systemd-udevd-control.socket systemd-udevd.service</span><br><span class="line">/var/run/avahi-daemon/socket avahi-daemon.socket avahi-daemon.service</span><br><span class="line">/var/run/cups/cups.sock cups.socket cups.service</span><br><span class="line">/var/run/dbus/system_bus_socket dbus.socket dbus.service</span><br><span class="line">/var/run/rpcbind.sock rpcbind.socket rpcbind.service</span><br><span class="line">@ISCSIADM_ABSTRACT_NAMESPACE iscsid.socket iscsid.service</span><br><span class="line">@ISCSID_UIP_ABSTRACT_NAMESPACE iscsiuio.socket iscsiuio.service</span><br><span class="line">kobject-uevent 1 systemd-udevd-kernel.socket systemd-udevd.service</span><br><span class="line"></span><br><span class="line">16 sockets listed.</span><br><span class="line">Pass --all to see loaded but inactive sockets, too.</span><br></pre></td></tr></table></figure></p><h4 id="早期的System-V-的init管理行为中-daemon的主要分类"><a href="#早期的System-V-的init管理行为中-daemon的主要分类" class="headerlink" title="早期的System V 的init管理行为中 daemon的主要分类"></a>早期的System V 的init管理行为中 daemon的主要分类</h4><p>基本上init 的管理机制有几个特色如下：</p><ul><li><strong>服务的启动、关闭与观察等方式：</strong><br>　　所有的服务启动脚本通通放置于/etc/init.d/底下，基本上都是使用bash shell script所写成的脚本程式，需要启动、关闭、重新启动、观察状态时，可以透过如下的方式来处理：<ul><li>启动：/etc/init.d/daemon start</li><li>关闭：/etc/init.d/daemon stop</li><li>重新启动：/etc/init.d/daemon restart</li><li>状态观察：/etc/init.d/daemon status</li></ul></li><li><strong>服务启动的分类：</strong><br>　　init服务的分类中，依据服务是独立启动或被一只总管程式管理而分为两大类：<ul><li>独立启动模式(stand alone)：服务独立启动，该服务直接常驻于记忆体中，提供本机或用户的服务行为，反应速度快。</li><li>总管程式(super daemon)：由特殊的xinetd 或inetd 这两个总管程式提供socket 对应或port 对应的管理。当没有用户要求某socket 或port 时， 所需要的服务是不会被启动的。若有用户要求时， xinetd 总管才会去唤醒相对应的服务程式。当该要求结束时，这个服务也会被结束掉～ 因为透过xinetd 所总管，因此这个家伙就被称为super daemon。好处是可以透过super daemon 来进行服务的时程、连线需求等的控制，缺点是唤醒服务需要一点时间的延迟。</li></ul></li><li><strong>服务的相依性问题：</strong><br>　　服务是可能会有相依性的～例如，你要启动网路服务，但是系统没有网路，那怎么可能可以唤醒网路服务呢？如果你需要连线到外部取得认证伺服器的连线，但该连线需要另一个A服务的需求，问题是，A服务没有启动，因此，你的认证服务就不可能会成功启动的！这就是所谓的服务相依性问题。<font color="red">init在管理员自己手动处理这些服务时，是没有办法协助相依服务的唤醒的！</font></li><li><strong>执行等级的分类：</strong><br>　　上面说到init是开机后核心主动呼叫的，然后init可以根据使用者自订的执行等级(runlevel)来唤醒不同的服务，以进入不同的操作界面。基本上Linux提供7个执行等级，分别是0, 1, 2…6 ，比较重要的是1)单人维护模式、3)纯文字模式、5)文字加图形界面。而各个执行等级的启动脚本是透过/etc/rc.d/rc[0-6]/SXXdaemon连结到/etc/init.d/daemon ，连结档名(SXXdaemon)的功能为： S为启动该服务，XX是数字，为启动的顺序。由于有SXX的设定，因此在开机时可以『依序执行』所有需要的服务，同时也能解决相依服务的问题。这点与管理员自己手动处理不太一样就是了。</li><li><strong>制定执行等级预设要启动的服务：</strong><br>　　若要建立如上提到的SXXdaemon的话，不需要管理员手动建立连结档，透过如下的指令可以来处理预设启动、预设不启动、观察预设启动否的行为：<ul><li>预设要启动： chkconfig daemon on</li><li>预设不启动： chkconfig daemon off</li><li>观察预设为启动否： chkconfig –list daemon</li></ul></li><li><strong>执行等级的切换行为：</strong><br>　　当你要从纯文字界面(runlevel 3)切换到图形界面(runlevel 5)，不需要手动启动、关闭该执行等级的相关服务，只要『 init 5 』即可切换，init这小子会主动去分析/etc/rc.d/rc[35].d/这两个目录内的脚本，然后启动转换runlevel中需要的服务～就完成整体的runlevel切换。</li></ul><p>基本上init 主要的功能都写在上头了，重要的指令包括daemon 本身自己的脚本(/etc/init.d/daemon) 、xinetd 这个特殊的总管程式(super daemon)、设定预设开机启动的chkconfig， 以及会影响到执行等级的init N 等。虽然CentOS 7 已经不使用init 来管理服务了，不过因为考量到某些脚本没有办法直接塞入systemd 的处理，因此这些脚本还是被保留下来， 所以，我们在这里还是稍微介绍了一下。</p><h4 id="systemd-使用的unit-分类"><a href="#systemd-使用的unit-分类" class="headerlink" title="systemd 使用的unit 分类"></a>systemd 使用的unit 分类</h4><p>从CentOS 7.x 以后，Red Hat 系列的distribution 放弃沿用多年的System V 开机启动服务的流程，就是前面提到的init 启动脚本的方法，改用systemd 这个启动服务管理机制。那么systemd 有什么好处呢？</p><ul><li><strong>平行处理所有服务，加速开机流程：</strong><br>旧的init启动脚本是『一项一项任务依序启动』的模式，因此不相依的服务也是得要一个一个的等待。但目前我们的硬体主机系统与作业系统几乎都支援多核心架构了，没道理未相依的服务不能同时启动啊！systemd就是可以让所有的服务同时启动，因此你会发现到，系统启动的速度变快了！</li><li><strong>一经要求就回应的on-demand启动方式：</strong><br>systemd全部就是仅有一只systemd服务搭配systemctl指令来处理，无须其他额外的指令来支援。不像systemV还要init, chkconfig, service…等等指令。此外， systemd由于常驻记忆体，因此任何要求(on-demand)都可以立即处理后续的daemon启动的任务。</li><li><strong>服务相依性的自我检查：</strong><br>由于systemd可以自订服务相依性的检查，因此如果B服务是架构在A服务上面启动的，那当你在没有启动A服务的情况下仅手动启动B服务时， systemd会自动帮你启动A服务喔！这样就可以免去管理员得要一项一项服务去分析的麻烦～(如果读者不是新手，应该会有印象，当你没有启动网路，但却启动NIS/NFS时，那个开机时的timeout甚至可达到10~30分钟…)</li><li><strong>依daemon功能分类：</strong><br>systemd旗下管理的服务非常多，包山包海啦～为了厘清所有服务的功能，因此，首先systemd先定义所有的服务为一个服务单位(unit)，并将该unit归类到不同的服务类型(type)去。旧的init仅分为stand alone与super daemon实在不够看，systemd将服务单位(unit)区分为service, socket, target, path, snapshot, timer等多种不同的类型(type)，方便管理员的分类与记忆。</li><li><strong>将多个daemons集合成为一个群组：</strong><br>如同systemV的init里头有个runlevel的特色，systemd亦将许多的功能集合成为一个所谓的target项目，这个项目主要在设计操作环境的建置，所以是集合了许多的daemons，亦即是执行某个target就是执行好多个daemon的意思！</li><li><strong>向下相容旧有的init服务脚本：</strong><br>基本上， systemd是可以相容于init的启动脚本的，因此，旧的init启动脚本也能够透过systemd来管理，只是更进阶的systemd功能就没有办法支援就是了。</li></ul><p>虽然如此，不过systemd 也是有些地方无法完全取代init 的！包括：</p><ul><li>在runlevel 的对应上，大概仅有runlevel 1, 3, 5 有对应到systemd 的某些target 类型而已，没有全部对应；</li><li>全部的systemd 都用systemctl 这个管理程式管理，而systemctl 支援的语法有限制，不像/etc/init.d/daemon 就是纯脚本可以自订参数，systemctl 不可自订参数。；</li><li>如果某个服务启动是管理员自己手动执行启动，而不是使用systemctl 去启动的(例如你自己手动输入crond 以启动crond 服务)，那么systemd 将无法侦测到该服务，而无法进一步管理。</li><li>systemd 启动过程中，无法与管理员透过standard input 传入讯息！因此，自行撰写systemd 的启动设定时，务必要取消互动机制～(连透过启动时传进的标准输入讯息也要避免！)</li></ul><p>不过，光是同步启动服务脚本这个功能就可以节省你很多开机的时间。同时systemd 还有很多特殊的服务类型(type) 可以提供更多有趣的功能！确实值得学一学～ 而且CentOS 7 已经用了systemd 了！既然要学，首先就得要针对systemd 管理的unit 来了解一下。</p><h5 id="1、systemd-的设定档放置目录"><a href="#1、systemd-的设定档放置目录" class="headerlink" title="1、systemd 的设定档放置目录"></a>1、systemd 的设定档放置目录</h5><p>基本上， systemd 将过去所谓的daemon 执行脚本通通称为一个服务单位(unit)，而每种服务单位依据功能来区分时，就分类为不同的类型(type)。基本的类型有包括系统服务、资料监听与交换的插槽档服务(socket)、储存系统状态的快照类型、提供不同类似执行等级分类的操作环境(target) 等等。</p><p>设定档都放置在底下的目录中：</p><ul><li><strong>/usr/lib/systemd/system/：</strong>每个服务最主要的启动脚本设定，有点类似以前的/etc/init.d底下的档案；</li><li><strong>/run/systemd/system/：</strong>系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/lib/systemd/system/高！</li><li><strong>/etc/systemd/system/：</strong>管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能！执行优先序又比/run/systemd/system/高喔！</li></ul><p>也就是说，到底系统开机会不会执行某些服务其实是看/etc/systemd/system/ 底下的设定，所以该目录底下就是一大堆连结档。而实际执行的systemd 启动脚本设定档， 其实都是放置在/usr/lib/systemd/system/ 底下的喔！因此如果你想要修改某个服务启动的设定，应该要去/usr/lib/systemd/system/ 底下修改才对！/etc/systemd/system/ 仅是连结到正确的执行脚本设定档而已。所以想要看执行脚本设定，应该就得要到/usr/lib/systemd/system/ 底下去查阅才对！</p><h5 id="2、systemd-的unit-类型分类说明"><a href="#2、systemd-的unit-类型分类说明" class="headerlink" title="2、systemd 的unit 类型分类说明"></a>2、systemd 的unit 类型分类说明</h5><p>那/usr/lib/systemd/system/ 以下的资料如何区分上述所谓的不同的类型(type) 呢？很简单！看副档名！举例来说，我们来瞧瞧上一章谈到的vsftpd 这个范例的启动脚本设定， 还有crond 与纯文字模式的multi-user 设定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# ll /usr/lib/systemd/system/ | grep -E &apos;(vsftpd|multi|cron)&apos;</span><br><span class="line">-rw-r--r--. 1 root root 284 7月30 2014 crond. service</span><br><span class="line">-rw-r--r--. 1 root root 567 3月6 06:51 multipathd.service</span><br><span class="line">-rw-r--r--. 1 root root 524 3月6 13:48 multi-user.target</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月4 17:52 multi-user.target.wants</span><br><span class="line">lrwxrwxrwx. 1 root root 17 5月4 17:52 runlevel2.target -&gt; multi-user.target</span><br><span class="line">lrwxrwxrwx. 1 root root 17 5月4 17:52 runlevel3.target -&gt; multi-user.target</span><br><span class="line">lrwxrwxrwx. 1 root root 17 5月4 17:52 runlevel4.target -&gt; multi-user.target</span><br><span class="line">-rw-r--r--. 1 root root 171 6月10 2014 vsftpd.service</span><br><span class="line">-rw-r--r--. 1 root root 184 6月10 2014 vsftpd@.service</span><br><span class="line">-rw-r--r--. 1 root root 89 6月10 2014 vsftpd.target</span><br><span class="line"># 比较重要的是上头提供的那三行特殊字体的部份！</span><br></pre></td></tr></table></figure></p><p>所以我们可以知道vsftpd 与crond 其实算是系统服务(service)，而multi-user 要算是执行环境相关的类型(target type)。根据这些副档名的类型， 我们大概可以找到几种比较常见的systemd 的服务类型如下：</p><style type="text/css">    table th:first-of-type {        width: 15%;    }</style><table><thead><tr><th>副档名</th><th>主要服务功能</th></tr></thead><tbody><tr><td>.service</td><td>一般服务类型(service unit)：主要是系统服务，包括伺服器本身所需要的本机服务以及网路服务都是！比较经常被使用到的服务大多是这种类型！所以，这也是最常见的类型了！</td></tr><tr><td>.socket</td><td>内部程序资料交换的插槽服务(socket unit)：主要是IPC (Inter-process communication) 的传输讯息插槽档(socket file) 功能。这种类型的服务通常在监控讯息传递的插槽档，当有透过此插槽档传递讯息来说要连结服务时，就依据当时的状态将该用户的要求传送到对应的daemon， 若daemon 尚未启动，则启动该daemon 后再传送用户的要求。<br>使用socket 类型的服务一般是比较不会被用到的服务，因此在开机时通常会稍微延迟启动的时间 (因为比较没有这么常用嘛！)。一般用于本机服务比较多，例如我们的图形界面很多的软体都是透过socket 来进行本机程序资料交换的行为。(这与早期的xinetd 这个super daemon 有部份的相似喔！)</td></tr><tr><td>.target</td><td>执行环境类型(target unit)：其实是一群unit 的集合，例如上面表格中谈到的multi-user.target 其实就是一堆服务的集合～也就是说， 选择执行multi-user.target 就是执行一堆其他.service 或/及.socket 之类的服务就是了！</td></tr><tr><td>.mount<br>.automount</td><td>档案系统挂载相关的服务(automount unit / mount unit)：例如来自网路的自动挂载、NFS 档案系统挂载等与档案系统相关性较高的程序管理。</td></tr><tr><td>.path</td><td>侦测特定档案或目录类型(path unit)：某些服务需要侦测某些特定的目录来提供伫列服务，例如最常见的列印服务，就是透过侦测列印伫列目录来启动列印功能！这时就得要.path 的服务类型支援了！</td></tr><tr><td>.timer</td><td>循环执行的服务(timer unit)：这个东西有点类似anacrontab 喔！不过是由systemd 主动提供的，比anacrontab 更加有弹性！</td></tr></tbody></table><p>其中又以.service 的系统服务类型最常见了！因为我们一堆网路服务都是透过这种类型来设计的啊！接下来，让我们来谈谈如何管理这些服务的启动与关闭。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;透过systemctl-管理服务&quot;&gt;&lt;a href=&quot;#透过systemctl-管理服务&quot; class=&quot;headerlink&quot; title=&quot;透过systemctl 管理服务&quot;&gt;&lt;/a&gt;透过systemctl 管理服务&lt;/h4&gt;&lt;p&gt;基本上，systemd 这个启动服务的机制，主要是透过一只名为systemctl 的指令来处理的！跟以前systemV 需要service / chkconfig / setup / init 等指令来协助不同，systemd 就是仅有systemctl 这个指令来处理而已！所以全部的行为都得要使用systemctl。 &lt;/p&gt;
&lt;h5 id=&quot;1、单一服务-service-unit-的启动-开机启动与观察状态&quot;&gt;&lt;a href=&quot;#1、单一服务-service-unit-的启动-开机启动与观察状态&quot; class=&quot;headerlink&quot; title=&quot;1、单一服务(service unit) 的启动/开机启动与观察状态&quot;&gt;&lt;/a&gt;1、单一服务(service unit) 的启动/开机启动与观察状态&lt;/h5&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;一般来说，服务的启动有两个阶段，一个是『开机的时候设定要不要启动这个服务』，以及『你现在要不要启动这个服务』&lt;/font&gt;，这两者之间有很大的差异。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7下执行firewall-cmd显示ImportError: No module named &#39;gi&#39;</title>
    <link href="http://yoursite.com/2018/03/16/CentOS-7%E4%B8%8B%E6%89%A7%E8%A1%8Cfirewall-cmd%E6%98%BE%E7%A4%BAImportError-No-module-named-gi/"/>
    <id>http://yoursite.com/2018/03/16/CentOS-7下执行firewall-cmd显示ImportError-No-module-named-gi/</id>
    <published>2018-03-16T05:17:26.000Z</published>
    <updated>2018-03-16T05:23:16.413Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在命令行下执行报错提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# firewall-cmd -h</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/bin/firewall-cmd&quot;, line 24, in &lt;module&gt;</span><br><span class="line">    from gi.repository import GObject</span><br><span class="line">ModuleNotFoundError: No module named &apos;gi&apos;</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><p>由错误信息也能够看出来是因为缺少 ‘gi’ 模块。<br>CentOS7 默认自带安装的是Python2.7版本，由于我前段时间安装了最新版的 Python3.6，且是共存的。更改了默认的Python版本为Python3，因此一些Linux命令不能使用，原因就是这些命令使用的Python2版本，由于我安装的Python3版本，并没有把所有的需要的包都安装，因此会提示缺少某些模块。（注：由此处就说明，升级Python2到Python3的时候，要保留Python2）</p><p>正确的做法就是，如果使用一些命令提示类似错误的时候，就把命令文件的头部Python版本改为CentOS默认的2.7版本即可。<br>更改方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一步，vim /usr/bin/firewall-cmd</span><br><span class="line">将#！/usr/bin/python -Es 改为 #！/usr/bin/python2 -Es（到目前为止，上面提到的问题已解决）</span><br><span class="line">第二步，vim /usr/sbin/firewalld</span><br><span class="line">将#！/usr/bin/python -Es 改为 #！/usr/bin/python2 -Es (这一步是针对于防火墙报错，进行的修改)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在命令行下执行报错提示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@VM_0_7_centos ~]# firewall-cmd -h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Traceback (most recent call last):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  File &amp;quot;/usr/bin/firewall-cmd&amp;quot;, line 24, in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    from gi.repository import GObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ModuleNotFoundError: No module named &amp;apos;gi&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Linux问题" scheme="http://yoursite.com/categories/Linux/Linux%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="firewalld" scheme="http://yoursite.com/tags/firewalld/"/>
    
  </entry>
  
  <entry>
    <title>防火墙之iptables和firewalld</title>
    <link href="http://yoursite.com/2018/03/16/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B9%8Biptables%E5%92%8Cfirewalld/"/>
    <id>http://yoursite.com/2018/03/16/防火墙之iptables和firewalld/</id>
    <published>2018-03-16T05:16:07.000Z</published>
    <updated>2018-03-16T05:26:18.810Z</updated>
    
    <content type="html"><![CDATA[<p>在RHEL 7系统中，firewalld防火墙取代了iptables防火墙。对于接触Linux系统比较早或学习过RHEL 6系统的读者来说，当他们发现曾经掌握的知识在RHEL 7中不再适用，就需要全新学习firewalld。其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已，或者说，它们只是一种服务。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。只要在这多个防火墙管理工具中任选一款并将其学透，就足以满足日常的工作需求了。<br><a id="more"></a></p><h4 id="防火墙的分类："><a href="#防火墙的分类：" class="headerlink" title="防火墙的分类："></a>防火墙的分类：</h4><p>根据工作的层次的不同来划分，常见的防火墙工作在OSI第三层，即网络层防火墙，工作在OSI第七层的称为应用层防火墙，或者代理服务器（代理网关）。</p><h5 id="1、网络层防火墙"><a href="#1、网络层防火墙" class="headerlink" title="1、网络层防火墙"></a>1、网络层防火墙</h5><p>网络层防火墙又称包过滤防火墙，在网络层对数据包进行选择，选择的依据是系统内设置的过滤逻辑，被称为访问控制列表（ACL），通过检查数据流中每个数据的源地址，目的地址，所用端口号和协议状态等因素,来确定是否允许该数据包通过。<br>特点：对用户来说透明，处理速度快且易于维护。但是一旦黑客突破防火墙，就可以轻易地伪造数据包的源地址，目的地址和IP的端口号，即“IP地址伪造”。</p><h5 id="2、应用层防火墙"><a href="#2、应用层防火墙" class="headerlink" title="2、应用层防火墙"></a>2、应用层防火墙</h5><p>代理服务型防火墙（Proxy Service）将所有跨越防火墙的网络通信链路分为两段。当代理服务器接收到用户对某个站点的访问请求后会检查该请求是否符合控制规则。如果规则允许，则代理服务器会替用户去那个站点取回所需要的信息，转发给用户。内外网用户的访问都是通过代理服务器上的“链接”来实现的，从而起到了隔离防火墙内外计算机系统的作用。<br>特点：在应用层对数据进行检查，比较安全。但是会增加防火墙的负载。</p><p>包过滤防火墙将对每一个接收到的包做出允许或拒绝的决定。具体地讲，它针对每一个数据包的包头，按照包过滤规则进行判定，与规则相匹配的包依据路由信息继续转发，否则就丢弃。包过滤是在IP层实现的，包过滤根据数据包的源IP地址、目的IP地址、协议类型（TCP包、UDP包、ICMP包）、源端口、目的端口等包头信息及数据包传输方向等信息来判断是否允许数据包通过。包过滤也包括与服务相关的过滤，这是指基于特定的服务进行包过滤，由于绝大多数服务的监听都驻留在特定TCP/UDP端口，因此，为阻断所有进入特定服务的链接，防火墙只需将所有包含特定TCP/UDP目的端口的包丢弃即可。</p><p>现实生产环境中所使用的防火墙一般都是二者结合体。即先检查网络数据，通过之后再送到应用层去检查。</p><h4 id="iptables-防火墙"><a href="#iptables-防火墙" class="headerlink" title="iptables 防火墙"></a>iptables 防火墙</h4><p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。对于如何在CentOS7系统中，从firewalld防火墙更改为iptables防火墙，可查看我的一篇文章<strong>《解决CentOS7关闭/开启防火墙出现Unit iptables.service failed to load: No such file or directory.》</strong>。</p><h5 id="1、策略与规则链"><a href="#1、策略与规则链" class="headerlink" title="1、策略与规则链"></a>1、策略与规则链</h5><p><font color="red">防火墙会从上至下的顺序来读取配置的策略规则</font>，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。一般而言，防火墙策略规则的设置有两种：一种是“通”（即放行），一种是“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许时，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。</p><p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：</p><blockquote><p>在进行路由选择前处理数据包（PREROUTING）；<br>处理流入的数据包（INPUT）；<br>处理流出的数据包（OUTPUT）；<br>处理转发的数据包（FORWARD）；<br>在进行路由选择后处理数据包（POSTROUTING）。</p></blockquote><p>一般来说，从内网向外网发送的流量一般都是可控且良性的，因此我们使用最多的就是INPUT规则链，该规则链可以增大黑客人员从外网入侵内网的难度。</p><h5 id="2、基本的命令参数"><a href="#2、基本的命令参数" class="headerlink" title="2、基本的命令参数"></a>2、基本的命令参数</h5><p>iptables是一款基于命令行的防火墙策略管理工具，具有大量参数，学习难度较大。好在对于日常的防火墙策略配置来讲，大家无需深入了解诸如“四表五链”的理论概念，只需要掌握常用的参数并做到灵活搭配即可，这就足以应对日常工作了。</p><p>iptables命令可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配，一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，<font color="red">防火墙策略规则的匹配顺序是从上至下的</font>，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误。表8-1总结归纳了常用的iptables命令参数。<br><strong>表8-1：iptables中常用的参数以及作用</strong></p><style type="text/css">    table th:first-of-type {        width: 35%;    }</style><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-P</td><td>设置默认策略</td></tr><tr><td>-F</td><td>清空规则链</td></tr><tr><td>-L</td><td>查看规则链</td></tr><tr><td>-A</td><td>在规则链的末尾加入新规则</td></tr><tr><td>-I num</td><td>在规则链的头部加入新规则</td></tr><tr><td>-D num</td><td>删除某一条规则</td></tr><tr><td>-s</td><td>匹配来源地址IP/MASK，加叹号“!”表示除这个IP外</td></tr><tr><td>-d</td><td>匹配目标地址</td></tr><tr><td>-i 网卡名称</td><td>匹配从这块网卡流入的数据</td></tr><tr><td>-o 网卡名称</td><td>匹配从这块网卡流出的数据</td></tr><tr><td>-p</td><td>匹配协议，如TCP、UDP、ICMP</td></tr><tr><td>–dport num</td><td>匹配目标端口号</td></tr><tr><td>–sport num</td><td>匹配来源端口号</td></tr></tbody></table><p>至于，具体的示例可参考我的另一篇文章<strong>《Linux 防火墙的设定》</strong>。</p><h4 id="firewalld-防火墙"><a href="#firewalld-防火墙" class="headerlink" title="firewalld 防火墙"></a>firewalld 防火墙</h4><p>RHEL 7系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。</p><p>相较于传统的防火墙管理配置工具，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。例如，我们有一台笔记本电脑，每天都要在办公室、咖啡厅和家里使用。按常理来讲，这三者的安全性按照由高到低的顺序来排列，应该是家庭、公司办公室、咖啡厅。当前，我们希望为这台笔记本电脑指定如下防火墙策略规则：在家中允许访问所有服务；在办公室内仅允许访问文件共享服务；在咖啡厅仅允许上网浏览。在以往，我们需要频繁地手动设置防火墙策略规则，而现在只需要预设好区域集合，然后只需轻点鼠标就可以自动切换了，从而极大地提升了防火墙策略的应用效率。firewalld中常见的区域名称（<font color="red">默认为public</font>）以及相应的策略规则如表8-2所示。<br><strong>表8-2：firewalld中常用的区域名称及策略规则</strong></p><table><thead><tr><th>区域</th><th>默认规则策略</th></tr></thead><tbody><tr><td>trusted</td><td>允许所有的数据包</td></tr><tr><td>home</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td></tr><tr><td>internal</td><td>等同于home区域</td></tr><tr><td>work</td><td>拒绝流入的流量，除非与流出的流量数相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td></tr><tr><td>public</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td></tr><tr><td>external</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td></tr><tr><td>dmz</td><td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td></tr><tr><td>block</td><td>拒绝流入的流量，除非与流出的流量相关</td></tr><tr><td>drop</td><td>拒绝流入的流量，除非与流出的流量相关</td></tr></tbody></table><h5 id="1、终端管理工具"><a href="#1、终端管理工具" class="headerlink" title="1、终端管理工具"></a>1、终端管理工具</h5><p>命令行终端是一种极富效率的工作方式，firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的，大家不要一听到长格式就头大，因为RHEL 7系统支持部分命令的参数补齐，其中就包含这条命令（很酷吧）。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐表8-3中所示的长格式参数了（这太棒了）。<br><strong>表8-3：firewall-cmd命令中使用的参数以及作用</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>–get-default-zone</td><td>查询默认的区域名称</td></tr><tr><td>–set-default-zone=&lt;区域名称&gt;</td><td>设置默认的区域，使其永久生效</td></tr><tr><td>–get-zones</td><td>显示可用的区域</td></tr><tr><td>–get-services</td><td>显示预先定义的服务</td></tr><tr><td>–get-active-zones</td><td>显示当前正在使用的区域与网卡名称</td></tr><tr><td>–remove-source=</td><td>将源自此IP或子网的流量导向指定的区域</td></tr><tr><td>–remove-source=</td><td>不再将源自此IP或子网的流量导向某个指定区域</td></tr><tr><td>–add-interface=&lt;网卡名称&gt;</td><td>将源自该网卡的所有流量都导向某个指定区域</td></tr><tr><td>–change-interface=&lt;网卡名称&gt;</td><td>将某个网卡与区域进行关联</td></tr><tr><td>–list-all</td><td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>–list-all-zones</td><td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>–add-service=&lt;服务名&gt;</td><td>设置默认区域允许该服务的流量</td></tr><tr><td>–add-port=&lt;端口号/协议&gt;</td><td>设置默认区域允许该端口的流量</td></tr><tr><td>–remove-service=&lt;服务名&gt;</td><td>设置默认区域不再允许该服务的流量</td></tr><tr><td>–remove-port=&lt;端口号/协议&gt;</td><td>设置默认区域不再允许该端口的流量</td></tr><tr><td>–reload</td><td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td></tr><tr><td>–panic-on</td><td>开启应急状况模式</td></tr><tr><td>–panic-off</td><td>关闭应急状况模式</td></tr></tbody></table><p>与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加–permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd –reload命令。</p><h5 id="2、常用命令汇总"><a href="#2、常用命令汇总" class="headerlink" title="2、常用命令汇总"></a>2、常用命令汇总</h5><p>（1）安装firewalld<br><code>yum install firewalld firewall-config</code></p><p>（2）运行、停止、禁用firewalld<br>启动：# systemctl start  firewalld<br>查看状态：# systemctl status firewalld 或者 firewall-cmd –state<br>停止：# systemctl disable firewalld<br>禁用：# systemctl stop firewalld<br>systemctl mask firewalld<br>systemctl unmask firewalld</p><p>（3）配置firewalld<br>查看版本：<code>$ firewall-cmd --version</code><br>查看帮助：<code>$ firewall-cmd --help</code></p><p>查看设置：<br>显示状态：<code>$ firewall-cmd --state</code><br>查看区域信息: <code>$ firewall-cmd --get-active-zones</code><br>查看指定接口所属区域：<code>$ firewall-cmd --get-zone-of-interface=eth0</code><br>拒绝所有包：<code># firewall-cmd --panic-on</code><br>取消拒绝状态：<code># firewall-cmd --panic-off</code><br>查看是否拒绝：<code>$ firewall-cmd --query-panic</code></p><p>更新防火墙规则：<br><code># firewall-cmd --reload</code><br><code># firewall-cmd --complete-reload</code><br>两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务</p><p>将接口添加到区域，默认接口都在public<br><code># firewall-cmd --zone=public --add-interface=eth0</code><br>永久生效再加上 –permanent 然后reload防火墙</p><p>设置默认接口区域<br><code># firewall-cmd --set-default-zone=public</code><br>立即生效无需重启</p><p>打开端口（貌似这个才最常用）<br>查看所有打开的端口：<br><code># firewall-cmd --zone=dmz --list-ports</code><br>加入一个端口到区域：<br><code># firewall-cmd --zone=dmz --add-port=8080/tcp</code><br>若要永久生效方法同上</p><p>打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档<br><code># firewall-cmd --zone=work --add-service=smtp</code><br>移除服务<br><code># firewall-cmd --zone=work --remove-service=smtp</code></p><h5 id="3、示例"><a href="#3、示例" class="headerlink" title="3、示例"></a>3、示例</h5><p>接下来的实验都很简单，但是提醒大家一定要仔细查看使用的是Runtime模式还是Permanent模式。如果不关注这个细节，就算是正确配置了防火墙策略，也可能无法达到预期的效果。</p><p>查看firewalld服务当前所使用的区域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --get-default-zone</span><br><span class="line">public</span><br></pre></td></tr></table></figure></p><p>查询eno16777728网卡在firewalld服务中的区域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728</span><br><span class="line">public</span><br></pre></td></tr></table></figure></p><p>把f默认irewalld服务中eno16777728网卡的区域修改为external，并在系统重启后生效。分别查看当前与永久模式下的区域名称：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --permanent --zone=external --change-interface=eno16777728</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728</span><br><span class="line">public</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --permanent --get-zone-of-interface=eno16777728</span><br><span class="line">external</span><br></pre></td></tr></table></figure></p><p>把firewalld服务的当前默认区域设置为public：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --set-default-zone=public</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --get-default-zone </span><br><span class="line">public</span><br></pre></td></tr></table></figure></p><p>启动/关闭firewalld防火墙服务的应急状况模式，阻断一切网络连接（当远程控制服务器时请慎用）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --panic-on</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --panic-off</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>查询public区域是否允许请求SSH和HTTPS协议的流量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=ssh</span><br><span class="line">yes</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https</span><br><span class="line">no</span><br></pre></td></tr></table></figure></p><p>把firewalld服务中请求HTTPS协议的流量设置为永久允许，并立即生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --zone=public --add-service=https</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>把firewalld服务中请求HTTP协议的流量设置为永久拒绝，并立即生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --remove-service=http </span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --reload </span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>把在firewalld服务中访问8080和8081端口的流量策略设置为允许，但仅限当前生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --zone=public --add-port=8080-8081/tcp</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --zone=public --list-ports </span><br><span class="line">8080-8081/tcp</span><br></pre></td></tr></table></figure></p><p>把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效：<br>流量转发命令格式为<code>firewall-cmd --permanent --zone=&lt;区域&gt; --add-forward-port=port=&lt;源端口号&gt;:proto=&lt;协议&gt;:toport=&lt;目标端口号&gt;:toaddr=&lt;目标IP地址&gt;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>在客户端使用ssh命令尝试访问192.168.10.10主机的888端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@client A ~]# ssh -p 888 192.168.10.10</span><br><span class="line">The authenticity of host &apos;[192.168.10.10]:888 ([192.168.10.10]:888)&apos; can&apos;t be established.</span><br><span class="line">ECDSA key fingerprint is b8:25:88:89:5c:05:b6:dd:ef:76:63:ff:1a:54:02:1a.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &apos;[192.168.10.10]:888&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">root@192.168.10.10&apos;s password:此处输入远程root管理员的密码</span><br><span class="line">Last login: Sun Jul 19 21:43:48 2017 from 192.168.10.10</span><br></pre></td></tr></table></figure></p><p>firewalld中的富规则表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.10.0/24&quot; service name=&quot;ssh&quot; reject&quot;</span><br><span class="line">success</span><br><span class="line">[root@linuxprobe ~]# firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>在客户端使用ssh命令尝试访问192.168.10.10主机的ssh服务（22端口）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@client A ~]# ssh 192.168.10.10</span><br><span class="line">Connecting to 192.168.10.10:22...</span><br><span class="line">Could not connect to &apos;192.168.10.10&apos; (port 22): Connection failed.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在RHEL 7系统中，firewalld防火墙取代了iptables防火墙。对于接触Linux系统比较早或学习过RHEL 6系统的读者来说，当他们发现曾经掌握的知识在RHEL 7中不再适用，就需要全新学习firewalld。其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已，或者说，它们只是一种服务。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。只要在这多个防火墙管理工具中任选一款并将其学透，就足以满足日常的工作需求了。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="firewalld" scheme="http://yoursite.com/tags/firewalld/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>SVN 详解之多仓库管理及使用钩子hooks/post-commit实现代码自动部署（四）</title>
    <link href="http://yoursite.com/2018/03/16/SVN-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%A4%9A%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E9%92%A9%E5%AD%90hooks-post-commit%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/16/SVN-详解之多仓库管理及使用钩子hooks-post-commit实现代码自动部署（四）/</id>
    <published>2018-03-16T02:42:33.000Z</published>
    <updated>2018-03-16T03:24:00.425Z</updated>
    
    <content type="html"><![CDATA[<h4 id="多仓库管理"><a href="#多仓库管理" class="headerlink" title="多仓库管理"></a>多仓库管理</h4><h5 id="1、首先，需要明白几个概念："><a href="#1、首先，需要明白几个概念：" class="headerlink" title="1、首先，需要明白几个概念："></a>1、首先，需要明白几个概念：</h5><p>（1）多仓库管理，则每个仓库对应的配置都要单独管理。即该仓库允许那些人员访问，人员所具有的的权限等都需设定。</p><p>（2）每个仓库的配置文件只可管理本仓库的属性，不需要涉及到其他仓库，涉及到也没用。即仓库与仓库之间是独立的管理。<br><a id="more"></a></p><h5 id="2、实战演示"><a href="#2、实战演示" class="headerlink" title="2、实战演示"></a>2、实战演示</h5><p>首先，新建2个仓库，project和common。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svnadmin create /var/svn/project//开放仓库</span><br><span class="line">svnadmin create /var/svn/common//共享资源仓库</span><br></pre></td></tr></table></figure></p><p>分别对应仓库的conf/ 下文件进行配置，passwd与svnserve.conf配置类似，不予说明。其中，authz文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># project:</span><br><span class="line">[groups]</span><br><span class="line">admin = admin, ben</span><br><span class="line">test = nana</span><br><span class="line"></span><br><span class="line">[/] == [project:/]</span><br><span class="line">@admin = rw</span><br><span class="line">@test = r @只有读的权限，可用于测试</span><br><span class="line"></span><br><span class="line"># common:</span><br><span class="line">[common:/]</span><br><span class="line">@test = rw</span><br><span class="line">ben = rw</span><br></pre></td></tr></table></figure></p><p><strong>注：对于用户享有单独某个目录权限，可如下操作：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[svn:/special1] == [/special1]</span><br><span class="line">ben = rw</span><br><span class="line">[svn:/special1/special2]</span><br><span class="line">nana = rw</span><br></pre></td></tr></table></figure></p><h5 id="3、问题解决"><a href="#3、问题解决" class="headerlink" title="3、问题解决"></a>3、问题解决</h5><blockquote><p>Invalid authz configuration<br>svn: Authorization failed解决办法</p></blockquote><p>报此类错误，都是因为auth权限文件配置错误，仔细检查就可发现原因。</p><h4 id="使用钩子hooks-post-commit实现代码自动部署"><a href="#使用钩子hooks-post-commit实现代码自动部署" class="headerlink" title="使用钩子hooks/post-commit实现代码自动部署"></a>使用钩子hooks/post-commit实现代码自动部署</h4><p>配置了台svn服务器，用来保存公司项目的代码，同时svn服务器也是一台web服务器。因此希望当我本地代码commit到svn服务器时,能够触发svn服务器的钩子hooks/post-commit将新版本的代码自动update到站点目录上去。</p><blockquote><p>svn 目录：/var/svn/project<br>站点目录：/data/www/project/</p></blockquote><h5 id="1、新建post-commit钩子"><a href="#1、新建post-commit钩子" class="headerlink" title="1、新建post-commit钩子"></a>1、新建post-commit钩子</h5><p>找到svn项目的hooks目录，这里是/var/svn/project/hooks。目录中默认会几个对应操作的钩子模板，我们需要创建一个post-commit的文件。<br>复制钩子文件，进行修改：<br><code>cp hooks/post-commit.tmpl hooks/post-commit</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">export LANG=zh_CN.UTF-8</span><br><span class="line">REPOS=&quot;$1&quot;</span><br><span class="line">REV=&quot;$2&quot;</span><br><span class="line"></span><br><span class="line">SVN_PATH=/usr/bin#svn命令路径</span><br><span class="line">WEB_PATH=/data/www/project/python_movie#项目路径，即已经检出的项目，具体到项目目录</span><br><span class="line">LOG_PATH=/data/www/project/python_movie/logs/svn_deploy.log#日志文件</span><br><span class="line">SVN_USER=ben</span><br><span class="line">SVN_PASS=ben1234</span><br><span class="line"></span><br><span class="line">echo `date &quot;+%Y-%m-%d %H:%M:%S&quot;` &gt;&gt; $LOG_PATH</span><br><span class="line">echo `whoami`,$REPOS,%REV &gt;&gt; %LOG_PATH</span><br><span class="line"></span><br><span class="line">$SVN_PATH/svn update $WEB_PATH --username $SVN_USER --password $SVN_PASS --no-auth-cache &gt;&gt; $LOG_PATH</span><br></pre></td></tr></table></figure></p><font color="red">说明：<br>whoami #执行此程序的用户<br>REPOS=”$1” #svn项目绝对路径值<br>REV=”$2” #最新版本号<br>–no-auth-cache #不保存账户认证信息</font><h5 id="2、修改post-commit文件权限"><a href="#2、修改post-commit文件权限" class="headerlink" title="2、修改post-commit文件权限"></a>2、修改post-commit文件权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown www:www /var/svn/python_movie/hooks/post-commit #设置脚本所属用户组，www为web服务运行账户和组</span><br><span class="line">chmod +x /var/svn/python_movie/hooks/post-commit #添加脚本执行权限</span><br></pre></td></tr></table></figure><h5 id="3、客户端测试"><a href="#3、客户端测试" class="headerlink" title="3、客户端测试"></a>3、客户端测试</h5><p>测试的话，我这里是在本地修改版本库，点commit，然后再看web(nginx)服务器上的数据是否更新来测试。</p><h5 id="4、问题解决"><a href="#4、问题解决" class="headerlink" title="4、问题解决"></a>4、问题解决</h5><p>Checkout一份代码到web服务器上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd /data/www/project/python_movie</span><br><span class="line"># /usr/bin/svn checkout svn://127.0.0.1/python_movie</span><br></pre></td></tr></table></figure></p><blockquote><p>在日志文件中提示<br>Skipped “/data/www/project/python_movie”<br>然后提交的文件并没有自动更新到web目录下</p></blockquote><p>解决方法是：<br>首先，需要在Web目录下检出SVN项目，生成 .svn目录。原因是 Web目录下没有 .svn目录，更新时钩子不能识别Web目录下的 .svn（因为没有），因此会跳过Web目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /data/www/project/python_movie</span><br><span class="line">svn checkout svn://服务器的ip地址/python_movie ./</span><br></pre></td></tr></table></figure></p><p>然后再次提交的文件就可以自动更新到web目录下了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;多仓库管理&quot;&gt;&lt;a href=&quot;#多仓库管理&quot; class=&quot;headerlink&quot; title=&quot;多仓库管理&quot;&gt;&lt;/a&gt;多仓库管理&lt;/h4&gt;&lt;h5 id=&quot;1、首先，需要明白几个概念：&quot;&gt;&lt;a href=&quot;#1、首先，需要明白几个概念：&quot; class=&quot;headerlink&quot; title=&quot;1、首先，需要明白几个概念：&quot;&gt;&lt;/a&gt;1、首先，需要明白几个概念：&lt;/h5&gt;&lt;p&gt;（1）多仓库管理，则每个仓库对应的配置都要单独管理。即该仓库允许那些人员访问，人员所具有的的权限等都需设定。&lt;/p&gt;
&lt;p&gt;（2）每个仓库的配置文件只可管理本仓库的属性，不需要涉及到其他仓库，涉及到也没用。即仓库与仓库之间是独立的管理。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="SVN" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/SVN/"/>
    
    
      <category term="SVN" scheme="http://yoursite.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>Linux 源码包与RPM包详解</title>
    <link href="http://yoursite.com/2018/03/15/Linux-%E6%BA%90%E7%A0%81%E5%8C%85%E4%B8%8ERPM%E5%8C%85%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/15/Linux-源码包与RPM包详解/</id>
    <published>2018-03-15T09:11:19.000Z</published>
    <updated>2018-03-19T05:45:02.638Z</updated>
    
    <content type="html"><![CDATA[<h4 id="源码包与RPM包的区别"><a href="#源码包与RPM包的区别" class="headerlink" title="源码包与RPM包的区别"></a>源码包与RPM包的区别</h4><h5 id="1、安装之前的区别：概念上的区别"><a href="#1、安装之前的区别：概念上的区别" class="headerlink" title="1、安装之前的区别：概念上的区别"></a>1、安装之前的区别：概念上的区别</h5><p>比如说：源码包是开源的，比RPM包安装更自由，但是它安装更慢，更容易报错；RPM包是经过编译的，不能看到源代码，但是它安装更快，报错更容易解决，只有依赖性问题。</p><h5 id="2、安装之后的区别：安装位置不同"><a href="#2、安装之后的区别：安装位置不同" class="headerlink" title="2、安装之后的区别：安装位置不同"></a>2、安装之后的区别：安装位置不同</h5><p>RPM包不需要指定安装位置，它会安装到系统默认位置；而源码包是人为手工设置的，下面我们就来看看到底位置有什么区别<br><a id="more"></a></p><p>（1）RPM包安装位置<br>是按照在默认位置中<br><strong>RPM包默认安装路径</strong></p><table><thead><tr><th>安装位置</th><th>对应目录功能</th></tr></thead><tbody><tr><td>/etc/</td><td>配置文件安装目录</td></tr><tr><td>/usr/bin/</td><td>可执行的命令安装目录</td></tr><tr><td>/usr/lib/</td><td>程序所使用的函数库保存位置</td></tr><tr><td>/usr/share/doc/</td><td>基本的软件使用手册保存位置</td></tr><tr><td>/usr/share/man/</td><td>帮助文件保存位置</td></tr></tbody></table><p>（2）源码包安装位置<br>安装在指定位置当中，一般是 <code>/usr/local/软件名/</code></p><h5 id="3、安装位置不同带来的影响"><a href="#3、安装位置不同带来的影响" class="headerlink" title="3、安装位置不同带来的影响"></a>3、安装位置不同带来的影响</h5><p>RPM包安装的服务可以使用系统服务管理命令（service）来管理，例如RPM包安装的apache的启动方法是：<br><code>/etc/rc.d/init.d/httpd start</code><br><code>service httpd start</code></p><p>而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理，如：<br><code>/usr/local/apache2/bin/apachectl start</code></p><h4 id="RPM包详解"><a href="#RPM包详解" class="headerlink" title="RPM包详解"></a>RPM包详解</h4><h5 id="1、rpm包命名结构"><a href="#1、rpm包命名结构" class="headerlink" title="1、rpm包命名结构"></a>1、rpm包命名结构</h5><p>rpm包的组成：name-version-release.arch.rpm</p><blockquote><p>name：表示包的名称，包括主包名和分包名<br>version：表示包的版本信息<br>release：用于标识rpm包本身的发行号，可还包含适应的操作系统<br>arch:表示主机平台,noarch表示此包能安装到所以平台上面</p></blockquote><p>例如：gd-devel-2.0.35-11.el6.x86_64.rpm</p><blockquote><p>gd是这个包的主包名，devel是这个包的分包名，<br>2.0.35是表示版本信息，2为主版本，0为此版本，35为修订号，<br>11.el6中的11是表示发行号，el6表示是RHEL6，<br>x86_64是表示包适合的平台，如果是noarch这表示与平台无关</p></blockquote><h5 id="2、rpm包命令操作总结"><a href="#2、rpm包命令操作总结" class="headerlink" title="2、rpm包命令操作总结"></a>2、rpm包命令操作总结</h5><style type="text/css">    table th:first-of-type {        width: 15%;    }    table th:nth-of-type(2) {        width: 17%;    }    table th:nth-of-type(3) {        width: 50%;    }    table th:nth-of-type(4) {        width: 40%;    }</style><table><thead><tr><th>&nbsp;</th><th>option</th><th>参数解释</th><th>Example</th></tr></thead><tbody><tr><td>安装</td><td>-i</td><td>安装</td><td>&#32;</td></tr><tr><td></td><td>-v&#124;-vv&#124;-vvv</td><td>显示详细信息</td><td>&#32;</td></tr><tr><td></td><td>-h</td><td>以#显示安装进度一个#表示2%的进度</td><td>rpm -ivh zsh-4.3.10-5.el6.x86_64.rpm</td></tr><tr><td></td><td>–nodeps</td><td>忽略依赖关系</td><td>&#32;</td></tr><tr><td></td><td>–test</td><td>测试安装</td><td>&#32;</td></tr><tr><td></td><td>–replacepkgs</td><td>重新安装(安装的包已经安装了)</td><td>&#32;</td></tr><tr><td>升级</td><td>-U   -Uvh</td><td>升级+安装</td><td>&#32;</td></tr><tr><td></td><td>-F    -Fvh</td><td>升级(此包已经安装了)</td><td>&#32;</td></tr><tr><td></td><td>–force</td><td>有冲突强制升级</td><td>&#32;</td></tr><tr><td></td><td>–nodeps</td><td>忽略包依赖性关系</td><td>&#32;</td></tr><tr><td>卸载</td><td>-e</td><td>卸载</td><td>rpm  -e  包名</td></tr><tr><td></td><td>–nodeps</td><td>忽略包依赖性关系</td><td>&#32;</td></tr><tr><td>查询</td><td>-q&#124;–query</td><td>&#32;</td><td>rpm -q&#124;–query  包名</td></tr><tr><td></td><td>-qa</td><td>查看所有已经安装的包</td><td>rpm -qa  查看所有包名 <br>rpm -qa &#124; grep 包名查看某个包名</td></tr><tr><td></td><td>-qi</td><td>查看包的摘要信息</td><td>&#32;</td></tr><tr><td></td><td>-qf</td><td>查看文件是有那个包安装的</td><td>rpm  -qf  /path/to/file</td></tr><tr><td></td><td>-ql</td><td>查看包安装生成的文件清单</td><td>&#32;</td></tr><tr><td></td><td>-qc</td><td>查看包安装生成的配置文件</td><td>&#32;</td></tr><tr><td></td><td>-qd</td><td>查看包安装生成的帮助文档</td><td>&#32;</td></tr><tr><td></td><td>-q  –scripts</td><td>查看相关的脚本</td><td>rpm -q–script   包名</td></tr><tr><td></td><td>-qp[i&#124;l&#124;d&#124;c]</td><td>查看尚未安装包的详细信息</td><td>rpm -qpi /path/to/rpm_file</td></tr><tr><td>校验</td><td>-V</td><td>&#32;</td><td>rpm -V   包名</td></tr><tr><td>数据库管理</td><td>–initdb</td><td>新建</td><td>rpm  –initdb</td></tr><tr><td></td><td>–rebuilddb</td><td>重建</td><td>rpm  –rebuilddb</td></tr></tbody></table><h5 id="3、RPM包安装方法之-yum-安装"><a href="#3、RPM包安装方法之-yum-安装" class="headerlink" title="3、RPM包安装方法之 yum 安装"></a>3、RPM包安装方法之 yum 安装</h5><p>yum(Yellowdog Update  Manager),yum是RPM的前端工具，是基于RPM的一个管理工具，他能自动的解决安装rpm包产生的依赖关系。</p><blockquote><p>yum 的配置文件    /etc/yum.conf<br>yum 的repository仓库的配置文件   /etc/yum.repos.d/*.repo</p></blockquote><p>yum常用命令总结</p><style type="text/css">    table th:nth-of-type(2) {        width: 40%;    }</style><table><thead><tr><th>&#32;</th><th>操作命令</th><th>命令解释</th></tr></thead><tbody><tr><td>列表</td><td><code>yum list &lt;package_name&gt;</code></td><td>列出指定安装软件的清单</td></tr><tr><td></td><td>yum list installed</td><td>列出所有已安装的软件包</td></tr><tr><td></td><td>yum list extras</td><td>列出所有已安装但不在 Yum  仓库內的软件包</td></tr><tr><td></td><td>yum grouplist</td><td>列出所有的组</td></tr><tr><td></td><td>yum grouplist “Group1”</td><td>列出指定组的软件包列表</td></tr><tr><td>安装</td><td><code>yum -y install &lt;package_name&gt;</code></td><td>安装指定的软件</td></tr><tr><td></td><td>yum -y groupinstall “Group1” “Group2”</td><td>安装指定的组</td></tr><tr><td></td><td><code>yum -y localinstall &lt;package_name&gt;</code></td><td>用yum安装下载到本地的rpm包</td></tr><tr><td>卸载</td><td><code>yum -y remove &lt;package_name&gt;</code></td><td>卸载指定的软件</td></tr><tr><td>更新</td><td>yum check-update</td><td>列出所有可更新的软件清单</td></tr><tr><td></td><td>yum update</td><td>安装所有更新软件</td></tr><tr><td></td><td><code>yum update &lt;package_name&gt;</code></td><td>更新指定的软件</td></tr><tr><td>信息</td><td>yum info</td><td>显示所有包的信息</td></tr><tr><td></td><td><code>yum info &lt;package_name&gt;</code></td><td>显示指定包的信息</td></tr><tr><td></td><td>yum groupinfo “Group1” “Group2”</td><td>显示指定组的信息</td></tr><tr><td>清除</td><td>yum clean all</td><td>清除所有yum所保存的信息</td></tr><tr><td></td><td>yum clean metadata</td><td>只清空保存的数据信息</td></tr><tr><td>其它操作</td><td>yum repolist [all&#124;enable&#124;disable]</td><td>查看yum仓库的个数，默认显示启用的</td></tr><tr><td></td><td>yum   makecache</td><td>手动生成缓存</td></tr><tr><td></td><td><code>yum search &lt;package_name&gt;</code></td><td>查询rpm包</td></tr><tr><td></td><td><code>yum reinstall &lt;package_name&gt;</code></td><td>重新安装一遍</td></tr><tr><td></td><td><code>yum provides &lt;package_name&gt;</code></td><td>列出软件包提供哪些文件</td></tr></tbody></table><h4 id="源码包详解"><a href="#源码包详解" class="headerlink" title="源码包详解"></a>源码包详解</h4><h5 id="1、tar-源码包编译安装"><a href="#1、tar-源码包编译安装" class="headerlink" title="1、tar 源码包编译安装"></a>1、tar 源码包编译安装</h5><p>编译安装的三部曲:<br>在安装三部曲之前，建议先看看解压之后目录里面的包含README, INSTALL文件，这里面的文件会告诉你详细安装步骤。</p><blockquote><p>（1）configure　　　检测编译环境<br>（2）make　　　　　进行编译<br>（3）make install　　编译安装</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;源码包与RPM包的区别&quot;&gt;&lt;a href=&quot;#源码包与RPM包的区别&quot; class=&quot;headerlink&quot; title=&quot;源码包与RPM包的区别&quot;&gt;&lt;/a&gt;源码包与RPM包的区别&lt;/h4&gt;&lt;h5 id=&quot;1、安装之前的区别：概念上的区别&quot;&gt;&lt;a href=&quot;#1、安装之前的区别：概念上的区别&quot; class=&quot;headerlink&quot; title=&quot;1、安装之前的区别：概念上的区别&quot;&gt;&lt;/a&gt;1、安装之前的区别：概念上的区别&lt;/h5&gt;&lt;p&gt;比如说：源码包是开源的，比RPM包安装更自由，但是它安装更慢，更容易报错；RPM包是经过编译的，不能看到源代码，但是它安装更快，报错更容易解决，只有依赖性问题。&lt;/p&gt;
&lt;h5 id=&quot;2、安装之后的区别：安装位置不同&quot;&gt;&lt;a href=&quot;#2、安装之后的区别：安装位置不同&quot; class=&quot;headerlink&quot; title=&quot;2、安装之后的区别：安装位置不同&quot;&gt;&lt;/a&gt;2、安装之后的区别：安装位置不同&lt;/h5&gt;&lt;p&gt;RPM包不需要指定安装位置，它会安装到系统默认位置；而源码包是人为手工设置的，下面我们就来看看到底位置有什么区别&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>解决CentOS7关闭/开启防火墙出现Unit iptables.service failed to load: No such file or directory.</title>
    <link href="http://yoursite.com/2018/03/15/%E8%A7%A3%E5%86%B3CentOS7%E5%85%B3%E9%97%AD-%E5%BC%80%E5%90%AF%E9%98%B2%E7%81%AB%E5%A2%99%E5%87%BA%E7%8E%B0Unit-iptables-service-failed-to-load-No-such-file-or-directory/"/>
    <id>http://yoursite.com/2018/03/15/解决CentOS7关闭-开启防火墙出现Unit-iptables-service-failed-to-load-No-such-file-or-directory/</id>
    <published>2018-03-15T09:11:04.000Z</published>
    <updated>2018-03-15T10:35:24.549Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS7中执行<br><code>service iptables start/stop</code></p><blockquote><p>会报错Failed to start iptables.service: Unit iptables.service failed to load: No such file or directory.</p></blockquote><p>在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，当然你可以还原传统的管理方式。或则使用新的命令进行管理。<br><a id="more"></a></p><p>1、还原传统的管理方式<br>执行一下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld  #停止 firewalld</span><br><span class="line">systemctl mask firewalld  #禁用 firewalld</span><br></pre></td></tr></table></figure></p><p>并且安装iptables-services：<br><code>yum install iptables-services</code></p><p>设置开机启动：<br><code>systemctl enable iptables</code></p><p>启动iptables：<br><code>systemctl start iptables</code></p><p>保存设置：<br>service iptables save 或者 /usr/libexec/iptables/iptables.init save</p><p>常用命令：<br>systemctl [stop|start|restart|reload] iptables（分开执行）</p><p>OK，再试一下传统管理方式应该就好使了。</p><p>2、使用新的防火墙firewalld进行管理</p><p>待补充…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS7中执行&lt;br&gt;&lt;code&gt;service iptables start/stop&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;会报错Failed to start iptables.service: Unit iptables.service failed to load: No such file or directory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，当然你可以还原传统的管理方式。或则使用新的命令进行管理。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Linux问题" scheme="http://yoursite.com/categories/Linux/Linux%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>SVN 详解之常用操作命令（三）</title>
    <link href="http://yoursite.com/2018/03/15/SVN-%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/15/SVN-详解之常用操作命令（三）/</id>
    <published>2018-03-15T06:10:44.000Z</published>
    <updated>2018-03-15T06:16:45.234Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、检出"><a href="#1、检出" class="headerlink" title="1、检出"></a>1、检出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span><br><span class="line">svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名</span><br><span class="line">简写：svn co xxx</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn checkout svn://localhost/测试工具 /home/testtools –username ben<br>svn checkout <a href="http://localhost/test/testapp" target="_blank" rel="noopener">http://localhost/test/testapp</a> –username ben<br>注：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。<br>　　其中 username 与 password前是两个短线，不是一个。<br>　　不指定本地目录全路径，则检出到当前目录下。<br><a id="more"></a></p><h4 id="2、导出"><a href="#2、导出" class="headerlink" title="2、导出"></a>2、导出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn  export  [-r 版本号]  http://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">svn  export  [-r 版本号]  svn://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">svn  export  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br></pre></td></tr></table></figure><p><strong>例子：</strong><br>svn export svn://localhost/测试工具 /home/testtools –username ben<br>svn export svn://localhost/test/testapp –username ben<br>svn export /home/testapp /home/testtools<br>注：第一种从版本库导出干净工作目录树的形式是指定URL，如果指定了修订版本号，会导出相应的版本，如果没有指定修订版本，则会导出最新的，导出到指定位置。如果省略本地目录全路径，URL的最后一部分会作为本地目录的名字。<br>第二种形式是指定 本地检出的目录全路径 到 要导出的本地目录全路径，所有的本地修改将会保留，但是不在版本控制下(即没提交的新文件，因为.svn文件夹里没有与之相关的信息记录)的文件不会拷贝。</p></blockquote><h4 id="3、添加新文件"><a href="#3、添加新文件" class="headerlink" title="3、添加新文件"></a>3、添加新文件</h4><p><code>svn　add　文件名</code><br>注：告诉SVN服务器要添加文件了，还要用svn commint -m真实的上传上去！</p><blockquote><p><strong>例子：</strong><br>svn add test.php     #添加test.php<br>svn commit -m “添加我的测试用test.php“ test.php<br>svn add <em>.php         #添加当前目录下所有的php文件<br>svn commit -m “添加我的测试用全部php文件“ </em>.php</p></blockquote><h4 id="4、提交"><a href="#4、提交" class="headerlink" title="4、提交"></a>4、提交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn　commit　-m　“提交备注信息文本“　[-N]　[--no-unlock]　文件名</span><br><span class="line">简写：svn ci xxx</span><br></pre></td></tr></table></figure><p>注：必须带上-m参数，参数可以为空，但是必须写上-m</p><blockquote><p><strong>例子：</strong><br>svn commit -m “提交当前目录下的全部在版本控制下的文件“ <em>          #注意这个</em>表示全部文件<br>svn commit -m “提交我的测试用test.php“ test.php<br>svn commit -m “提交我的测试用test.php“ -N –no-unlock test.php     #保持锁就用–no-unlock开关<br>svn ci -m “提交当前目录下的全部在版本控制下的文件“ <em>             #注意这个</em>表示全部文件<br>svn ci -m “提交我的测试用test.php“ test.php<br>svn ci -m “提交我的测试用test.php“ -N –no-unlock test.php         #保持锁就用–no-unlock开关</p></blockquote><h4 id="5、更新"><a href="#5、更新" class="headerlink" title="5、更新"></a>5、更新</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn　update</span><br><span class="line">svn　update　-r　修正版本　文件名</span><br><span class="line">svn　update　文件名</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn update                         #后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本<br>svn update -r 200 test.cpp         #将版本库中的文件 test.cpp 还原到修正版本（revision）200<br>svn update test.php             #更新与版本库同步。<br>　　提交的时候提示过期冲突，需要先 update 修改文件，然后清除svn resolved，最后再提交commit。</p></blockquote><h4 id="6、删除"><a href="#6、删除" class="headerlink" title="6、删除"></a>6、删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">svn　delete　svn://路径(目录或文件的全路径) -m “删除备注信息文本”</span><br><span class="line">推荐如下操作：</span><br><span class="line">svn　delete　文件名 </span><br><span class="line">svn　ci　-m　“删除备注信息文本”</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn delete svn://localhost/testapp/test.php -m “删除测试文件test.php”<br>推荐如下操作：<br>svn delete test.php<br>svn ci -m “删除测试文件test.php”</p></blockquote><h4 id="7、比较差异"><a href="#7、比较差异" class="headerlink" title="7、比较差异"></a>7、比较差异</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn　diff　文件名 </span><br><span class="line">svn　diff　-r　修正版本号m:修正版本号n　文件名</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn diff test.php                 #将修改的文件与基础版本比较<br>svn diff -r 200:201 test.php     #对 修正版本号200 和 修正版本号201 比较差异</p></blockquote><h4 id="8、查看文件或者目录状态"><a href="#8、查看文件或者目录状态" class="headerlink" title="8、查看文件或者目录状态"></a>8、查看文件或者目录状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">svn st 目录路径/名</span><br><span class="line">svn status 目录路径/名  #目录下的文件和子目录的状态，正常状态不显示 </span><br><span class="line">　　　　　　　　　　　　　【?：不在svn的控制中；  M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 </span><br><span class="line">svn st -v 目录路径/名</span><br><span class="line">svn status -v 目录路径/名  #显示文件和子目录状态</span><br><span class="line">　　　　　　　　　　　　　　【第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人】</span><br></pre></td></tr></table></figure><p>注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。</p><h4 id="9、查看日志"><a href="#9、查看日志" class="headerlink" title="9、查看日志"></a>9、查看日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　log　文件名</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn log test.php     #显示这个文件的所有修改记录，及其版本号的变化</p></blockquote><h4 id="10、查看文件详细信息"><a href="#10、查看文件详细信息" class="headerlink" title="10、查看文件详细信息"></a>10、查看文件详细信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn info file</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn info test.php</p></blockquote><h4 id="11、帮助"><a href="#11、帮助" class="headerlink" title="11、帮助"></a>11、帮助</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn help#全部功能选项</span><br><span class="line">svn help ci #具体功能的说明</span><br></pre></td></tr></table></figure><h4 id="12、加锁-解锁"><a href="#12、加锁-解锁" class="headerlink" title="12、加锁/解锁"></a>12、加锁/解锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn　lock　-m　“加锁备注信息文本“　[--force]　文件名 </span><br><span class="line">svn　unlock　文件名</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn lock -m “锁信测试用test.php文件“ test.php<br>svn unlock test.php</p></blockquote><h4 id="13、查看版本库下的文件和目录列表"><a href="#13、查看版本库下的文件和目录列表" class="headerlink" title="13、查看版本库下的文件和目录列表"></a>13、查看版本库下的文件和目录列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn list svn://路径（目录或文件的全路径） </span><br><span class="line">简写：svn ls xx</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn list svn://localhost/test<br>svn ls svn://localhost/test      #显示svn://localhost/test目录下的所有属于版本库的文件和目录</p></blockquote><h4 id="14、创建纳入版本控制下的新目录"><a href="#14、创建纳入版本控制下的新目录" class="headerlink" title="14、创建纳入版本控制下的新目录"></a>14、创建纳入版本控制下的新目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn mkdir 目录名</span><br><span class="line">svn mkdir -m &quot;新增目录备注文本&quot; http://目录全路径</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn mkdir newdir<br>svn mkdir -m “Making a new dir.” svn://localhost/test/newdir<br>注：添加完子目录后，一定要回到根目录更新一下，不然在该目录下提交文件会提示“提交失败”</p></blockquote><p><code>svn update</code></p><blockquote><p>注：如果手工在 checkout 出来的目录中新建目录 newsubdir，再用 svn mkdir newsubdir 命令后，SVN会提示：<br>svn: 尝试用 “svn add”或 “svn add –non-recursive”代替？<br>svn: 无法创建目录“hello”: 文件已经存在<br>此时用如下命令解决：<br><code>svn add --non-recursive newsubdir</code><br>在进入这个newsubdir文件夹，用ls -a查看它下面的全部目录与文件，会发现多了：.svn目录。再用 svn mkdir -m “添hello功能模块文件” svn://localhost/test/newdir/newsubdir 命令。</p></blockquote><h4 id="15、恢复本地修改"><a href="#15、恢复本地修改" class="headerlink" title="15、恢复本地修改"></a>15、恢复本地修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　revert　[--recursive]　文件名</span><br></pre></td></tr></table></figure><p>注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</p><blockquote><p><strong>例子：</strong><br>svn revert foo.c               #丢弃对一个文件的修改<br>svn revert –recursive .     #恢复一整个目录的文件，. 为当前目录</p></blockquote><h4 id="16、把工作拷贝更新到别的URL"><a href="#16、把工作拷贝更新到别的URL" class="headerlink" title="16、把工作拷贝更新到别的URL"></a>16、把工作拷贝更新到别的URL</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　switch　http://目录全路径　本地目录全路径</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn switch <a href="http://localhost/test/456" target="_blank" rel="noopener">http://localhost/test/456</a> .  # (原为123的分支)当前所在目录分支到localhost/test/456</p></blockquote><h4 id="17、解决冲突"><a href="#17、解决冲突" class="headerlink" title="17、解决冲突"></a>17、解决冲突</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　resolved　[本地目录全路径]</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>$ svn update<br>C foo.c<br>Updated to revision 31.<br>如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：<br>$ ls<br>foo.c<br>foo.c.mine<br>foo.c.r30<br>foo.c.r31<br>当你解决了foo.c的冲突，并且准备提交，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。<br>你可以仅仅删除冲突的文件并且提交，但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。</p></blockquote><h4 id="18、不checkout而查看输出特定文件或URL的内容"><a href="#18、不checkout而查看输出特定文件或URL的内容" class="headerlink" title="18、不checkout而查看输出特定文件或URL的内容"></a>18、不checkout而查看输出特定文件或URL的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn　cat　http://文件全路径</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子：</strong><br>svn cat <a href="http://localhost/test/readme.txt" target="_blank" rel="noopener">http://localhost/test/readme.txt</a></p></blockquote><h4 id="19、新建一个分支copy"><a href="#19、新建一个分支copy" class="headerlink" title="19、新建一个分支copy"></a>19、新建一个分支copy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn copy branchA branchB  -m &quot;make B branch&quot; // 从branchA拷贝出一个新分支branchB</span><br></pre></td></tr></table></figure><p>20、合并内容到分支merge<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn merge branchA branchB  // 把对branchA的修改合并到分支branchB</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、检出&quot;&gt;&lt;a href=&quot;#1、检出&quot; class=&quot;headerlink&quot; title=&quot;1、检出&quot;&gt;&lt;/a&gt;1、检出&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;简写：svn co xxx&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;例子：&lt;/strong&gt;&lt;br&gt;svn checkout svn://localhost/测试工具 /home/testtools –username ben&lt;br&gt;svn checkout &lt;a href=&quot;http://localhost/test/testapp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://localhost/test/testapp&lt;/a&gt; –username ben&lt;br&gt;注：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。&lt;br&gt;　　其中 username 与 password前是两个短线，不是一个。&lt;br&gt;　　不指定本地目录全路径，则检出到当前目录下。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="SVN" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/SVN/"/>
    
    
      <category term="SVN" scheme="http://yoursite.com/tags/SVN/"/>
    
  </entry>
  
</feed>
