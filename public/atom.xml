<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-21T09:20:39.155Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sublime配置代码追踪</title>
    <link href="http://yoursite.com/2018/07/18/Sublime%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA/"/>
    <id>http://yoursite.com/2018/07/18/Sublime配置代码追踪/</id>
    <published>2018-07-18T11:44:28.000Z</published>
    <updated>2018-07-21T09:20:39.155Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读别人代码的时候，非常喜欢IDE中的追踪代码功能。也想在sublime text中也使用。从网上查找发现可以使用ctags插件。</p><p>下面介绍下如何在sublime text中安装使用ctags：</p><h4 id="1、安装package-control"><a href="#1、安装package-control" class="headerlink" title="1、安装package control"></a>1、安装package control</h4><p>点击<code>Preferences &gt; Browse Packages</code>菜单，进入打开的目录的上层目录，然后再进入Installed Packages/目录，下载Package Control.sublime-package并复制到Installed Packages/目录<br>pControl.sublime-package下载地址：<a href="/uploads/2018/07/Package Control.sublime-package">点击下载</a><br><a id="more"></a></p><p>输入Ctrl+Shift+P（菜单 - Tools - Command Paletter），输入Install Package并回车，输入或选择你需要的插件回车就安装了。<br>如果快捷键不好使，重启Sublime Text。</p><h4 id="2、安装ctags"><a href="#2、安装ctags" class="headerlink" title="2、安装ctags"></a>2、安装ctags</h4><h5 id="（1）安装sublime-text插件"><a href="#（1）安装sublime-text插件" class="headerlink" title="（1）安装sublime text插件"></a>（1）安装sublime text插件</h5><p>输入ctags安装，会发现编辑器左下角正在下载安装。</p><h5 id="（2）安装可执行程序"><a href="#（2）安装可执行程序" class="headerlink" title="（2）安装可执行程序"></a>（2）安装可执行程序</h5><p>下载ctags可执行程序，地址为<code>http://prdownloads.sourceforge.net/ctags/ctags58.zip</code>，解压到一个目录，注意要是纯ASCII字符的目录不要带空格或中文命名的目录。</p><h5 id="（3）配置"><a href="#（3）配置" class="headerlink" title="（3）配置"></a>（3）配置</h5><p>配置可执行文件路径：打开菜单在Preferences菜单中打开<code>Package settings-&gt;ctags-&gt;settings-user和settings-default</code>把default中的配置全部复制到user中，然后改一下command配置项，为ctags的可执行文件路径,即ctags.exe路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Path to ctags executable.</span><br><span class="line">//</span><br><span class="line">// Alter this value if your ctags command is not in the PATH, or if using</span><br><span class="line">// a different version of ctags to that in the path (i.e. for OSX).</span><br><span class="line">//</span><br><span class="line">// NOTE: You *should not* place entire commands here. These commands are</span><br><span class="line">// built automatically using the values below. For example, this is OK:</span><br><span class="line">//</span><br><span class="line">//     &quot;command&quot;: &quot;/usr/bin/ctags&quot;</span><br><span class="line">//</span><br><span class="line">// This, on the other hand, won&apos;t work!</span><br><span class="line">//</span><br><span class="line">//     &quot;command&quot;: &quot;ctags -R -f .tags --exclude=some/path&quot;</span><br><span class="line">//</span><br><span class="line">&quot;command&quot;: &quot;C:/Windows/System32/ctags58/ctags.exe&quot;,</span><br></pre></td></tr></table></figure></p><p>配置快捷键：配置在sublime中使用Ctrl+左键单击函数跳转、Ctrl+右键单击跳回函数调用位置<br>复制以下代码到 <code>Preferences-&gt;Package Settings-&gt;Ctags-&gt;Mouse Bindings-User</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;button&quot;: &quot;button1&quot;,</span><br><span class="line">        &quot;count&quot;: 1,</span><br><span class="line">        &quot;press_command&quot;: &quot;drag_select&quot;,</span><br><span class="line">        &quot;modifiers&quot;: [&quot;ctrl&quot;],</span><br><span class="line">        &quot;command&quot;: &quot;navigate_to_definition&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;button&quot;: &quot;button2&quot;,</span><br><span class="line">        &quot;count&quot;: 1,</span><br><span class="line">        &quot;modifiers&quot;: [&quot;ctrl&quot;],</span><br><span class="line">        &quot;command&quot;: &quot;jump_prev&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h5 id="（4）使用"><a href="#（4）使用" class="headerlink" title="（4）使用"></a>（4）使用</h5><p>在使用函数调转功能前，需要先生成.tags文件，只需在<font color="red">项目文件管理器的项目文件上右键点击Ctags:Rebuild Tags即可</font><strong>（注意，在改动文件之后也许重新生成.tags）</strong></p><h5 id="（5）所有工作都准备充分之后，就可以在函数名上-Ctrl-左键-点击指定函数跳转了，Ctrl-右键返回上一个跳转函数；"><a href="#（5）所有工作都准备充分之后，就可以在函数名上-Ctrl-左键-点击指定函数跳转了，Ctrl-右键返回上一个跳转函数；" class="headerlink" title="（5）所有工作都准备充分之后，就可以在函数名上 Ctrl+左键 点击指定函数跳转了，Ctrl+右键返回上一个跳转函数；"></a>（5）所有工作都准备充分之后，就可以在函数名上 Ctrl+左键 点击指定函数跳转了，Ctrl+右键返回上一个跳转函数；</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在阅读别人代码的时候，非常喜欢IDE中的追踪代码功能。也想在sublime text中也使用。从网上查找发现可以使用ctags插件。&lt;/p&gt;
&lt;p&gt;下面介绍下如何在sublime text中安装使用ctags：&lt;/p&gt;
&lt;h4 id=&quot;1、安装package-control&quot;&gt;&lt;a href=&quot;#1、安装package-control&quot; class=&quot;headerlink&quot; title=&quot;1、安装package control&quot;&gt;&lt;/a&gt;1、安装package control&lt;/h4&gt;&lt;p&gt;点击&lt;code&gt;Preferences &amp;gt; Browse Packages&lt;/code&gt;菜单，进入打开的目录的上层目录，然后再进入Installed Packages/目录，下载Package Control.sublime-package并复制到Installed Packages/目录&lt;br&gt;pControl.sublime-package下载地址：&lt;a href=&quot;/uploads/2018/07/Package Control.sublime-package&quot;&gt;点击下载&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编辑器" scheme="http://yoursite.com/categories/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>搭建VPS记录</title>
    <link href="http://yoursite.com/2018/07/18/%E6%90%AD%E5%BB%BAVPN%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/07/18/搭建VPN记录/</id>
    <published>2018-07-18T11:43:42.000Z</published>
    <updated>2018-07-21T09:20:39.249Z</updated>
    
    <content type="html"><![CDATA[<p>通过Stack Overflow搜索到一个靠谱点的搭建VPS方法，完成搭建，现整理如下：</p><h4 id="一、服务器端安装"><a href="#一、服务器端安装" class="headerlink" title="一、服务器端安装"></a>一、服务器端安装</h4><h5 id="1、软件安装"><a href="#1、软件安装" class="headerlink" title="1、软件安装"></a>1、软件安装</h5><p>Debian / Ubuntu:<br>　　apt-get install python-pip<br>　　pip install shadowsocks</p><p>CentOS:<br>　　yum install python-setuptools &amp;&amp; easy_install pip<br>　　pip install shadowsocks</p><p>Windows:<br>　　See [Install Server on Windows]<br><a id="more"></a></p><h5 id="2、账号配置及常用命令"><a href="#2、账号配置及常用命令" class="headerlink" title="2、账号配置及常用命令"></a>2、账号配置及常用命令</h5><p>启动：<br>　　ssserver -p 443 -k password -m aes-256-cfb<br>后台启动：<br>　　sudo ssserver -p 443 -k password -m aes-256-cfb –user nobody -d start<br>停止：<br>　　sudo ssserver -d stop<br>检查log日志：<br>　　sudo less /var/log/shadowsocks.log</p><h4 id="二、客户端安装wiki"><a href="#二、客户端安装wiki" class="headerlink" title="二、客户端安装wiki"></a>二、客户端安装wiki</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Android]:           https://github.com/shadowsocks/shadowsocks-android</span><br><span class="line">[Build Status]:      https://img.shields.io/travis/shadowsocks/shadowsocks/master.svg?style=flat</span><br><span class="line">[Configuration]:     https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File</span><br><span class="line">[Coverage Status]:   https://jenkins.shadowvpn.org/result/shadowsocks</span><br><span class="line">[Coverage]:          https://jenkins.shadowvpn.org/job/Shadowsocks/ws/PYENV/py34/label/linux/htmlcov/index.html</span><br><span class="line">[Debian sid]:        https://packages.debian.org/unstable/python/shadowsocks</span><br><span class="line">[iOS]:               https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help</span><br><span class="line">[Issue Tracker]:     https://github.com/shadowsocks/shadowsocks/issues?state=open</span><br><span class="line">[Install Server on Windows]: https://github.com/shadowsocks/shadowsocks/wiki/Install-Shadowsocks-Server-on-Windows</span><br><span class="line">[Mailing list]:      https://groups.google.com/group/shadowsocks</span><br><span class="line">[OpenWRT]:           https://github.com/shadowsocks/openwrt-shadowsocks</span><br><span class="line">[OS X]:              https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help</span><br><span class="line">[PyPI]:              https://pypi.python.org/pypi/shadowsocks</span><br><span class="line">[PyPI version]:      https://img.shields.io/pypi/v/shadowsocks.svg?style=flat</span><br><span class="line">[Travis CI]:         https://travis-ci.org/shadowsocks/shadowsocks</span><br><span class="line">[Troubleshooting]:   https://github.com/shadowsocks/shadowsocks/wiki/Troubleshooting</span><br><span class="line">[Wiki]:              https://github.com/shadowsocks/shadowsocks/wiki</span><br><span class="line">[Windows]:           https://github.com/shadowsocks/shadowsocks-csharp</span><br></pre></td></tr></table></figure><h4 id="三、报错集锦"><a href="#三、报错集锦" class="headerlink" title="三、报错集锦"></a>三、报错集锦</h4><h5 id="1、启动服务的时候报："><a href="#1、启动服务的时候报：" class="headerlink" title="1、启动服务的时候报："></a>1、启动服务的时候报：</h5><blockquote><p>AttributeError: /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol</p></blockquote><p>这个问题是由于在openssl1.1.0版本中，废弃了<code>EVP_CIPHER_CTX_cleanup</code>函数，如官网中所说：</p><blockquote><p>EVP_CIPHER_CTX was made opaque in OpenSSL 1.1.0. As a result, EVP_CIPHER_CTX_reset() appeared and EVP_CIPHER_CTX_cleanup() disappeared.<br>EVP_CIPHER_CTX_init() remains as an alias for EVP_CIPHER_CTX_reset().</p></blockquote><p><strong>修改方法：</strong></p><blockquote><p>(1) 用vim打开文件：vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py (该路径请根据自己的系统情况自行修改，如果不知道该文件在哪里的话，可以使用find命令查找文件位置)<br>(2) 跳转到52行（shadowsocks2.8.2版本，其他版本搜索一下cleanup）<br>(3) 进入编辑模式<br>(4) 将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)<br>　　改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)<br>(5) 再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)<br>　　改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)<br>(6) 保存并退出<br>(7) 启动shadowsocks服务：service shadowsocks start 或 sslocal -c ss配置文件目录<br>(8) 问题解决</p></blockquote><p><strong>插曲：</strong><br>在 Vultr 上面购买的“东京”服务器用来搭建VPN，刚开始购买的是 $2.5/month，上面标注的是 only ipv6，服务器启动后，才发现国内目前还没有普及ipv6，ping都不通，在阿里云服务器上开启ipv6，然后再ping仍然不通。 应该是网络运营商方面没有开启ipv6，所以都出不去，才ping不通。迫不得已，又删除掉服务器，重新购买了 $5/month 的服务器，搭建完毕。</p><p><em>下面查看电脑是否支持IPV6访问：</em><br>登陆<code>http://test-ipv6.com/</code>（如果能上网的话）<br>根据网站给出的信息，判断是否支持IPv6。<br><img src="/uploads/2018/07/vpn_01.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过Stack Overflow搜索到一个靠谱点的搭建VPS方法，完成搭建，现整理如下：&lt;/p&gt;
&lt;h4 id=&quot;一、服务器端安装&quot;&gt;&lt;a href=&quot;#一、服务器端安装&quot; class=&quot;headerlink&quot; title=&quot;一、服务器端安装&quot;&gt;&lt;/a&gt;一、服务器端安装&lt;/h4&gt;&lt;h5 id=&quot;1、软件安装&quot;&gt;&lt;a href=&quot;#1、软件安装&quot; class=&quot;headerlink&quot; title=&quot;1、软件安装&quot;&gt;&lt;/a&gt;1、软件安装&lt;/h5&gt;&lt;p&gt;Debian / Ubuntu:&lt;br&gt;　　apt-get install python-pip&lt;br&gt;　　pip install shadowsocks&lt;/p&gt;
&lt;p&gt;CentOS:&lt;br&gt;　　yum install python-setuptools &amp;amp;&amp;amp; easy_install pip&lt;br&gt;　　pip install shadowsocks&lt;/p&gt;
&lt;p&gt;Windows:&lt;br&gt;　　See [Install Server on Windows]&lt;br&gt;
    
    </summary>
    
    
      <category term="VPS" scheme="http://yoursite.com/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>面试 - 数据库相关问题</title>
    <link href="http://yoursite.com/2018/06/11/%E9%9D%A2%E8%AF%95%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/06/11/面试 - 数据库相关问题/</id>
    <published>2018-06-11T09:58:07.000Z</published>
    <updated>2018-07-21T09:20:39.312Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、什么是索引-SQL-Server-2000里有什么类型的索引"><a href="#1、什么是索引-SQL-Server-2000里有什么类型的索引" class="headerlink" title="1、什么是索引?SQL Server 2000里有什么类型的索引?"></a>1、什么是索引?SQL Server 2000里有什么类型的索引?</h5><p>任何有经验的数据库开发人员都应该能够很轻易地回答这个问题。一些经验不太多的开发人员能够回答这个问题，但是有些地方会说不清楚。<br>简单地说，索引是一个数据结构，用来快速访问数据库表格或者视图里的数据。在SQL Server里，它们有两种形式:聚集索引和非聚集索引。聚集索引在索引的叶级保存数据。这意味着不论聚集索引里有表格的哪个(或哪些)字段，这些字段都会按顺序被保存在表格。由于存在这种排序，所以每个表格只会有一个聚集索引。非聚集索引在索引的叶级有一个行标识符。这个行标识符是一个指向磁盘上数据的指针。它允许每个表格有多个非聚集索引。</p><a id="more"></a><h5 id="2、什么是主键-什么是外键"><a href="#2、什么是主键-什么是外键" class="headerlink" title="2、什么是主键?什么是外键?"></a>2、什么是主键?什么是外键?</h5><p>主键是表格里的(一个或多个)字段，只用来定义表格里的行;主键里的值总是唯一的。外键是一个用来建立两个表格之间关系的约束。这种关系一般都涉及一个表格里的主键字段与另外一个表格(尽管可能是同一个表格)里的一系列相连的字段。那么这些相连的字段就是外键。</p><h5 id="3、什么是触发器-SQL-Server-2000有什么不同类型的触发器"><a href="#3、什么是触发器-SQL-Server-2000有什么不同类型的触发器" class="headerlink" title="3、什么是触发器?SQL Server 2000有什么不同类型的触发器?"></a>3、什么是触发器?SQL Server 2000有什么不同类型的触发器?</h5><p>让未来的数据库开发人员知道可用的触发器类型以及如何实现它们是非常有益的。<br>触发器是一种专用类型的存储过程，它被捆绑到SQL Server 2000的表格或者视图上。在SQL Server 2000里，有INSTEAD-OF和AFTER两种触发器。INSTEAD-OF触发器是替代数据操控语言(Data Manipulation Language，DML)语句对表格执行语句的存储过程。例如，如果我有一个用于TableA的INSTEAD-OF-UPDATE触发器，同时对这个表格执行一个更新语句，那么INSTEAD-OF-UPDATE触发器里的代码会执行，而不是我执行的更新语句则不会执行操作。<br>AFTER触发器要在DML语句在数据库里使用之后才执行。这些类型的触发器对于监视发生在数据库表格里的数据变化十分好用。</p><p>您如何确一个带有名为Fld1字段的TableB表格里只具有Fld1字段里的那些值，而这些值同时在名为TableA的表格的Fld1字段里?<br>这个与关系相关的问题有两个可能的答案。第一个答案(而且是您希望听到的答案)是使用外键限制。外键限制用来维护引用的完整性。它被用来确保表格里的字段只保存有已经在不同的(或者相同的)表格里的另一个字段里定义了的值。这个字段就是候选键(通常是另外一个表格的主键)。<br>另外一种答案是触发器。触发器可以被用来保证以另外一种方式实现与限制相同的作用，但是它非常难设置与维护，而且性能一般都很糟糕。由于这个原因，微软建议开发人员使用外键限制而不是触发器来维护引用的完整性。</p><h5 id="4、对一个投入使用的在线事务处理表格有过多索引需要有什么样的性能考虑"><a href="#4、对一个投入使用的在线事务处理表格有过多索引需要有什么样的性能考虑" class="headerlink" title="4、对一个投入使用的在线事务处理表格有过多索引需要有什么样的性能考虑?"></a>4、对一个投入使用的在线事务处理表格有过多索引需要有什么样的性能考虑?</h5><p>你正在寻找进行与数据操控有关的应聘人员。对一个表格的索引越多，数据库引擎用来更新、插入或者删除数据所需要的时间就越多，因为在数据操控发生的时候索引也必须要维护。</p><h5 id="5、你可以用什么来确保表格里的字段只接受特定范围里的值"><a href="#5、你可以用什么来确保表格里的字段只接受特定范围里的值" class="headerlink" title="5、你可以用什么来确保表格里的字段只接受特定范围里的值?"></a>5、你可以用什么来确保表格里的字段只接受特定范围里的值?</h5><p>这个问题可以用多种方式来回答，但是只有一个答案是“好”答案。您希望听到的回答是Check限制，它在数据库表格里被定义，用来限制输入该列的值。<br>触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求触发器在表格里被定义，这可能会在某些情况下影响到性能。因此，微软建议使用Check限制而不是其他的方式来限制域的完整性。</p><h5 id="6、对关系型数据库而言，索引是相当重要的概念，请回答有关索引几个问题"><a href="#6、对关系型数据库而言，索引是相当重要的概念，请回答有关索引几个问题" class="headerlink" title="6、对关系型数据库而言，索引是相当重要的概念，请回答有关索引几个问题:"></a>6、对关系型数据库而言，索引是相当重要的概念，请回答有关索引几个问题:</h5><p>a) 索引的目的是什么?<br>b) 索引对数据库系统的负面影响是什么?<br>c) 为数据表建立索引的原则有哪些?<br>d) 什么情况下不宜建立索引?</p><p>答：<br>索引的目的：</p><ol><li>快速访问数据表中的特定信息，提高检索速度</li><li>创建唯一性索引，保证数据库表中每一行数据的唯一性</li><li>加速表和表之间的连接</li><li>使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</li></ol><p>负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改的时候索引也要动态维护，这样就降低了数据的维护速度。</p><p>建立索引的原则：</p><ol><li>在最频繁使用的、用以缩小查询范围的字段上建立索引</li><li>在平频繁使用的、需要排序的字段上建立索引</li></ol><p>什么情况下不宜建立索引：</p><ol><li>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引</li><li>对于一些特殊的数据类型，不宜建立索引，比如文本字段(text)等。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1、什么是索引-SQL-Server-2000里有什么类型的索引&quot;&gt;&lt;a href=&quot;#1、什么是索引-SQL-Server-2000里有什么类型的索引&quot; class=&quot;headerlink&quot; title=&quot;1、什么是索引?SQL Server 2000里有什么类型的索引?&quot;&gt;&lt;/a&gt;1、什么是索引?SQL Server 2000里有什么类型的索引?&lt;/h5&gt;&lt;p&gt;任何有经验的数据库开发人员都应该能够很轻易地回答这个问题。一些经验不太多的开发人员能够回答这个问题，但是有些地方会说不清楚。&lt;br&gt;简单地说，索引是一个数据结构，用来快速访问数据库表格或者视图里的数据。在SQL Server里，它们有两种形式:聚集索引和非聚集索引。聚集索引在索引的叶级保存数据。这意味着不论聚集索引里有表格的哪个(或哪些)字段，这些字段都会按顺序被保存在表格。由于存在这种排序，所以每个表格只会有一个聚集索引。非聚集索引在索引的叶级有一个行标识符。这个行标识符是一个指向磁盘上数据的指针。它允许每个表格有多个非聚集索引。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试 - php易混淆题集锦</title>
    <link href="http://yoursite.com/2018/06/11/%E9%9D%A2%E8%AF%95-php%E6%98%93%E6%B7%B7%E6%B7%86%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://yoursite.com/2018/06/11/面试-php易混淆题集锦/</id>
    <published>2018-06-11T08:55:20.000Z</published>
    <updated>2018-07-21T09:53:20.548Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-写出如下程序的输出结果（考点：变量判空）"><a href="#1-写出如下程序的输出结果（考点：变量判空）" class="headerlink" title="1. 写出如下程序的输出结果（考点：变量判空）"></a>1. 写出如下程序的输出结果（考点：变量判空）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$a1 = null;</span><br><span class="line">$a2 = false;</span><br><span class="line">$a3 = 0;</span><br><span class="line">$a4 = &apos;&apos;;</span><br><span class="line">$a5 = &apos;0&apos;;</span><br><span class="line">$a6 = &apos;null&apos;;</span><br><span class="line">$a7 = array();</span><br><span class="line">$a8 = array(array());</span><br><span class="line"></span><br><span class="line">echo empty($a1) ? &apos;true&apos; : &apos;false&apos;;             //true</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a2) ? &apos;true&apos; : &apos;false&apos;;             //true</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a3) ? &apos;true&apos; : &apos;false&apos;;             //true</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a4) ? &apos;true&apos; : &apos;false&apos;;             //true</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a5) ? &apos;true&apos; : &apos;false&apos;;             //false  true</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a6) ? &apos;true&apos; : &apos;false&apos;;             //false</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a7) ? &apos;true&apos; : &apos;false&apos;;             //true</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a8) ? &apos;true&apos; : &apos;false&apos;;             //true  false</span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h5 id="2-写出如下程序的输出结果（考点：变量引用）"><a href="#2-写出如下程序的输出结果（考点：变量引用）" class="headerlink" title="2. 写出如下程序的输出结果（考点：变量引用）"></a>2. 写出如下程序的输出结果（考点：变量引用）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$test = &apos;aaaaaa&apos;;</span><br><span class="line">$abc = &amp;$test;</span><br><span class="line">unset($test);</span><br><span class="line"></span><br><span class="line">echo $abc;              //aaaaaa</span><br><span class="line">echo $test;             //undefined valiable</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure><hr><h5 id="3-写出如下程序的输出结果（考点：静态变量）"><a href="#3-写出如下程序的输出结果（考点：静态变量）" class="headerlink" title="3. 写出如下程序的输出结果（考点：静态变量）"></a>3. 写出如下程序的输出结果（考点：静态变量）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$count = 5;</span><br><span class="line">function get_count()&#123;</span><br><span class="line">        static $count = 0;</span><br><span class="line">        return $count++;</span><br><span class="line">&#125;</span><br><span class="line">echo $count;            //5</span><br><span class="line">++$count;</span><br><span class="line"></span><br><span class="line">echo get_count();       //0</span><br><span class="line">echo get_count();       //1</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure><hr><h5 id="4-写出如下程序的输出结果（考点：全局变量作用域）"><a href="#4-写出如下程序的输出结果（考点：全局变量作用域）" class="headerlink" title="4. 写出如下程序的输出结果（考点：全局变量作用域）"></a>4. 写出如下程序的输出结果（考点：全局变量作用域）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS[&apos;var1&apos;] = 5;</span><br><span class="line">$var2 = 1;</span><br><span class="line">function get_value()&#123;</span><br><span class="line">        global $var2;</span><br><span class="line">        $var1 = 0;</span><br><span class="line">        return $var2++;</span><br><span class="line">&#125;</span><br><span class="line">get_value();</span><br><span class="line"></span><br><span class="line">echo $var1;     //5</span><br><span class="line">echo $var2;     //2</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure><p><strong>全局变量的作用域问题：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function destroy_foo() </span><br><span class="line">&#123;</span><br><span class="line">        global $foo;</span><br><span class="line">        unset($foo);</span><br><span class="line">        // unset($GLOBALS[&apos;foo&apos;]);//清除全局变量$foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$foo = &apos;bar&apos;;</span><br><span class="line">destroy_foo();</span><br><span class="line">echo $foo;      //bar</span><br></pre></td></tr></table></figure></p><p>unset($foo) 的作用是清除函数内的 $foo变量，并没有清除全局变量的$foo，因此执行此函数后，变量仍存在。想要彻底清除$foo，需要清除掉全局变量里的$foo值。</p><hr><h5 id="5-写出如下程序的输出结果（考点：unset对于数组的作用）"><a href="#5-写出如下程序的输出结果（考点：unset对于数组的作用）" class="headerlink" title="5. 写出如下程序的输出结果（考点：unset对于数组的作用）"></a>5. 写出如下程序的输出结果（考点：unset对于数组的作用）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function get_arr($arr)&#123;</span><br><span class="line">        unset($arr[0]);</span><br><span class="line">&#125;</span><br><span class="line">function get_arr2(&amp;$arr)&#123;</span><br><span class="line">        unset($arr[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr1 = array(1, 2);</span><br><span class="line">$arr2 = array(1, 2);</span><br><span class="line"></span><br><span class="line">get_arr($arr1);</span><br><span class="line">get_arr2($arr2);</span><br><span class="line"></span><br><span class="line">echo count($arr1);      //2</span><br><span class="line">echo count($arr2);      //1</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure><hr><h5 id="6-字符串强制转换为整型为0"><a href="#6-字符串强制转换为整型为0" class="headerlink" title="6. 字符串强制转换为整型为0"></a>6. 字符串强制转换为整型为0</h5><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;a1&quot;  =&gt; 0  //首字母a为字符，强制转换为整型为0</span><br><span class="line">&quot;1a&quot;  =&gt; 1      //首字母1为数字，强制转换为整型为1</span><br></pre></td></tr></table></figure></p><hr><h5 id="7-amp-与-amp-amp-的区别"><a href="#7-amp-与-amp-amp-的区别" class="headerlink" title="7. &amp; 与 &amp;&amp; 的区别"></a>7. &amp; 与 &amp;&amp; 的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;$b = 10;</span><br><span class="line"></span><br><span class="line">if($a &lt; 4 &amp;&amp; (++$a &gt; 10))&#123;&#125;</span><br><span class="line">if($b &lt; 4 &amp; (++$b &gt; 10))&#123;&#125;</span><br><span class="line"></span><br><span class="line">echo $a;</span><br><span class="line">echo $b;</span><br></pre></td></tr></table></figure><p>&amp; 是按位与操作符，两边都为 1 则为 1。左侧为false，也会运行右侧的代码。<br>&amp;&amp; 是逻辑与操作符，左侧为false，不运行右侧的代码。<br>相同点：都可进行 and 判断。</p><hr><h5 id="8-unset对于数组的作用"><a href="#8-unset对于数组的作用" class="headerlink" title="8. unset对于数组的作用"></a>8. unset对于数组的作用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$arr = array(</span><br><span class="line">        1=&gt; &apos;a&apos;,</span><br><span class="line">        2=&gt; &apos;bb&apos;,</span><br><span class="line">        3=&gt; &apos;c&apos;,</span><br><span class="line">        4=&gt; &apos;dd&apos;</span><br><span class="line">        );</span><br><span class="line">foreach($arr as $k=&gt;&amp;$v)&#123;</span><br><span class="line">        if($k == 3)&#123;</span><br><span class="line">                $v = &apos;x&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        // unset($v);   //保持键4 的值不变</span><br><span class="line">&#125;</span><br><span class="line">foreach($arr as $k=&gt;$v)&#123;</span><br><span class="line">        echo &quot;&#123;$k&#125;\t&#123;$v&#125;&lt;br/&gt;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：array(‘a’, ‘bb’, ‘x’, ‘x’);<br><em>为什么结果是这样？</em><br>　　因为满足条件语句之后，就把数组的值指向了’x’的内存地址了。因此后面的数组索引都是指向了’x’。<br><em>怎么能让 键4 的值不变？</em><br>　　使用 unset($v) 来清除 指针。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-写出如下程序的输出结果（考点：变量判空）&quot;&gt;&lt;a href=&quot;#1-写出如下程序的输出结果（考点：变量判空）&quot; class=&quot;headerlink&quot; title=&quot;1. 写出如下程序的输出结果（考点：变量判空）&quot;&gt;&lt;/a&gt;1. 写出如下程序的输出结果（考点：变量判空）&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$a1 = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a2 = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a3 = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a4 = &amp;apos;&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a5 = &amp;apos;0&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a6 = &amp;apos;null&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a7 = array();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a8 = array(array());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a1) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a2) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a3) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a4) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a5) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //false  true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a6) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a7) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a8) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //true  false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;hr/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之netstat</title>
    <link href="http://yoursite.com/2018/06/11/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bnetstat/"/>
    <id>http://yoursite.com/2018/06/11/Linux命令之netstat/</id>
    <published>2018-06-11T08:06:20.000Z</published>
    <updated>2018-07-21T09:20:39.015Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat命令各个参数说明如下：</span><br><span class="line">-a : 显示全部端口</span><br><span class="line">　　-t : 指明显示TCP端口</span><br><span class="line">　　-u : 指明显示UDP端口</span><br><span class="line">　　-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)</span><br><span class="line">　　-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。</span><br><span class="line">　　-n : 不进行DNS轮询，显示IP(可以加速操作)</span><br></pre></td></tr></table></figure><a id="more"></a><p>即可显示当前服务器上所有端口及进程服务，于grep结合可查看某个具体端口及服务情况··<br><code>netstat -ntlp   //查看当前所有tcp端口·</code><br><code>netstat -ntulp |grep 80   //查看所有80端口使用情况·</code><br><code>netstat -an | grep 3306   //查看所有3306端口使用情况·</code></p><p><strong>查看一台服务器上面哪些服务及端口</strong><br><code>netstat  -lanp</code></p><p><strong>查看一个服务有几个端口。比如要查看mysqld</strong><br><code>ps -ef |grep mysqld</code></p><p><strong>查看某一端口的连接数量,比如3306端口</strong><br><code>netstat -pnt |grep :3306 |wc</code></p><p><strong>查看某一端口的连接客户端IP 比如3306端口</strong><br><code>netstat -anp |grep 3306</code></p><p><code>netstat -an 查看网络端口</code></p><p><code>lsof -i :port，使用lsof -i :port就能看见所指定端口运行的程序，同时还有当前连接。</code></p><p><code>nmap 端口扫描</code><br><code>netstat -nupl  (UDP类型的端口)</code><br><code>netstat -ntpl  (TCP类型的端口)</code><br><code>netstat -anp 显示系统端口使用情况</code></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;netstat命令各个参数说明如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	-a : 显示全部端口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-t : 指明显示TCP端口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-u : 指明显示UDP端口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-n : 不进行DNS轮询，显示IP(可以加速操作)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>PHP 传值与传引用详解</title>
    <link href="http://yoursite.com/2018/06/05/PHP%20%E4%BC%A0%E5%80%BC%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/06/05/PHP 传值与传引用详解/</id>
    <published>2018-06-05T10:03:52.000Z</published>
    <updated>2018-07-21T09:20:39.124Z</updated>
    
    <content type="html"><![CDATA[<p>首先，看两个示例，进行比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = 1; $b = &amp;$a; $c = 2; $a = &amp;$c; $c = 2;</span><br><span class="line">echo $a.&apos;&lt;br/&gt;&apos;;</span><br><span class="line">echo $b.&apos;&lt;br/&gt;&apos;;</span><br><span class="line">echo $c.&apos;&lt;br/&gt;&apos;;</span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure></p><p>此时，$a、$b、$c 的值是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = 1; $b = &amp;$a; $c = 2; $c = &amp;$a; $c = 2;</span><br><span class="line">echo $a.&apos;&lt;br/&gt;&apos;;</span><br><span class="line">echo $b.&apos;&lt;br/&gt;&apos;;</span><br><span class="line">echo $c.&apos;&lt;br/&gt;&apos;;</span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure><p>此时，$a、$b、$c 的值又是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = 1; $b = &amp;$a; $c = 2; $c = &amp;$a;</span><br><span class="line">echo $a.&apos;&lt;br/&gt;&apos;;</span><br><span class="line">echo $b.&apos;&lt;br/&gt;&apos;;</span><br><span class="line">echo $c.&apos;&lt;br/&gt;&apos;;</span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure><p>此时，$a、$b、$c 的值又是多少？</p><p><em>（先不要着急往下看，文章的末尾会附属答案。）</em><br><a id="more"></a></p><p>下面对赋值与赋引用进行说明。<br>再看个示例，进行说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;//将常量值赋给变量，会为a分配内存空间</span><br><span class="line">$b = $a;//变量赋值给变量，是不是copy了一份副本，b也分配了内存空间呢？</span><br><span class="line">$a = &amp;$c;//引用是不会为c分配空间的，c和a是共用一份空间的。</span><br><span class="line">         //此时，a和c都指向同一个内存空间，且为空。（注：a就不是10了）。</span><br><span class="line"></span><br><span class="line">echo $a;//无输出</span><br><span class="line">echo $c;//无输出</span><br><span class="line">echo PHP_EOL;</span><br><span class="line">echo $b;//由于b是副本，输出10</span><br><span class="line"></span><br><span class="line">$a = 5;</span><br><span class="line">echo $c;//输出5，因为a和c 是指向同一个内存空间</span><br><span class="line">echo PHP_EOL;</span><br><span class="line">echo $b;//由于b是副本，对a的操作不会影响b，输出10</span><br></pre></td></tr></table></figure></p><p><strong>（1）赋值</strong><br>由上面示例可看出，将常量值赋值给变量，会分配内存空间（属于新建变量）；当将变量赋值给变量，只是拷贝一份副本，并不会重新分配内存空间，PHP底层变量计数会加1。只有当这两个变量中的其中任一个改变，才会重新分配内存空间（属于新建变量），且此两个变量的更改与否互相无关。</p><p><strong>（2）赋引用</strong><br>&amp;赋引用的时候，视为一个变量定义了一个别名，增加了一个对内存空间的引用。改变其中一个，会影响其他的引用。而使用unset()时，只是断开了对变量内存空间的引用，内存空间不会释放（底层就是释放了指向内存空间的指针）。<br>由上面示例可看出，赋引用的先后是有影响的。$a=&amp;$c 指把$c的引用地址赋值给$a，且$c的引用地址对应的值为空，因此$a=$c为空。若$c=&amp;$a 指把$a的引用地址赋值给$c，且$a的引用地址对应的值为10，因此$a=$c=10。</p><font color="red"><strong>划重点：赋引用的时候，先后赋引用的顺序是有影响的。</strong></font><hr><font color="red"><strong>示例答案：</strong><br>示例一：$a=2,$b=1,$c=2;<br>示例二：$a=2,$b=2,$c=2;<br>示例三：$a=1,$b=1,$c=1;<br></font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，看两个示例，进行比较：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$a = 1; $b = &amp;amp;$a; $c = 2; $a = &amp;amp;$c; $c = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $a.&amp;apos;&amp;lt;br/&amp;gt;&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $b.&amp;apos;&amp;lt;br/&amp;gt;&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $c.&amp;apos;&amp;lt;br/&amp;gt;&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;hr/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时，$a、$b、$c 的值是多少？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$a = 1; $b = &amp;amp;$a; $c = 2; $c = &amp;amp;$a; $c = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $a.&amp;apos;&amp;lt;br/&amp;gt;&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $b.&amp;apos;&amp;lt;br/&amp;gt;&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $c.&amp;apos;&amp;lt;br/&amp;gt;&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;hr/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此时，$a、$b、$c 的值又是多少？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$a = 1; $b = &amp;amp;$a; $c = 2; $c = &amp;amp;$a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $a.&amp;apos;&amp;lt;br/&amp;gt;&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $b.&amp;apos;&amp;lt;br/&amp;gt;&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $c.&amp;apos;&amp;lt;br/&amp;gt;&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;hr/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此时，$a、$b、$c 的值又是多少？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（先不要着急往下看，文章的末尾会附属答案。）&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP知识点" scheme="http://yoursite.com/tags/PHP%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>接口文档说明</title>
    <link href="http://yoursite.com/2018/06/04/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/06/04/接口文档说明/</id>
    <published>2018-06-04T10:35:31.000Z</published>
    <updated>2018-07-21T09:20:39.249Z</updated>
    
    <content type="html"><![CDATA[<p>接口文档编写格式：</p><p>服务名称：<br>video-clip-repeat</p><p>需求概述：<br>很多视频是由相同片段重复播放合成，这种视频信息量低，用户观看体验差，检测出此类视频能有效降低feed、大搜等badcase。</p><p>核心功能：<br>检测出视频是否包含重复片段，如果包含则给出重复片段时间点。</p><a id="more"></a><p>错误码表：</p><table><thead><tr><th>错误码</th><th>错误信息</th><th>解释</th></tr></thead><tbody><tr><td>0</td><td>Success</td><td>成功</td></tr><tr><td>1</td><td>Failed to parse input json.</td><td>配置文件解析错误</td></tr><tr><td>2</td><td>Not found KEY:video_url in input json</td><td>json格式里没有video_url字段</td></tr><tr><td>3</td><td>Video_url value is NULL</td><td>video_url字段的内容为空</td></tr></tbody></table><p>返回信息格式：</p><table><thead><tr><th>参数</th><th>参数类型</th><th>必须</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>err_no</td><td>uint32</td><td>是</td><td>错误码</td><td>0正常，非零错误</td></tr><tr><td>err_msg</td><td>string</td><td>是</td><td>错误信息</td><td>参考错误码表</td></tr><tr><td>result</td><td>string</td><td>否</td><td></td><td>只在err_no为0时有结果</td></tr></tbody></table><p>接口名称：<br>1、接口地址：<br><a href="http://xxxx:8120/xxx" target="_blank" rel="noopener">http://xxxx:8120/xxx</a></p><p>2、HTTP方法：POST</p><p>3、请求参数：<br>格式：json</p><table><thead><tr><th>参数</th><th>类型</th><th>是否必选</th><th>说明     </th></tr></thead><tbody><tr><td>video_url</td><td>string</td><td>是</td><td>视频的url链接，必选参数，不能为空</td></tr><tr><td>type_name</td><td>string</td><td>是</td><td>固定值：video-clip-repeat</td></tr></tbody></table><p>4、输出参数：<br>格式：json</p><table><thead><tr><th>参数</th><th></th><th></th><th>类型</th><th>必须</th><th>说明     </th></tr></thead><tbody><tr><td>ratio</td><td></td><td></td><td>double</td><td>是</td><td>重复片段占视频时长的比例</td></tr><tr><td>video_time</td><td></td><td></td><td>string</td><td>是</td><td>视频总时长</td></tr><tr><td>result</td><td></td><td></td><td>json</td><td>是</td><td>列表列表里面是重复片段组的json</td></tr><tr><td></td><td>scopes</td><td></td><td>json</td><td>是</td><td>列表列表包含了每个重复片段的起始时间</td></tr><tr><td></td><td></td><td>start_time</td><td>string</td><td>是</td><td>片段起始时间，例如：”00:01:58”</td></tr><tr><td></td><td></td><td>end_time</td><td>string</td><td>是</td><td>片段终止时间，例如：”00:01:58”</td></tr></tbody></table><p>5、正确返回值示例：<br>{<br>    “log_id”: 2874085801,<br>    “words_result”: [{<br>        “location”: {<br>            “left”: 69,<br>            “top”: 35,<br>            “width”: 510,<br>            “height”: 100<br>        },<br>        “words”: “DOO”,<br>        “chars”: [{<br>            “location”: {<br>                “left”: 84,<br>                “top”: 40,<br>                “width”: 330,<br>                “height”: 90<br>            },<br>            “char”: “DOO”<br>        }]<br>    }],<br>    “words_result_num”: 1<br>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口文档编写格式：&lt;/p&gt;
&lt;p&gt;服务名称：&lt;br&gt;video-clip-repeat&lt;/p&gt;
&lt;p&gt;需求概述：&lt;br&gt;很多视频是由相同片段重复播放合成，这种视频信息量低，用户观看体验差，检测出此类视频能有效降低feed、大搜等badcase。&lt;/p&gt;
&lt;p&gt;核心功能：&lt;br&gt;检测出视频是否包含重复片段，如果包含则给出重复片段时间点。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
      <category term="接口" scheme="http://yoursite.com/categories/PHP/%E6%8E%A5%E5%8F%A3/"/>
    
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>接口代码架构</title>
    <link href="http://yoursite.com/2018/06/04/%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2018/06/04/接口代码架构/</id>
    <published>2018-06-04T10:35:22.000Z</published>
    <updated>2018-07-21T09:20:39.249Z</updated>
    
    <content type="html"><![CDATA[<p>下面列出接口代码架构格式，不一定完全一致，大概满足需求即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">— InterfaceBase.php //接口基文件</span><br><span class="line">— InterfaceFactory.php     //接口工厂文件，即入口文件（按需求使用）</span><br><span class="line">— GoodInterface.php //商品接口基文件</span><br><span class="line">— CartInterface.php //购物车接口基文件</span><br><span class="line">— Output.php //定义错误码文件</span><br><span class="line">— ......//其它接口文件</span><br><span class="line">— api_1/// 1版本的接口文件夹</span><br><span class="line">— — Good.php   //商品接口文件</span><br><span class="line">— — Cart.php   //购物车接口文件</span><br><span class="line">— — ......   //其它接口文件</span><br><span class="line">— api_2///2版本的接口文件夹</span><br><span class="line">— — Good.php   //商品接口文件</span><br><span class="line">— — ......  //其它接口文件</span><br></pre></td></tr></table></figure></p><p>下面附属重要文件的代码格式，一般不需要改变。<br><a id="more"></a></p><h5 id="接口基文件：InterfaceBase-php"><a href="#接口基文件：InterfaceBase-php" class="headerlink" title="接口基文件：InterfaceBase.php"></a>接口基文件：InterfaceBase.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * @file InterfaceBase.php</span><br><span class="line"> * @author ***</span><br><span class="line"> * @date 2017/05/26</span><br><span class="line"> * @brief </span><br><span class="line"> *  </span><br><span class="line"> **/</span><br><span class="line">class Service_data_Ocr_Base_OcrBase &#123;</span><br><span class="line">    protected $_fixed_args = null;      //接口默认参数</span><br><span class="line">    protected $_args = null;            //接口处理参数</span><br><span class="line">    protected $_requestData;            //请求数据</span><br><span class="line">    protected $_resizeImage = null;     //压缩图片数据</span><br><span class="line">    protected $_ocrResizeFactor = 1.0;  //压缩因子</span><br><span class="line">    protected $_service_name = null;    //请求服务</span><br><span class="line">    protected $_appid = null;           //用户APPID</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *@param service name &amp; fixed args</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    public function __construct($service_name,$fixed_args) &#123;</span><br><span class="line">        $this-&gt;_service_name = $service_name;</span><br><span class="line">        $this-&gt;_fixed_args = $fixed_args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入口方法</span><br><span class="line">     *@param input param</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    public function run(&amp;$arrInput) &#123;</span><br><span class="line">        $this-&gt;_checkParams($arrInput);</span><br><span class="line">        $this-&gt;_buildRequest($arrInput);</span><br><span class="line">        $this-&gt;_appid = $arrInput[&apos;appid&apos;];</span><br><span class="line">        $rpcResponse = $this-&gt;_getResult();</span><br><span class="line">        $result = $this-&gt;_buildResponse($arrInput,$rpcResponse);</span><br><span class="line">        return $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 检测传入参数数据</span><br><span class="line">     *@param &amp;$arrInput input params from client</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    protected function _checkParams(&amp;$arrInput) &#123;</span><br><span class="line">        $ori_image_size = strlen($arrInput[&apos;image&apos;]);</span><br><span class="line">        $this-&gt;_checkImage($arrInput);</span><br><span class="line">        $resize_image_size = strlen($arrInput[&apos;image&apos;]);</span><br><span class="line">        if($resize_image_size !== $ori_image_size) &#123;</span><br><span class="line">            $this-&gt;_resizeImage = $arrInput[&apos;image&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对图片进行处理 （单独模块拉出来实现，避免一个方法的实现内容过长）</span><br><span class="line">     *@param &amp;$arrInput, $ocrResizeFactor</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    protected function _checkImage(&amp;$arrInput) &#123;</span><br><span class="line">        //对图片进行处理</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *@param &amp;$arrInput, $ocrResizeFactor</span><br><span class="line">     * @param: $refusedLen 直接拒绝图片尺寸阈值;$refusedSize 直接拒绝图片大小阈值;$minBoderLen: 直接拒绝的最小尺寸图片</span><br><span class="line">     * @param: $resizeLen 符合压缩图片的边长上限; $resizeSize 符合压缩条件的大小上限</span><br><span class="line">     * @param: $resizedSizeThread 压缩后图片是否请求后端的条件大小</span><br><span class="line">     * @return null</span><br><span class="line">     */</span><br><span class="line">    protected function _checkImageExtra(&amp;$arrInput, $refusedLen, $refusedSize, $resizeLen, $resizeSize, $resizedSizeThread, $minBoderLen = 15) &#123;</span><br><span class="line">        pass;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 单独接口处理请求参数，在每个接口中实现</span><br><span class="line">     *@param build args</span><br><span class="line">     *@return </span><br><span class="line">     */</span><br><span class="line">    protected function _buildArgs(&amp;$arrInput) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 整合请求参数数据</span><br><span class="line">     *@param arrInput</span><br><span class="line">     *@return</span><br><span class="line">     */</span><br><span class="line">    protected function _buildRequest(&amp;$arrInput) &#123;</span><br><span class="line">        $this-&gt;_buildArgs($arrInput);   //调用接口处理参数并返回处理结果</span><br><span class="line">        $appid = $arrInput[&apos;appid&apos;];</span><br><span class="line">        $requestData = array(</span><br><span class="line">            &apos;appid&apos; =&gt; $appid,</span><br><span class="line">            &apos;logid&apos; =&gt; intval(Bd_Log::genLogID()),</span><br><span class="line">            &apos;format&apos; =&gt; &apos;json&apos;,</span><br><span class="line">            &apos;from&apos; =&gt; &apos;openapi&apos;,</span><br><span class="line">            &apos;cmdid&apos; =&gt; &apos;123&apos;,</span><br><span class="line">            &apos;clientip&apos; =&gt; strval($_SERVER[&apos;HTTP_X_REAL_IP&apos;]),</span><br><span class="line">            &apos;data&apos; =&gt; base64_encode($this-&gt;_args),</span><br><span class="line">        );</span><br><span class="line">        $this-&gt;_requestData = $requestData;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向后端请求数据</span><br><span class="line">     *@param null</span><br><span class="line">     *@return ral response </span><br><span class="line">     */    </span><br><span class="line">    protected function  _getResult() &#123;</span><br><span class="line">        $service_name = $this-&gt;_service_name;</span><br><span class="line">        $arrayHeader = array(</span><br><span class="line">            &apos;pathinfo&apos;   =&gt; &apos;GeneralClassifyService/classify&apos;,</span><br><span class="line">            &apos;Content-Type&apos; =&gt; &apos;application/json&apos;,</span><br><span class="line">        );        </span><br><span class="line">        $arrayReturn = ral($service_name, &apos;post&apos;, $this-&gt;_requestData, *, $arrayHeader);</span><br><span class="line">        $intErrno = ral_get_errno();</span><br><span class="line">        $strErrmsg = ral_get_error();</span><br><span class="line">        if ($intErrno != 0) &#123;</span><br><span class="line">            Bd_Log::warning(&quot;get from ocr ral error.[$intErrno][$strErrmsg] from service_name[$service_name]&quot;);</span><br><span class="line">            throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_INTERNAL_ERROR);</span><br><span class="line">        &#125;        </span><br><span class="line">        return $arrayReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 整合数据并返回</span><br><span class="line">     *@param input params &amp; return from ral</span><br><span class="line">     *@return </span><br><span class="line">     */</span><br><span class="line">    protected function _buildResponse($arrInput,$arrayReturn) &#123;</span><br><span class="line">        Util::dealErrResponse($arrayReturn);        //处理错误输出</span><br><span class="line">        $decodedResult = base64_decode($arrayReturn[&apos;result&apos;]);</span><br><span class="line">        $result = json_decode($decodedResult, $assoc=true);</span><br><span class="line">        return $this-&gt;buildResponse($arrInput, $result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *@param arrInput, array        //用户传入数据</span><br><span class="line">     *@param ocrResult, array       //后端处理后数据</span><br><span class="line">     *@return openapiResult, array  //返回整合数组</span><br><span class="line">     */</span><br><span class="line">    protected function buildResponse(&amp;$arrInput, &amp;$ocrResult) &#123;</span><br><span class="line">        // 建立数据并返回</span><br><span class="line">        return $openapiResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接口工厂文件：InterfaceFactory-php"><a href="#接口工厂文件：InterfaceFactory-php" class="headerlink" title="接口工厂文件：InterfaceFactory.php"></a>接口工厂文件：InterfaceFactory.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line">* @file InterfaceFactory.php</span><br><span class="line">* @brief </span><br><span class="line">* @author ** *</span><br><span class="line">* @version </span><br><span class="line">* @date 2016-08-03</span><br><span class="line"> */</span><br><span class="line">class InterfaceFactory &#123;</span><br><span class="line">    /**</span><br><span class="line">     *@param arrInput</span><br><span class="line">     *@return object of Service_Data_InterfaceProxy</span><br><span class="line">     */</span><br><span class="line">    public static function create(&amp;$arrInput) &#123;</span><br><span class="line">        switch ($arrInput[&apos;openservice&apos;]) &#123;</span><br><span class="line">            case &apos;good&apos;:</span><br><span class="line">                switch ($arrInput[&apos;classify_type&apos;]) &#123;</span><br><span class="line">                    case &apos;clothing&apos;:</span><br><span class="line">                        if (strtolower($arrInput[&apos;version&apos;]) == &apos;v1&apos;) &#123;</span><br><span class="line">                            return new api_v1/ClothingInterface($arrInput);</span><br><span class="line">                        &#125;else &#123;</span><br><span class="line">                            return new api_v2/ClothingInterface($arrInput);</span><br><span class="line">                        &#125;</span><br><span class="line">                    case &apos;shoes&apos;:</span><br><span class="line">                        if (strtolower($arrInput[&apos;version&apos;]) == &apos;v2&apos;) &#123;</span><br><span class="line">                            return new api_v2/ShoesInterface($arrInput);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            return new api_v1/ShoesInterface($arrInput);</span><br><span class="line">                        &#125;</span><br><span class="line">                    default:</span><br><span class="line">                        throw new Exception(&apos;&apos;, Output::ERRNUM_METHOD_NOT_SUPPORT);</span><br><span class="line">                &#125;</span><br><span class="line">            case &apos;cart&apos;:</span><br><span class="line">                return new CartInterface($arrInput);</span><br><span class="line">            default:</span><br><span class="line">                try &#123;</span><br><span class="line">                    $className = ucfirst($arrInput[&apos;openservice&apos;]).&quot;Interface&quot;;</span><br><span class="line">                    $clazz = new ReflectionClass($className);</span><br><span class="line">                    return $clazz-&gt;newInstance($arrInput);</span><br><span class="line">                &#125; catch (Exception $e) &#123;</span><br><span class="line">                    throw new Exception(&apos;&apos;, Output::ERRNUM_METHOD_NOT_SUPPORT);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="商品接口文件：GoodInterface-php"><a href="#商品接口文件：GoodInterface-php" class="headerlink" title="商品接口文件：GoodInterface.php"></a>商品接口文件：GoodInterface.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @file GoodInterface.php</span><br><span class="line"> * @author ***</span><br><span class="line"> * @date 2017/11/16</span><br><span class="line"> * @brief </span><br><span class="line"> *  </span><br><span class="line"> **/</span><br><span class="line">class GoodInterface extends InterfaceBase &#123;</span><br><span class="line">    /*</span><br><span class="line">     *@param null</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    public function __construct() &#123;</span><br><span class="line">        $fixed_args = &quot;encoding=1&amp;recg_type=seq&amp;international=1&amp;save_img=true&quot;; //接口默认参数</span><br><span class="line">        parent::__construct(&quot;serverName&quot;,$fixed_args); //传入基文件数据</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户处理对应接口传入数据</span><br><span class="line">     *@param input params outside</span><br><span class="line">     *@return protected memerber:args</span><br><span class="line">     */    </span><br><span class="line">    protected function _buildArgs(&amp;$arrInput) &#123;</span><br><span class="line">        if($arrInput[&apos;object_type&apos;] == &apos;webimage_s1&apos;)&#123;</span><br><span class="line">            $this-&gt;_service_name = &apos;serverName01&apos;;</span><br><span class="line">            $object_type = &apos;webimage_v1&apos;;</span><br><span class="line">        &#125;else if($arrInput[&apos;object_type&apos;] == &apos;webimage_s2&apos;)&#123;</span><br><span class="line">            $this-&gt;_service_name = &apos;serverName01&apos;;</span><br><span class="line">            $object_type = &apos;webimage_v2&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        $args = Util::dealArgs($arrInput);</span><br><span class="line">        $this-&gt;_args = $this-&gt;_args . $args;</span><br><span class="line">        if(isset($arrInput[&apos;language_type&apos;]))&#123;</span><br><span class="line">            $this-&gt;_args = $this-&gt;_args . &quot;&amp;languagetype=CHN_ENG&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $image = $arrInput[&apos;image&apos;];</span><br><span class="line">        //组合处理参数，供请求函数调用</span><br><span class="line">        $this-&gt;_args = $this-&gt;_fixed_args . $this-&gt;_args . &quot;&amp;object_type=&quot; .$object_type. &quot;&amp;image=&quot; .$image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="购物车接口文件：CartInterface-php"><a href="#购物车接口文件：CartInterface-php" class="headerlink" title="购物车接口文件：CartInterface.php"></a>购物车接口文件：CartInterface.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * @file CartInterface.php</span><br><span class="line"> * @author ***</span><br><span class="line"> * @date 2018/3/9</span><br><span class="line"> * @brief </span><br><span class="line"> *  </span><br><span class="line"> **/</span><br><span class="line">class CartInterface extends InterfaceBase &#123;</span><br><span class="line">    /*</span><br><span class="line">     *@param null</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    public function __construct() &#123;</span><br><span class="line">        $fixed_args = &quot;&quot;;</span><br><span class="line">        parent::__construct(&quot;serverName&quot;,$fixed_args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     *@param input params outside</span><br><span class="line">     *@return protected memerber:args</span><br><span class="line">     */</span><br><span class="line">    protected function _buildArgs(&amp;$arrInput) &#123;</span><br><span class="line">        $image = $arrInput[&apos;image&apos;];</span><br><span class="line">        $this-&gt;_args = &quot;object_type=vat_invoice&amp;image=$image&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 接口自定义返回数据</span><br><span class="line">     *@param arrInput, array</span><br><span class="line">     *@param ocrResult, array</span><br><span class="line">     *@return openapiResult, array</span><br><span class="line">     */</span><br><span class="line">    protected function buildResponse(&amp;$arrInput, &amp;$ocrResult) &#123;</span><br><span class="line">        $words_result = $ocrResult[&apos;ret&apos;];</span><br><span class="line">        $words_result_num = count($words_result);</span><br><span class="line">        if($words_result_num == 0)&#123;</span><br><span class="line">            $words_result = array();</span><br><span class="line">        &#125;</span><br><span class="line">        return array(</span><br><span class="line">            &apos;words_result_num&apos; =&gt; $words_result_num,</span><br><span class="line">            &apos;words_result&apos; =&gt; $words_result</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="版本1对应的商品接口文件：Good-php"><a href="#版本1对应的商品接口文件：Good-php" class="headerlink" title="版本1对应的商品接口文件：Good.php"></a>版本1对应的商品接口文件：Good.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @file Good.php</span><br><span class="line"> * @author ***</span><br><span class="line"> * @date 2017/11/16</span><br><span class="line"> * @brief </span><br><span class="line"> *  </span><br><span class="line"> **/</span><br><span class="line">class Good extends GoodInterface &#123;</span><br><span class="line">    /*</span><br><span class="line">     *@param null</span><br><span class="line">     *@return null</span><br><span class="line">     */</span><br><span class="line">    public function __construct() &#123; //根据需求可自定义修改</span><br><span class="line">        parent::__construct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户处理对应接口传入数据</span><br><span class="line">     *@param input params outside</span><br><span class="line">     *@return protected memerber:args</span><br><span class="line">     */    </span><br><span class="line">    protected function _buildArgs(&amp;$arrInput) &#123;</span><br><span class="line">        $this-&gt;_service_name = &apos;serverName03&apos;;</span><br><span class="line">        $object_type = &apos;webimage_v3&apos;;</span><br><span class="line">        $args = Util::dealArgs($arrInput);</span><br><span class="line">        $this-&gt;_args = $this-&gt;_args . $args;</span><br><span class="line">        if(isset($arrInput[&apos;language_type&apos;]))&#123;</span><br><span class="line">            $this-&gt;_args = $this-&gt;_args . &quot;&amp;languagetype=CHN_ENG&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        $image = $arrInput[&apos;image&apos;];</span><br><span class="line">        //组合处理参数，供请求函数调用</span><br><span class="line">        $this-&gt;_args = $this-&gt;_fixed_args . $this-&gt;_args . &quot;&amp;object_type=&quot; .$object_type. &quot;&amp;image=&quot; .$image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="输出错误整合文件：Output-php"><a href="#输出错误整合文件：Output-php" class="headerlink" title="输出错误整合文件：Output.php"></a>输出错误整合文件：Output.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * @author ***</span><br><span class="line"> * @description 输出http请求结果</span><br><span class="line"> */</span><br><span class="line">class Output &#123;</span><br><span class="line">    const ERROR_NO_INVALID_PARAM        = 1;    // 非法参数</span><br><span class="line">    const ERROR_NO_POST_RESPONSE_EMPTY  = 2;    // 后端返回为空</span><br><span class="line">    const ERROR_NO_POST_RESPONSE_ERROR  = 3;    // 后端返回错误</span><br><span class="line">    const ERROR_NO_MOLA_RESPONSE_ERROR  = 4;    // mola返回内容错误</span><br><span class="line">    const ERROR_NO_CACHE_RESPONSE_ERROR = 5;    // cache返回内容错误</span><br><span class="line"></span><br><span class="line">    private static $objTpl = null;                  // 模板对象实例</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param int Errornum to be translated</span><br><span class="line">     * @return string The translated string</span><br><span class="line">     * 根据错误码返回错误文字信息 </span><br><span class="line">     */</span><br><span class="line">    public static function findErrorMsg($intErrNo)</span><br><span class="line">    &#123;</span><br><span class="line">        switch($intErrNo) &#123;</span><br><span class="line">            case self::ERROR_NO_INVALID_PARAM:</span><br><span class="line">                return &apos;参数不合法&apos;;</span><br><span class="line">            case self::ERROR_NO_POST_RESPONSE_EMPTY:</span><br><span class="line">                return &apos;抱歉，后端数据返回为空&apos;;</span><br><span class="line">            case self::ERROR_NO_POST_RESPONSE_ERROR:</span><br><span class="line">                return &apos;抱歉，后端数据返回错误&apos;;</span><br><span class="line">            case self::ERROR_NO_MOLA_RESPONSE_ERROR:</span><br><span class="line">                return &apos;抱歉，MOLA数据返回错误&apos;;</span><br><span class="line">            case self::ERROR_NO_CACHE_RESPONSE_ERROR:</span><br><span class="line">                return &apos;抱歉，CACHE数据返回错误&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &apos;未知错误&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * 根据strCallbackName是否为空，返回json或者jsonp的错误结果</span><br><span class="line">     * @param string </span><br><span class="line">     * @param integer</span><br><span class="line">     * @param string</span><br><span class="line">     * @param array</span><br><span class="line">     * @param array</span><br><span class="line">     * @return </span><br><span class="line">     */</span><br><span class="line">    public static function showErrorJS(</span><br><span class="line">        $strCallbackName,</span><br><span class="line">        $intErrNo,</span><br><span class="line">        $strErrmsg = &apos;&apos;,</span><br><span class="line">        $arrData = array(),</span><br><span class="line">        $arrExtra = array()</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * 根据strCallbackName是否为空，返回json或者jsonp的成功结果</span><br><span class="line">     * @param string </span><br><span class="line">     * @param array</span><br><span class="line">     * @param array</span><br><span class="line">     * @return </span><br><span class="line">     **/</span><br><span class="line">    public static function showSuccessJS(</span><br><span class="line">        $strCallbackName,</span><br><span class="line">        $arrData,</span><br><span class="line">        $arrExtra = array()</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 返回显示错误信息的json </span><br><span class="line">     * @param integer</span><br><span class="line">     * @param string</span><br><span class="line">     * @param array</span><br><span class="line">     * @param array</span><br><span class="line">     * @return </span><br><span class="line">     */</span><br><span class="line">    public static function showErrorJSON($intErrNo, $strErrmsg = &apos;&apos;, $arrData = array(), $arrExtra = array())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回包含成功数据信息的json </span><br><span class="line">     * @param array</span><br><span class="line">     * @param array</span><br><span class="line">     * @return </span><br><span class="line">     */</span><br><span class="line">    public static function showSuccessJSON($arrData, $arrExtra = array())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回显示错误信息的jsonp</span><br><span class="line">     * @param string</span><br><span class="line">     * @param integer</span><br><span class="line">     * @param string</span><br><span class="line">     * @param array</span><br><span class="line">     * @param array</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static function showErrorJSONP(</span><br><span class="line">        $strCallbackName,</span><br><span class="line">        $intErrNo,</span><br><span class="line">        $strErrmsg = &apos;&apos;,</span><br><span class="line">        $arrData = array(),</span><br><span class="line">        $arrExtra = array()</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回包含成功数据信息的jsonp</span><br><span class="line">     * @param string</span><br><span class="line">     * @param array</span><br><span class="line">     * @param array</span><br><span class="line">     * @return </span><br><span class="line">     */</span><br><span class="line">    public static function showSuccessJSONP(</span><br><span class="line">        $strCallbackName,</span><br><span class="line">        $arrData,</span><br><span class="line">        $arrExtra = array()</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 显示模版</span><br><span class="line">     * @param string</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static function showSuccessPage($strTemplatePath)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 显示出错模版</span><br><span class="line">     * @param integer</span><br><span class="line">     * @param string</span><br><span class="line">     * @return </span><br><span class="line">     */</span><br><span class="line">    public static function showErrorPage($intErrNo, $strTemplatePath)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取模版对象</span><br><span class="line">     * @param</span><br><span class="line">     * @return object</span><br><span class="line">     */</span><br><span class="line">    public static function getTplInstance()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果url上带有debug=true参数，则输出所有模版变量；</span><br><span class="line">     * 如果还带有debugParam参数，则输出特定某一个变量</span><br><span class="line">     * @param</span><br><span class="line">     * @return bool</span><br><span class="line">     */</span><br><span class="line">    public static function makeDebug()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为openapi定制的输出格式</span><br><span class="line">     * @param array 未经处理的输出格式</span><br><span class="line">     * @param integer int64的日志号</span><br><span class="line">     * @return null</span><br><span class="line">     */</span><br><span class="line">    public static function printOpenapi($arrInput, $intLogid)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="公共处理函数：Util-php"><a href="#公共处理函数：Util-php" class="headerlink" title="公共处理函数：Util.php"></a>公共处理函数：Util.php</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * @file Util.php</span><br><span class="line"> * @author ***</span><br><span class="line"> * @date 2017/06/07 10:57:13</span><br><span class="line"> * @brief </span><br><span class="line"> *  </span><br><span class="line"> **/</span><br><span class="line">class Util &#123;</span><br><span class="line"></span><br><span class="line">    private static $OCR_PASSTHROUGH_PARAMS = array(</span><br><span class="line">        &apos;version&apos; =&gt; &apos;version&apos;,</span><br><span class="line">        &apos;auto_enhance&apos; =&gt; &apos;auto_enhance&apos;,</span><br><span class="line">        &apos;fromproduct&apos; =&gt; &apos;fromproduct&apos;,</span><br><span class="line">    ); </span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     *@param $arrayReturn </span><br><span class="line">     *@return ret</span><br><span class="line">     */</span><br><span class="line">    static public function dealErrResponse($arrayReturn)</span><br><span class="line">    &#123;</span><br><span class="line">        if($arrayReturn[&apos;err_no&apos;] == 0) return;</span><br><span class="line">        if ( $arrayReturn[&apos;err_no&apos;] == 5 ) &#123;</span><br><span class="line">            Bd_Log::addNotice(&apos;ocr_backend_error&apos;, &quot;[&quot; . $arrayReturn[&apos;err_no&apos;] . &quot;][&quot; . $arrayReturn[&apos;err_msg&apos;] . &quot;]&quot;);</span><br><span class="line">            $innerError = json_decode($arrayReturn[&apos;err_msg&apos;], $assoc=true);</span><br><span class="line">            if ( is_array($innerError) ) &#123;</span><br><span class="line">                switch (intval($innerError[&apos;errno&apos;])) &#123;</span><br><span class="line">                    case -1:</span><br><span class="line">                        throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_OCR_RECOGNIZE_UNKONWN_ERROR);</span><br><span class="line">                        break;</span><br><span class="line">                    case -2:</span><br><span class="line">                        throw new Exception(&apos;image too large&apos;, Service_Data_Output::ERRNUM_INVALID_IMGSIZE);</span><br><span class="line">                        break;</span><br><span class="line">                    case -3:</span><br><span class="line">                        throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_INVALID_IMAGE_FORMAT);</span><br><span class="line">                        break;</span><br><span class="line">                    case -4:</span><br><span class="line">                        throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_INVALID_IMAGE_FORMAT);</span><br><span class="line">                        break;</span><br><span class="line">                    case -5:</span><br><span class="line">                        throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_INTERNAL_ERROR);</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_UNKNOWN);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_UNKNOWN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ($arrayReturn[&apos;err_no&apos;] != 0) &#123;</span><br><span class="line">            Bd_Log::addNotice(&apos;ocr_backend_error&apos;, &quot;[&quot; . $arrayReturn[&apos;err_no&apos;] . &quot;][&quot; . $arrayReturn[&apos;err_msg&apos;] . &quot;]&quot;);</span><br><span class="line">            Bd_Log::warning(&quot;get from service error.[&quot; . $arrayReturn[&apos;err_no&apos;] . &quot;][&quot; . $arrayReturn[&apos;err_msg&apos;] . &quot;]&quot;);</span><br><span class="line">            throw new Exception(&apos;&apos;, Service_Data_Output::ERRNUM_UNKNOWN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param $arrInput</span><br><span class="line">     * @return string</span><br><span class="line">     */</span><br><span class="line">    static public function dealArgs($arrInput)</span><br><span class="line">    &#123;</span><br><span class="line">        $args = &apos;&apos;;</span><br><span class="line">        ;</span><br><span class="line">        return $args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red">注：以上代码信息只做说明架构思想，所含信息内容可忽略。</font></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面列出接口代码架构格式，不一定完全一致，大概满足需求即可。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;— InterfaceBase.php 		//接口基文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— InterfaceFactory.php 	    //接口工厂文件，即入口文件（按需求使用）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— GoodInterface.php 		//商品接口基文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— CartInterface.php 		//购物车接口基文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— Output.php 				//定义错误码文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— ......					//其它接口文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— api_1/			// 1版本的接口文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— — Good.php 		  //商品接口文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— — Cart.php 		  //购物车接口文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— — ...... 			  //其它接口文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— api_2/			//2版本的接口文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— — Good.php 		  //商品接口文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;— — ......			  //其它接口文件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下面附属重要文件的代码格式，一般不需要改变。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
      <category term="接口" scheme="http://yoursite.com/categories/PHP/%E6%8E%A5%E5%8F%A3/"/>
    
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Flask - SQLAlchemy 多条件模糊查询</title>
    <link href="http://yoursite.com/2018/04/23/Flask%20-%20SQLAlchemy%20%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/"/>
    <id>http://yoursite.com/2018/04/23/Flask - SQLAlchemy 多条件模糊查询/</id>
    <published>2018-04-23T10:53:25.000Z</published>
    <updated>2018-07-21T09:20:38.858Z</updated>
    
    <content type="html"><![CDATA[<p>在做项目的时候，总会遇到搜索的需求，平常写SQL语句很简单。但是，在Flask 使用SQLAlchemy管理数据库的时候，应该如何使用，做了一下笔记，如下。</p><h4 id="一、使用SQLALchemy"><a href="#一、使用SQLALchemy" class="headerlink" title="一、使用SQLALchemy"></a>一、使用SQLALchemy</h4><p>一般的搜索都需要模糊查询，如果存在多条查询的需求，可如下操作：<br><code>users = User.query.filter(User.name.like(&quot;%&quot;+搜索的内容+&quot;%&quot;), User.age.like(&quot;%&quot;+搜索的内容+&quot;%&quot;)).all()</code></p><p>此种方式有一个弊端，就是不能 “or” 查询，只能 “and” 查询。<br>进行 “or” 查询，我的一个做法就是只能分开查询，然后合并数据即可。<br><a id="more"></a></p><h4 id="二、使用原生SQL操作"><a href="#二、使用原生SQL操作" class="headerlink" title="二、使用原生SQL操作"></a>二、使用原生SQL操作</h4><p>使用 session会话执行 SQL语句。（注：还有一种支持线程安全的方式，可使用 <code>scoped_session()</code>实现）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from app import db</span><br><span class="line"></span><br><span class="line">sql = &quot;SELECT * FROM `moviecol` \</span><br><span class="line">        LEFT JOIN `movie` ON moviecol.movie_id=movie.id \</span><br><span class="line">        LEFT JOIN `user` ON moviecol.user_id=user.id \</span><br><span class="line">        WHERE movie.title like &apos;%&quot;+keywords+&quot;%&apos; or user.name like &apos;%&quot;+keywords+&quot;%&apos; \</span><br><span class="line">        ORDER BY moviecol.addtime DESC \</span><br><span class="line">        LIMIT &quot;+str(page)+&quot;,&quot;+str(page_config[&apos;moviecol_per_page&apos;])</span><br><span class="line">res = db.session.execute(sql).fetchall()</span><br></pre></td></tr></table></figure></p><p>其中 Session类的相关方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public_methods = (</span><br><span class="line">    &apos;__contains__&apos;, &apos;__iter__&apos;, &apos;add&apos;, &apos;add_all&apos;, &apos;begin&apos;, &apos;begin_nested&apos;,</span><br><span class="line">    &apos;close&apos;, &apos;commit&apos;, &apos;connection&apos;, &apos;delete&apos;, &apos;execute&apos;, &apos;expire&apos;,</span><br><span class="line">    &apos;expire_all&apos;, &apos;expunge&apos;, &apos;expunge_all&apos;, &apos;flush&apos;, &apos;get_bind&apos;,</span><br><span class="line">    &apos;is_modified&apos;, &apos;bulk_save_objects&apos;, &apos;bulk_insert_mappings&apos;,</span><br><span class="line">    &apos;bulk_update_mappings&apos;,</span><br><span class="line">    &apos;merge&apos;, &apos;query&apos;, &apos;refresh&apos;, &apos;rollback&apos;,</span><br><span class="line">    &apos;scalar&apos;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做项目的时候，总会遇到搜索的需求，平常写SQL语句很简单。但是，在Flask 使用SQLAlchemy管理数据库的时候，应该如何使用，做了一下笔记，如下。&lt;/p&gt;
&lt;h4 id=&quot;一、使用SQLALchemy&quot;&gt;&lt;a href=&quot;#一、使用SQLALchemy&quot; class=&quot;headerlink&quot; title=&quot;一、使用SQLALchemy&quot;&gt;&lt;/a&gt;一、使用SQLALchemy&lt;/h4&gt;&lt;p&gt;一般的搜索都需要模糊查询，如果存在多条查询的需求，可如下操作：&lt;br&gt;&lt;code&gt;users = User.query.filter(User.name.like(&amp;quot;%&amp;quot;+搜索的内容+&amp;quot;%&amp;quot;), User.age.like(&amp;quot;%&amp;quot;+搜索的内容+&amp;quot;%&amp;quot;)).all()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此种方式有一个弊端，就是不能 “or” 查询，只能 “and” 查询。&lt;br&gt;进行 “or” 查询，我的一个做法就是只能分开查询，然后合并数据即可。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Python 标准模块之 uuiid</title>
    <link href="http://yoursite.com/2018/04/23/Python%20%E6%A0%87%E5%87%86%E6%A8%A1%E5%9D%97%E4%B9%8B%20uuiid/"/>
    <id>http://yoursite.com/2018/04/23/Python 标准模块之 uuiid/</id>
    <published>2018-04-23T10:52:51.000Z</published>
    <updated>2018-07-21T09:20:39.140Z</updated>
    
    <content type="html"><![CDATA[<p>uuid是128位的全局唯一标识符（univeral unique identifier），通常用32位的一个字符串的形式来表现。有时也称guid(global unique identifier)。python中自带了uuid模块来进行uuid的生成和管理工作。</p><p>python中的uuid模块基于信息如MAC地址、时间戳、命名空间、随机数、伪随机数来uuid。具体方法有如下几个：</p><blockquote><p><strong>uuid.getnode()：</strong>获取硬件地址为48位正整数。这是第一次运行，它可能会启动一个单独的程序，可能会很慢。如果所有尝试获取硬件地址都失败，我们选择一个随机的48位数字，其第8位设置为1，如RFC 4122中推荐的那样。“硬件地址”表示网络接口的MAC地址，以及具有多个网络接口可以返回其中任何一个的MAC地址。<br><strong>uuid.uuid1([ node [，clock_seq ] ])：</strong>从主机ID，序列号和当前时间生成一个UUID。如果 没有给出节点，getnode()则用于获取硬件地址。如果 给出clock_seq，它将用作序列号; 否则选择一个随机的14位序列号。（可以保证全球范围内的唯一性。但是可能会危害隐私，因为它会创建一个包含计算机网络地址的UUID。）<br><strong>uuid.uuid3(名称空间，名称)：</strong>根据名称空间标识（这是一个UUID）和一个名称（这是一个字符串）的MD5散列生成一个UUID。<br><strong>uuid.uuid4()：</strong>生成一个随机的UUID。（注：有一定概率重复的）<br><strong>uuid.uuid5 (名称空间，名称)：</strong>根据名称空间标识（这是一个UUID）和名称（它是一个字符串）的SHA-1散列生成一个UUID。（注：和uuid3基本相同，只不过采用的散列算法是sha1）</p></blockquote><a id="more"></a><p>该uuid模块定义了以下用于uuid3()或的名称空间标识符 uuid5()。</p><blockquote><p><strong>uuid.NAMESPACE_DNS</strong><br>当指定此名称空间时，名称字符串是完全限定的域名。<br><strong>uuid.NAMESPACE_URL</strong><br>当这个名字空间被指定时，名字字符串就是一个URL。<br><strong>uuid.NAMESPACE_OID</strong><br>当这个名字空间被指定时，名字字符串就是一个ISO OID。<br><strong>uuid.NAMESPACE_X500</strong><br>当指定此名称空间时，名称字符串是DER中的X.500 DN或文本输出格式。</p></blockquote><p>UUID 实例具有这些只读属性：</p><blockquote><p><strong>UUID.bytes</strong><br>UUID作为一个16字节的字符串（包含以big-endian字节顺序的六个整数字段）。<br><strong>UUID.bytes_le</strong><br>UUID作为16字节的字符串（以 little-endian字节顺序包含time_low，time_mid和time_hi_version）。<br><strong>UUID.fields</strong><br>UUID的六个整数字段的元组，它们也可用作六个单独的属性和两个派生属性：</p></blockquote><table><thead><tr><th>领域</th><th>含义</th></tr></thead><tbody><tr><td>time_low</td><td>UUID的前32位</td></tr><tr><td>time_mid</td><td>UUID的接下来的16位</td></tr><tr><td>time_hi_version</td><td>UUID的接下来的16位</td></tr><tr><td>clock_seq_hi_variant</td><td>UUID的接下来的8位</td></tr><tr><td>clock_seq_low</td><td>UUID的接下来的8位</td></tr><tr><td>node</td><td>UUID的最后48位</td></tr><tr><td>time</td><td>60位时间戳</td></tr><tr><td>clock_seq</td><td>14位序列号</td></tr></tbody></table><blockquote><p><strong>UUID.hex</strong><br>UUID作为32个字符的十六进制字符串。<br><strong>UUID.int</strong><br>UUID是一个128位整数。<br><strong>UUID.urn</strong><br>UUID作为RFC4122中规定的URN。<br><strong>UUID.variant</strong><br>UUID变体，它确定UUID的内部布局。这将是一个常量RESERVED_NCS，RFC_4122， RESERVED_MICROSOFT，或RESERVED_FUTURE。<br><strong>UUID.version</strong><br>UUID版本号（1到5，仅在变体时才有意义 RFC_4122）。</p></blockquote><p>以下是uuid模块典型用法的一些示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import uuid</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # make a UUID based on the host ID and current time</span><br><span class="line">&gt;&gt;&gt; uuid.uuid1()</span><br><span class="line">UUID(&apos;a8098c1a-f86e-11da-bd1a-00112444be1e&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # make a UUID using an MD5 hash of a namespace UUID and a name</span><br><span class="line">&gt;&gt;&gt; uuid.uuid3(uuid.NAMESPACE_DNS, &apos;python.org&apos;)</span><br><span class="line">UUID(&apos;6fa459ea-ee8a-3ca4-894e-db77e160355e&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # make a random UUID</span><br><span class="line">&gt;&gt;&gt; uuid.uuid4()</span><br><span class="line">UUID(&apos;16fd2706-8baf-433b-82eb-8c7fada847da&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # make a UUID using a SHA-1 hash of a namespace UUID and a name</span><br><span class="line">&gt;&gt;&gt; uuid.uuid5(uuid.NAMESPACE_DNS, &apos;python.org&apos;)</span><br><span class="line">UUID(&apos;886313e1-3b8a-5372-9b90-0c9aee199e5d&apos;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;uuid是128位的全局唯一标识符（univeral unique identifier），通常用32位的一个字符串的形式来表现。有时也称guid(global unique identifier)。python中自带了uuid模块来进行uuid的生成和管理工作。&lt;/p&gt;
&lt;p&gt;python中的uuid模块基于信息如MAC地址、时间戳、命名空间、随机数、伪随机数来uuid。具体方法有如下几个：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;uuid.getnode()：&lt;/strong&gt;获取硬件地址为48位正整数。这是第一次运行，它可能会启动一个单独的程序，可能会很慢。如果所有尝试获取硬件地址都失败，我们选择一个随机的48位数字，其第8位设置为1，如RFC 4122中推荐的那样。“硬件地址”表示网络接口的MAC地址，以及具有多个网络接口可以返回其中任何一个的MAC地址。&lt;br&gt;&lt;strong&gt;uuid.uuid1([ node [，clock_seq ] ])：&lt;/strong&gt;从主机ID，序列号和当前时间生成一个UUID。如果 没有给出节点，getnode()则用于获取硬件地址。如果 给出clock_seq，它将用作序列号; 否则选择一个随机的14位序列号。（可以保证全球范围内的唯一性。但是可能会危害隐私，因为它会创建一个包含计算机网络地址的UUID。）&lt;br&gt;&lt;strong&gt;uuid.uuid3(名称空间，名称)：&lt;/strong&gt;根据名称空间标识（这是一个UUID）和一个名称（这是一个字符串）的MD5散列生成一个UUID。&lt;br&gt;&lt;strong&gt;uuid.uuid4()：&lt;/strong&gt;生成一个随机的UUID。（注：有一定概率重复的）&lt;br&gt;&lt;strong&gt;uuid.uuid5 (名称空间，名称)：&lt;/strong&gt;根据名称空间标识（这是一个UUID）和名称（它是一个字符串）的SHA-1散列生成一个UUID。（注：和uuid3基本相同，只不过采用的散列算法是sha1）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python模块" scheme="http://yoursite.com/tags/Python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Flask 常见错误篇</title>
    <link href="http://yoursite.com/2018/04/16/Flask%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%AF%87/"/>
    <id>http://yoursite.com/2018/04/16/Flask 常见错误篇/</id>
    <published>2018-04-16T05:31:49.000Z</published>
    <updated>2018-07-21T09:20:38.905Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、在 admin/forms.py 表单文件中使用如下语句报错：</strong><br><code>auth_list = Auth.query.all()</code></p><p>报错信息，如下：</p><blockquote><p>RuntimeError: No application found. Either work inside a view function or push an application contex.</p></blockquote><p>报错信息意思是：没有找到应用程序。可以在视图函数内工作，也可以推动应用程序上下文。<br><a id="more"></a><br>因此，我们就要建立程序上下文，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.from_object(config[config_name])</span><br><span class="line">config[config_name].init_app(app)</span><br><span class="line"></span><br><span class="line">with app.app_context():</span><br><span class="line">db.init_app(app)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">return app</span><br></pre></td></tr></table></figure></p><p>就是在初始化的时候，添加 <code>app_context()</code> 上下文。</p><p><strong>2、元组赋值报错，如下：</strong></p><blockquote><p>TypeError: ‘NoneType’ object is not iterable</p></blockquote><p>这个错误提示一般发生在将None赋给多个值时。<br>在判断语句中，当if条件不满足，并且没有else语句时，函数默认返回None。<br>在没有return语句时，python也默认会返回None。<br>调用时，将None赋给多个值时，会出现提示：TypeError: ‘NoneType’ object is not iterable.</p><p><strong>3、模板中使用表单（wtf），报错如下：</strong></p><blockquote><p>TypeError: html_params() got multiple values for keyword argument ‘name’</p></blockquote><p>这个是由于表单中有一个变量为 “render_kw”，其值是键值对字典，且其键不能为 “name”。否则就报错！</p><p><strong>4、Flask 的 validate_on_submit() 老是false ??</strong><br>在 flask中提交表单时使用了validate_on_submit()来验证，但是每次提交时都是false，不知道什么原因啊？<br>但是只要把生成form表单的地方换成 quick_form自动生成，就正常了。<br>最后，通过上网搜索知道问题的原因了，就是CSRF的原因，直接在form里加上csrf_token就行了。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; form.csrf_token &#125;&#125;</span><br><span class="line">&#123;&#123; form.submit() &#125;&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1、在 admin/forms.py 表单文件中使用如下语句报错：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;auth_list = Auth.query.all()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;报错信息，如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RuntimeError: No application found. Either work inside a view function or push an application contex.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;报错信息意思是：没有找到应用程序。可以在视图函数内工作，也可以推动应用程序上下文。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask 使用session</title>
    <link href="http://yoursite.com/2018/04/16/Flask%20%E4%BD%BF%E7%94%A8session/"/>
    <id>http://yoursite.com/2018/04/16/Flask 使用session/</id>
    <published>2018-04-16T05:30:53.000Z</published>
    <updated>2018-07-21T09:20:38.874Z</updated>
    
    <content type="html"><![CDATA[<p>1、首先安装session<br><code>pip install flask-session</code></p><p>2、引入框架中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from flask_session import Session</span><br><span class="line">sess = Session()</span><br><span class="line">sess.init_app(app)</span><br></pre></td></tr></table></figure></p><p>3、下面就可以在视图中使用引用使用了<br><code>from flask import session</code></p><a id="more"></a><p><strong>报错集锦：</strong></p><blockquote><p>Flask  session报下面错误：<br>RuntimeError: The session is unavailable because no secret key was set.  Set the secret_key on the application to something unique and secret.</p></blockquote><p>查找代码发现：<br>SERECT_KEY 已经设定。但是，仍然报此错误。原因是 SESSION_TYPE 未设置，如果不使用 内存缓存的话，可以使文件缓存。即：<br><code>SESSION_TYPE = &#39;filesystem&#39;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、首先安装session&lt;br&gt;&lt;code&gt;pip install flask-session&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、引入框架中&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;from flask_session import Session&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sess = Session()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sess.init_app(app)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3、下面就可以在视图中使用引用使用了&lt;br&gt;&lt;code&gt;from flask import session&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Python3 支持MySQL</title>
    <link href="http://yoursite.com/2018/04/16/Python3%20%E6%94%AF%E6%8C%81MySQL/"/>
    <id>http://yoursite.com/2018/04/16/Python3 支持MySQL/</id>
    <published>2018-04-16T05:30:05.000Z</published>
    <updated>2018-07-21T09:20:39.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font color="red">注：MySQLdb 只适用于Python2.x，在Python3的替代品是：pymysql</font></blockquote><p>1、安装： pip install pymysql</p><p>一些框架默认仍然用的是MySQLdb，但是python3已经不支持MySQLdb，取而代之的是pymysql，因此运行的时候会报<br><code>ModuleNotFoundError: No module named &#39;MySQLdb&#39;</code></p><p>2、使用方式：</p><ol><li>安装成功后，可使用MySQLdb的语法使用pymysql</li><li>使用Flask集成的SQLAlchemy管理MySQL</li></ol><a id="more"></a><p>在框架中引入下面语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure></p><p>然后，在配置 <code>SQLALCHEMY_DATABASE_URI</code> 参数时，直接使用 mysql的使用方式即可。</p><blockquote><p>使用方式：<code>mysql://username:password@hostname/database</code></p></blockquote><p>3、生成对应数据表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python manage.py db init</span><br><span class="line">python manage.py db migrate</span><br><span class="line">python manage.py db upgrade</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;font color=&quot;red&quot;&gt;注：MySQLdb 只适用于Python2.x，在Python3的替代品是：pymysql&lt;/font&gt;

&lt;/blockquote&gt;
&lt;p&gt;1、安装： pip install pymysql&lt;/p&gt;
&lt;p&gt;一些框架默认仍然用的是MySQLdb，但是python3已经不支持MySQLdb，取而代之的是pymysql，因此运行的时候会报&lt;br&gt;&lt;code&gt;ModuleNotFoundError: No module named &amp;#39;MySQLdb&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、使用方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装成功后，可使用MySQLdb的语法使用pymysql&lt;/li&gt;
&lt;li&gt;使用Flask集成的SQLAlchemy管理MySQL&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 和 Socket 的区别</title>
    <link href="http://yoursite.com/2018/04/10/HTTP%20%E5%92%8C%20Socket%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/04/10/HTTP 和 Socket 的区别/</id>
    <published>2018-04-10T10:29:35.000Z</published>
    <updated>2018-07-21T09:20:38.937Z</updated>
    
    <content type="html"><![CDATA[<p>要弄明白 http 和 socket 首先要熟悉网络七层：物 数 网 传 会 表 应，如下图<br><img src="/uploads/2018/04/network_protocol.jpg" alt=""><br><a id="more"></a></p><blockquote><p><strong>HTTP 协议：</strong>超文本传输协议，对应于应用层，用于如何封装数据.<br><strong>TCP/UDP 协议：</strong>传输控制协议，对应于传输层，主要解决数据在网络中的传输。<br><strong>IP 协议：</strong>对应于网络层，同样解决数据在网络中的传输。</p></blockquote><p>传输数据的时候只使用 TCP/IP 协议(传输层)，如果没有应用层来识别数据内容，传输后的协议都是无用的。<br>应用层协议很多 FTP,HTTP,TELNET等，也可以自己定义应用层协议。<br>web 使用 HTTP 作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议，将数据发送到网络上。</p><h4 id="一、HTTP-连接"><a href="#一、HTTP-连接" class="headerlink" title="一、HTTP 连接"></a>一、HTTP 连接</h4><p>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</p><p>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，即使用的是<font color="red">“请求-响应”方式</font>。在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。即是<font color="red">“无状态”</font>的协议。</p><ul><li>1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</li><li>2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</li></ul><p><strong>http 为短连接：</strong>由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”。通常要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p><h4 id="二、Socket-连接"><a href="#二、Socket-连接" class="headerlink" title="二、Socket 连接"></a>二、Socket 连接</h4><p>要想明白 Socket，必须要理解 TCP 连接。<br>TCP 三次握手：握手过程中并不传输数据，在握手后服务器与客户端才开始传输数据，理想状态下，TCP 连接一旦建立，在通讯双方中的任何一方主动断开连接之前 TCP 连接会一直保持下去。</p><p>Socket 是对 TCP/IP 协议的封装，<font color="red">Socket 只是个接口不是协议，</font>通过 Socket 我们才能使用 TCP/IP 协议，除了 TCP，也可以使用 UDP 协议来传递数据。</p><p>创建 Socket 连接的时候，可以指定传输层协议，可以是 TCP 或者 UDP，当用 TCP 连接，该Socket就是个TCP连接，反之。</p><p>Socket 连接,至少需要一对套接字，分为 clientSocket，serverSocket。连接分为3个步骤：服务器监听、客户端请求、连接确认。<br><strong>Socket 为长连接：</strong>通常情况下Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立,通讯双方开始互发数据内容，直到双方断开连接。在实际应用中，由于网络节点过多，在传输过程中，会被节点断开连接，因此要通过轮询高速网络，该节点处于活跃状态。</p><p>很多情况下，都是需要服务器端向客户端主动推送数据，保持客户端与服务端的实时同步。</p><ul><li>若双方是 Socket 连接，可以由服务器直接向客户端发送数据。</li><li>若双方是 HTTP 连接，则服务器需要等客户端发送请求后，才能将数据回传给客户端。因此，客户端定时向服务器端发送请求，不仅可以保持在线，同时也询问服务器是否有新数据，如果有就将数据传给客户端。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要弄明白 http 和 socket 首先要熟悉网络七层：物 数 网 传 会 表 应，如下图&lt;br&gt;&lt;img src=&quot;/uploads/2018/04/network_protocol.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 详解</title>
    <link href="http://yoursite.com/2018/04/10/HTTP%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/10/HTTP 详解/</id>
    <published>2018-04-10T08:23:25.000Z</published>
    <updated>2018-07-21T09:20:38.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础概念篇"><a href="#一、基础概念篇" class="headerlink" title="一、基础概念篇"></a>一、基础概念篇</h3><h4 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。</p><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p><p>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。<br><a id="more"></a></p><h4 id="2、在TCP-IP协议栈中的位置"><a href="#2、在TCP-IP协议栈中的位置" class="headerlink" title="2、在TCP/IP协议栈中的位置"></a>2、在TCP/IP协议栈中的位置</h4><p>HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：<br><img src="/uploads/2018/04/network_http_01.jpg" alt=""><br>默认HTTP的端口号为80，HTTPS的端口号为443。</p><h4 id="3、HTTP的请求响应模型"><a href="#3、HTTP的请求响应模型" class="headerlink" title="3、HTTP的请求响应模型"></a>3、HTTP的请求响应模型</h4><p>HTTP协议永远都是客户端发起请求，服务器回送响应。见下图：<br><img src="/uploads/2018/04/network_http_02.jpg" alt=""><br>这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。<br>HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。</p><h4 id="4、工作流程"><a href="#4、工作流程" class="headerlink" title="4、工作流程"></a>4、工作流程</h4><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><blockquote><p>1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。<br>2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。<br>3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。<br>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p></blockquote><p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p><h4 id="5、客户端一个请求流程（详细版）"><a href="#5、客户端一个请求流程（详细版）" class="headerlink" title="5、客户端一个请求流程（详细版）"></a>5、客户端一个请求流程（详细版）</h4><p>待补充。。。</p><h3 id="二、协议详解篇"><a href="#二、协议详解篇" class="headerlink" title="二、协议详解篇"></a>二、协议详解篇</h3><h4 id="1、HTTP-1-0-与-HTTP-1-1-比较"><a href="#1、HTTP-1-0-与-HTTP-1-1-比较" class="headerlink" title="1、HTTP/1.0 与 HTTP/1.1 比较"></a>1、HTTP/1.0 与 HTTP/1.1 比较</h4><table><thead><tr><th>异同点</th><th>HTTP/1.0</th><th>HTTP/1.1</th></tr></thead><tbody><tr><td>建立连接方面</td><td>连接不能复用</td><td>可复用，减少TCP三次握手的开销</td></tr><tr><td>请求方式</td><td>GET、POST、HEAD</td><td>GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE、CONNECT</td></tr><tr><td>Request消息头</td><td></td><td>新增Host域 </td></tr></tbody></table><h4 id="2、HTTP请求消息"><a href="#2、HTTP请求消息" class="headerlink" title="2、HTTP请求消息"></a>2、HTTP请求消息</h4><h5 id="（1）请求消息格式"><a href="#（1）请求消息格式" class="headerlink" title="（1）请求消息格式"></a>（1）请求消息格式</h5><p>HTTP请求消息实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /hello.htm HTTP/1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-cn</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">If-Modified-Since: Wed, 17 Oct 2007 02:15:55 GMT</span><br><span class="line">If-None-Match: W/&quot;158-1192587355000&quot;</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)</span><br><span class="line">Host: 192.168.2.162:8080</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure></p><p>请求消息格式如下所示：</p><blockquote><p>请求行<br>通用信息头|请求头|实体头<br>CRLF(回车换行)<br>实体内容</p></blockquote><p>其中“请求行”为：请求行 = 方法 [空格] 请求URI [空格] 版本号 [回车换行]</p><h5 id="（2）请求方法"><a href="#（2）请求方法" class="headerlink" title="（2）请求方法"></a>（2）请求方法</h5><p>HTTP的请求方法包括如下几种：<br>GET | POST | HEAD | PUT | DELETE | OPTIONS | TRACE | CONNECT</p><h4 id="3、HTTP响应消息"><a href="#3、HTTP响应消息" class="headerlink" title="3、HTTP响应消息"></a>3、HTTP响应消息</h4><h5 id="（1）响应消息格式"><a href="#（1）响应消息格式" class="headerlink" title="（1）响应消息格式"></a>（1）响应消息格式</h5><p>HTTP响应消息实例如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">ETag: W/&quot;158-1192590101000&quot;</span><br><span class="line">Last-Modified: Wed, 17 Oct 2007 03:01:41 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 158</span><br><span class="line">Date: Wed, 17 Oct 2007 03:01:59 GMT</span><br><span class="line">Server: Apache-Coyote/1.1</span><br></pre></td></tr></table></figure></p><p>HTTP响应消息的格式如下所示：</p><blockquote><p>状态行<br>通用信息头|响应头|实体头<br>CRLF<br>实体内容</p></blockquote><p>其中：状态行 = 版本号 [空格] 状态码 [空格] 原因 [回车换行]</p><h5 id="（2）响应状态码"><a href="#（2）响应状态码" class="headerlink" title="（2）响应状态码"></a>（2）响应状态码</h5><p><strong>1**：请求收到，继续处理</strong><br>100——客户必须继续发出请求<br>101——客户要求服务器根据请求转换HTTP协议版本</p><p><strong>2**：操作成功收到，分析、接受</strong></p><font color="red">200——交易成功</font><br>201——提示知道新文件的URL<br>202——接受和处理、但处理未完成<br>203——返回信息不确定或不完整<br>204——请求收到，但返回信息为空<br>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br>206——服务器已经完成了部分用户的GET请求<br><br><strong>3**：完成此请求必须进一步处理</strong><br>300——请求的资源可在多处得到<br><font color="red">301——删除请求数据</font><br>302——在其他地址发现了请求数据<br>303——建议客户访问其他URL或访问方式<br>304——客户端已经执行了GET，但文件未变化<br>305——请求的资源必须从服务器指定的地址得到<br>306——前一版本HTTP中使用的代码，现行版本中不再使用<br>307——申明请求的资源临时性删除<br><br><strong>4**：请求包含一个错误语法或不能完成</strong><br><font color="red">400——错误请求，如语法错误</font><br><font color="red">401——未授权</font><br>HTTP 401.1 - 未授权：登录失败<br>　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败<br>　　HTTP 401.3 - ACL 禁止访问资源<br>　　HTTP 401.4 - 未授权：授权被筛选器拒绝<br>　　HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败<br>402——保留有效ChargeTo头响应<br><font color="red">403——禁止访问</font><br>HTTP 403.1 禁止访问：禁止可执行访问<br>　　HTTP 403.2 - 禁止访问：禁止读访问<br>　　HTTP 403.3 - 禁止访问：禁止写访问<br>　　HTTP 403.4 - 禁止访问：要求 SSL<br>　　HTTP 403.5 - 禁止访问：要求 SSL 128<br>　　HTTP 403.6 - 禁止访问：IP 地址被拒绝<br>　　HTTP 403.7 - 禁止访问：要求客户证书<br>　　HTTP 403.8 - 禁止访问：禁止站点访问<br>　　HTTP 403.9 - 禁止访问：连接的用户过多<br>　　HTTP 403.10 - 禁止访问：配置无效<br>　　HTTP 403.11 - 禁止访问：密码更改<br>　　HTTP 403.12 - 禁止访问：映射器拒绝访问<br>　　HTTP 403.13 - 禁止访问：客户证书已被吊销<br>　　HTTP 403.15 - 禁止访问：客户访问许可过多<br>　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效<br>　　HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效<br><font color="red">404——没有发现文件、查询或URl</font><br>405——用户在Request-Line字段定义的方法不允许<br>406——根据用户发送的Accept拖，请求资源不可访问<br>407——类似401，用户必须首先在代理服务器上得到授权<br>408——客户端没有在用户指定的饿时间内完成请求<br>409——对当前资源状态，请求不能完成<br>410——服务器上不再有此资源且无进一步的参考地址<br>411——服务器拒绝用户定义的Content-Length属性请求<br>412——一个或多个请求头字段在当前请求中错误<br>413——请求的资源大于服务器允许的大小<br>414——请求的资源URL长于服务器允许的长度<br>415——请求资源不支持请求项目格式<br>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段<br>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。<br><br><strong>5**：服务器执行一个完全有效请求失败</strong><br><font color="red">HTTP 500 - 内部服务器错误</font><br>　　HTTP 500.100 - 内部服务器错误 - ASP 错误<br>　　HTTP 500-11 服务器关闭<br>　　HTTP 500-12 应用程序重新启动<br>　　HTTP 500-13 - 服务器太忙<br>　　HTTP 500-14 - 应用程序无效<br>　　HTTP 500-15 - 不允许请求 global.asa<br>Error 501 - 未实现<br><font color="red">HTTP 502 - 网关错误</font><h4 id="4、请求头："><a href="#4、请求头：" class="headerlink" title="4、请求头："></a>4、请求头：</h4><p>HTTP最常见的请求头如下：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Accept：</td><td>浏览器可接受的MIME类型；</td></tr><tr><td>Accept-Charset：</td><td>浏览器可接受的字符集；</td></tr><tr><td>Accept-Encoding：</td><td>浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间；</td></tr><tr><td>Accept-Language：</td><td>浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到；</td></tr><tr><td>Authorization：</td><td>授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中；</td></tr><tr><td>Connection：</td><td>表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小；</td></tr><tr><td>Content-Length：</td><td>表示请求消息正文的长度；</td></tr><tr><td>Cookie：</td><td>这是最重要的请求头信息之一；</td></tr><tr><td>From：</td><td>请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它；</td></tr><tr><td>Host：</td><td>初始URL中的主机和端口；</td></tr><tr><td>If-Modified-Since：</td><td>只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答；</td></tr><tr><td>Pragma：</td><td>指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；</td></tr><tr><td>Referer：</td><td>包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</td></tr></tbody></table><p>User-Agent：            | 浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用；<br>UA-Pixels，UA-Color，UA-OS，UA-CPU： | 由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</p><h4 id="5、响应头："><a href="#5、响应头：" class="headerlink" title="5、响应头："></a>5、响应头：</h4><p>HTTP最常见的响应头如下所示：</p><style type="text/css">    table th:first-of-type{        width: 24%;    }</style><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Allow：</td><td>服务器支持哪些请求方法（如GET、POST等）；</td></tr><tr><td>Content-Encoding：</td><td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即<code>request.getHeader(&quot;Accept-Encoding&quot;)</code>）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面；</td></tr><tr><td>Content-Length：</td><td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过<code>byteArrayStream.writeTo(response.getOutputStream()</code>发送内容；</td></tr><tr><td>Content-Type：</td><td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和MIME类型的对应关系；</td></tr><tr><td>Date：</td><td>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦；</td></tr><tr><td>Expires：</td><td>指明应该在什么时候认为文档已经过期，从而不再缓存它。</td></tr><tr><td>Last-Modified：</td><td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置；</td></tr><tr><td>Location：</td><td>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302；</td></tr><tr><td>Refresh：</td><td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过<code>setHeader(&quot;Refresh&quot;, &quot;5; URL=http://host/path&quot;)</code>让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的<code>&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;5;URL=http://host/path&quot;&gt;</code>实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是<meta http-equiv="Refresh" ...="">。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td></tr></tbody></table><h4 id="6、实体头"><a href="#6、实体头" class="headerlink" title="6、实体头"></a>6、实体头</h4><p>实体头用坐实体内容的元信息，描述了实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Allow：</td><td>GET,POST</td></tr><tr><td>Content-Encoding：</td><td>文档的编码（Encode）方法，例如：gzip，见“2.5 响应头”；</td></tr><tr><td>Content-Language：</td><td>内容的语言类型，例如：zh-cn；</td></tr><tr><td>Content-Length：</td><td>表示内容长度，eg：80，可参考“2.5响应头”；</td></tr><tr><td>Content-Location：</td><td>表示客户应当到哪里去提取文档，例如：<code>http://www.dfdf.org/</code>dfdf.html，可参考“2.5响应头”；</td></tr><tr><td>Content-MD5：</td><td>MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。Eg1：Content-MD5: <base64 128="" of="" md5="" digest="">。Eg2：dfdfdfdfdfdfdff==；</base64></td></tr><tr><td>Content-Range：</td><td>随部分实体一同发送；标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。Eg1：Content-Range: 1001-2000/5000，eg2：bytes 2543-4532/7898</td></tr><tr><td>Content-Type：</td><td>标明发送或者接收的实体的MIME类型。Eg：text/html; charset=GB2312       主类型/子类型；</td></tr><tr><td>Expires：</td><td>为0证明不缓存；</td></tr><tr><td>Last-Modified：</td><td>WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT.</td></tr></tbody></table><h4 id="7、扩展头"><a href="#7、扩展头" class="headerlink" title="7、扩展头"></a>7、扩展头</h4><p>在HTTP消息中，也可以使用一些再HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头，他们通常被当作是一种实体头处理。</p><p>现在流行的浏览器实际上都支持Cookie,Set-Cookie,Refresh和Content-Disposition等几个常用的扩展头字段。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Refresh：1;<code>url=http://www.dfdf.org</code></td><td>//过1秒跳转到指定位置；</td></tr><tr><td>Content-Disposition：</td><td>头字段,可参考“2.5响应头”；</td></tr><tr><td>Content-Type：</td><td>WEB 服务器告诉浏览器自己响应的对象的类型。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、基础概念篇&quot;&gt;&lt;a href=&quot;#一、基础概念篇&quot; class=&quot;headerlink&quot; title=&quot;一、基础概念篇&quot;&gt;&lt;/a&gt;一、基础概念篇&lt;/h3&gt;&lt;h4 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h4&gt;&lt;p&gt;HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。&lt;/p&gt;
&lt;p&gt;HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。&lt;/p&gt;
&lt;p&gt;HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>socket 详解</title>
    <link href="http://yoursite.com/2018/04/10/socket%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/10/socket 详解/</id>
    <published>2018-04-10T08:13:54.000Z</published>
    <updated>2018-07-21T09:20:39.171Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、网络中进程之间是如何通信？"><a href="#1、网络中进程之间是如何通信？" class="headerlink" title="1、网络中进程之间是如何通信？"></a>1、网络中进程之间是如何通信？</h4><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC）</li></ul><p>在本地我们通过进程 PID 来唯一标识一个进程，但是在网络中是行不通的。而 TCP/IP 协议簇帮我们解决了这个问题，<font color="red">网络层的“IP地址”</font>可以唯一标识网络中的主机，<font color="red">传输层的“协议+端口”</font>可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址、协议、端口）就可以标识网络中的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p><a id="more"></a><h4 id="2、什么是socket"><a href="#2、什么是socket" class="headerlink" title="2、什么是socket"></a>2、什么是socket</h4><p>那什么是socket呢？其实，Socket 就是编程接口（API），是对 TCP/IP 的封装，对外提供的接口。网络中进程间通信采用的就是 socket（套接字）。<br>看下图即可明白 socket：<br><img src="/uploads/2018/04/linux_socket_04.png" alt="" title="图1"><br><img src="/uploads/2018/04/linux_socket_03.png" alt="" title="图2"></p><blockquote><p>几种典型的应用编程接口：</p><ul><li>Berkeley UNIX 操作系统定义了一种 API，称为套接字接口（socket Interface），简称<font color="red">套接字（socket）</font>。</li><li>微软公司在其操作系统中采用了套接字接口 API，形成了一个稍有不同的 API，并称为 Windows Socket Interface，<font color="red">WINSOCK</font>。</li><li>AT&amp;T 为其 UNIX 系统 V 定义了一种 API，简写为 <font color="red">TLI</font>（Transport Layer Interface）(已经被淘汰了)。</li></ul></blockquote><h4 id="3、套接字（socket）概念"><a href="#3、套接字（socket）概念" class="headerlink" title="3、套接字（socket）概念"></a>3、套接字（socket）概念</h4><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p><p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，<strong>许多计算机操作系统为应用程序与TCP／IP协议交互提供了</strong><font color="red">套接字(Socket)接口</font>（由图2可看出来）。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><h4 id="4、socket原理"><a href="#4、socket原理" class="headerlink" title="4、socket原理"></a>4、socket原理</h4><p>要想明白 Socket，必须要理解TCP连接。</p><blockquote><p>建立TCP连接的“三次握手”：</p><ul><li><strong>第一次：</strong>客户端向服务器发送SYN包(syn=j)，同时自己处于SYN_SEND状态。</li><li><strong>第二次：</strong>服务器端收到SYN包后，必须确认客户的SYN(syn=j+1)，同时也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态。</li><li><strong>第三次：</strong>客户端收到服务器发来的SYN+ACK包，就向服务器发送SYN(syn=k+1)，发送完毕后，服务器和客户端都进入ESTABLISHED状态。完成三次握手。</li></ul></blockquote><p>握手过程中，并不传输数据。在握手后，服务器与客户端才开始传输数据，理想状态下，TCP连接一旦建立，在通讯双方中的任何一方主动断开连接之前，TCP连接会一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”。</p><h5 id="（1）socket-连接"><a href="#（1）socket-连接" class="headerlink" title="（1）socket 连接"></a>（1）socket 连接</h5><p>Socket连接，至少需要一对套接字，分为 clientSocket，serverSocket。连接分为3个步骤：</p><ul><li><strong>服务器监听：</strong>服务器并不定位具体客户端的套接字，而是时刻处于监听状态。</li><li><strong>客户端请求：</strong>客户端的套接字要描述它要连接的服务器的套接字。提供地址和端口号，然后向服务器套接字提出连接请求。</li><li><strong>连接确认：</strong>当服务器套接字收到客户端套接字发来的请求后，就响应客户端套接字的请求，并建立一个新的线程，把服务器端的套接字的描述发给客户端，一旦客户端确认了此描述，就正式建立连接。而服务器套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li></ul><p>创建Socket连接的时候，可以指定传输层协议。可以是TCP或者UDP，当用TCP连接，该Socket就是个TCP连接。</p><h5 id="（2）socket-函数"><a href="#（2）socket-函数" class="headerlink" title="（2）socket 函数"></a>（2）socket 函数</h5><p>Socket接口对外提供的函数如下：</p><style type="text/css">    table th:first-of-type{        width: 15%;    }</style><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>socket</td><td>创建套接字 </td></tr><tr><td>connect</td><td>“连接”远端服务器（仅用于客户端）</td></tr><tr><td>closesocket</td><td>释放/关闭套接字</td></tr><tr><td>bind</td><td>绑定套接字的本地IP地址和端口号（通常客户端不需要）</td></tr><tr><td>listen</td><td>配置服务端TCP套接字为监听模式，并设置队列大小（仅用于服务器端TCP套接字）</td></tr><tr><td>accept</td><td>接受/提取一个连接请求，创建新套接字，通过新套接（仅用于服务器端的TCP套接字）</td></tr><tr><td>recv</td><td>接收数据（用于TCP套接字或连接模式的客户端UDP套接字）</td></tr><tr><td>recvfrom</td><td>接收数据报（用于非连接模式的UDP套接字）</td></tr><tr><td>send</td><td>发送数据（用于TCP套接字或连接模式的客户端UDP套接字）</td></tr><tr><td>sendto</td><td>发送数据报（用于非连接模式的UDP套接字）</td></tr><tr><td>setsockopt</td><td>设置套接字选项参数</td></tr><tr><td>getsockopt</td><td>获取套接字选项参数</td></tr></tbody></table><h5 id="（3）socket-调用流程"><a href="#（3）socket-调用流程" class="headerlink" title="（3）socket 调用流程"></a>（3）socket 调用流程</h5><p><img src="/uploads/2018/04/linux_socket_05.png" alt=""></p><h5 id="（4）socket-管理"><a href="#（4）socket-管理" class="headerlink" title="（4）socket 管理"></a>（4）socket 管理</h5><p>通过 Socket描述符表来进行管理，每个进程中有一个描述符表。当应用进程创建套接字时，操作系统分配一个数据结构存储该套接字相关信息。如下图所示：<br><img src="/uploads/2018/04/linux_socket_02.png" alt=""></p><h5 id="（5）并发面向连接服务器基本流程"><a href="#（5）并发面向连接服务器基本流程" class="headerlink" title="（5）并发面向连接服务器基本流程"></a>（5）并发面向连接服务器基本流程</h5><p><img src="/uploads/2018/04/linux_socket_01.png" alt=""><br><strong>主线程1：</strong>创建（主）套接字，并绑定熟知端口号；<br><strong>主线程2：</strong>创建（主）套接字为被动监听模式，准备用于服务器；<br><strong>主线程3：</strong>反复调用accept() 函数接收下一个<font color="red">连接请求</font>（通过主套接字），并创建一个新的子线程处理该客户端响应；<br><strong>子线程1：</strong>接收一个客户端的<font color="red">服务请求</font>（通过新创建的套接字）；<br><strong>子线程2：</strong>遵循应用层协议与特定客户进行交互；<br><strong>子线程3：</strong>关闭/释放连接并推出（线程终止）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、网络中进程之间是如何通信？&quot;&gt;&lt;a href=&quot;#1、网络中进程之间是如何通信？&quot; class=&quot;headerlink&quot; title=&quot;1、网络中进程之间是如何通信？&quot;&gt;&lt;/a&gt;1、网络中进程之间是如何通信？&lt;/h4&gt;&lt;p&gt;本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息传递（管道、FIFO、消息队列）&lt;/li&gt;
&lt;li&gt;同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）&lt;/li&gt;
&lt;li&gt;共享内存（匿名的和具名的）&lt;/li&gt;
&lt;li&gt;远程过程调用（Solaris门和Sun RPC）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本地我们通过进程 PID 来唯一标识一个进程，但是在网络中是行不通的。而 TCP/IP 协议簇帮我们解决了这个问题，&lt;font color=&quot;red&quot;&gt;网络层的“IP地址”&lt;/font&gt;可以唯一标识网络中的主机，&lt;font color=&quot;red&quot;&gt;传输层的“协议+端口”&lt;/font&gt;可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址、协议、端口）就可以标识网络中的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置文件详解</title>
    <link href="http://yoursite.com/2018/04/09/Nginx%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/09/Nginx 配置文件详解/</id>
    <published>2018-04-09T10:09:58.000Z</published>
    <updated>2018-07-21T09:20:39.108Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、结构分析"><a href="#1、结构分析" class="headerlink" title="1、结构分析"></a>1、结构分析</h4><p>nginx配置文件中主要包括六块：main，events，http，server，location，upstream<br>结构如下图：</p><ul><li><strong>main块：</strong>主要控制nginx子进程的所属用户/用户组、派生子进程数、错误日志位置/级别、pid位置、子进程优先级、进程对应cpu、进程能够打开的文件描述符数目等</li><li><strong>events块：</strong>控制nginx处理连接的方式</li><li><strong>http块：</strong>是nginx处理http请求的主要配置模块，大多数配置都在这里面进行</li><li><strong>server块：</strong>是nginx中主机的配置块，可以配置多个虚拟主机</li><li><strong>location块：</strong>是server中对应的目录级别的控制块，可以有多个</li><li><strong>upstream块：</strong>是nginx做反向代理和负载均衡的配置块，可以有多个</li></ul><a id="more"></a><h4 id="2、配置命令解释"><a href="#2、配置命令解释" class="headerlink" title="2、配置命令解释"></a>2、配置命令解释</h4><p>nginx中每条配置命令都必须要以分号“;”结束！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">#定义Nginx运行的用户和用户组</span><br><span class="line">user www www;</span><br><span class="line"></span><br><span class="line">#nginx进程数，建议设置为等于CPU总核心数。</span><br><span class="line">worker_processes 8;</span><br><span class="line"></span><br><span class="line">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">error_log /var/log/nginx/error.log info;</span><br><span class="line"></span><br><span class="line">#指定nginx  pid的存放路径</span><br><span class="line">pid /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）</span><br><span class="line">#与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">#工作模式与连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; </span><br><span class="line">    #epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。</span><br><span class="line">    use epoll;</span><br><span class="line">    #单个进程最大连接数（最大连接数=连接数*进程数）</span><br><span class="line">    worker_connections 65535;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#设定http服务器</span><br><span class="line">http &#123;</span><br><span class="line">    include mime.types; #文件扩展名与文件类型映射表</span><br><span class="line">    default_type application/octet-stream; #默认文件类型</span><br><span class="line">    #charset utf-8; #默认编码</span><br><span class="line">    server_names_hash_bucket_size 128; #服务器名字的hash表大小</span><br><span class="line">    client_header_buffer_size 32k; #设定请求缓</span><br><span class="line">    large_client_header_buffers 4 64k; #设定请求缓</span><br><span class="line">    client_max_body_size 8m; #配置客户端能够上传的文件大小</span><br><span class="line">    sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，</span><br><span class="line">    #对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，</span><br><span class="line">    #以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br><span class="line">    autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line">    tcp_nopush on; #防止网络阻塞</span><br><span class="line">    tcp_nodelay on; #防止网络阻塞</span><br><span class="line">    keepalive_timeout 120; #长连接超时时间，单位是秒</span><br><span class="line">    </span><br><span class="line">    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问    速度。下面参数看字面意思都能理解。</span><br><span class="line">    fastcgi_connect_timeout 300;</span><br><span class="line">    fastcgi_send_timeout 300;</span><br><span class="line">    fastcgi_read_timeout 300;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">    #gzip模块设置</span><br><span class="line">    gzip on; #开启gzip压缩输出</span><br><span class="line">    gzip_min_length 1k; #最小压缩文件大小</span><br><span class="line">    gzip_buffers 4 16k; #压缩缓冲区</span><br><span class="line">    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br><span class="line">    gzip_comp_level 2; #压缩等级</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class="line">    #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用</span><br><span class="line"></span><br><span class="line">    #日志格式设定</span><br><span class="line">    log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;</span><br><span class="line">    #启用访问日志，并且指定日志采用的格式</span><br><span class="line">    access_log /var/log/nginx/ha97access.log main;</span><br><span class="line">    #自定义日志格式</span><br><span class="line">    #log_format access &apos;$http_x_forwarded_for $remote_addr [$time_local] &quot;http://$host&quot; &quot;$request&quot; &apos;</span><br><span class="line">    #&apos;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$remote_user&quot; &apos;;</span><br><span class="line">    #（x_forwarded_for表示用户的真实IP。）</span><br><span class="line"></span><br><span class="line">    upstream blog.ha97.com &#123;</span><br><span class="line">        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。</span><br><span class="line">        #weigth参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">        server 192.168.80.121:80 weight=3;</span><br><span class="line">        server 192.168.80.122:80 weight=2;</span><br><span class="line">        server 192.168.80.123:80 weight=3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #虚拟主机的配置</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">        #监听端口</span><br><span class="line">        listen 80;</span><br><span class="line">        #域名可以有多个，用空格隔开</span><br><span class="line">        server_name www.ha97.com ha97.com;</span><br><span class="line">        #默认索引文件</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">        #主机站点根目录地址</span><br><span class="line">        root /data/www/ha97;</span><br><span class="line">        #error_page   404    /404.html;  //404页面地址（可以配置其它错误页面地址如500等，格式一样）</span><br><span class="line"></span><br><span class="line">        #转发PHP文件到指定服务</span><br><span class="line">        location ~ .*\.(php|php5)?$&#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            include fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        #图片缓存时间设置</span><br><span class="line">        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$&#123;</span><br><span class="line">            expires 10d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #JS和CSS缓存时间设置</span><br><span class="line">        location ~ .*\.(js|css)?$&#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #对 &quot;/&quot; 启用反向代理</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:88;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            #以下是一些反向代理的配置，可选。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            client_max_body_size 10m; #允许客户端请求的最大单文件字节数</span><br><span class="line">            client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">            proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">            proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)</span><br><span class="line">            proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">            proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">            proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置</span><br><span class="line">            proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">            proxy_temp_file_write_size 64k;</span><br><span class="line">            #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #设定查看Nginx状态的地址</span><br><span class="line">        location /NginxStatus &#123;</span><br><span class="line">            stub_status on;</span><br><span class="line">            access_log on;</span><br><span class="line">            auth_basic &quot;NginxStatus&quot;;</span><br><span class="line">            auth_basic_user_file conf/htpasswd;</span><br><span class="line">            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #本地动静分离反向代理配置</span><br><span class="line">        #所有jsp的页面均交由tomcat或resin处理</span><br><span class="line">        location ~ .(jsp|jspx|do)?$ &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">        #所有静态文件由nginx直接读取不经过tomcat或resin</span><br><span class="line">        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip</span><br><span class="line">        |txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$&#123; </span><br><span class="line">            expires 15d; </span><br><span class="line">        &#125;</span><br><span class="line">        location ~ .*.(js|css)?$&#123; </span><br><span class="line">            expires 1h; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、结构分析&quot;&gt;&lt;a href=&quot;#1、结构分析&quot; class=&quot;headerlink&quot; title=&quot;1、结构分析&quot;&gt;&lt;/a&gt;1、结构分析&lt;/h4&gt;&lt;p&gt;nginx配置文件中主要包括六块：main，events，http，server，location，upstream&lt;br&gt;结构如下图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;main块：&lt;/strong&gt;主要控制nginx子进程的所属用户/用户组、派生子进程数、错误日志位置/级别、pid位置、子进程优先级、进程对应cpu、进程能够打开的文件描述符数目等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;events块：&lt;/strong&gt;控制nginx处理连接的方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;http块：&lt;/strong&gt;是nginx处理http请求的主要配置模块，大多数配置都在这里面进行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;server块：&lt;/strong&gt;是nginx中主机的配置块，可以配置多个虚拟主机&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;location块：&lt;/strong&gt;是server中对应的目录级别的控制块，可以有多个&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;upstream块：&lt;/strong&gt;是nginx做反向代理和负载均衡的配置块，可以有多个&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 中的事件驱动模型</title>
    <link href="http://yoursite.com/2018/04/09/Nginx%20%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/04/09/Nginx 中的事件驱动模型/</id>
    <published>2018-04-09T09:19:16.000Z</published>
    <updated>2018-07-21T09:20:39.108Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是事件驱动模型？"><a href="#什么是事件驱动模型？" class="headerlink" title="什么是事件驱动模型？"></a>什么是事件驱动模型？</h4><p>在计算机编程领域，事件驱动模型对应一种程序设计方式，Event-driven programming，即事件驱动程序设计。事件驱动模型一般是由事件收集器，事件发送器，事件处理器三部分基本单元组成。</p><ul><li>事件收集器专门负责收集所有的事件，包括来自用户的（如鼠标单击事件、键盘输入事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。</li><li>事件发送器负责将收集器收集到的事件分发到目标对象中。目标对象就是事件处理器所处的位置。</li><li>事件处理器主要负责具体事件的响应工作，它往往要到实现阶段才完全确定。</li></ul><p>事件驱动程序可以由任何编程语言来实现，只是难易程度有别。如果一个系统是以事件驱动程序模型作为编程基础的，那么，它的架构基本上是这样的：预先设计一个事件循环所形成的程序，这个事件循环程序构成了“事件收集器”，它不断地检查目前要处理的事件信息，然后使用“事件发送器”传递给“事件处理器”。“事件处理器”一般运用虚函数机制来实现。<br><a id="more"></a></p><h4 id="Nginx中的事件驱动模型"><a href="#Nginx中的事件驱动模型" class="headerlink" title="Nginx中的事件驱动模型"></a>Nginx中的事件驱动模型</h4><p>Nginx服务器响应和处理Web请求的过程，就是基于事件驱动模型的，它也包含事件收集器、事件发送器和事件处理器等三部分基本单元。Nginx的“事件收集器”和“事件发送器”的实现没有太大的特点，重点介绍一下它的“事件处理器”。<br>通常，我们在编写服务器处理模型的程序时，基于事件驱动模型，“目标对象”中的“事件处理器”可以有以下几种实现办法：</p><ul><li>“事件发送器”每传递过来一个请求，“目标对象”就创建一个新的进程，调用“事件处理器”来处理该请求。</li><li>“事件发送器”每传递过来一个请求，“目标对象”就创建一个新的线程，调用“事件处理器”来处理该请求。</li><li>“事件发送器”每传递过来一个请求，“目标对象”就将其放入一个待处理事件的列表，使用非阻塞I/O方式调用“事件处理器”来处理该请求。</li></ul><p>以上的三种处理方式，各有特点，第一种方式，由于创建新的进程的开销比较大，会导致服务器性能比较差，但其实现相对来说比较简单。<br>第二种方式，由于要涉及到线程的同步，故可能会面临死锁、同步等一系列问题，编码比较复杂。<br>第三种方式，在编写程序代码时，逻辑比前面两种都复杂。大多数网络服务器采用了第三种方式，逐渐形成了所谓的“事件驱动处理库”。<br>事件驱动处理库又被称为多路IO复用方法，最常见的包括以下三种：select模型，poll模型和epoll模型。Nginx服务器还支持rtsig模型、kqueue模型、dev/poll模型和eventport模型等。通过Nginx配置可以使得Nginx服务器支持这几种事件驱动处理模型。这里详细介绍以下它们。</p><h4 id="select库"><a href="#select库" class="headerlink" title="select库"></a>select库</h4><p>select库，是各个版本的Linux和Windows平台都支持的基本事件驱动模型库，并且在接口的定义上也基本相同，只是部分参数的含义略有差异。使用select库的步骤一般是：<br>首先，创建所关注事件的描述符集合。对于一个描述符，可以关注其上面的（Read)事件、写（Write)事件以及异常发送（Exception）事件，所以要创建三类事件描述符集合，分别用来收集读事件的描述符、写事件的描述符和异常事件的描述符。<br>其次，调用底层提供的select()函数，等待事件发生。这里需要注意的一点是，select的阻塞与是否设置非阻塞I/O是没有关系的。<br>然后，轮询所有事件描述符集合中的每一个事件描述符，检查是否有相应的事件发生，如果有，就进行处理。<br>Nginx服务器在编译过程中如果没有为其指定其他高性能事件驱动模型库，它将自动编译该库。我们可以使用–with-select_module和–without-select_module两个参数强制Nginx是否编译该库。</p><blockquote><p><strong>缺点：</strong><br>1、单个进程可监视的fd（描述符）数量被限制，即能监听端口的大小有限。<br>    一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.<br>2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：<br>    当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。<br>3、需要维护一个用来存放大量fd（描述符）的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p></blockquote><h4 id="poll库"><a href="#poll库" class="headerlink" title="poll库"></a>poll库</h4><p>poll库，作为Linux平台上的基本事件驱动模型，实在Linux2.1.23中引入的。Windows平台不支持poll库。<br>poll与select的基本工作方式是相同的，都是现创建一个关注事件的描述符集合，再去等待这些事件发生，然后在轮询描述符集合，检查有没有事件发生，如果有，就进行处理。<br>poll库与select库的主要区别在于，select库需要为读事件、写事件和异常事件分别创建一个描述符集合，因此在最后轮询的时候，需要分别轮询这三个集合。而poll库只需要创建一个集合，在每个描述符对应的结构上分别设置读事件、写事件或者异常事件，最后轮询的时候，可以同时检查这三种事件是否发生。可以说，poll库是select库的优化实现。<br>Nginx服务器在编译过程中如果没有为其制定其他高性能事件驱动模型库，它将自动编译该库。我们可以使用–with-poll_module和–without-poll_module两个参数强制Nginx是否编译该库。</p><blockquote><p><strong>缺点：</strong><br>1、大量的fd（描述符）的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。<br>2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p></blockquote><h4 id="epoll库"><a href="#epoll库" class="headerlink" title="epoll库"></a>epoll库</h4><p>epoll库是Nginx服务器支持的高性能事件驱动库之一，它是公认的非常优秀的事件驱动模型，和poll库及select库有很大的不同。epoll属于poll库的一个变种，是在Linux 2.5.44中引入的，在Linux 2.6以上的版本都可以使用它。poll库和select库在实际工作中，最大的区别在于效率。<br>从前面的介绍我们知道，它们的处理方式都是创建一个待处理事件列表，然后把这个列表发给内核，返回的时候，再去轮询检查这个列表，以判断事件是否发生。这样在描述符比较多的应用中，效率就显得比较低下了。一种比较好的做法是，把描述符列表的管理交给内核负责，一旦有某种事件发生，内核把发生事件的描述符列表通知给进程，这样就避免了轮询整个描述符列表。epoll库就是这样一种模型。<br>首先，epoll库通过相关调用通知内核创建一个由N个描述符的事件列表。然后，给这些描述符设置所关注的事件，并把它添加到内核的事件列表中去，在具体的编码过程中也可以通过相关调用对事件列表中的描述符进行修改和删除。<br>完成设置之后，epoll库就开始等待内核通知事件发生了。某一事件发生后，内核将发生事件的描述符列表上报给epoll库。得到事件列表的epoll库，就可以进行事件处理了。<br>epoll库在Linux平台上是最高效的。它支持一个进程打开大数目的事件描述符，上限是系统可以打开文件的最大数目。同时，epoll库的IO效率不随描述符数目增加而线性下降，因为它只会对内核上报的“活跃”的描述符进行操作。</p><blockquote><p><strong>优点：</strong><br>1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；<br>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；<br>    即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。<br>3、内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p></blockquote><h4 id="rtsig模型"><a href="#rtsig模型" class="headerlink" title="rtsig模型"></a>rtsig模型</h4><p>rtsig是Real-Time Signal的缩写，是实时信号的意思。从严格意义上说，rtsig模型并不是常用的事件驱动模型，但Nginx服务器使用了使用实时信号对事件进行响应的支持，官方文档中将rtsig模型与其他的事件驱动模型并列。<br>使用rtsig模型时，工作进程会通过系统内核建立一个rtsig队列用于存放标记事件发生（在Nginx服务器应用中特指客户端请求发生）的信号。每个事件发生时，系统内核就会产生一个信号存放到rtsig队列中等待工作进程的处理。<br>需要指出的是，rtsig队列有长度限制，超过该长度后就会发生溢出。默认情况下，Linux系统事件信号队列的最大长度设置为1024，也就是同时最多可以存放1024个发生事件的信号。在Linux 2.6.6-mm2之前的版本中，系统各个进程的事件信号队列是由内核统一管理的，用户可以通过修改内核参数/proc/sys/kernel/rtsig-max/来自定义该长度设置。在Linux 2.6.6-mm2之后的版本中，该内核参数被取消，系统各个进程分别拥有各自的事件信号队列，这个队列的大小由Linux系统的RLIMT_SIGPENGIND参数定义，在执行setrlimit()系统调用时确定该大小。Nginx提供了worker_rlimit_sigpending参数用于调节这种情况下的事件信号队列长度。<br>当rtsig队列发生溢出时，Nginx将暂时停止使用rtsig模型，而调用poll库处理未处理的事件，直到rgsit信号队列全部清空，然后再次启动rtsig模型，以防止新的溢出发生。<br>Nginx在配置文件中提供了相关参数对rtsig模型的使用配置。编译Nginx服务器时，使用–with-rtsig_module配置选项来启用rtsig模型的编译。</p><h4 id="其他事件驱动模型"><a href="#其他事件驱动模型" class="headerlink" title="其他事件驱动模型"></a>其他事件驱动模型</h4><p>除了以上四种主要的事件驱动模型，Nginx服务器针对特定的Linux平台提供了响应的事件驱动模型支持。目前实现的主要有kqueue模型、/dev/poll模型和eventport模型等。</p><ul><li><strong>kqueue模型</strong>，是用于支持BSD系列平台的高效事件驱动模型，主要用在FreeBSD 4.1及以上版本、OpenBSD 2.9及以上版本、NetBSD 2.0及以上版本以及Mac OS X平台上。该模型也是poll库的一个变种，其和epoll库的处理方式没有本质上的区别，都是通过避免轮询操作提供效率。该模型同时支持条件触发（level-triggered,也叫水平触发，只要满足条件就触发一个事件）和边缘触发（edge-triggered，每当状态变化时，触发一个事件）。如果大家在这些平台下使用Nginx服务器，建议选在该模型用于请求处理，以提高Nginx服务器的处理性能。</li><li><strong>/dev/poll模型</strong>，适用于支持Unix衍生平台的高效事件驱动模型，其主要在Solaris711/99及以上版本、HP/UX 11.22及以上版本、IRIX 6.5.15及以上版本和Tru64 UNIX 5.1A及以上版本的平台中使用。该模型是Sun公司在开发Solaris系列平台时提出的用于完成事件驱动机制的方案，它使用了虚拟的/dev/poll设备，开发人员可以将要监视的文件描述符加入这个设备，然后通过ioctl()调用来获取事件通知。在以上提到的平台中，建议使用该模型处理请求。</li><li><strong>eventport模型</strong>，适用于支持Solaris 10及以上版本平台的高效事件驱动模型。该模型也是Sun公司在开发Solaris系列平台时提出的用于完成事件驱动机制的方案，它可以有效防止内核崩溃情况的发生。Nginx服务器为此提供了支持。</li></ul><p>以上就是Nginx服务器支持的事件驱动库。可以看到，Nginx服务器针对不同的Linux或Unix衍生平台提供了多种事件驱动模型的处理，尽量发挥系统平台本身的优势，最大程度地提高处理客户端请求事件的能力。在实际工作中，我们需要根据具体情况和应用情景选择使用不同的事件驱动模型，以保证Nginx服务器的高效运行。</p><h4 id="select、poll、epoll-区别总结："><a href="#select、poll、epoll-区别总结：" class="headerlink" title="select、poll、epoll 区别总结："></a>select、poll、epoll 区别总结：</h4><p><strong>1、支持一个进程所能打开的最大连接数</strong></p><style type="text/css">    table th:first-of-type{        width: 10%;    }</style><table><thead><tr><th>select</th><th>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</th></tr></thead><tbody><tr><td>poll</td><td>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td></tr><tr><td>epoll</td><td>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</td></tr></tbody></table><p><strong>2、FD剧增后带来的IO效率问题</strong></p><table><thead><tr><th>select</th><th>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</th></tr></thead><tbody><tr><td>poll</td><td>同上</td></tr><tr><td>epoll</td><td>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</td></tr></tbody></table><p><strong>3、 消息传递方式</strong></p><table><thead><tr><th>select</th><th>内核需要将消息传递到用户空间，都需要内核拷贝动作</th></tr></thead><tbody><tr><td>poll</td><td>同上</td></tr><tr><td>epoll</td><td>epoll通过内核和用户空间共享一块内存来实现的。</td></tr></tbody></table><p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。<br>1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。<br>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是事件驱动模型？&quot;&gt;&lt;a href=&quot;#什么是事件驱动模型？&quot; class=&quot;headerlink&quot; title=&quot;什么是事件驱动模型？&quot;&gt;&lt;/a&gt;什么是事件驱动模型？&lt;/h4&gt;&lt;p&gt;在计算机编程领域，事件驱动模型对应一种程序设计方式，Event-driven programming，即事件驱动程序设计。事件驱动模型一般是由事件收集器，事件发送器，事件处理器三部分基本单元组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件收集器专门负责收集所有的事件，包括来自用户的（如鼠标单击事件、键盘输入事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。&lt;/li&gt;
&lt;li&gt;事件发送器负责将收集器收集到的事件分发到目标对象中。目标对象就是事件处理器所处的位置。&lt;/li&gt;
&lt;li&gt;事件处理器主要负责具体事件的响应工作，它往往要到实现阶段才完全确定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件驱动程序可以由任何编程语言来实现，只是难易程度有别。如果一个系统是以事件驱动程序模型作为编程基础的，那么，它的架构基本上是这样的：预先设计一个事件循环所形成的程序，这个事件循环程序构成了“事件收集器”，它不断地检查目前要处理的事件信息，然后使用“事件发送器”传递给“事件处理器”。“事件处理器”一般运用虚函数机制来实现。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx + FastCGI运行原理</title>
    <link href="http://yoursite.com/2018/04/09/Nginx%20+%20FastCGI%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/09/Nginx + FastCGI运行原理/</id>
    <published>2018-04-09T07:17:41.000Z</published>
    <updated>2018-07-21T09:20:39.108Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、什么是-FastCGI"><a href="#1、什么是-FastCGI" class="headerlink" title="1、什么是 FastCGI"></a>1、什么是 FastCGI</h4><p>FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等。同时，FastCGI也被许多脚本语言支持，其中就有PHP。</p><p>FastCGI是从CGI发展改进而来的。传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后将结果返回给HTTP服务器。这在处理高并发访问时几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少使用了。<br><a id="more"></a><br>FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p><h4 id="2、Nginx-FastCGI运行原理"><a href="#2、Nginx-FastCGI运行原理" class="headerlink" title="2、Nginx+FastCGI运行原理"></a>2、Nginx+FastCGI运行原理</h4><p>Nginx不支持对外部程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket（这个socket可以是文件socket，也可以是ip socket）。</p><p>wrapper：为了调用CGI程序，还需要一个FastCGI的wrapper（wrapper可以理解为用于启动另一个程序的程序），这个wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接收到请求，然后Fork(派生）出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据（html页面或者图片）发送给客户端。这就是Nginx+FastCGI的整个运作过程，如图1-3所示。<br><img src="/uploads/2018/04/nginx_fastcgi.png" alt=""></p><p>所以，我们首先需要一个wrapper，这个wrapper需要完成的工作：</p><ol><li>通过调用fastcgi（库）的函数通过socket和ningx通信（读写socket是fastcgi内部实现的功能，对wrapper是非透明的）</li><li>调度thread，进行fork和kill</li><li>和application（php）进行通信</li></ol><h4 id="3、spawn-fcgi与PHP-FPM"><a href="#3、spawn-fcgi与PHP-FPM" class="headerlink" title="3、spawn-fcgi与PHP-FPM"></a>3、spawn-fcgi与PHP-FPM</h4><p>FastCGI接口方式在脚本解析服务器上启动一个或者多个守护进程对动态脚本进行解析，这些进程就是FastCGI进程管理器，或者称为FastCGI引擎。 spawn-fcgi与PHP-FPM就是支持PHP的两个FastCGI进程管理器。因此HTTPServer完全解放出来，可以更好地进行响应和并发处理。</p><blockquote><p>spawn-fcgi与PHP-FPM的异同：<br>1）spawn-fcgi是HTTP服务器lighttpd的一部分，目前已经独立成为一个项目，一般与lighttpd配合使用来支持PHP。但是ligttpd的spwan-fcgi在高并发访问的时候，会出现内存泄漏甚至自动重启FastCGI的问题。即：PHP脚本处理器当机，这个时候如果用户访问的话，可能就会出现白页(即PHP不能被解析或者出错)。<br>2）Nginx是个轻量级的HTTP server，必须借助第三方的FastCGI处理器才可以对PHP进行解析，因此其实这样看来nginx是非常灵活的，它可以和任何第三方提供解析的处理器实现连接从而实现对PHP的解析(在nginx.conf中很容易设置)。nginx也可以使用spwan-fcgi(需要一同安装lighttpd，但是需要为nginx避开端口，一些较早的blog有这方面安装的教程)，但是由于spawn-fcgi具有上面所述的用户逐渐发现的缺陷，现在慢慢减少用nginx+spawn-fcgi组合了。</p></blockquote><p>由于spawn-fcgi的缺陷，现在出现了第三方(目前已经加入到PHP core中)的PHP的FastCGI处理器PHP-FPM，它和spawn-fcgi比较起来有如下优点：</p><ul><li>由于它是作为PHP的patch补丁来开发的，安装的时候需要和php源码一起编译，也就是说编译到php core中了，因此在性能方面要优秀一些；</li><li>同时它在处理高并发方面也优于spawn-fcgi，至少不会自动重启fastcgi处理器。因此，推荐使用Nginx+PHP/PHP-FPM这个组合对PHP进行解析。</li><li>相对Spawn-FCGI，PHP-FPM在CPU和内存方面的控制都更胜一筹，而且前者很容易崩溃，必须用crontab进行监控，而PHP-FPM则没有这种烦恼。</li><li>FastCGI 的主要优点是把动态语言和HTTP Server分离开来，所以Nginx与PHP/PHP-FPM经常被部署在不同的服务器上，以分担前端Nginx服务器的压力，使Nginx专一处理静态请求和转发动态请求，而PHP/PHP-FPM服务器专一解析PHP动态请求。</li></ul><h4 id="4、Nginx-PHP-FPM"><a href="#4、Nginx-PHP-FPM" class="headerlink" title="4、Nginx+PHP-FPM"></a>4、Nginx+PHP-FPM</h4><p>PHP-FPM是管理FastCGI的一个管理器，它作为PHP的插件存在，在安装PHP要想使用PHP-FPM时在老php的老版本（php5.3.3之前）就需要把PHP-FPM以补丁的形式安装到PHP中，而且PHP要与PHP-FPM版本一致，这是必须的）</p><p>PHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。<br>PHP5.3.3已经集成php-fpm了，不再是第三方的包了。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多优点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。</p><p>fastcgi已经在php5.3.5的core中了，不必在configure时添加 –enable-fastcgi了。老版本如php5.2的需要加此项。</p><p><strong>当我们安装Nginx和PHP-FPM完后，配置信息：</strong></p><blockquote><p>PHP-FPM的默认配置php-fpm.conf：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listen_address  127.0.0.1:9000 #这个表示php的fastcgi进程监听的ip地址以及端口</span><br><span class="line">start_servers</span><br><span class="line">min_spare_servers</span><br><span class="line">max_spare_servers</span><br></pre></td></tr></table></figure></p><p>Nginx配置运行php： 编辑nginx.conf加入如下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root html;   </span><br><span class="line">    fastcgi_pass 127.0.0.1:9000; 指定了fastcgi进程侦听的端口,nginx就是通过这里与php交互的</span><br><span class="line">    fastcgi_index index.php;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME   /usr/local/nginx/html$fastcgi_script_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>Nginx通过location指令，将所有以php为后缀的文件都交给127.0.0.1:9000来处理，而这里的IP地址和端口就是FastCGI进程监听的IP地址和端口。</p><p><strong>其整体工作流程：</strong><br>1)  FastCGI进程管理器php-fpm自身初始化，启动主进程php-fpm和启动start_servers个CGI 子进程。<br>    主进程php-fpm主要是管理fastcgi子进程，监听9000端口。<br>    fastcgi子进程等待来自Web Server的连接。<br>2)  当客户端请求到达Web Server Nginx是时，Nginx通过location指令，将所有以php为后缀的文件都交给127.0.0.1:9000来处理，即Nginx通过location指令，将所有以php为后缀的文件都交给127.0.0.1:9000来处理。<br>3)  FastCGI进程管理器PHP-FPM选择并连接到一个子进程CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程。<br>4)  FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。<br>5)  FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在 WebServer中）的下一个连接。</p><h4 id="5、Nginx-PHP正确配置"><a href="#5、Nginx-PHP正确配置" class="headerlink" title="5、Nginx+PHP正确配置"></a>5、Nginx+PHP正确配置</h4><p>一般web都做统一入口：把PHP请求都发送到同一个文件上，然后在此文件里通过解析「REQUEST_URI」实现路由。</p><p>Nginx配置文件分为好多块，常见的从外到内依次是「http」、「server」、「location」等等，缺省的继承关系是从外到内，也就是说内层块会自动获取外层块的值作为缺省值。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 80;  </span><br><span class="line">    server_name foo.com;  </span><br><span class="line">    root /path;  </span><br><span class="line">    location / &#123;  </span><br><span class="line">        index index.html index.htm index.php;  </span><br><span class="line">        if (!-e $request_filename) &#123;  </span><br><span class="line">            rewrite . /index.php last;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    location ~ \.php$ &#123;  </span><br><span class="line">        include fastcgi_params;  </span><br><span class="line">        fastcgi_param SCRIPT_FILENAME /path$fastcgi_script_name;  </span><br><span class="line">        fastcgi_pass 127.0.0.1:9000;  </span><br><span class="line">        fastcgi_index index.php;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>1) 不应该在location 模块定义index</strong><br>一旦未来需要加入新的「location」，必然会出现重复定义的「index」指令，这是因为多个「location」是平级的关系，不存在继承，此时应该在「server」里定义「index」，借助继承关系，「index」指令在所有的「location」中都能生效。</p><p><strong>2) 使用try_files</strong><br>接下来看看「if」指令，说它是大家误解最深的Nginx指令毫不为过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!-e $request_filename) &#123;</span><br><span class="line">    rewrite . /index.php last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很多人喜欢用「if」指令做一系列的检查，不过这实际上是「try_files」指令的职责：<br><code>try_files $uri $uri/ /index.php;</code></p><p>除此以外，初学者往往会认为「if」指令是内核级的指令，但是实际上它是rewrite模块的一部分，加上Nginx配置实际上是声明式的，而非过程式的，所以当其和非rewrite模块的指令混用时，结果可能会非你所愿。</p><p><strong>3）fastcgi_params」配置文件：</strong><br><code>include fastcgi_params;</code></p><p>Nginx有两份fastcgi配置文件，分别是「fastcgi_params」和「fastcgi.conf」，它们没有太大的差异，唯一的区别是后者比前者多了一行「SCRIPT_FILENAME」的定义：<br><code>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</code></p><p>注意：$document_root 和 $fastcgi_script_name 之间没有 /。<br>原本Nginx只有「fastcgi_params」，后来发现很多人在定义「SCRIPT_FILENAME」时使用了硬编码的方式，于是为了规范用法便引入了「fastcgi.conf」。</p><p>不过这样的话就产生一个疑问：为什么一定要引入一个新的配置文件，而不是修改旧的配置文件？这是因为「fastcgi_param」指令是数组型的，和普通指令相同的是：内层替换外层；和普通指令不同的是：当在同级多次使用的时候，是新增而不是替换。换句话说，如果在同级定义两次「SCRIPT_FILENAME」，那么它们都会被发送到后端，这可能会导致一些潜在的问题，为了避免此类情况，便引入了一个新的配置文件。</p><p>此外，我们还需要考虑一个安全问题：在PHP开启「cgi.fix_pathinfo」的情况下，PHP可能会把错误的文件类型当作PHP文件来解析。如果Nginx和PHP安装在同一台服务器上的话，那么最简单的解决方法是用「try_files」指令做一次过滤：<br><code>try_files $uri =404;</code></p><p>依照前面的分析，给出一份改良后的版本，是不是比开始的版本清爽了很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 80;  </span><br><span class="line">    server_name foo.com;  </span><br><span class="line">    root /path;  </span><br><span class="line">    index index.html index.htm index.php;  </span><br><span class="line">    location / &#123;  </span><br><span class="line">        try_files $uri $uri/ /index.php;  </span><br><span class="line">    &#125;  </span><br><span class="line">    location ~ \.php$ &#123;  </span><br><span class="line">       try_files $uri =404;  </span><br><span class="line">       include fastcgi.conf;  </span><br><span class="line">       fastcgi_pass 127.0.0.1:9000;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、什么是-FastCGI&quot;&gt;&lt;a href=&quot;#1、什么是-FastCGI&quot; class=&quot;headerlink&quot; title=&quot;1、什么是 FastCGI&quot;&gt;&lt;/a&gt;1、什么是 FastCGI&lt;/h4&gt;&lt;p&gt;FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等。同时，FastCGI也被许多脚本语言支持，其中就有PHP。&lt;/p&gt;
&lt;p&gt;FastCGI是从CGI发展改进而来的。传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后将结果返回给HTTP服务器。这在处理高并发访问时几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少使用了。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 概述及工作原理</title>
    <link href="http://yoursite.com/2018/04/09/Nginx%20%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/09/Nginx 概述及工作原理/</id>
    <published>2018-04-09T07:17:01.000Z</published>
    <updated>2018-07-21T09:20:39.108Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、nginx概述"><a href="#一、nginx概述" class="headerlink" title="一、nginx概述"></a>一、nginx概述</h4><p>Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强。</p><h5 id="1、什么是nginx？"><a href="#1、什么是nginx？" class="headerlink" title="1、什么是nginx？"></a>1、什么是nginx？</h5><p>Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。Nginx 是由俄罗斯人 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，它已经在该站点运行超过两年半了。Igor Sysoev 在建立的项目时,使用基于 BSD 许可。<br><a id="more"></a></p><p>Nginx 以<font color="red">事件驱动</font>的方式编写，所以有非常好的性能，同时也是<font color="red">一个非常高效的反向代理、负载平衡</font>。其拥有匹配 Lighttpd 的性能，同时还没有 Lighttpd 的内存泄漏问题，而且 Lighttpd 的 mod_proxy 也有一些问题并且很久没有更新。</p><p>现在，Igor 将源代码以类 BSD 许可证的形式发布。Nginx 因为它的稳定性、丰富的模块库、灵活的配置和低系统资源的消耗而闻名．业界一致认为它是 Apache2.2＋mod_proxy_balancer 的轻量级代替者，不仅是因为响应静态页面的速度非常快，而且它的模块数量达到 Apache 的近 2/3。对 proxy 和 rewrite 模块的支持很彻底，还支持 mod_fcgi、ssl、vhosts ，适合用来做 mongrel clusters 的前端 HTTP 响应。</p><h5 id="2、nginx的特点"><a href="#2、nginx的特点" class="headerlink" title="2、nginx的特点"></a>2、nginx的特点</h5><p>Nginx 做为 HTTP 服务器，有以下几项基本特性：</p><ul><li>I/O多路复用 epoll</li><li>轻量级：主要说功能模块少，代码模块化（Nginx仅保存了HTTP和核心功能相关的代码模块）</li><li>CPU 亲和：是一种把CPU核心和Nginx工作进程绑定方式，把每个worker进程固定在一个CPU上执行，减少CPU切换，获得更好的性能</li><li>sendfile：使Nginx处理静态文件非常有优势</li></ul><blockquote><p><strong>I/O多路复用：</strong>多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，这就叫I/O多路复用，这里的“复用”指的是复用同一个线程。<em><br><strong>sendfile 运行原理：</strong>正常一个http请求会经过内核空间到用户空间，再传输给socket的流程，而请求会在内核空间和用户空间进行多次切换，静态文件是不需要经过用户空间的。因此开启sendfile，则静态文件直接通过内核空间传递给socket，返回给客户端。无需经过用户空间，提高性能</em></p></blockquote><p>Nginx 专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率 。它支持内核 Poll 模型，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。</p><p>Nginx 具有很高的稳定性。其它 HTTP 服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前 apache 一旦上到 200 个以上进程，web响应速度就明显非常缓慢了。而 Nginx 采取了分阶段资源分配技术，使得它的 CPU 与内存占用率非常低。Nginx 官方表示保持 10,000 个没有活动的连接，它只占 2.5M 内存，所以类似 DOS 这样的攻击对 Nginx 来说基本上是毫无用处的。就稳定性而言,Nginx 比 lighthttpd 更胜一筹。</p><p>Nginx 支持热部署。它的启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。</p><h4 id="二、nginx的架构"><a href="#二、nginx的架构" class="headerlink" title="二、nginx的架构"></a>二、nginx的架构</h4><p>众所周知，Nginx 性能高，而 Nginx 的高性能与其架构是分不开的。那么 Nginx 究竟是怎么样的呢？</p><p>Nginx 在启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程。我们也可以手动地关掉后台模式，让 Nginx 在前台运行，并且通过配置让 Nginx 取消 master 进程，从而可以使 Nginx 以单进程方式运行。很显然，生产环境下我们肯定不会这么做，所以关闭后台模式，一般是用来调试用的。所以，我们可以看到，Nginx 是以多进程的方式来工作的，当然 Nginx 也是支持多线程的方式的，只是我们主流的方式还是多进程的方式，也是 Nginx 的默认方式。Nginx 采用多进程的方式有诸多好处，所以我就主要讲解 Nginx 的多进程模式吧。</p><h5 id="1、Nginx-的进程模型"><a href="#1、Nginx-的进程模型" class="headerlink" title="1、Nginx 的进程模型"></a>1、Nginx 的进程模型</h5><p>刚才讲到，Nginx 在启动后，会有一个 master 进程和多个 worker 进程。<strong>master 进程主要用来管理 worker 进程，包含：接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动新的 worker 进程。而基本的网络事件，则是放在 worker 进程中来处理了。多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。</strong><font color="red">一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求。</font> worker 进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的<em>原因与 Nginx 的进程模型以及事件处理模型是分不开的</em>。Nginx 的进程模型，可以由下图来表示：<br><img src="/uploads/2018/04/nginx-chapter-01.png" alt=""></p><p>在 Nginx 启动后，如果我们要操作 Nginx，要怎么做呢？从上文中我们可以看到，master 来管理 worker 进程，所以我们只需要与 master 进程通信就行了。master 进程会接收来自外界发来的信号，再根据信号做不同的事情。所以我们要控制 Nginx，只需要通过 kill 向 master 进程发送信号就行了。比如kill -HUP pid，则是告诉 Nginx，从容地重启 Nginx，我们一般用这个信号来重启 Nginx，或重新加载配置，因为是从容地重启，因此服务是不中断的。master 进程在接收到 HUP 信号后是怎么做的呢？<font color="red">首先 master 进程在接到信号后，会先重新加载配置文件，然后再启动新的 worker 进程，并向所有老的 worker 进程发送信号，告诉他们可以光荣退休了。新的 worker 在启动后，就开始接收新的请求，而老的 worker 在收到来自 master 的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。</font>当然，直接给 master 进程发送信号，这是比较老的操作方式，Nginx 在 0.8 版本之后，引入了一系列命令行参数，来方便我们管理。比如，./nginx -s reload，就是来重启 Nginx，./nginx -s stop，就是来停止 Nginx 的运行。如何做到的呢？我们还是拿 reload 来说，我们看到，<font color="red">执行命令时，我们是启动一个新的 Nginx 进程，而新的 Nginx 进程在解析到 reload 参数后，就知道我们的目的是控制 Nginx 来重新加载配置文件了，它会向 master 进程发送信号，然后接下来的动作，就和我们直接向 master 进程发送信号一样了。</font></p><p>现在，我们知道了当我们在操作 Nginx 的时候，Nginx 内部做了些什么事情，那么，worker 进程又是如何处理请求的呢？我们前面有提到，<font color="red">worker 进程之间是平等的，每个进程，处理请求的机会也是一样的。</font>当我们提供 80 端口的 http 服务时，一个连接请求过来，每个进程都有可能处理这个连接，怎么做到的呢？首先，每个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面，先建立好需要 listen 的 socket（listenfd）<font color="red">（socket不知道是啥的，可点击查询）</font>之后，然后再 fork 出多个 worker 进程。所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当一个 worker 进程在 accept 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，<font color="red">一个请求，完全由 worker 进程来处理，而且只在一个 worker 进程中处理。</font></p><p>那么，Nginx 采用这种进程模型有什么好处呢？当然，好处肯定会很多了。首先，对于每个 worker 进程来说，独立的进程，不需要加锁<strong>（因为需要争抢处理请求，不使用accept_mutex接受互斥量，会导致多个worker进程处理一个请求的混乱结果）</strong>，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的 worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。当然，好处还有很多，大家可以慢慢体会。</p><h5 id="2、Nginx-事件模型"><a href="#2、Nginx-事件模型" class="headerlink" title="2、Nginx 事件模型"></a>2、Nginx 事件模型</h5><p>上面讲了很多关于 Nginx 的进程模型，接下来，我们来看看 Nginx 是如何处理事件的。</p><p>有人可能要问了，Nginx 采用多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限啊，多少个 worker 就能处理多少个并发，何来高并发呢？非也，这就是 Nginx 的高明之处，<font color="red">Nginx 采用了异步非阻塞的方式来处理请求，也就是说，Nginx 是可以同时处理成千上万个请求的。</font>想想 apache 的常用工作方式（apache 也有异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），每个请求会独占一个工作线程，当并发数上到几千时，就同时有几千的线程在处理请求了。这对操作系统来说，是个不小的挑战，线程带来的内存占用非常大，线程的上下文切换带来的 cpu 开销很大，自然性能就上不去了，而这些开销完全是没有意义的。</p><p>为什么 Nginx 可以采用异步非阻塞的方式来处理呢，或者异步非阻塞到底是怎么回事呢？我们先回到原点，看看一个请求的完整过程。<strong>首先，请求过来，要建立连接，然后再接收数据，接收数据后，再发送数据。具体到系统底层，就是读写事件，而当读写事件没有准备好时，必然不可操作，如果不用非阻塞的方式来调用，那就得阻塞调用了，事件没有准备好，那就只能等了，等事件准备好了，你再继续吧。阻塞调用会进入内核等待，cpu 就会让出去给别人用了，<font color="red">对单线程的 worker 来说</font>，显然不合适，当网络事件越多时，大家都在等待呢，cpu 空闲下来没人用，cpu利用率自然上不去了，更别谈高并发了。</strong>好吧，你说加进程数，这跟apache的线程模型有什么区别，注意，别增加无谓的上下文切换。所以，<font color="red">在 Nginx 里面，最忌讳阻塞的系统调用了。</font>不要阻塞，那就非阻塞喽。非阻塞就是，事件没有准备好，马上返回 EAGAIN，告诉你，事件还没准备好呢，你慌什么，过会再来吧。好吧，你过一会，再来检查一下事件，直到事件准备好了为止，在这期间，你就可以先去做其它事情，然后再来看看事件好了没。虽然不阻塞了，但你得不时地过来检查一下事件的状态，你可以做更多的事情了，但带来的开销也是不小的。所以，才会有了<font color="red">异步非阻塞的事件处理机制</font>，<strong>具体到系统调用就是像 select/poll/epoll/kqueue 这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。</strong><font color="red">这种机制正好解决了我们上面的两个问题，拿 epoll 为例(在后面的例子中，我们多以 epoll 为例子，以代表这一类函数)，当事件没准备好时，放到 epoll 里面，事件准备好了，我们就去读写，当读写返回 EAGAIN 时，我们将它再次加入到 epoll 里面。这样，只要有事件准备好了，我们就去处理它，只有当所有事件都没准备好时，才在 epoll 里面等着。这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。</font><strong>与多线程相比，这种事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常的轻量级。</strong>并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。 我之前有对连接数进行过测试，在 24G 内存的机器上，处理的并发请求数达到过 200 万。现在的网络服务器基本都采用这种方式，这也是nginx性能高效的主要原因。</p><p>我们之前说过，<font color="red">推荐设置 worker 的个数为 cpu 的核数，在这里就很容易理解了，更多的 worker 数，只会导致进程来竞争 cpu 资源了，从而带来不必要的上下文切换。</font>而且，nginx为了更好的利用多核特性，提供了 cpu 亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来 cache 的失效。像这种小的优化在 Nginx 中非常常见，同时也说明了 Nginx 作者的苦心孤诣。比如，Nginx 在做 4 个字节的字符串比较时，会将 4 个字符转换成一个 int 型，再作比较，以减少 cpu 的指令数等等。</p><p>现在，知道了 Nginx 为什么会选择这样的进程模型与事件模型了。对于一个基本的 Web 服务器来说，事件通常有三种类型，网络事件、信号、定时器。从上面的讲解中知道，网络事件通过异步非阻塞可以很好的解决掉。如何处理信号与定时器？</p><p>首先，<font color="red">信号的处理</font>。对 Nginx 来说，有一些特定的信号，代表着特定的意义。信号会中断掉程序当前的运行，在改变状态后，继续执行。如果是系统调用，则可能会导致系统调用的失败，需要重入。关于信号的处理，大家可以学习一些专业书籍，这里不多说。对于 Nginx 来说，如果nginx正在等待事件（epoll_wait 时），如果程序收到信号，在信号处理函数处理完后，epoll_wait 会返回错误，然后程序可再次进入 epoll_wait 调用。</p><p>另外，再来看看<font color="red">定时器</font>。由于 epoll_wait 等函数在调用的时候是可以设置一个超时时间的，所以 Nginx 借助这个超时时间来实现定时器。nginx里面的定时器事件是放在一颗维护定时器的红黑树里面，每次在进入 epoll_wait前，先从该红黑树里面拿到所有定时器事件的最小时间，在计算出 epoll_wait 的超时时间后进入 epoll_wait。所以，当没有事件产生，也没有中断信号时，epoll_wait 会超时，也就是说，定时器事件到了。这时，nginx会检查所有的超时事件，将他们的状态设置为超时，然后再去处理网络事件。由此可以看出，当我们写 Nginx 代码时，在处理网络事件的回调函数时，通常做的第一个事情就是判断超时，然后再去处理网络事件。</p><p>我们可以用一段伪代码来总结一下 Nginx 的事件处理模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    for t in run_tasks:</span><br><span class="line">        t.handler();</span><br><span class="line">    update_time(&amp;now);</span><br><span class="line">    timeout = ETERNITY;</span><br><span class="line">    for t in wait_tasks: /* sorted already */</span><br><span class="line">        if (t.time &lt;= now) &#123;</span><br><span class="line">            t.timeout_handler();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timeout = t.time - now;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    nevents = poll_function(events, timeout);</span><br><span class="line">    for i in nevents:</span><br><span class="line">        task t;</span><br><span class="line">        if (events[i].type == READ) &#123;</span><br><span class="line">            t.handler = read_handler;</span><br><span class="line">        &#125; else &#123; /* events[i].type == WRITE */</span><br><span class="line">            t.handler = write_handler;</span><br><span class="line">        &#125;</span><br><span class="line">        run_tasks_add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好，本节我们讲了进程模型，事件模型，包括网络事件，信号，定时器事件。</p><h4 id="三、Nginx的工作原理"><a href="#三、Nginx的工作原理" class="headerlink" title="三、Nginx的工作原理"></a>三、Nginx的工作原理</h4><p>nginx 主要用于Web和代理服务器，接收请求，对请求进行解析，静态资源直接返回，动态请求转发到后端做处理。由上面对nginx的架构进行解析知道，nginx常采用多进程的工作方式，nginx启动后，会有一个master进程和多个worker进程生成。master进程主要用来管理worker进程，而worker进程主要就是用来处理请求的，多个worker进程之间是对等的，他们同等竞争客户端的请求，相互之间是独立的。</p><p>每个worker进程中只有一个主线程，且采用异步非阻塞的事件处理机制来处理请求。假设机制处理采用的是epoll，主线程就会循环epoll，如果发现事件已经准备好了，就进行处理，否则再次放入epoll，继续循环。epoll中的请求数就是worker进程的连接数。因此就可处理大量的并发了。要注意，worker同一时间只能处理一个请求（因为只有一个主线程），会来回进行请求切换处理。但是，请求间的切换是没有代价的，切换也是因为异步事件未准备好，而主动让出的。</p><blockquote><font color="red"><strong>工作原理要点：</strong><br>1. nginx采用多进程的工作方式，进程模型是master-worker形式。（注：常采用多进程方式，也有多线程，单进程方式）<br>2. worker处理请求时采用异步非阻塞的处理方式。因此可支持高并发。<br>3. 进程间、线程间是没有上下文切换，仅仅只是请求切换，是没有任何代价的。（注：进程与进程间是相互独立的；每个请求仅且只可在一个worker进程中完成；worker进程中只包含一个主线程；请求间的切换是通过循环事件来实现的。）</font></blockquote><h4 id="四、Nginx相关问题"><a href="#四、Nginx相关问题" class="headerlink" title="四、Nginx相关问题"></a>四、Nginx相关问题</h4><h5 id="1、nginx为啥性能高？"><a href="#1、nginx为啥性能高？" class="headerlink" title="1、nginx为啥性能高？"></a>1、nginx为啥性能高？</h5><p>（1）nginx采用的是多进程模型<br>首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。<br>其次，采用独立的进程，可以让相互之间不会影响，一个进程退出之后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。当然，worker进程的异常退出，肯定是程序出BUG了，异常退出，会导致当前的worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险。<br>（2）nginx采用多进程事件模型：异步非阻塞<br>虽然nginx采用多worker的方式来处理请求，每个worker里面只有一个主线程，那能够处理的并发数很有限啊，多少个worker就能处理多少个并发，何来高并发呢？非也，这就是nginx的高明之处，nginx采用了异步非阻塞的方式来处理请求，也就是说，nginx是可以同时处理成千上万个请求的。一个worker进程可以同时处理的请求数只受限于内存大小，而且在架构设计上，不同的worker进程之间处理并发请求时几乎没有同步锁的限制，worker进程通常不会进入睡眠状态，因此，当Nginx上的进程数与CPU核心数相等时（最好每一个worker进程都绑定特定的CPU核心），进程间切换的代价是最小的。</p><p>而apache的常用工作方式（apache也有异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），每个进程在一个时刻只处理一个请求，因此，当并发数上到几千时，就同时有几千的进程在处理请求了。这对操作系统来说，是个不小的挑战，进程带来的内存占用非常大，进程的上下文切换带来的cpu开销很大，自然性能就上不去了，而这些开销完全是没有意义的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、nginx概述&quot;&gt;&lt;a href=&quot;#一、nginx概述&quot; class=&quot;headerlink&quot; title=&quot;一、nginx概述&quot;&gt;&lt;/a&gt;一、nginx概述&lt;/h4&gt;&lt;p&gt;Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强。&lt;/p&gt;
&lt;h5 id=&quot;1、什么是nginx？&quot;&gt;&lt;a href=&quot;#1、什么是nginx？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是nginx？&quot;&gt;&lt;/a&gt;1、什么是nginx？&lt;/h5&gt;&lt;p&gt;Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。Nginx 是由俄罗斯人 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，它已经在该站点运行超过两年半了。Igor Sysoev 在建立的项目时,使用基于 BSD 许可。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
</feed>
