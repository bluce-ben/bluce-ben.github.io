<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-30T04:16:43.582Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zheng Benwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker之Dockerfile配置LNMP服务实战篇</title>
    <link href="http://yoursite.com/2018/09/30/Docker%E4%B9%8BDockerfile%E9%85%8D%E7%BD%AELNMP%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <id>http://yoursite.com/2018/09/30/Docker之Dockerfile配置LNMP服务实战篇/</id>
    <published>2018-09-30T04:13:48.000Z</published>
    <updated>2018-09-30T04:16:43.582Z</updated>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="http://blog.51cto.com/zpf666/1905555" target="_blank" rel="noopener">传送门</a><br>supervisor：<a href="https://www.cnblogs.com/zhoujinyi/p/6073705.html" target="_blank" rel="noopener">传送门</a><br>详细Dockers学习记录参考：<a href="https://www.cnblogs.com/CloudMan6/tag/%E5%AE%B9%E5%99%A8/default.html?page=10" target="_blank" rel="noopener">传送门</a></p><p>待整理…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考博客：&lt;a href=&quot;http://blog.51cto.com/zpf666/1905555&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;supervisor：&lt;a href=&quot;https://www.cnblogs.com
      
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker之手动配置LNMP服务实战篇</title>
    <link href="http://yoursite.com/2018/09/30/Docker%E4%B9%8B%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AELNMP%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <id>http://yoursite.com/2018/09/30/Docker之手动配置LNMP服务实战篇/</id>
    <published>2018-09-30T04:01:07.000Z</published>
    <updated>2018-09-30T04:07:04.253Z</updated>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="https://blog.csdn.net/xy752068432/article/details/75975065" target="_blank" rel="noopener">传送门</a></p><h5 id="1、安装MySQL"><a href="#1、安装MySQL" class="headerlink" title="1、安装MySQL"></a>1、安装MySQL</h5><ol><li><p>拉取MySQL5.6版本<br><code>docker pull mysql:5.6</code></p></li><li><p>创建并启动一个容器<br><code>docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=xy123456 --name test_mysql mysql:5.6</code></p><a id="more"></a></li><li><p>进入到mysql容器后，我们通过创建一个远程可以访问的用户，这样我们就能从别的主机访问到我们的数据库了。<br>（注：容器中默认是没有vim的，所以我们首先要安装vim,需要注意的是安装前记得先执行apt-get update命令，不然安装会出现问题。）<br><code>docker exec -it test_mysql /bin/bash</code></p></li></ol><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进入数据库授权并新建用户</span><br><span class="line">&gt;mysql -uroot -p &quot;xy123456&quot;</span><br><span class="line">&gt;create database test;</span><br><span class="line">&gt;grant all privileges on test.* to &apos;test&apos;@&apos;%&apos; identified by &apos;123456&apos;;</span><br><span class="line">&gt;grant all privileges on *.* to &apos;root&apos;@&apos;%&apos;;</span><br><span class="line">&gt;exit;</span><br></pre></td></tr></table></figure><h5 id="2、安装PHP"><a href="#2、安装PHP" class="headerlink" title="2、安装PHP"></a>2、安装PHP</h5><ol><li><p>拉取PHP版本<br><code>docker pull php:7.0-fpm</code></p></li><li><p>创建一个phpfpm容器<br><code>docker run -d -v $PWD/nginx/www/html:/var/www/html -p 9001:9000 --link test_mysql:mysql --name test_phpfpm php:7.0-fpm</code></p></li><li><p>进入容器中，并在 /var/www/html 下新建一个 index.php文件；查看宿主机中的 ./nginx/www/html下是否也有 index.php</p></li><li><p>在容器中，需要安装<code>pdo_mysql</code>模块，在docker容器中可以这样来安装<br><code>docker-php-ext-install pdo_mysql</code><br>然后，通过命令 <code>php -m</code> 查看我们的PHP所有模块（后面会用到PDO来测试数据库的连通性）。</p></li></ol><h5 id="3、安装Nginx"><a href="#3、安装Nginx" class="headerlink" title="3、安装Nginx"></a>3、安装Nginx</h5><ol><li><p>拉取Nginx版本<br><code>docker pull nginx:1.10.3</code></p></li><li><p>创建一个Nginx容器<br><code>docker run -d -p 8080:80 --name test_nginx -v $PWD/nginx/www/html:/var/www/html --link test_phpfpm:phpfpm nginx:1.10.3</code></p></li><li><p>进入容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y vim</span><br><span class="line">apt-get install -y net-tools</span><br></pre></td></tr></table></figure></li></ol><p>再容器里找到nginx的配置文件，并修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root           /var/www/html;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    fastcgi_pass   phpfpm:9000;//这里改成我们之前--link进来的容器，也可以直接用php容器的ip</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME $document_root$fastcdi_script_name;//如果你的根目录和php容器的根目录不一样，这里的$document_root需要换成你php下的根目录，不然php就找不到文件了</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>（注：docker容器中服务修改配置，需要重新启动，才能生效。）</strong></p><h5 id="4、测试连通性"><a href="#4、测试连通性" class="headerlink" title="4、测试连通性"></a>4、测试连通性</h5><ol><li>直接访问nginx，检测nginx端口是否映射成功。（失败可在容器中查看nginx日志。）</li><li>访问php文件，检测nginx与php的连通性。（失败可查看容器日志，<code>docker logs container_id -f</code>）</li><li>通过php文件操作数据库，检测nginx、php与mysql的连通性。</li></ol><p>检测代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">try &#123;</span><br><span class="line">    $con = new PDO(&apos;mysql:host=mysql;dbname=test&apos;, &apos;xuye&apos;, &apos;xy123456&apos;);</span><br><span class="line">    $con-&gt;query(&apos;SET NAMES UTF8&apos;);</span><br><span class="line">    $res =  $con-&gt;query(&apos;select * from test&apos;);</span><br><span class="line">    while ($row = $res-&gt;fetch(PDO::FETCH_ASSOC)) &#123;</span><br><span class="line">        echo &quot;id:&#123;$row[&apos;id&apos;]&#125; name:&#123;$row[&apos;name&apos;]&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (PDOException $e) &#123;</span><br><span class="line">     echo &apos;错误原因：&apos;  . $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结说明：</p><ol><li>同一个host下容器之间通信，由于现在的版本，只要默认生成的容器，都会加入到Docker默认的docker0网络下。相互之间可通信。（缺点：相同端口的容器只可开启一个容器。）</li><li>承接上面，在生成容器的时候，可不添加 –link仍可相互通信。（已验证。–link可更改容器中使用的容器名称）</li></ol><p><strong>常用命令特殊安装：</strong></p><table><thead><tr><th>安装命令</th><th>安装包</th><th>命令</th></tr></thead><tbody><tr><td>ps</td><td>procps</td><td>apt-get install -y procps</td></tr><tr><td>netstat</td><td>net-tools</td><td>apt-get install -y net-tools</td></tr><tr><td>ping</td><td>inetutils-ping</td><td>apt-get install inetutils-ping</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考博客：&lt;a href=&quot;https://blog.csdn.net/xy752068432/article/details/75975065&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;1、安装MySQL&quot;&gt;&lt;a href=&quot;#1、安装MySQL&quot; class=&quot;headerlink&quot; title=&quot;1、安装MySQL&quot;&gt;&lt;/a&gt;1、安装MySQL&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;拉取MySQL5.6版本&lt;br&gt;&lt;code&gt;docker pull mysql:5.6&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建并启动一个容器&lt;br&gt;&lt;code&gt;docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=xy123456 --name test_mysql mysql:5.6&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker之容器间通信</title>
    <link href="http://yoursite.com/2018/09/30/Docker%E4%B9%8B%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2018/09/30/Docker之容器间通信/</id>
    <published>2018-09-30T04:00:38.000Z</published>
    <updated>2018-09-30T04:08:03.837Z</updated>
    
    <content type="html"><![CDATA[<p>容器之间可通过 IP，Docker DNS Server 或 joined 容器三种方式通信。</p><h4 id="IP-通信"><a href="#IP-通信" class="headerlink" title="IP 通信"></a>IP 通信</h4><p>两个容器要能通信，必须要有属于同一个网络的网卡。<br>满足这个条件后，容器就可以通过 IP 交互了。具体做法是在容器创建时通过 –network 指定相应的网络，或者通过 docker network connect 将现有容器加入到指定网络。<br><a id="more"></a></p><h4 id="Docker-DNS-Server"><a href="#Docker-DNS-Server" class="headerlink" title="Docker DNS Server"></a>Docker DNS Server</h4><p>通过 IP 访问容器虽然满足了通信的需求，但还是不够灵活。因为我们在部署应用之前可能无法确定 IP，部署之后再指定要访问的 IP 会比较麻烦。对于这个问题，可以通过 docker 自带的 DNS 服务解决。</p><p>从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过“容器名”通信。方法很简单，只要在启动时用 –name 为容器命名就可以了。</p><p>下面启动两个容器 bbox1 和 bbox2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network=my_net2 --name=bbox1 busybox</span><br><span class="line">docker run -it --network=my_net2 --name=bbox2 busybox</span><br></pre></td></tr></table></figure></p><p>然后，bbox2 就可以直接 ping 到 bbox1 了：<br><img src="/uploads/2018/09/docker-network-communication-01.jpg" alt=""></p><p>使用 docker DNS 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的。下面验证一下：<br>创建 bbox3 和 bbox4，均连接到 bridge 网络。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=bbox3 busybox</span><br><span class="line">docker run -it --name=bbox4 busybox</span><br></pre></td></tr></table></figure></p><p>bbox4 无法 ping 到 bbox3。<br><img src="/uploads/2018/09/docker-network-communication-02.jpg" alt=""></p><h4 id="joined-容器"><a href="#joined-容器" class="headerlink" title="joined 容器"></a>joined 容器</h4><p>joined 容器是另一种实现容器间通信的方式。<br>joined 容器非常特别，它可以使两个或多个容器共享一个网络栈，共享网卡和配置信息，joined 容器之间可以通过 127.0.0.1 直接通信。请看下面的例子：</p><p>先创建一个 httpd 容器，名字为 web1。<br><code>docker run -d -it --name=web1 httpd</code><br>然后创建 busybox 容器并通过 <code>--network=container:web1</code> 指定 jointed 容器为 web1：<br><img src="/uploads/2018/09/docker-network-communication-03.jpg" alt=""></p><p>请注意 busybox 容器中的网络配置信息，下面我们查看一下 web1 的网络：<br><img src="/uploads/2018/09/docker-network-communication-04.jpg" alt=""></p><p>看！busybox 和 web1 的网卡 mac 地址与 IP 完全一样，它们共享了相同的网络栈。busybox 可以直接用 127.0.0.1 访问 web1 的 http 服务。<br><img src="/uploads/2018/09/docker-network-communication-05.jpg" alt=""></p><p>joined 容器非常适合以下场景：</p><ol><li>不同容器中的程序希望通过 loopback 高效快速地通信，比如 web server 与 app server。</li><li>希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。</li></ol><p>容器之间的通信我们已经搞清楚了，接下来要考虑的是容器如何与外部世界通信？</p><h4 id="容器如何访问到外部世界？"><a href="#容器如何访问到外部世界？" class="headerlink" title="容器如何访问到外部世界？"></a>容器如何访问到外部世界？</h4><p><strong>容器默认就能访问外网。</strong><br>详细信息查看博客：<a href="https://www.cnblogs.com/CloudMan6/p/7107407.html" target="_blank" rel="noopener">传送门</a></p><h4 id="外部世界如何访问容器？"><a href="#外部世界如何访问容器？" class="headerlink" title="外部世界如何访问容器？"></a>外部世界如何访问容器？</h4><p>答案是：<strong>端口映射。</strong></p><p>docker 可将容器对外提供服务的端口映射到 host 的某个端口，外网通过该端口访问容器。容器启动时通过-p参数映射端口：<br><img src="/uploads/2018/09/docker-network-communication-06.jpg" alt=""></p><p>容器启动后，可通过 docker ps 或者 docker port 查看到 host 映射的端口。在上面的例子中，httpd 容器的 80 端口被映射到 host 32773 上，这样就可以通过 <code>&lt;host ip&gt;:&lt;32773&gt;</code> 访问容器的 web 服务了。<br><img src="/uploads/2018/09/docker-network-communication-07.jpg" alt=""></p><p>除了映射动态端口，也可在 -p 中指定映射到 host 某个特定端口，例如可将 80 端口映射到 host 的 8080 端口：<br><img src="/uploads/2018/09/docker-network-communication-08.jpg" alt=""></p><p>每一个映射的端口，host 都会启动一个 docker-proxy 进程来处理访问容器的流量：<br><img src="/uploads/2018/09/docker-network-communication-09.jpg" alt=""></p><p>以 0.0.0.0:32773-&gt;80/tcp 为例分析整个过程：<br><img src="/uploads/2018/09/docker-network-communication-10.jpg" alt=""></p><ol><li>docker-proxy 监听 host 的 32773 端口。</li><li>当 curl 访问 10.0.2.15:32773 时，docker-proxy 转发给容器 172.17.0.2:80。</li><li>httpd 容器响应请求并返回结果。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器之间可通过 IP，Docker DNS Server 或 joined 容器三种方式通信。&lt;/p&gt;
&lt;h4 id=&quot;IP-通信&quot;&gt;&lt;a href=&quot;#IP-通信&quot; class=&quot;headerlink&quot; title=&quot;IP 通信&quot;&gt;&lt;/a&gt;IP 通信&lt;/h4&gt;&lt;p&gt;两个容器要能通信，必须要有属于同一个网络的网卡。&lt;br&gt;满足这个条件后，容器就可以通过 IP 交互了。具体做法是在容器创建时通过 –network 指定相应的网络，或者通过 docker network connect 将现有容器加入到指定网络。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker之容器网络解析</title>
    <link href="http://yoursite.com/2018/09/30/Docker%E4%B9%8B%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/30/Docker之容器网络解析/</id>
    <published>2018-09-30T04:00:17.000Z</published>
    <updated>2018-09-30T04:09:21.285Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Docker原生网络"><a href="#一、Docker原生网络" class="headerlink" title="一、Docker原生网络"></a>一、Docker原生网络</h4><p>Docker 网络从覆盖范围可分为单个 host 上的容器网络和跨多个 host 的网络。</p><h5 id="1、单个-host-上的容器网络"><a href="#1、单个-host-上的容器网络" class="headerlink" title="1、单个 host 上的容器网络"></a>1、单个 host 上的容器网络</h5><p>Docker 安装时会自动在 host 上创建三个网络，我们可用 docker network ls 命令查看：<br><img src="/uploads/2018/09/docker-network-01.jpg" alt=""><br><a id="more"></a></p><h6 id="（1）none-网络"><a href="#（1）none-网络" class="headerlink" title="（1）none 网络"></a>（1）none 网络</h6><p>故名思议，none 网络就是什么都没有的网络。挂在这个网络下的容器除了 lo，没有其他任何网卡。容器创建时，可以通过 –network=none 指定使用 none 网络。<br><img src="/uploads/2018/09/docker-network-none.jpg" alt=""></p><p>我们不禁会问，这样一个封闭的网络有什么用呢？<br>其实还真有应用场景。封闭意味着隔离，一些对安全性要求高并且不需要联网的应用可以使用 none 网络。<br>比如某个容器的唯一用途是生成随机密码，就可以放到 none 网络中避免密码被窃取。</p><h6 id="（2）host-网络"><a href="#（2）host-网络" class="headerlink" title="（2）host 网络"></a>（2）host 网络</h6><p>连接到 host 网络的容器共享 Docker host 的网络栈，容器的网络配置与 host 完全一样。可以通过 –network=host 指定使用 host 网络。<br><img src="/uploads/2018/09/docker-network-host.jpg" alt=""></p><p>在容器中可以看到 host 的所有网卡，并且连 hostname 也是 host 的。host 网络的使用场景又是什么呢？<br>直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。当然不便之处就是牺牲一些灵活性，比如要考虑端口冲突问题，Docker host 上已经使用的端口就不能再用了。</p><p>Docker host 的另一个用途是让容器可以直接配置 host 网路。比如某些跨 host 的网络解决方案，其本身也是以容器方式运行的，这些方案需要对网络进行配置，比如管理 iptables。</p><h6 id="（3）bridge-网络"><a href="#（3）bridge-网络" class="headerlink" title="（3）bridge 网络"></a>（3）bridge 网络</h6><p>应用最广泛也是默认的 bridge 网络。<br>Docker 安装时会创建一个 命名为 docker0 的 linux bridge。如果不指定–network，创建的容器默认都会挂到 docker0 上。<br><img src="/uploads/2018/09/docker-network-02.jpg" alt=""></p><blockquote><p>使用brctl命令，需要安装</p></blockquote><p>当前 docker0 上没有任何其他网络设备，我们创建一个容器看看有什么变化。<br><img src="/uploads/2018/09/docker-network-03.jpg" alt=""><br>一个新的网络接口 veth28c57df 被挂到了 docker0 上，veth28c57df就是新创建容器的虚拟网卡。</p><p>下面看一下容器的网络配置。<br><img src="/uploads/2018/09/docker-network-04.jpg" alt=""><br>容器有一个网卡 eth0@if34。大家可能会问了，为什么不是veth28c57df 呢？</p><p>实际上 eth0@if34 和 veth28c57df 是一对 veth pair。veth pair 是一种成对出现的特殊网络设备，可以把它们想象成由一根虚拟网线连接起来的一对网卡，网卡的一头（eth0@if34）在容器中，另一头（veth28c57df）挂在网桥 docker0 上，其效果就是将 eth0@if34 也挂在了 docker0 上。</p><p>我们还看到 eth0@if34 已经配置了 IP 172.17.0.2，为什么是这个网段呢？让我们通过 docker network inspect bridge 看一下 bridge 网络的配置信息:<br><img src="/uploads/2018/09/docker-network-05.jpg" alt=""></p><p>原来 bridge 网络配置的 subnet 就是 172.17.0.0/16，并且网关是 172.17.0.1。这个网关在哪儿呢？大概你已经猜出来了，就是 docker0。<br><img src="/uploads/2018/09/docker-network-06.jpg" alt=""></p><p>当前容器网络拓扑结构如图所示：<br><img src="/uploads/2018/09/docker-network-07.jpg" alt=""><br>容器创建时，docker 会自动从 172.17.0.0/16 中分配一个 IP，这里 16 位的掩码保证有足够多的 IP 可以供容器使用。</p><h5 id="2、跨多个-host-的网络"><a href="#2、跨多个-host-的网络" class="headerlink" title="2、跨多个 host 的网络"></a>2、跨多个 host 的网络</h5><p>待补充…</p><h4 id="二、自定义网络"><a href="#二、自定义网络" class="headerlink" title="二、自定义网络"></a>二、自定义网络</h4><p>除了 none, host, bridge 这三个自动创建的网络，用户也可以根据业务需要创建 user-defined 网络。</p><p>Docker 提供三种 user-defined 网络驱动：bridge, overlay 和 macvlan。overlay 和 macvlan 用于创建跨主机的网络。</p><p>我们可通过 bridge 驱动创建类似前面默认的 bridge 网络，例如<br><img src="/uploads/2018/09/docker-network-bridge-01.jpg" alt=""></p><p>查看一下当前 host 的网络结构变化：<br><img src="/uploads/2018/09/docker-network-bridge-02.jpg" alt=""></p><p>新增了一个网桥 br-eaed97dc9a77，这里 eaed97dc9a77 正好新建 bridge 网络 my_net 的短 id。执行 docker network inspect 查看一下 my_net 的配置信息：<br><img src="/uploads/2018/09/docker-network-bridge-03.jpg" alt=""></p><p>这里 172.18.0.0/16 是 Docker 自动分配的 IP 网段。</p><p>我们可以自己指定 IP 网段吗？<br>答案是：可以。</p><p>只需在创建网段时指定 –subnet 和 –gateway 参数：<br><img src="/uploads/2018/09/docker-network-bridge-04.jpg" alt=""></p><p>这里我们创建了新的 bridge 网络 my_net2，网段为 172.22.16.0/24，网关为 172.22.16.1。与前面一样，网关在 my_net2 对应的网桥 br-5d863e9f78b6 上：<br><img src="/uploads/2018/09/docker-network-bridge-05.jpg" alt=""></p><p>容器要使用新的网络，需要在启动时通过 –network 指定：<br><img src="/uploads/2018/09/docker-network-bridge-06.jpg" alt=""></p><p>容器分配到的 IP 为 172.22.16.2。</p><p>到目前为止，容器的 IP 都是 docker 自动从 subnet 中分配，我们能否指定一个静态 IP 呢？</p><p>答案是：可以，通过–ip指定。<br><img src="/uploads/2018/09/docker-network-bridge-07.jpg" alt=""><br>注：<strong>只有使用 –subnet 创建的网络才能指定静态 IP。</strong></p><p>my_net 创建时没有指定 –subnet，如果指定静态 IP 报错如下：<br><img src="/uploads/2018/09/docker-network-bridge-08.jpg" alt=""></p><p>好了，我们来看看当前 docker host 的网络拓扑结构。<br><img src="/uploads/2018/09/docker-network-bridge-09.jpg" alt=""></p><h4 id="三、理解容器之间的连通性"><a href="#三、理解容器之间的连通性" class="headerlink" title="三、理解容器之间的连通性"></a>三、理解容器之间的连通性</h4><p>通过上面的实践，当前 docker host 的网络拓扑结构如下图所示<br><img src="/uploads/2018/09/docker-network-bridge-10.jpg" alt=""></p><p>两个 busybox 容器都挂在 my_net2 上，应该能够互通，我们验证一下：<br><img src="/uploads/2018/09/docker-network-bridge-11.jpg" alt=""><br>可见同一网络中的容器、网关之间都是可以通信的。</p><p>my_net2 与默认 bridge 网络能通信吗？</p><p>从拓扑图可知，两个网络属于不同的网桥，应该不能通信，我们通过实验验证一下，让 busybox 容器 ping httpd 容器：<br><img src="/uploads/2018/09/docker-network-bridge-12.jpg" alt=""><br>确实 ping 不通，符合预期。</p><p>原因：<strong>iptables DROP 掉了网桥 docker0 与 br-5d863e9f78b6 之间双向的流量。</strong><br>从规则的命名 DOCKER-ISOLATION 可知 docker 在设计上就是要隔离不同的 netwrok。</p><p>那么接下来的问题是：怎样才能让 busybox 与 httpd 通信呢？<br>答案是：为 httpd 容器添加一块 net_my2 的网卡。这个可以通过docker network connect 命令实现。</p><p><img src="/uploads/2018/09/docker-network-bridge-13.jpg" alt=""></p><p>我们在 httpd 容器中查看一下网络配置：<br><img src="/uploads/2018/09/docker-network-bridge-14.jpg" alt=""></p><p>容器中增加了一个网卡 eth1，分配了 my_net2 的 IP 172.22.16.3。现在 busybox 应该能够访问 httpd 了，验证一下：<br><img src="/uploads/2018/09/docker-network-bridge-15.jpg" alt=""></p><p>busybox 能够 ping 到 httpd，并且可以访问 httpd 的 web 服务。当前网络结构如图所示：<br><img src="/uploads/2018/09/docker-network-bridge-16.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、Docker原生网络&quot;&gt;&lt;a href=&quot;#一、Docker原生网络&quot; class=&quot;headerlink&quot; title=&quot;一、Docker原生网络&quot;&gt;&lt;/a&gt;一、Docker原生网络&lt;/h4&gt;&lt;p&gt;Docker 网络从覆盖范围可分为单个 host 上的容器网络和跨多个 host 的网络。&lt;/p&gt;
&lt;h5 id=&quot;1、单个-host-上的容器网络&quot;&gt;&lt;a href=&quot;#1、单个-host-上的容器网络&quot; class=&quot;headerlink&quot; title=&quot;1、单个 host 上的容器网络&quot;&gt;&lt;/a&gt;1、单个 host 上的容器网络&lt;/h5&gt;&lt;p&gt;Docker 安装时会自动在 host 上创建三个网络，我们可用 docker network ls 命令查看：&lt;br&gt;&lt;img src=&quot;/uploads/2018/09/docker-network-01.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker之问题集锦</title>
    <link href="http://yoursite.com/2018/09/29/Docker%E4%B9%8B%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://yoursite.com/2018/09/29/Docker之问题集锦/</id>
    <published>2018-09-29T09:26:13.000Z</published>
    <updated>2018-09-29T09:26:57.481Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、WINDOWS下错误集锦"><a href="#一、WINDOWS下错误集锦" class="headerlink" title="一、WINDOWS下错误集锦"></a>一、WINDOWS下错误集锦</h4><h5 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h5><p>解决 Docker pull 出现的net/http: TLS handshake timeout 的一个办法</p><p>解决思路：百度搜了下net/http: TLS handshake timeout</p><p>出现一个这个结果比较满意<br><code>http://dockone.io/article/876?utm_source=tuicool&amp;utm_medium=referral</code><br>我不用官方的dockhub了，转而使用国内的仓库daocloud<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;DOCKER_OPTS=\&quot;\$DOCKER_OPTS --registry-mirror=http://f2d6cb40.m.daocloud.io\&quot;&quot; | sudo tee -a /etc/default/docker</span><br><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure></p><p>重启docker服务后，再次pull 就 ok了<br><a id="more"></a></p><h5 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h5><p>运行Dockerfile启动容器的时候报错，如下：<br><code>docker: executable file not found in $PATH</code></p><p>问题出现的原因：<br>主要原因是docker 执行的时候没有找到对应的Dockerfile文件位置。</p><p>解决方法：<br>在执行<code>docker run</code>的时候，要指定Dockerfile的运行目录位置。如果DOckerfile在当前目录，则在命令后添加“.”即可。（必须项，否则会报此错误。）</p><h5 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h5><p>在Windows家庭版下安装了docker，并尝试在其中运行jupyter notebook等服务，但映射完毕之后，在主机的浏览器中，打开localhost:port无法访问对应的服务。</p><p>问题出现的原因：</p><blockquote><p>The reason you’re having this, is because on Linux, the docker daemon (and your containers) run on the Linux machine itself, so “localhost” is also the host that the container is running on, and the ports are mapped to.<br>On Windows (and OS X), the docker daemon, and your containers cannot run natively, so only the docker client is running on your Windows machine, but the daemon (and your containers) run in a VirtualBox Virtual Machine, that runs Linux.</p><p>因为docker是运行在Linux上的，在Windows中运行docker，实际上还是在Windows下先安装了一个Linux环境，然后在这个系统中运行的docker。也就是说，服务中使用的localhost指的是这个Linux环境的地址，而不是我们的宿主环境Windows。</p></blockquote><p>解决方法：<br>通过命令 <code>docker-machine ip default</code><br>其中，default 是docker-machine的name，可以通过<code>docker-machine -ls</code> 查看<br>找到这个Linux的ip地址，一般情况下这个地址是192.168.99.100，然后在Windows的浏览器中，输入这个地址，加上服务的端口即可启用了。<br>（<a href="https://www.cnblogs.com/hypnus-ly/p/8683215.html" target="_blank" rel="noopener">参考博客</a>）</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、WINDOWS下错误集锦&quot;&gt;&lt;a href=&quot;#一、WINDOWS下错误集锦&quot; class=&quot;headerlink&quot; title=&quot;一、WINDOWS下错误集锦&quot;&gt;&lt;/a&gt;一、WINDOWS下错误集锦&lt;/h4&gt;&lt;h5 id=&quot;问题一&quot;&gt;&lt;a href=&quot;#问题一&quot; class=&quot;headerlink&quot; title=&quot;问题一&quot;&gt;&lt;/a&gt;问题一&lt;/h5&gt;&lt;p&gt;解决 Docker pull 出现的net/http: TLS handshake timeout 的一个办法&lt;/p&gt;
&lt;p&gt;解决思路：百度搜了下net/http: TLS handshake timeout&lt;/p&gt;
&lt;p&gt;出现一个这个结果比较满意&lt;br&gt;&lt;code&gt;http://dockone.io/article/876?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/code&gt;&lt;br&gt;我不用官方的dockhub了，转而使用国内的仓库daocloud&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ echo &amp;quot;DOCKER_OPTS=\&amp;quot;\$DOCKER_OPTS --registry-mirror=http://f2d6cb40.m.daocloud.io\&amp;quot;&amp;quot; | sudo tee -a /etc/default/docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo service docker restart&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;重启docker服务后，再次pull 就 ok了&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker之Dockerfile详解</title>
    <link href="http://yoursite.com/2018/09/28/Docker%E4%B9%8BDockerfile%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/09/28/Docker之Dockerfile详解/</id>
    <published>2018-09-28T09:43:38.000Z</published>
    <updated>2018-09-29T09:23:50.149Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Dockerfile详解"><a href="#一、Dockerfile详解" class="headerlink" title="一、Dockerfile详解"></a>一、Dockerfile详解</h4><h5 id="（1）Dockerfile包含的信息"><a href="#（1）Dockerfile包含的信息" class="headerlink" title="（1）Dockerfile包含的信息"></a>（1）Dockerfile包含的信息</h5><ul><li>基础镜像信息 </li><li>维护者信息 </li><li>镜像操作指令 </li><li>容器启动时执行指令<a id="more"></a><h5 id="（2）文件的编写"><a href="#（2）文件的编写" class="headerlink" title="（2）文件的编写"></a>（2）文件的编写</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># This is docker file</span><br><span class="line"># version v1</span><br><span class="line"># Author wangshibo</span><br><span class="line"># Base image(基础镜像)</span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line"># Maintainer(维护者信息)</span><br><span class="line">MAINTAINER wangshibo  2134728394@qq.com</span><br><span class="line"></span><br><span class="line"># Commands(执行命令)</span><br><span class="line">RUN rpm -ivh  http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line">RUN yum -y install nginx</span><br><span class="line"># Add(添加文件)</span><br><span class="line">ADD index.html /usr/share/nginx/html/index.html    # index.html是自己编写的文件，放在后面的目录中，因为yum安装后Documentroot是在这里</span><br><span class="line">RUN echo &quot;daemon off;&quot; &gt;&gt;/etc/nginx/nginx.conf</span><br><span class="line">EXPOSE 80           # 对外的端口</span><br><span class="line">CMD [&apos;nginx&apos;]       # 执行的命令</span><br></pre></td></tr></table></figure></li></ul><p><img src="./images/docker-dockerfile.png" alt=""></p><h5 id="（3）构建容器，并运行"><a href="#（3）构建容器，并运行" class="headerlink" title="（3）构建容器，并运行"></a>（3）构建容器，并运行</h5><blockquote><p>建立newnginx容器，-t：标签，执行/opt/dockerfile/nginx/下面的默认的Dockerfile文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linux-node2 nginx]# docker build -t cgt/mynginx:v3 /opt/dockerfile/nginx/</span><br><span class="line">[root@linux-node2 nginx]# docker run -d -p 83:80 cgt/mynginx:v3</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="二、指令说明"><a href="#二、指令说明" class="headerlink" title="二、指令说明"></a>二、指令说明</h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>指定所创建镜像的基础镜像</td></tr><tr><td>MAINTAINER</td><td>指定维护者信息</td></tr><tr><td>RUN</td><td>运行命令</td></tr><tr><td>CMD</td><td>指定启动容器时默认执行的命令</td></tr><tr><td>LABEL</td><td>指定生成镜像的元数据标签信息</td></tr><tr><td>EXPOSE</td><td>声明镜像内服务所监听的端口</td></tr><tr><td>ENV</td><td>指定环境变量</td></tr><tr><td>ADD</td><td>赋值指定的<code>&lt;src&gt;</code>路径下的内容到容器中的<code>&lt;dest&gt;</code>路径下，<code>&lt;src&gt;</code>可以为URL；如果为tar文件，会自动解压到<code>&lt;dest&gt;</code>路径下</td></tr><tr><td>COPY</td><td>赋值本地主机的<code>&lt;src&gt;</code>路径下的内容到容器中的<code>&lt;dest&gt;</code>路径下；一般情况下推荐使用COPY而不是ADD</td></tr><tr><td>ENTRYPOINT</td><td>指定镜像的默认入口</td></tr><tr><td>VOLUME</td><td>创建数据挂载点</td></tr><tr><td>USER</td><td>指定运行容器时的用户名或UID</td></tr><tr><td>WORKDIR</td><td>配置工作目录</td></tr><tr><td>ARG</td><td>指定镜像内使用的参数（例如版本号信息等）</td></tr><tr><td>ONBUILD</td><td>配置当前所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作的命令</td></tr><tr><td>STOPSIGNAL</td><td>容器退出的信号</td></tr><tr><td>HEALTHCHECK</td><td>如何进行健康检查</td></tr><tr><td>SHELL</td><td>指定使用SHELL时的默认SHELL类型</td></tr></tbody></table><h5 id="1-FROM"><a href="#1-FROM" class="headerlink" title="1. FROM"></a>1. FROM</h5><p>指定所创建的镜像的基础镜像，如果本地不存在，则默认会去Docker Hub下载指定镜像。<br>格式为：<br><code>FROM &lt;image&gt;</code>，或<code>FROM &lt;image&gt;:&lt;tag&gt;</code>，或<code>FROM &lt;image&gt;@&lt;digest&gt;</code><br>任何Dockerfile中的第一条指令必须为FROM指令。并且，如果在同一个Dockerfile文件中创建多个镜像，可以使用多个FROM指令(每个镜像一次)。</p><h5 id="2-MAINTAINER"><a href="#2-MAINTAINER" class="headerlink" title="2. MAINTAINER"></a>2. MAINTAINER</h5><p>指定维护者信息。<br>格式为：<br><code>MAINTAINER &lt;name&gt;</code><br>例如：<br>MAINTAINER <a href="mailto:image_creator@docker.com" target="_blank" rel="noopener">image_creator@docker.com</a><br>该信息将会写入生成镜像的Author属性域中。</p><h5 id="3-RUN"><a href="#3-RUN" class="headerlink" title="3. RUN"></a>3. RUN</h5><p>运行指定命令。<br>格式为：<br><code>RUN &lt;command&gt;</code> 或 <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></p><font color="red">注意：后一个指令会被解析为json数组，所以必须使用双引号。</font><br>前者默认将在shell终端中运行命令，即/bin/sh -c；后者则使用exec执行，不会启动shell环境。<br>指定使用其他终端类型可以通过第二种方式实现，例如：<br><code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code><br>每条RUN指令将在当前镜像的基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用\换行。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update \</span><br><span class="line">        &amp;&amp; apt-get install -y libsnappy-dev zliblg-dev libbz2-dev \</span><br><span class="line">        &amp;&amp; rm -rf /var/cache/apt</span><br></pre></td></tr></table></figure><br><br>##### 4. CMD #####<br>CMD指令用来指定启动容器时默认执行的命令。它支持三种格式：<br>1. <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 使用exec执行，是推荐使用的方式；<br>2. <code>CMD param1 param2</code>  在/bin/sh中执行，提供给需要交互的应用；<br>3. <code>CMD [&quot;param1&quot;, &quot;param2&quot;]</code>  提供给ENTRYPOINT的默认参数。<br><br>每个Dockerfile只能有一条CMD命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时指定了运行的命令(作为run的参数)，则会覆盖掉CMD指定的命令。<br><br>##### 5. LABEL #####<br>LABEL指令用来生成用于生成镜像的元数据的标签信息。<br>格式为：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code><br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=&quot;1.0&quot;</span><br><span class="line">LABEL description=&quot;This text illustrates \ that label-values can span multiple lines.&quot;</span><br></pre></td></tr></table></figure><br><br>##### 6. EXPOSE #####<br>声明镜像内服务所监听的端口。<br>格式为：<code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code><br>例如：<br><code>EXPOSE 22 80 443 3306</code><br><font color="red">注意：<br>该命令只是起到声明租用，并不会自动完成端口映射。<br>在容器启动时需要使用-P(大写P)，Docker主机会自动分配一个宿主机未被使用的临时端口转发到指定的端口；使用-p(小写p)，则可以具体指定哪个宿主机的本地端口映射过来。</font><h5 id="7-ENV"><a href="#7-ENV" class="headerlink" title="7. ENV"></a>7. ENV</h5><p>指定环境变量，在镜像生成过程中会被后续RUN指令使用，在镜像启动的容器中也会存在。<br>格式为：<code>ENV &lt;key&gt;&lt;value&gt;或ENV&lt;key&gt;=&lt;value&gt;...</code><br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENV GOLANG_VERSION 1.6.3</span><br><span class="line">ENV GOLANG_DOWNLOAD_RUL https://golang.org/dl/go$GOLANG_VERSION.linux-amd64.tar.gz</span><br><span class="line">ENV GOLANG_DOWNLOAD_SHA256 cdd5e08530c0579255d6153b08fdb3b8e47caabbe717bc7bcd7561275a87aeb</span><br><span class="line"></span><br><span class="line">RUN curl -fssL &quot;$GOLANG_DOWNLOAD_RUL&quot; -o golang.tar.gz &amp;&amp; echo &quot;$GOLANG_DOWNLOAD_SHA256 golang.tar.gz&quot; | sha256sum -c - &amp;&amp; tar -C /usr/local -xzf golang.tar.gz &amp;&amp; rm golang.tar.gz</span><br><span class="line"></span><br><span class="line">ENV GOPATH $GOPATH/bin:/usr/local/go/bin:$PATH</span><br><span class="line"></span><br><span class="line">RUN mkdir -p &quot;$GOPATH/bin&quot; &amp;&amp; chmod -R 777 &quot;$GOPATH&quot;</span><br></pre></td></tr></table></figure></p><p>指令指定的环境变量在运行时可以被覆盖掉，如<code>docker run --env &lt;key&gt;=&lt;value&gt; built_image</code>。</p><h5 id="8-ADD"><a href="#8-ADD" class="headerlink" title="8. ADD"></a>8. ADD</h5><p>该指令将复制指定的<src>路径下的内容到容器中的<dest>路径下。<br>格式为：<code>ADD&lt;src&gt; &lt;dest&gt;</code><br>其中<code>&lt;src&gt;</code>可以使Dockerfile所在目录的一个相对路径(文件或目录)，也可以是一个URL，还可以是一个tar文件(如果是tar文件，会自动解压到<code>&lt;dest&gt;</code>路径下)。<code>&lt;dest&gt;</code>可以使镜像内的绝对路径，或者相当于工作目录(WORKDIR)的相对路径。路径支持正则表达式，例如：<br><code>ADD *.c /code/</code></dest></src></p><h5 id="9-COPY"><a href="#9-COPY" class="headerlink" title="9. COPY"></a>9. COPY</h5><p>复制本地主机的<code>&lt;src&gt;</code>(为Dockerfile所在目录的一个相对路径、文件或目录)下的内容到镜像中的<code>&lt;dest&gt;</code>下。目标路径不存在时，会自动创建。路径同样支持正则。<br>格式为：<code>COPY &lt;src&gt; &lt;dest&gt;</code><br>当使用本地目录为源目录时，推荐使用COPY。</p><h5 id="10-ENTRYPOINT"><a href="#10-ENTRYPOINT" class="headerlink" title="10. ENTRYPOINT"></a>10. ENTRYPOINT</h5><p>指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有传入值作为该命令的参数。<br>支持两种格式：</p><ol><li><code>ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> (exec调用执行)；</li><li><code>ENTRYPOINT command param1 param2</code>(shell中执行)。</li></ol><p>此时，CMD指令指定值将作为根命令的参数。<br>每个Dockerfile中只能有一个ENTRYPOINT，当指定多个时，只有最后一个有效。<br>在运行时可以被<code>--entrypoint</code>参数覆盖掉，如<code>docker run --entrypoint</code>。</p><h5 id="11-VOLUME"><a href="#11-VOLUME" class="headerlink" title="11. VOLUME"></a>11. VOLUME</h5><p>创建一个数据卷挂载点。<br>格式为：<code>VOLUME [&quot;/data&quot;]</code><br>可以从本地主机或者其他容器挂载数据卷，一般用来存放数据库和需要保存的数据等。</p><h5 id="12-USER"><a href="#12-USER" class="headerlink" title="12. USER"></a>12. USER</h5><p>指定运行容器时的用户名或UID，后续的RUN等指令也会使用特定的用户身份。<br>格式为：<code>USER daemon</code><br>当服务不需要管理员权限时，可以通过该指令指定运行用户，并且可以在之前创建所需要的用户。例如：<br><code>RUN groupadd -r nginx &amp;&amp; useradd -r -g nginx nginx</code><br>要临时获取管理员权限可以用gosu或者sudo。</p><h5 id="13-WORKDIR"><a href="#13-WORKDIR" class="headerlink" title="13. WORKDIR"></a>13. WORKDIR</h5><p>为后续的RUN、CMD和ENTRYPOINT指令配置工作目录。<br>格式为：<code>WORKDIR /path/to/workdir</code><br>可以使用多个WORKDIR指令，后续命令如果参数是相对的，则会基于之前命令指定的路径。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure></p><p>则最终路径为/a/b/c</p><h5 id="14-ARG"><a href="#14-ARG" class="headerlink" title="14. ARG"></a>14. ARG</h5><p>指定一些镜像内使用的参数(例如版本号信息等)，这些参数在执行<code>docker build</code>命令时才以<code>--build-arg&lt;varname&gt;=&lt;value&gt;</code>格式传入。<br>格式为：<code>ARG&lt;name&gt;[=&lt;default value&gt;]</code><br>则可以用<code>docker build --build-arg&lt;name&gt;=&lt;value&gt;</code>来指定参数值。</p><h5 id="15-ONBUILD"><a href="#15-ONBUILD" class="headerlink" title="15. ONBUILD"></a>15. ONBUILD</h5><p>配置当所创建的镜像作为其他镜像的基础镜像的时候，所执行创建操作指令。<br>格式为：<code>ONBUILD [INSTRUCTION]</code><br>例如Dockerfile使用如下的内容创建了镜像image-A：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></p><p>如果基于image-A镜像创建新的镜像时，新的Dockerfile中使用FROM image-A指定基础镜像，会自动执行ONBUILD指令的内容，等价于在后面添加了两条指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM image-A</span><br><span class="line"></span><br><span class="line"># Automatically run the following</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure></p><p>使用ONBUILD指令的镜像，推荐在标签中注明，例如：<code>ruby:1.9-onbuild</code>。</p><h4 id="三、后记"><a href="#三、后记" class="headerlink" title="三、后记"></a>三、后记</h4><p>从需求出发，定制适合自己需求、高效方便的镜像，可以参考他人优秀的Dockerfile文件，在构建中慢慢优化Dockerfile文件：</p><ol><li>精简镜像用途：                 尽量让每个镜像的用途都比较集中、单一，避免构造大而复杂、多功能的镜像；</li><li>选用合适的基础镜像：            过大的基础镜像会造成构建出臃肿的镜像，一般推荐比较小巧的镜像作为基础镜像；</li><li>提供详细的注释和维护者信息：     Dockerfile也是一种代码，需要考虑方便后续扩展和他人使用；</li><li>正确使用版本号：               使用明确的具体数字信息的版本号信息，而非latest，可以避免无法确认具体版本号，统一环境；</li><li>减少镜像层数：                减少镜像层数建议尽量合并RUN指令，可以将多条RUN指令的内容通过&amp;&amp;连接；</li><li>及时删除临时和缓存文件：        这样可以避免构造的镜像过于臃肿，并且这些缓存文件并没有实际用途；</li><li>提高生产速度：                合理使用缓存、减少目录下的使用文件，使用.dockeringore文件等；</li><li>调整合理的指令顺序：           在开启缓存的情况下，内容不变的指令尽量放在前面，这样可以提高指令的复用性；</li><li>减少外部源的干扰：             如果确实要从外部引入数据，需要制定持久的地址，并带有版本信息，让他人可以重复使用而不出错。</li><li>不要在容器中存储数据：            容器可能被停止，销毁，或替换。一个运行在容器中的程序版本1.0，应该很容易被1.1的版本替换且不影响或损失数据。有鉴于此，如果你需要存储数据，请存在卷中，并且注意如果两个容器在同一个卷上写数据会导致崩溃。确保你的应用被设计成在共享数据存储上写入。</li><li>不要在镜像中存储凭据。使用环境变量：        不要将镜像中的任何用户名/密码写死。使用环境变量来从容器外部获取此信息。</li><li>使用非root用户运行进程：        “docker容器默认以root运行。（…）随着docker的成熟，更多的安全默认选项变得可用。现如今，请求root对于其他人是危险的，可能无法在所有环境中可用。你的镜像应该使用USER指令来指令容器的一个非root用户来运行。”</li><li>不要依赖IP地址：        每个容器都有自己的内部IP地址，如果你启动并停止它地址可能会变化。如果你的应用或微服务需要与其他容器通讯，使用任何命名与（或者）环境变量来从一个容器传递合适信息到另一个。</li></ol><h4 id="附属实例：Nginx（已验证）"><a href="#附属实例：Nginx（已验证）" class="headerlink" title="附属实例：Nginx（已验证）"></a>附属实例：Nginx（已验证）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM  centos</span><br><span class="line"></span><br><span class="line">MAINTAINER 2018-04-011 lipengcheng 777@qq.com</span><br><span class="line"></span><br><span class="line">RUN  yum -y install gcc*  make pcre-devel zlib-devel</span><br><span class="line"></span><br><span class="line">RUN  rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm &amp;&amp; yum -y install nginx</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、Dockerfile详解&quot;&gt;&lt;a href=&quot;#一、Dockerfile详解&quot; class=&quot;headerlink&quot; title=&quot;一、Dockerfile详解&quot;&gt;&lt;/a&gt;一、Dockerfile详解&lt;/h4&gt;&lt;h5 id=&quot;（1）Dockerfile包含的信息&quot;&gt;&lt;a href=&quot;#（1）Dockerfile包含的信息&quot; class=&quot;headerlink&quot; title=&quot;（1）Dockerfile包含的信息&quot;&gt;&lt;/a&gt;（1）Dockerfile包含的信息&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;基础镜像信息 &lt;/li&gt;
&lt;li&gt;维护者信息 &lt;/li&gt;
&lt;li&gt;镜像操作指令 &lt;/li&gt;
&lt;li&gt;容器启动时执行指令
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker之基础篇</title>
    <link href="http://yoursite.com/2018/09/28/Docker%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://yoursite.com/2018/09/28/Docker之基础篇/</id>
    <published>2018-09-28T08:32:51.000Z</published>
    <updated>2018-09-29T09:22:39.151Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h4><h5 id="1、容器生命周期管理"><a href="#1、容器生命周期管理" class="headerlink" title="1、容器生命周期管理"></a>1、容器生命周期管理</h5><ol><li>运行容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run [-it] [-d] [--name container_name] [-p container_port:host_port] imageId</span><br><span class="line">参数详解：</span><br><span class="line">-i  打开容器的标准输入STDIN。</span><br><span class="line">-t 为容器建立一个命令行终端。Ctrl+D退出容器</span><br><span class="line">-d 以deamon后台运行</span><br><span class="line">-p  宿主机与容器端口建立映射</span><br><span class="line">--name 为容器命名一个name</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>进入运行中的容器<br><code>docker exec -it container_id /bin/sh</code></p></li><li><p>查看运行中的容器日志信息<br><code>docker logs container_id</code></p></li><li><p>停止所有容器<br><code>docker stop $(docker ps -qa)</code></p></li><li><p>删除所有容器<br><code>docker rm [-f] $(docker ps -qa)</code></p></li><li><p>删除所有镜像<br><code>docker rmi [-f] $(docker ps -qa)</code></p></li><li><p>导入导出(未操作，待添加)<br><code>docker load</code><br><code>docker save</code><br><code>docker export</code><br><code>docker import</code></p></li></ol><h5 id="2、容器操作"><a href="#2、容器操作" class="headerlink" title="2、容器操作"></a>2、容器操作</h5><ol><li><p>新建容器<br><code>docker build -t container_name/container_tag</code> ./</p></li><li><p>容器开启/关闭/重启<br><code>docker start/stop/restart container_id</code></p></li><li><p>查看容器详细信息<br><code>docker inspect container_id</code></p></li><li><p>查看容器端口信息<br><code>docker port container_id</code></p></li><li><p>查看运行中的容器<br><code>docker ps</code></p></li><li><p>重新命名容器名称<br><code>docker rename container_id new_name</code></p></li><li><p>删除容器<br><code>docker rm [-f] container_id</code></p></li><li><p>进入容器（进入到容器启动命令的终端）<br><code>docker attach 94ab7a046f7c</code></p></li></ol><h5 id="3、镜像仓库"><a href="#3、镜像仓库" class="headerlink" title="3、镜像仓库"></a>3、镜像仓库</h5><ol><li><p>查看docker信息<br><code>docker info</code><br>（要点：Registry: <a href="https://index.docker.io/v1/" target="_blank" rel="noopener">https://index.docker.io/v1/</a> 镜像仓库地址）</p></li><li><p>查看本地镜像文件<br><code>docker images</code></p></li><li><p>查看镜像<br><code>docker search whalesay</code>  //从镜像仓库中查询镜像文件</p></li><li><p>拉取镜像<br><code>docker pull whalesay</code></p></li><li><p>推送本地镜像到远程仓库（注：必须先登录，之后才能成功推送。登录使用<code>docker login</code>）<br><code>docker push myname/whalesay</code></p></li><li><p>删除镜像<br><code>docker rmi [-f] container_id</code></p></li><li><p>Docker重命名镜像名称和TAG<br><code>docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签）</code></p></li></ol><h4 id="二、Docker概念"><a href="#二、Docker概念" class="headerlink" title="二、Docker概念"></a>二、Docker概念</h4><p>Docker是开发人员和系统管理员开发、部署和运行带有容器的应用程序的平台。使用Linux容器来部署应用程序称为“容器化”。容器不是一个新概念，但是使用它们能够轻松部署应用程序。</p><p><strong>容器越来越受欢迎，有如下优点：</strong></p><ul><li>灵活：即使是最复杂的应用程序也可以被容器化</li><li>轻量级：容器利用并共享宿主内核</li><li>可互换：您可以动态地部署更新和升级</li><li>可移植：您可以在本地构建，部署到云中，并在任何地方运行</li><li>可伸缩：您可以增加并自动分发容器副本。</li></ul><p>Docker有三个大的概念：<em>Images（镜像）</em>、<em>Containers（容器）</em>、<em>Registry（仓库）</em></p><blockquote><p><strong>Docker 镜像</strong><br>Docker 镜像是Docker容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。Docker 使用 UnionFS 来将这些层联合到单独的镜像中。UnionFS 允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新 的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。</p></blockquote><blockquote><p><strong>Docker 仓库</strong><br>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。同样的，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。Docker 仓库是 Docker 的分发部分。</p></blockquote><blockquote><p><strong>Docker 容器</strong><br>Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台，Docker 容器是 Docker 的运行部分。</p></blockquote><p><strong>镜像和容器：</strong><br>一个容器是通过运行一个图像来启动的。图像是一个可执行的包，它包含运行应用程序所需的一切——代码、运行时、库、环境变量和配置文件。</p><p><strong>容器和虚拟机：</strong><br>一个容器在Linux上运行，并与其他容器共享主机的内核。它运行一个离散的过程，没有比任何其他可执行文件更少的内存，使它变得轻量级。<br>相比之下，虚拟机（VM）运行一个成熟的“客户”操作系统，通过虚拟机监控程序虚拟访问主机资源。一般来说，VMs提供的环境比大多数应用程序需要的资源都多。</p><table><br>  <tr><br>    <td><center><img src="/uploads/2018/09/container_vm_01.png"></center></td><br>    <td><center><img src="/uploads/2018/09/container_vm_02.png"></center></td><br>  </tr><br></table><h4 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h4><h5 id="1、Windows版"><a href="#1、Windows版" class="headerlink" title="1、Windows版"></a>1、Windows版</h5><p>win7、win8 等需要利用 docker toolbox 来安装，国内可以使用阿里云的镜像来下载，下载地址：<a href="http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/" target="_blank" rel="noopener">传送门</a><br>win10 直接下载官方的安装包：<a href="http://www.docker-cn.com/community-edition#/overview" target="_blank" rel="noopener">传送门</a></p><blockquote><p>docker toolbox 是一个工具集，它主要包含以下一些内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Docker CLI 客户端，用来运行docker引擎创建镜像和容器</span><br><span class="line">Docker Machine. 可以让你在windows的命令行中运行docker引擎命令</span><br><span class="line">Docker Compose. 用来运行docker-compose命令</span><br><span class="line">Kitematic. 这是Docker的GUI版本</span><br><span class="line">Docker QuickStart shell. 这是一个已经配置好Docker的命令行环境</span><br><span class="line">Oracle VM Virtualbox. 虚拟机</span><br></pre></td></tr></table></figure></p></blockquote><p>下载完成之后直接点击安装，安装成功后，桌边会出现三个图标，入下图所示：<br><img src="/uploads/2018/09/docker-toolbox-01.png" alt=""></p><h5 id="2、Linux版"><a href="#2、Linux版" class="headerlink" title="2、Linux版"></a>2、Linux版</h5><ol><li><p>移除旧的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></li><li><p>安装一些必要的系统工具<br><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></p></li><li><p>添加软件源信息<br><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></p><blockquote><p>如果报错：<br>使用yum命令报错File “/bin/yum-config-manager”, line 133 except yum.Errors.RepoError, e: SyntaxError: invalid syntax问题<br><code>vim /bin/yum-config-manager</code>打开，可看见首行为 /usr/bin/python ，由报错可看出使用的是Python2的语法，而我单独安装了Python3，且设置为默认版本导致的语法错误。将/usr/bin/python2 更改为使用版本2的即可。</p></blockquote></li><li><p>更新 yum 缓存<br><code>sudo yum makecache fast</code></p></li><li><p>安装Docker-ce<br><code>sudo yum -y install docker-ce</code></p></li><li><p>启动Docker后台服务<br><code>sudo systemctl start docker</code></p></li><li><p>测试运行 hello-world<br><code>docker run hello-world</code></p></li></ol><p><strong>镜像加速</strong><br>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决。<br>比较常用的是网易的镜像中心和daocloud镜像市场。 </p><ul><li>网易镜像中心：<a href="https://c.163.com/hub#/m/home/" target="_blank" rel="noopener">https://c.163.com/hub#/m/home/</a> </li><li>daocloud镜像市场：<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">https://hub.daocloud.io/</a></li></ul><p>我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。请在该配置文件中加入（没有该文件的话，请先建一个。配置文件默认是在" target="_blank" rel="noopener">http://hub-mirror.c.163.com。请在该配置文件中加入（没有该文件的话，请先建一个。配置文件默认是在</a> /etc/default/docker）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以刚开始我在寻找/etc/default/docker这个配置文件，一直找不到，后来发现是因为系统和版本的差异。<br>在centos7上这个配置文件已经被更改为 /etc/docker/daemon.json 。<br>可以在这个配置中添加相应的registry-mirrors路径 。<br>原来是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# cat daemon.json </span><br><span class="line">&#123;</span><br><span class="line">    &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;http://ef017c13.m.daocloud.io&quot;],</span><br><span class="line">    &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以手动vim添加，也可以使用daocloud给出的命令直接更改（建议使用命令）<br><code>[root@localhost docker]# curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://ef017c13.m.daocloud.io</code><br>更改后重启docker<br><code>systemctl restart docker</code></p><p><strong>删除Docker CE</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker-ce</span><br><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、常用命令&quot;&gt;&lt;a href=&quot;#一、常用命令&quot; class=&quot;headerlink&quot; title=&quot;一、常用命令&quot;&gt;&lt;/a&gt;一、常用命令&lt;/h4&gt;&lt;h5 id=&quot;1、容器生命周期管理&quot;&gt;&lt;a href=&quot;#1、容器生命周期管理&quot; class=&quot;headerlink&quot; title=&quot;1、容器生命周期管理&quot;&gt;&lt;/a&gt;1、容器生命周期管理&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;运行容器&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run [-it] [-d] [--name container_name] [-p container_port:host_port] imageId&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数详解：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-i  打开容器的标准输入STDIN。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-t 	为容器建立一个命令行终端。Ctrl+D退出容器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-d 	以deamon后台运行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-p  宿主机与容器端口建立映射&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--name 	为容器命名一个name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>ORDER BY与索引</title>
    <link href="http://yoursite.com/2018/08/28/ORDER-BY%E4%B8%8E%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2018/08/28/ORDER-BY与索引/</id>
    <published>2018-08-28T11:04:48.000Z</published>
    <updated>2018-08-28T11:08:52.530Z</updated>
    
    <content type="html"><![CDATA[<p>一条SQL实际上可以分为三步。</p><ol><li>得到数据</li><li>处理数据</li><li>返回处理后的数据</li></ol><p>比如这条语句<code>select sid from zhuyuehua.student where sid &lt; 50000 and id &lt; 50000 order by id desc</code><br>第一步：根据where条件和统计信息生成执行计划，得到数据。<br>第二步：将得到的数据排序。<br><strong>当执行处理数据（order by）时，数据库会先查看第一步的执行计划，看order by 的字段是否在执行计划中利用了索引。如果是，则可以利用索引顺序而直接取得已经排好序的数据。</strong>如果不是，则排序操作。<br>第三步：返回排序后的数据。 </p><p>总结：<br><strong>当order by 中的字段出现在where条件中时，才会利用索引而不排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作。</strong></p><p>这个结论不仅对order by有效，对其他需要排序的操作也有效。比如<strong><font color="red">group by 、union 、distinct</font></strong>等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一条SQL实际上可以分为三步。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;得到数据&lt;/li&gt;
&lt;li&gt;处理数据&lt;/li&gt;
&lt;li&gt;返回处理后的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如这条语句&lt;code&gt;select sid from zhuyuehua.student where sid &amp;
      
    
    </summary>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
      <category term="SQL优化" scheme="http://yoursite.com/categories/SQL%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
      <category term="SQL优化" scheme="http://yoursite.com/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux 配置支持IPv6</title>
    <link href="http://yoursite.com/2018/08/28/Linux-%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81IPv6/"/>
    <id>http://yoursite.com/2018/08/28/Linux-配置支持IPv6/</id>
    <published>2018-08-28T09:56:05.000Z</published>
    <updated>2018-08-28T10:21:10.209Z</updated>
    
    <content type="html"><![CDATA[<p>由于ipv4已经不能满足当前的使用，ipv6出现了，也必将兼容ipv4的地位。因此，下面是配置ipv6的步骤：</p><h4 id="一、检查Linux是否已经开启ipv6"><a href="#一、检查Linux是否已经开启ipv6" class="headerlink" title="一、检查Linux是否已经开启ipv6"></a>一、检查Linux是否已经开启ipv6</h4><p><code>[root@iz2ze3oyrjbxg32wecre15z /]# ifconfig</code><br><a id="more"></a><br><img src="/uploads/2018/08/network_ipv6_01.png" alt=""></p><p>从结果看出，输出结果没有 ipv6支持，如果支持ipv6，则输出结果会包含 “inet6”。<br><img src="/uploads/2018/08/network_ipv6_02.png" alt=""></p><p>可以测试一下，如果环境已经支持，则可以不用往下看了！</p><h4 id="二、开启ipv6"><a href="#二、开启ipv6" class="headerlink" title="二、开启ipv6"></a>二、开启ipv6</h4><p>（1）找到配置sysctl.conf 文件，路径在：<code>/etc/sysctl.conf</code> ，找到如下配置：<br><img src="/uploads/2018/08/network_ipv6_03.png" alt=""></p><p>如果已经存在，则直接修改，如果不存在，则新增。<br>将列出的ipv6相关配置更改为0<br><img src="/uploads/2018/08/network_ipv6_04.png" alt=""></p><p>（2）找到 disable_ipv6.conf 文件，路径在: <code>/etc/modprobe.d/disable_ipv6.conf</code><br>找到如下配置：<br><img src="/uploads/2018/08/network_ipv6_05.png" alt=""></p><p>列出的配置更改为 0<br><img src="/uploads/2018/08/network_ipv6_06.png" alt=""></p><p>（3）找到 network.conf 文件，路径在：<code>/etc/sysconfig/network</code><br>找到如下配置：<br><img src="/uploads/2018/08/network_ipv6_07.png" alt=""></p><p>将列出的配置更改为 yes<br><img src="/uploads/2018/08/network_ipv6_08.png" alt=""></p><p>（4）重启网络服务<br><code>[root@iz2ze3oyrjbxg32wecre15z /]# service network restart</code></p><p>（5）通过ifconfig 命令检查是否已经启动ipv6<br><code>[root@iz2ze3oyrjbxg32wecre15z /]# ifconfig|grep -i inet6</code><br><img src="/uploads/2018/08/network_ipv6_09.png" alt=""></p><p>结果显示，已经包含 inet6 相关信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于ipv4已经不能满足当前的使用，ipv6出现了，也必将兼容ipv4的地位。因此，下面是配置ipv6的步骤：&lt;/p&gt;
&lt;h4 id=&quot;一、检查Linux是否已经开启ipv6&quot;&gt;&lt;a href=&quot;#一、检查Linux是否已经开启ipv6&quot; class=&quot;headerlink&quot; title=&quot;一、检查Linux是否已经开启ipv6&quot;&gt;&lt;/a&gt;一、检查Linux是否已经开启ipv6&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[root@iz2ze3oyrjbxg32wecre15z /]# ifconfig&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VPN 与 VPS的区别</title>
    <link href="http://yoursite.com/2018/08/28/VPN-%E4%B8%8E-VPS%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/08/28/VPN-与-VPS的区别/</id>
    <published>2018-08-28T09:48:27.000Z</published>
    <updated>2018-08-28T09:50:55.625Z</updated>
    
    <content type="html"><![CDATA[<p>VPS：是Virtual Private Server的英文件缩写，说得是在一台服务器上创建多个相互隔离的虚拟服务器。这些虚拟服务器以最大化的效率共享硬件、软件许可证以及管理资源。对其用户和应用程序来讲，每一个VPS平台的运行和管理都和一台独立主机完全相同，因为每一个VPS都可以独立进行重启，并拥有自己的root访问权限、用户、IP地址、内存、过程、文件、应用程序、系统函数库以及配置文件。<br><a id="more"></a><br>VPN：是Virtual Private Network的英文缩写，也就是虚拟专用网络。在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。</p><p><strong>VPN和VPS的区别：</strong><br>我们可以把VPS理解为服务器。一台服务器用软件分割开以后，就成了多台服务器，他们有独立的操作系统，具有独立的IP，这个时候每一个小的独立操作系统，就是一个VPS。也可以理解为，VPS就是一个配置低了点的服务器。<br>VPN是一个软件。用一个帐号和密码，我们登陆了以后，我们的机器访问网站或者是上QQ或者是登陆一些网络软件的时候，所显示的和使用的IP都是国外的。也就是说，VPN是一个可以让我们的机器直接连接到国外的网线上的东西。VPN分为两种，一种是静态的VPN，另外一种就是动态的VPN。动态的VPN是每登陆一次，就变化一次IP的。</p><p><strong>VPN的用途：</strong><br>VPN的主要用途：用来做国外的EBAY。<br>VPN在国内最主要的用途：做国外的游戏。例如现在想打国外的游戏币，就要购买VPN，这也是VPN的主要用途。<br>VPN的其它用途：供游戏币工作室来使用，其次是供一些做国外注册类网站的朋友使用。</p><p><strong>VPS的用途：</strong><br>VPS主机主要是从空间转向服务器一个过渡。特点就是价格便宜，但是稳定性一般。<br>VPS是桌面操作的，用远程登陆以后，和自己的机器是一样的布局，可以在上面安装软件等。<br>VPS的另外一个常用的用途，就是用来做下载站。因为毕竟是虚拟主机，所以速度比一般的空间要快得多，同时硬盘也大，适合做下载站。所以一般做迅雷的，都会选择一个VPS主机。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VPS：是Virtual Private Server的英文件缩写，说得是在一台服务器上创建多个相互隔离的虚拟服务器。这些虚拟服务器以最大化的效率共享硬件、软件许可证以及管理资源。对其用户和应用程序来讲，每一个VPS平台的运行和管理都和一台独立主机完全相同，因为每一个VPS都可以独立进行重启，并拥有自己的root访问权限、用户、IP地址、内存、过程、文件、应用程序、系统函数库以及配置文件。&lt;br&gt;
    
    </summary>
    
      <category term="随记" scheme="http://yoursite.com/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="随记" scheme="http://yoursite.com/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>windows 下设置定时任务</title>
    <link href="http://yoursite.com/2018/08/28/windows-%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/08/28/windows-下设置定时任务/</id>
    <published>2018-08-28T08:53:45.000Z</published>
    <updated>2018-08-28T10:50:35.608Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 系统可以通过crontab -e 设置定时任务，Windows系统没有crontab命令，但是Windows系统有跟crontab命令比较接近的命令： schtasks 命令。</p><a id="more"></a><h4 id="schtasks-语法"><a href="#schtasks-语法" class="headerlink" title="schtasks 语法"></a>schtasks 语法</h4><h5 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h5><p><strong>语法</strong><br><code>schtasks /create /tn TaskName /tr TaskRun /sc schedule [/mo modifier] [/d day] [/m month[,month...] [/i IdleTime] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\]user /p password]] [/ru {[Domain\]User | &quot;System&quot;} [/rp Password]] /?</code></p><p><strong>参数</strong><br>/tn TaskName         指定任务的名称。<br>/tr TaskRun 指定任务运行的程序或命令。键入可执行文件、脚本文件或批处理文件的完全合格的路径和文件名。（如果忽略该路径，SchTasks.exe 将假定文件在 Systemroot\System32 目录下。）<br>/sc schedule           指定计划类型。有效值为 MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY、ONCE、ONSTART、ONLOGON、ONIDLE。</p><blockquote><p>值说明<br>MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY         指定计划的时间单位。<br>ONCE     任务在指定的日期和时间运行一次。<br>ONSTART     任务在每次系统启动的时候运行。可以指定启动的日期，或下一次系统启动的时候运行任务。<br>ONLOGON     每当用户（任意用户）登录的时候，任务就运行。可以指定日期，或在下次用户登录的时候运行任务。<br>ONIDLE         只要系统空闲了指定的时间，任务就运行。可以指定日期，或在下次系统空闲的时候运行任务。</p></blockquote><p>/mo modifier         指定任务在其计划类型内的运行频率。这个参数对于 MONTHLY 计划是必需的。对于 MINUTE、HOURLY、DAILY 或 WEEKLY 计划，这个参数有效，但也可选。默认值为 1。</p><blockquote><p>计划类型<br>修饰符<br>说明<br>MINUTE<br>1 ～ 1439<br>任务每 n 分钟运行一次。<br>HOURLY<br>1 ～ 23<br>任务每 n 小时运行一次。<br>DAILY<br>1 ～ 365<br>任务每 n 天运行一次。<br>WEEKLY<br>1 ～ 52<br>任务每 n 周运行一次。<br>MONTHLY<br>1 ～ 12<br>任务每 n 月运行一次。<br>LASTDAY<br>任务在月份的最后一天运行。<br>FIRST、SECOND、THIRD、FOURTH、LAST<br>与 /d day 参数共同使用,并在特定的周和天运行任务。例如，在月份的第三个周三。</p></blockquote><p>/d dirlist         指定周或月的一天。只与 WEEKLY 或 MONTHLY 计划共同使用时有效。</p><blockquote><p>计划类型<br>日期值<br>WEEKLY<br>可选项。有效值是 MON ~ SUN 和 * （每一天）。MON 是默认值。<br>MONTHLY<br>在使用 FIRST、SECOND、THIRD、FOURTH 或 LAST 修饰符 (/mo) 时，需要 MON ～ SUN 中的某个值。1 ～ 31 是可选的，只在没有修饰符或修饰符为 1 ～ 12 类型时有效。默认值是 1 （月份的第一天）。</p></blockquote><p>/m month[,month…]         指定一年中的一个月。有效值是 JAN ～ DEC 和 <em> （每个月）。/m 参数只对于 MONTHLY 计划有效。在使用 LASTDAY 修饰符时，这个参数是必需的。否则，它是可选的，默认值是 </em> （每个月）。<br>/i InitialPageFileSize         指定任务启动之前计算机空闲多少分钟。键入一个 1 ～ 999 之间的整数。这个参数只对于 ONIDLE 计划有效，而且是必需的。<br>/st StartTime                 以 HH:MM:SS 24 小时格式指定时间。默认值是命令完成时的当前本地时间。/st 参数只对于 MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY 和 ONCE 计划有效。它只对于 ONCE 计划是必需的。<br>/sd StartDate                 以 MM/DD/YYYY 格式指定任务启动的日期。默认值是当前日期。/sd 参数对于所有的计划有效，但只对于 ONCE 计划是必需的。<br>/ed EndDate                 指定任务计划运行的最后日期。此参数是可选的。它对于 ONCE、ONSTART、ONLOGON 或 ONIDLE 计划无效。默认情况下，计划没有结束日期。<br>/s Computer                 指定远程计算机的名称或 IP 地址（带有或者没有反斜杠）。默认值是本地计算机。<br>/u [domain]user             使用特定用户帐户的权限运行命令。默认情况下，使用已登录到运行 SchTasks 的计算机上的用户的权限运行命令。<br>/p password                 指定在 /u 参数中指定的用户帐户的密码。如果使用 /u 参数，则需要该参数。<br>/ru {[Domain]User | “System”}         使用指定用户帐户的权限运行任务。默认情况下，使用用户登录到运行 SchTasks 的计算机上的权限运行任务。</p><blockquote><p>值<br>说明<br>[domain}User?<br>指定用户帐户。<br>“System” 或 “”<br>指定操作系统使用的 NT Authority\System 帐户。</p></blockquote><p>/p Password                 指定用户帐户的密码，该用户帐户在 /u 参数中指定。如果在指定用户帐户的时候忽略了这个参数，SchTasks.exe 会提示您输入密码而且不显示键入的文本。使用 NT Authority\System 帐户权限运行的任务不需要密码，SchTasks.exe 也不会提示索要密码。<br>/?                             在命令提示符显示帮助。</p><p><strong>示例</strong><br>（1）计划任务每 20 分钟运行一次。（从脚本创建成功开始计时）<br><code>schtasks /create /sc minute /mo 20 /tn &quot;Security Script&quot; /tr \\central\data\scripts\sec.vbs</code></p><p>（2）计划命令在每小时过五分的时候运行。<br><code>schtasks /create /sc hourly /st 00:05:00 /tn &quot;My App&quot; /tr c:\apps\myapp.exe</code></p><p>（3）计划命令每五小时运行一次（它使用 /mo 参数来指定间隔时间，使用 /sd 参数来指定起始日期。）<br><code>schtasks /create /sc hourly /mo 5 /sd 03/01/2001 /tn &quot;My App&quot; /tr c:\apps\myapp.exe</code></p><p>（4）计划任务每天运行一次<br><code>schtasks /create /tn &quot;My App&quot; /tr c:\apps\myapp.exe /sc daily /st 08:00:00 /ed 12/31/2001</code></p><p>（5）计划任务每隔一天运行一次（命令使用 /mo 参数来指定间隔天数。使用 /st 参数来指定起始时间， /sd 参数来指定起始日期。）<br><code>schtasks /create /tn &quot;My App&quot; /tr c:\apps\myapp.exe /sc daily /mo 2 /st 13:00:00 /sd 12/31/2001</code></p><p>（6）计划任务每六周运行一次<br><code>schtasks /create /tn &quot;My App&quot; /tr c:\apps\myapp.exe /sc weekly /mo 6 /s Server16 /ru Admin01</code><br>（该命令使用 /mo 参数来指定间隔。它也使用 /s 参数来指定远程计算机，使用 /ru 参数来计划任务以用户的 Administrator 帐户权限运行。因为忽略了 /rp 参数，SchTasks.exe 会提示用户输入 Administrator 帐户密码。<br>另外，因为命令是远程运行的，所以命令中所有的路径，包括到 MyApp.exe 的路径，都是指向远程计算机上的路径。）</p><p>（7）计划任务每隔一周在周五运行<br><code>schtasks /create /tn &quot;My App&quot; /tr c:\apps\myapp.exe /sc weekly /mo 2 /d FRI</code><br>（下面的命令计划任务每隔一周在周五运行。它使用 /mo 参数来指定两周的间隔，使用 /d 参数来指定是一周内的哪一天。如计划任务在每个周五运行，要忽略 /mo 参数或将其设置为 1。）</p><p>（8）计划任务运行一次<br><code>schtasks /create /tn &quot;My App&quot; /tr c:\apps\myapp.exe /sc once /st 00:00:00 /sd 01/01/2002 /ru Admin23 /rp p@ssworD1</code><br>（下面的命令计划 MyApp 程序在 2002 年 1 月 1 日午夜运行一次。它使用 /ru 参数指定以用户的 Administrator 帐户权限运行任务，使用 /rp 参数为 Administrator 帐户提供密码。）</p><p>（9）计划任务在每次系统启动的时候运行（下面的命令计划 MyApp 程序在每次系统启动的时候运行，起始日期是 2001 年 3 月 15 日。）<br><code>schtasks /create /tn &quot;My App&quot; /tr c:\apps\myapp.exe /sc onstart /sd 03/15/2001</code></p><p>（10）计划任务在用户登录到远程计算机的时候运行<br><code>schtasks /create /tn &quot;Start Web Site&quot; /tr c:\myiis\webstart.bat /sc onlogon /s Server23</code><br>（下面的命令计划批处理文件在用户（任何用户）每次登录到远程计算机上的时候运行。它使用 /s 参数指定远程计算机。因为命令是远程的，所以命令中所有的路径，包括批处理文件的路径，都指定为远程计算机上的路径。）</p><p>（11）计划某项任务在计算机空闲的时候运行<br><code>schtasks /create /tn &quot;My App&quot; /tr c:\apps\myapp.exe /sc onidle /i 10</code><br>（下面的命令计划 MyApp 程序在计算机空闲的时候运行。它使用必需的 /i 参数指定在启动任务之前计算机必需持续空闲十分钟。）</p><h5 id="立即执行计划任务"><a href="#立即执行计划任务" class="headerlink" title="立即执行计划任务"></a>立即执行计划任务</h5><p>立即运行计划任务。run 操作忽略计划，但使用程序文件位置、用户帐户和存储在任务中的密码立即运行任务。<br><strong>语法</strong><br><code>schtasks /run /tn TaskName [/s computer [/u [domain\]user /p password]] /?</code><br><strong>示例：</strong><br>在本地计算机上运行任务<br>下面的命令启动 “Security Script” 任务。<br><code>schtasks /run /tn &quot;Security Script&quot;</code></p><p>在远程计算机上运行任务<br>下面的命令在远程计算机 Svr01 上运行 Update 任务：<br><code>schtasks /run /tn Update /s Svr01</code></p><h5 id="终止由任务启动的程序"><a href="#终止由任务启动的程序" class="headerlink" title="终止由任务启动的程序"></a>终止由任务启动的程序</h5><p><strong>语法</strong><br><code>schtasks /end /tn TaskName [/s computer [/u [domain\]user /p password]] /?</code><br><strong>示例</strong><br>终止本地计算机上的任务<br>下面的命令终止由 My Notepad 任务启动的 Notepad 实例：<br><code>schtasks /end /tn &quot;My Notepad&quot;</code><br>终止远程计算机上的任务<br>下面的命令终止远程计算机 Svr01 上由 InternetOn 任务启动的 Internet Explorer 实例：<br><code>schtasks /end /tn InternetOn /s Svr01</code></p><h5 id="删除计划任务"><a href="#删除计划任务" class="headerlink" title="删除计划任务"></a>删除计划任务</h5><p><strong>语法</strong><br><code>schtasks /delete /tn {TaskName | *} [/f] [/s computer [/u [domain\]user /p password]] [/?]</code><br><strong>示例</strong><br>（1）从远程计算机上的计划表中删除任务<br>下面的命令从远程计算机上的计划表中删除 “Start Mail” 任务。它使用 /s 参数来标识远程计算机。<br><code>schtasks /delete /tn &quot;Start Mail&quot; /s Svr16</code></p><p>（2）删除所有为本地计算机计划的任务。<br>下面的命令从本地计算机的计划表中删除所有的任务，包括由其它用户计划的任务。它使用 /tn <em> 参数代表计算机上所有的任务，使用/f 参数取消确认消息。<br>`schtasks /delete /tn </em> /f`</p><h5 id="更改计划任务"><a href="#更改计划任务" class="headerlink" title="更改计划任务"></a>更改计划任务</h5><p>更改一个或多个下列任务属性。</p><ul><li>任务运行的程序 (/tr)。</li><li>任务运行的用户帐户 (/ru)。</li><li>用户帐户的密码 (/rp)。</li></ul><p><strong>语法</strong><br><code>schtasks /change /tn TaskName [/s computer [/u [domain\]user /p password]] [/tr TaskRun] [/ru [Domain\]User | &quot;System&quot;] [/rp Password]</code><br><strong>示例</strong><br>（1）更改任务运行的程序<br>下面的命令将 Virus Check 任务运行的程序由 VirusCheck.exe 更改为 VirusCheck2.exe。此命令使用 /tn 参数标识任务，使用 /tr 参数指定任务的新程序。（不能更改任务名称。）<br><code>schtasks /change /tn &quot;Virus Check&quot; /tr C:\VirusCheck2.exe</code></p><p>（2）更改远程任务的用户密码<br>下面的命令更改用于远程计算机 Svr01 上 RemindMe 任务的用户帐户密码。命令使用 /tn 参数标识任务，使用 /s 参数指定远程计算机。它使用 /rp 参数指定新的密码 p@ssWord3。<br>在用户帐户密码过期或更改的时候需要此过程。如果存储在任务中的密码无效，那么任务不会运行。<br><code>schtasks /change /tn RemindMe /s Svr01 /rp p@ssWord3</code></p><h5 id="显示计划任务"><a href="#显示计划任务" class="headerlink" title="显示计划任务"></a>显示计划任务</h5><p>显示计划在计算机上运行的所有任务，包括那些由其它用户计划的任务。<br><strong>语法</strong><br><code>schtasks [/query] [/fo {TABLE | LIST | CSV}] [/nh] [/v] [/s computer [/u [domain\]user /p password]]</code></p><h4 id="Windows下查看定时任务"><a href="#Windows下查看定时任务" class="headerlink" title="Windows下查看定时任务"></a>Windows下查看定时任务</h4><p><img src="/uploads/2018/08/windows_schtasks.png" alt=""></p><h4 id="Windows自定义定时任务"><a href="#Windows自定义定时任务" class="headerlink" title="Windows自定义定时任务"></a>Windows自定义定时任务</h4><p>（1）自定义脚本文件 “.bat”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c:</span><br><span class="line">cd \schtasks</span><br><span class="line">D:\dev\Go\src\myTest\ceshi.exe &gt;&gt; D:\go.txt</span><br></pre></td></tr></table></figure></p><p><strong>说明：</strong><br>在定时执行的bat文件开头加几行命令，先进入存放配置文件的目录。<br>（schtasks的默认其实路径为：C:\Windows\System32）</p><p>（2）设置定时任务<br><code>schtasks /create /sc minute /mo 1 /tn &quot;windows_crontab&quot; /tr d:\schtasks\ceshi.bat</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 系统可以通过crontab -e 设置定时任务，Windows系统没有crontab命令，但是Windows系统有跟crontab命令比较接近的命令： schtasks 命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Windows" scheme="http://yoursite.com/categories/Windows/"/>
    
    
      <category term="Windows" scheme="http://yoursite.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置HTTPS及生成CA证书</title>
    <link href="http://yoursite.com/2018/07/29/Nginx-%E9%85%8D%E7%BD%AEHTTPS%E5%8F%8A%E7%94%9F%E6%88%90CA%E8%AF%81%E4%B9%A6/"/>
    <id>http://yoursite.com/2018/07/29/Nginx-配置HTTPS及生成CA证书/</id>
    <published>2018-07-29T10:23:12.000Z</published>
    <updated>2018-07-29T10:33:38.806Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h4><h5 id="（1）HTTPS-采用对称加密和非对称加密两种形式。"><a href="#（1）HTTPS-采用对称加密和非对称加密两种形式。" class="headerlink" title="（1）HTTPS 采用对称加密和非对称加密两种形式。"></a>（1）HTTPS 采用对称加密和非对称加密两种形式。</h5><p><strong>对称加密：</strong><br>明文M -&gt; 加密算法（包含加密秘钥） -&gt; 生成密文Y发送 -&gt; 解密算法（包含加密秘钥） -&gt; 明文M<br>（注：加密算法中的秘钥 = 解密算法中的秘钥）</p><p><strong>非对称加密：</strong><br>发送方：明文M -&gt; 加密（通过会话秘钥（服务器端生成的公钥）及加密算法） -&gt; 生成密文Y<br>接收方：接收密文Y -&gt; 解密（通过会话秘钥（服务器端生成的私钥）及加密算法） -&gt;明文M<br><em>（注：服务器端生成公私钥，公钥可以公开用于客户端加密传输数据，秘钥保管在服务器端，用于解密数据。私钥很重要，不能泄露。）</em><br><a id="more"></a></p><h5 id="（2）HTTPS-加密协议原理："><a href="#（2）HTTPS-加密协议原理：" class="headerlink" title="（2）HTTPS 加密协议原理："></a>（2）HTTPS 加密协议原理：</h5><p>客户端        -&gt; 发起SSL连接        -&gt; 服务器端（保管唯一私钥）<br>　　　　　　<- 发送公钥="" 　　　　　　-="">发送对称密码（发送对称密码利用公钥加密）<br>　　　　　　<-><br>　　（利用对称秘钥传输数据） </-></-></p><blockquote><p>此种方式安全漏洞：<br>会出现一种中间人：<br>① 在客户端“发起SSL连接”的时候，伪装成服务端接受连接，并再次伪装成客户端向服务端发送SSL连接；<br>② 当服务端接受SSL连接的时候，会向客户端发送“公钥”，然后中间人会伪装成客户端接受“公钥”，就会获取公钥；<br>③ 然后中间人会伪装成服务端向真正客户端发送“公钥”，获取客户端利用“公钥”返回的“对称密码”；<br>④ 到此，中间人就把传输数据的安全信息都获取了，可以进行伪装传输数据了。</p></blockquote><p><strong>为解决此安全漏洞，HTTPS采用了数字证书的方式（即CA证书）。</strong><br>原理即是在发送公钥这一层，将服务端返回公钥改成发送“CA签名证书”，然后，客户端已经安装了服务端生成的证书。对服务端返回的证书进行验证即可。校验通过，客户端发送“对称密码”；校验失败则停止会话。</p><h4 id="秘钥及证书生成"><a href="#秘钥及证书生成" class="headerlink" title="秘钥及证书生成"></a>秘钥及证书生成</h4><p>准备工作：Nginx必备模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#openssl version</span><br><span class="line">OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">#nginx -V</span><br><span class="line">--with-http_ssl_module</span><br></pre></td></tr></table></figure></p><h5 id="（1）生成key秘钥"><a href="#（1）生成key秘钥" class="headerlink" title="（1）生成key秘钥"></a>（1）生成key秘钥</h5><p><code>openssl genrsa -idea -out jesonc.key 1024</code></p><h5 id="（2）生成证书签名请求文件（csr文件）"><a href="#（2）生成证书签名请求文件（csr文件）" class="headerlink" title="（2）生成证书签名请求文件（csr文件）"></a>（2）生成证书签名请求文件（csr文件）</h5><p><code>openssl req -new -key jesonc.key -out jesonc.csr</code></p><h5 id="（3）生成证书签名文件（CA文件）"><a href="#（3）生成证书签名文件（CA文件）" class="headerlink" title="（3）生成证书签名文件（CA文件）"></a>（3）生成证书签名文件（CA文件）</h5><p><code>openssl x509 -req -days 3650 -in jesonc.csr -signkey jesonc.key -out jesonc.crt</code></p><h5 id="（4）通过秘钥直接生成证书文件"><a href="#（4）通过秘钥直接生成证书文件" class="headerlink" title="（4）通过秘钥直接生成证书文件"></a>（4）通过秘钥直接生成证书文件</h5><p><code>openssl req -days 3650 -x509 -sha256 -nodes -newkey rsa:2048 -keyout jesonc.key -out jesonc_apple.crt</code></p><h5 id="（5）免密启动服务设置"><a href="#（5）免密启动服务设置" class="headerlink" title="（5）免密启动服务设置"></a>（5）免密启动服务设置</h5><p><code>openssl rsa -in ./jesonc.key -out ./jesonc_nopass.key</code></p><h4 id="HTTPS语法配置"><a href="#HTTPS语法配置" class="headerlink" title="HTTPS语法配置"></a>HTTPS语法配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Syntax： ssl on | off;</span><br><span class="line">Context：http, server</span><br></pre></td></tr></table></figure><p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen443;</span><br><span class="line">server_name ip;</span><br><span class="line">ssl on;</span><br><span class="line">ssl_certificate /etc/nginx/ssl_key/jesonc.crt;</span><br><span class="line">ssl_certificate_key/etc/nginx/ssl_key/jesonc.key;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>场景 - 配置苹果要求的证书</p><ol><li>服务器所有的连接使用TLS1.2以上版本（openssl 1.0.2）</li><li>HTTPS证书必须使用SHA256以上哈希算法签名</li><li>HTTPS证书必须使用RSA 2048位或ECC 256位以上公钥算法</li><li>使用向前加密技术</li></ol></blockquote><p><em>（注：查看本地证书要求：<code>openssl x509 -noout -text -in ./jesonc.crt</code>）</em></p><h4 id="HTTPS服务优化"><a href="#HTTPS服务优化" class="headerlink" title="HTTPS服务优化"></a>HTTPS服务优化</h4><p>（1）激活keepalive长连接<br>（2）设置 ssl session缓存<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keepalive_timeout100;</span><br><span class="line"></span><br><span class="line">ssl on;</span><br><span class="line">ssl_session_cache    shared:SSL:10m;</span><br><span class="line">ssl_session_timeout  10m;</span><br></pre></td></tr></table></figure></p><h4 id="升级SSL版本"><a href="#升级SSL版本" class="headerlink" title="升级SSL版本"></a>升级SSL版本</h4><p>（1）下载：<code>wget http://www.openssl.org/source/openssl-1.0.2k.tar.gz</code><br>（2）解压及安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf openssl-1.0.2k.tar.gz</span><br><span class="line">cd openssl-1.0.2k</span><br><span class="line">./config --prefix=/usr/local/openssl</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>（3）将旧的OpenSSL备份<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/bin/openssl /usr/bin/openssl.OFF</span><br><span class="line">mv /usr/include/openssl /usr/include/openssl.OFF</span><br></pre></td></tr></table></figure></p><p>（4）将新的OpenSSL软链接到指定位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl</span><br><span class="line">ln -s /usr/local/openssl/include/openssl /usr/include/openssl</span><br></pre></td></tr></table></figure></p><p>（5）将新安装的openssl的库路径追加到系统的库文件的搜索路径中<br><code>echo &quot;/usr/local/openssl/lib&quot; &gt;&gt; /etc/ld.so.conf</code><br>（6）加载系统库文件，使修改后的/etc/ld.so.conf生效<br><code>ldconfig -v</code><br>（7）查看openssl是否已更新成功<br><code>openssl version -a</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;原理详解&quot;&gt;&lt;a href=&quot;#原理详解&quot; class=&quot;headerlink&quot; title=&quot;原理详解&quot;&gt;&lt;/a&gt;原理详解&lt;/h4&gt;&lt;h5 id=&quot;（1）HTTPS-采用对称加密和非对称加密两种形式。&quot;&gt;&lt;a href=&quot;#（1）HTTPS-采用对称加密和非对称加密两种形式。&quot; class=&quot;headerlink&quot; title=&quot;（1）HTTPS 采用对称加密和非对称加密两种形式。&quot;&gt;&lt;/a&gt;（1）HTTPS 采用对称加密和非对称加密两种形式。&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;对称加密：&lt;/strong&gt;&lt;br&gt;明文M -&amp;gt; 加密算法（包含加密秘钥） -&amp;gt; 生成密文Y发送 -&amp;gt; 解密算法（包含加密秘钥） -&amp;gt; 明文M&lt;br&gt;（注：加密算法中的秘钥 = 解密算法中的秘钥）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非对称加密：&lt;/strong&gt;&lt;br&gt;发送方：明文M -&amp;gt; 加密（通过会话秘钥（服务器端生成的公钥）及加密算法） -&amp;gt; 生成密文Y&lt;br&gt;接收方：接收密文Y -&amp;gt; 解密（通过会话秘钥（服务器端生成的私钥）及加密算法） -&amp;gt;明文M&lt;br&gt;&lt;em&gt;（注：服务器端生成公私钥，公钥可以公开用于客户端加密传输数据，秘钥保管在服务器端，用于解密数据。私钥很重要，不能泄露。）&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置常见问题</title>
    <link href="http://yoursite.com/2018/07/29/Nginx-%E9%85%8D%E7%BD%AE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/07/29/Nginx-配置常见问题/</id>
    <published>2018-07-29T10:19:56.000Z</published>
    <updated>2018-07-29T10:33:38.806Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-相同server-name多个虚拟主机优先级访问"><a href="#1-相同server-name多个虚拟主机优先级访问" class="headerlink" title="1. 相同server_name多个虚拟主机优先级访问"></a>1. 相同server_name多个虚拟主机优先级访问</h4><p>答： 相同的server_name，在nginx.conf文件中，会由上往下匹配，匹配成功则不往下继续匹配；而在vhost/下，则依据文件顺序由上往下进行匹配（即文件名称的顺序）。</p><h4 id="2-location匹配优先级"><a href="#2-location匹配优先级" class="headerlink" title="2. location匹配优先级"></a>2. location匹配优先级</h4><p>location方式有三种：</p><ol><li>=     进行普通字符精确匹配，也就是完全匹配</li><li>^~    表示普通字符匹配，使用前缀匹配方式</li><li>~/~*    表示执行一个正则匹配()</li><li>@     用来定义“Named Location”,是专门用来处理“内部重定向”请求的<br>说明：<br>（1）1、2优先级最高，匹配成功后，就不继续往下匹配。而3的优先级低，会一直往下匹配，直到找到最匹配的为止。<br>（2）~与~<em>的区别：~ 表示区分大小写；~</em>则表示不区分大小写。<a id="more"></a></li></ol><h4 id="3-try-files使用"><a href="#3-try-files使用" class="headerlink" title="3. try_files使用"></a>3. try_files使用</h4><p>答：按顺序检查文件是否存在<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">root /opt/app/code/cache;</span><br><span class="line">try_files $uri @php_page;</span><br><span class="line">&#125;</span><br><span class="line">location @php_page &#123;</span><br><span class="line">proxy_pass http://127.0.0.1:9090;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解释：检测$uri文件是否存在，如果不存在，则重定向到@php_page模块。</p><h4 id="4-Nginx的alias和root区别"><a href="#4-Nginx的alias和root区别" class="headerlink" title="4. Nginx的alias和root区别"></a>4. Nginx的alias和root区别</h4><p>（1）root<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /request_path/image/ &#123;</span><br><span class="line">root /local_path/image/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请求链接：<code>http://hostname/request_path/image/cat.png</code><br>会指向：<code>/local_path/image/request_path/image/cat.png</code><br>（2）alias<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /request_path/image/ &#123;</span><br><span class="line">alias /local_path/image/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请求链接：<code>http://hostname/request_path/image/cat.png</code><br>会指向：<code>/local_path/image/cat.png</code></p><h4 id="5-用什么方法传递用户的真实IP"><a href="#5-用什么方法传递用户的真实IP" class="headerlink" title="5. 用什么方法传递用户的真实IP"></a>5. 用什么方法传递用户的真实IP</h4><p>可通过第一层代理增加http头变量来传递用户真实IP，后端服务可通过该变量来获取。<br><code>set x_real_ip=$remote_addr</code><br><em>（注：<code>x-forwarded-for</code> 可被用户篡改）</em></p><p><strong>附属一个工具用例：Nginx压测工具 ab</strong><br>示例： <code>ab -n 2000 -c 2 url</code><br>说明：<br>-n     总的请求数<br>-c     并发数<br>-k     是否开启长连接</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-相同server-name多个虚拟主机优先级访问&quot;&gt;&lt;a href=&quot;#1-相同server-name多个虚拟主机优先级访问&quot; class=&quot;headerlink&quot; title=&quot;1. 相同server_name多个虚拟主机优先级访问&quot;&gt;&lt;/a&gt;1. 相同server_name多个虚拟主机优先级访问&lt;/h4&gt;&lt;p&gt;答： 相同的server_name，在nginx.conf文件中，会由上往下匹配，匹配成功则不往下继续匹配；而在vhost/下，则依据文件顺序由上往下进行匹配（即文件名称的顺序）。&lt;/p&gt;
&lt;h4 id=&quot;2-location匹配优先级&quot;&gt;&lt;a href=&quot;#2-location匹配优先级&quot; class=&quot;headerlink&quot; title=&quot;2. location匹配优先级&quot;&gt;&lt;/a&gt;2. location匹配优先级&lt;/h4&gt;&lt;p&gt;location方式有三种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;=     进行普通字符精确匹配，也就是完全匹配&lt;/li&gt;
&lt;li&gt;^~    表示普通字符匹配，使用前缀匹配方式&lt;/li&gt;
&lt;li&gt;~/~*    表示执行一个正则匹配()&lt;/li&gt;
&lt;li&gt;@     用来定义“Named Location”,是专门用来处理“内部重定向”请求的&lt;br&gt;说明：&lt;br&gt;（1）1、2优先级最高，匹配成功后，就不继续往下匹配。而3的优先级低，会一直往下匹配，直到找到最匹配的为止。&lt;br&gt;（2）~与~&lt;em&gt;的区别：~ 表示区分大小写；~&lt;/em&gt;则表示不区分大小写。
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Git 常见错误集锦</title>
    <link href="http://yoursite.com/2018/07/21/Git-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/"/>
    <id>http://yoursite.com/2018/07/21/Git-常见错误集锦/</id>
    <published>2018-07-21T10:40:22.000Z</published>
    <updated>2018-07-21T11:46:12.844Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、git-add出现-“in-unpopulated-submodule-‘A’-“-问题"><a href="#一、git-add出现-“in-unpopulated-submodule-‘A’-“-问题" class="headerlink" title="一、git add出现 “in unpopulated submodule ‘A’ “ 问题"></a>一、git add出现 “in unpopulated submodule ‘A’ “ 问题</h4><p><strong>问题场景：</strong><br>我博客Hexo+GitHub中用到了Next主题，而Next主题是我直接从GitHub上下载使用的。因此我Hexo博客中有.git文件，而Next主题也有.git文件，且这两者文件含义不同。因此，在我git push的时候，报此错误。<br><a id="more"></a></p><p><strong>原因解释：</strong><br>在 ./ 下有一文件夹 命名为“A”，A/ 有之前建立的仓库，我在 ./ 下add commit push 后发现远程仓库内并没有A/的内容，于是我在 A/ 下执行 ”git add .” 提示：“in unpopulated submodule ‘A’ ”（翻译为”在一个无人居住的子模块“，感觉意思是说位于子模块下，无法 add 0.0） </p><p><strong>解决方法是：</strong><br>（1）删除 A/ 的.git 文件夹<br>（2）在 ./ 下输入”git rm -rf –-cached A/“ //谨记：是 A/ ，意为A目录下<br>（3）在 ./ 下输入”git add A”<br>（4）git commit -m “”<br>（5）git push origin master</p><h4 id="二、GitHub上提示package-lock-json中依赖文件需要更新"><a href="#二、GitHub上提示package-lock-json中依赖文件需要更新" class="headerlink" title="二、GitHub上提示package-lock.json中依赖文件需要更新"></a>二、GitHub上提示package-lock.json中依赖文件需要更新</h4><p><strong>问题场景：</strong><br>将文章更新到GitHub上时，偶然间发现提示一个Warning！package-lock.json 依赖文件有漏洞，提示更新。一下就蒙圈了，package-lock.json是啥？怎么更新？<br>经过查找发现，package-lock.json 是npm的包管理文件，即你下载的npm包都记录在里面。<br>那需要怎么更新呢？度娘说直接使用“npm install” 即可，会自动的从package.json里面更新对应包，尝试失败。</p><p><strong>解决方法：</strong><br>直接在Hexo根目录下使用命令：<br><code>npm install packagename</code><br>直接填写对应包名，更新即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、git-add出现-“in-unpopulated-submodule-‘A’-“-问题&quot;&gt;&lt;a href=&quot;#一、git-add出现-“in-unpopulated-submodule-‘A’-“-问题&quot; class=&quot;headerlink&quot; title=&quot;一、git add出现 “in unpopulated submodule ‘A’ “ 问题&quot;&gt;&lt;/a&gt;一、git add出现 “in unpopulated submodule ‘A’ “ 问题&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;问题场景：&lt;/strong&gt;&lt;br&gt;我博客Hexo+GitHub中用到了Next主题，而Next主题是我直接从GitHub上下载使用的。因此我Hexo博客中有.git文件，而Next主题也有.git文件，且这两者文件含义不同。因此，在我git push的时候，报此错误。&lt;br&gt;
    
    </summary>
    
      <category term="版本控制" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
      <category term="Git问题" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/Git%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="Git问题" scheme="http://yoursite.com/tags/Git%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 实战场景配置</title>
    <link href="http://yoursite.com/2018/07/21/Nginx-%E5%AE%9E%E6%88%98%E5%9C%BA%E6%99%AF%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/07/21/Nginx-实战场景配置/</id>
    <published>2018-07-21T10:26:00.000Z</published>
    <updated>2018-07-29T10:33:38.806Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、静态资源配置"><a href="#1、静态资源配置" class="headerlink" title="1、静态资源配置"></a>1、静态资源配置</h4><p>配置语法 - sendfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Syntax : sendfile on | off;</span><br><span class="line">Contaxt: http, server, location, if in location</span><br></pre></td></tr></table></figure></p><p>作用：开启sendfile，则静态数据不会被后端处理（即不会进入用户空间），直接在Nginx层返回数据（即经过内核空间直接返回）。<br><a id="more"></a><br>配置语法 - tcp_nopush （注：sendfile 开启的情况下，提高网络包的传输效率）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Syntax : tcp_nopush on | off;</span><br><span class="line">Contaxt: http, server, location</span><br></pre></td></tr></table></figure></p><p>配置语法 - tcp_nodelay（注：keepalive 连接下，提高网络包的传输实时性）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Syntax : tcp_nodelay on | off;</span><br><span class="line">Contaxt: http, server, location</span><br></pre></td></tr></table></figure></p><p>配置语法 - 压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Syntax : gzip on | off;</span><br><span class="line">Contaxt: http, server, location, if in location</span><br></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(jpg|gif|png)$ &#123;</span><br><span class="line">#gzip on;</span><br><span class="line">#gzip_http_version 1.1;</span><br><span class="line">#gzip_comp_level 2;</span><br><span class="line">#gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">root /opt/app/code/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、浏览器缓存配置"><a href="#2、浏览器缓存配置" class="headerlink" title="2、浏览器缓存配置"></a>2、浏览器缓存配置</h4><p>客户端校验过期机制：</p><table><thead><tr><th>校验是否过期</th><th>Expires、Cache-Control(max-age)</th></tr></thead><tbody><tr><td>协议中Etag头信息校验</td><td>Etag</td></tr><tr><td>Last-Modified头信息校验</td><td>Last-Modified</td></tr></tbody></table><p>服务端配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax : expires [modified] time;</span><br><span class="line"> expires epoch | max | off;</span><br><span class="line">Contaxt: http, server, location, if in location</span><br></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(html|htm)$ &#123;</span><br><span class="line">expires 24h;</span><br><span class="line">root /opt/app/code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、跨站访问配置"><a href="#3、跨站访问配置" class="headerlink" title="3、跨站访问配置"></a>3、跨站访问配置</h4><p>客户端显示跨域信息：<br><code>Access-Control-Allow-Origin</code><br>服务端设置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Syntax : add_header name value [always];</span><br><span class="line">Contaxt: http, server, location, if in location</span><br></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(html|htm)$ &#123;</span><br><span class="line">add_header Access-Control-Allow-Origin http://www.url.com;</span><br><span class="line">add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;</span><br><span class="line">root /opt/app/code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4、防盗链配置"><a href="#4、防盗链配置" class="headerlink" title="4、防盗链配置"></a>4、防盗链配置</h4><p>基于http_refer防盗链配置模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Syntax : valid_referers none | blocked | server_names | string ...;</span><br><span class="line">Contaxt: server, location</span><br></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(jpg|gif|png)$ &#123;</span><br><span class="line">valid_referers none blocked 116.62.103.228; （注：也可使用正则匹配）</span><br><span class="line">if ($invalid_referer) &#123;</span><br><span class="line">return 443;</span><br><span class="line">&#125;</span><br><span class="line">root /opt/app/code/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5、代理配置"><a href="#5、代理配置" class="headerlink" title="5、代理配置"></a>5、代理配置</h4><blockquote><p>代理区别：区别在于代理的对象不一样<br>　　正向代理代理的对象是客户端<br>　　反向代理代理的对象是服务端</p></blockquote><p>配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Syntax : proxy_pass URL;</span><br><span class="line">Contaxt: location, if in location, limit_execpt</span><br></pre></td></tr></table></figure></p><h5 id="（1）正向代理"><a href="#（1）正向代理" class="headerlink" title="（1）正向代理"></a>（1）正向代理</h5><p>服务端需限制访问路径，下面服务端只开启对应的IP能够访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">if ( $http_x_forwarded_for !~* &quot;^116\.62\.104\.228&quot; ) &#123;</span><br><span class="line">return 403;</span><br><span class="line">&#125;</span><br><span class="line">root /opt/app/code;</span><br><span class="line">index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>（注：$http_x_forwarded_for 为代理的所有信息，包括客户端的IP。）</em><br>然后再对应的116.62.104.228服务器上配置正向代理即可。配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8;//Google的一个dns解析</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://$http_host$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后再客户端配置好代理服务器（116.62.104.228）即可进行访问。<br>（注：此处服务端配置可不限制访问也可。理解正向代理就是客户端通过代理服务器向外访问。）</p><h5 id="（2）反向代理"><a href="#（2）反向代理" class="headerlink" title="（2）反向代理"></a>（2）反向代理</h5><p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ /test_proxy.html$ &#123;</span><br><span class="line">proxy_pass http://127.0.0.1:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其它代理配置语法：可浏览Nginx官网进行查看。</p><h4 id="6、负载均衡配置"><a href="#6、负载均衡配置" class="headerlink" title="6、负载均衡配置"></a>6、负载均衡配置</h4><p>配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Syntax : upstream name &#123;...&#125;</span><br><span class="line">Context: http</span><br></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">upstream imooc &#123;</span><br><span class="line">server 116.62.103.228:8001 down;//不提供服务</span><br><span class="line">server 116.62.103.228:8002 backup;//备份结点</span><br><span class="line">server 116.62.103.228:8003 max_fails=1 fail_timeout=10s; //能够访问，最大试错为1次，服务暂停时间为10s</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://imooc;</span><br><span class="line">include proxy_params;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>负载均衡默认规则是轮询。会依据访问请求来依次进行分配。当其中一台机器宕机，会停止对其访问。<br><strong>后端服务器在负载均衡调度中的状态：</strong></p><table><thead><tr><th>down</th><th>当前的server暂时不参与负载均衡</th></tr></thead><tbody><tr><td>backup</td><td>预留的备份服务器</td></tr><tr><td>max_fails</td><td>允许请求失败的次数</td></tr><tr><td>fail_timeout</td><td>经过max_fails失败后，服务暂停的时间</td></tr><tr><td>max_conns</td><td>限制最大的接收的连接数</td></tr></tbody></table><h5 id="调度算法："><a href="#调度算法：" class="headerlink" title="调度算法："></a>调度算法：</h5><table><thead><tr><th>轮询</th><th>按时间顺序逐一分配到不同的后端服务器</th></tr></thead><tbody><tr><td>加权轮询</td><td>weight值越大，分配到的访问几率越高</td></tr><tr><td>ip_hash</td><td>每个请求按访问IP的hash结果分配，这样来自同一个IP的固定访问一个后端服务器</td></tr><tr><td>url_hash</td><td>按照访问的URL的hash结果分配请求，是每个URL定向到同一个后端服务器</td></tr><tr><td>least_conn</td><td>最少链接数，那个机器连接数少就分发</td></tr><tr><td>hash关键数值</td><td>hash自定义的key</td></tr></tbody></table><p>url_hash 配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax : hash key [consistent];</span><br><span class="line">Context: upstream</span><br><span class="line">（This directive appeared in version 1.7.2）</span><br></pre></td></tr></table></figure></p><p><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream imooc &#123;</span><br><span class="line">hash $request_uri;</span><br><span class="line">server 116.62.103.228:8001;</span><br><span class="line">server 116.62.103.228:8002;</span><br><span class="line">server 116.62.103.228:8003; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面示例的意思就是根据 $request_uri的值来计算hash值。此处的key可自定义，只要在配置文件中定义即可。</p><h4 id="7、缓存服务配置（Nginx）"><a href="#7、缓存服务配置（Nginx）" class="headerlink" title="7、缓存服务配置（Nginx）"></a>7、缓存服务配置（Nginx）</h4><p>proxy_cache 配置语法。</p><h4 id="8、CPU亲和设置"><a href="#8、CPU亲和设置" class="headerlink" title="8、CPU亲和设置"></a>8、CPU亲和设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">worker_processes2;</span><br><span class="line">worker_cpu_affinity auto; //Nginx1.9之后</span><br><span class="line">worker_cpu_affinity0101010101010101 1010101010101010;</span><br><span class="line"></span><br><span class="line">worker_rlimit_nofile35535; //worker进程句柄数限制</span><br></pre></td></tr></table></figure><h4 id="9、文件上传漏洞"><a href="#9、文件上传漏洞" class="headerlink" title="9、文件上传漏洞"></a>9、文件上传漏洞</h4><p><code>http://hostname/upload/1.jpg/1.php</code><br>Nginx 将1.jpg作为php代码执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /upload &#123;</span><br><span class="line">root /opt/app/images;</span><br><span class="line">if ($request_filename ~* (.*)\.php) &#123;</span><br><span class="line">return 403;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="10、Nginx动静分离"><a href="#10、Nginx动静分离" class="headerlink" title="10、Nginx动静分离"></a>10、Nginx动静分离</h4><p><strong>实现原理：</strong>就是将静态内容，直接通过Nginx层就返回给用户，无需通过后端PHP处理。而动态数据，则发往后端处理后返回。<br>静态数据包括：html/htm、js/css、jpg/png/gif、zip/rar 等。<br>示例：<br><strong>动态请求：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">proxy_pass 127.0.0.1:9000</span><br><span class="line">proxy_params $SCRIPT$REQUIRT_URI;</span><br><span class="line">proxy_</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>静态内容：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.(jpg|png|gif)$ &#123;</span><br><span class="line">expires 1h;</span><br><span class="line">gzip on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="11、Nginx-之Rewrite配置"><a href="#11、Nginx-之Rewrite配置" class="headerlink" title="11、Nginx 之Rewrite配置"></a>11、Nginx 之Rewrite配置</h4><p><strong>配置语法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sysntax: rewrite regex replacement [flag];</span><br><span class="line">Context: server, location, if</span><br></pre></td></tr></table></figure></p><p><strong>正则表达式：</strong></p><table><thead><tr><th>.</th><th>匹配除换行符以外的任意字符</th></tr></thead><tbody><tr><td>?</td><td>重复0次或1次</td></tr><tr><td>+</td><td>重复1次或更多次</td></tr><tr><td>*</td><td>最少链接数，那个机器连接数少就分发</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>[c]</td><td>匹配单个字符c</td></tr><tr><td>[a-z]</td><td>匹配a-z小写字母的任意一个</td></tr><tr><td>\</td><td>转义字符</td></tr><tr><td>()</td><td>用于匹配括号之间的内容，通过$1、$2调用</td></tr></tbody></table><p>（注：可使用pcretest 来测试正则是否正确。）</p><p><strong>flag：</strong></p><table><thead><tr><th>last</th><th>停止rewrite检测</th></tr></thead><tbody><tr><td>break</td><td>停止rewrite检测</td></tr><tr><td>redirect</td><td>返回302临时重定向，地址栏会显示跳转后的地址</td></tr><tr><td>permanent</td><td>返回301永久重定向，地址栏会显示跳转后的地址</td></tr></tbody></table><p><em>（注：301与302的区别：临时重定向是客户端向服务器请求则返回，若服务器宕机，则不能够访问。永久重定向一旦服务器返回，再次访问则不需要请求服务器。永久性的指向重定向的服务器。）</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、静态资源配置&quot;&gt;&lt;a href=&quot;#1、静态资源配置&quot; class=&quot;headerlink&quot; title=&quot;1、静态资源配置&quot;&gt;&lt;/a&gt;1、静态资源配置&lt;/h4&gt;&lt;p&gt;配置语法 - sendfile&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Syntax : sendfile on | off;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Contaxt: http, server, location, if in location&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;作用：开启sendfile，则静态数据不会被后端处理（即不会进入用户空间），直接在Nginx层返回数据（即经过内核空间直接返回）。&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Sublime配置代码追踪</title>
    <link href="http://yoursite.com/2018/07/18/Sublime%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA/"/>
    <id>http://yoursite.com/2018/07/18/Sublime配置代码追踪/</id>
    <published>2018-07-18T11:44:28.000Z</published>
    <updated>2018-07-20T06:07:54.890Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读别人代码的时候，非常喜欢IDE中的追踪代码功能。也想在sublime text中也使用。从网上查找发现可以使用ctags插件。</p><p>下面介绍下如何在sublime text中安装使用ctags：</p><h4 id="1、安装package-control"><a href="#1、安装package-control" class="headerlink" title="1、安装package control"></a>1、安装package control</h4><p>点击<code>Preferences &gt; Browse Packages</code>菜单，进入打开的目录的上层目录，然后再进入Installed Packages/目录，下载Package Control.sublime-package并复制到Installed Packages/目录<br>pControl.sublime-package下载地址：<a href="/uploads/2018/07/Package Control.sublime-package">点击下载</a><br><a id="more"></a></p><p>输入Ctrl+Shift+P（菜单 - Tools - Command Paletter），输入Install Package并回车，输入或选择你需要的插件回车就安装了。<br>如果快捷键不好使，重启Sublime Text。</p><h4 id="2、安装ctags"><a href="#2、安装ctags" class="headerlink" title="2、安装ctags"></a>2、安装ctags</h4><h5 id="（1）安装sublime-text插件"><a href="#（1）安装sublime-text插件" class="headerlink" title="（1）安装sublime text插件"></a>（1）安装sublime text插件</h5><p>输入ctags安装，会发现编辑器左下角正在下载安装。</p><h5 id="（2）安装可执行程序"><a href="#（2）安装可执行程序" class="headerlink" title="（2）安装可执行程序"></a>（2）安装可执行程序</h5><p>下载ctags可执行程序，地址为<code>http://prdownloads.sourceforge.net/ctags/ctags58.zip</code>，解压到一个目录，注意要是纯ASCII字符的目录不要带空格或中文命名的目录。</p><h5 id="（3）配置"><a href="#（3）配置" class="headerlink" title="（3）配置"></a>（3）配置</h5><p>配置可执行文件路径：打开菜单在Preferences菜单中打开<code>Package settings-&gt;ctags-&gt;settings-user和settings-default</code>把default中的配置全部复制到user中，然后改一下command配置项，为ctags的可执行文件路径,即ctags.exe路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Path to ctags executable.</span><br><span class="line">//</span><br><span class="line">// Alter this value if your ctags command is not in the PATH, or if using</span><br><span class="line">// a different version of ctags to that in the path (i.e. for OSX).</span><br><span class="line">//</span><br><span class="line">// NOTE: You *should not* place entire commands here. These commands are</span><br><span class="line">// built automatically using the values below. For example, this is OK:</span><br><span class="line">//</span><br><span class="line">//     &quot;command&quot;: &quot;/usr/bin/ctags&quot;</span><br><span class="line">//</span><br><span class="line">// This, on the other hand, won&apos;t work!</span><br><span class="line">//</span><br><span class="line">//     &quot;command&quot;: &quot;ctags -R -f .tags --exclude=some/path&quot;</span><br><span class="line">//</span><br><span class="line">&quot;command&quot;: &quot;C:/Windows/System32/ctags58/ctags.exe&quot;,</span><br></pre></td></tr></table></figure></p><p>配置快捷键：配置在sublime中使用Ctrl+左键单击函数跳转、Ctrl+右键单击跳回函数调用位置<br>复制以下代码到 <code>Preferences-&gt;Package Settings-&gt;Ctags-&gt;Mouse Bindings-User</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;button&quot;: &quot;button1&quot;,</span><br><span class="line">        &quot;count&quot;: 1,</span><br><span class="line">        &quot;press_command&quot;: &quot;drag_select&quot;,</span><br><span class="line">        &quot;modifiers&quot;: [&quot;ctrl&quot;],</span><br><span class="line">        &quot;command&quot;: &quot;navigate_to_definition&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;button&quot;: &quot;button2&quot;,</span><br><span class="line">        &quot;count&quot;: 1,</span><br><span class="line">        &quot;modifiers&quot;: [&quot;ctrl&quot;],</span><br><span class="line">        &quot;command&quot;: &quot;jump_prev&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h5 id="（4）使用"><a href="#（4）使用" class="headerlink" title="（4）使用"></a>（4）使用</h5><p>在使用函数调转功能前，需要先生成.tags文件，只需在<font color="red">项目文件管理器的项目文件上右键点击Ctags:Rebuild Tags即可</font><strong>（注意，在改动文件之后也许重新生成.tags）</strong></p><h5 id="（5）所有工作都准备充分之后，就可以在函数名上-Ctrl-左键-点击指定函数跳转了，Ctrl-右键返回上一个跳转函数；"><a href="#（5）所有工作都准备充分之后，就可以在函数名上-Ctrl-左键-点击指定函数跳转了，Ctrl-右键返回上一个跳转函数；" class="headerlink" title="（5）所有工作都准备充分之后，就可以在函数名上 Ctrl+左键 点击指定函数跳转了，Ctrl+右键返回上一个跳转函数；"></a>（5）所有工作都准备充分之后，就可以在函数名上 Ctrl+左键 点击指定函数跳转了，Ctrl+右键返回上一个跳转函数；</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在阅读别人代码的时候，非常喜欢IDE中的追踪代码功能。也想在sublime text中也使用。从网上查找发现可以使用ctags插件。&lt;/p&gt;
&lt;p&gt;下面介绍下如何在sublime text中安装使用ctags：&lt;/p&gt;
&lt;h4 id=&quot;1、安装package-control&quot;&gt;&lt;a href=&quot;#1、安装package-control&quot; class=&quot;headerlink&quot; title=&quot;1、安装package control&quot;&gt;&lt;/a&gt;1、安装package control&lt;/h4&gt;&lt;p&gt;点击&lt;code&gt;Preferences &amp;gt; Browse Packages&lt;/code&gt;菜单，进入打开的目录的上层目录，然后再进入Installed Packages/目录，下载Package Control.sublime-package并复制到Installed Packages/目录&lt;br&gt;pControl.sublime-package下载地址：&lt;a href=&quot;/uploads/2018/07/Package Control.sublime-package&quot;&gt;点击下载&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编辑器" scheme="http://yoursite.com/categories/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>搭建VPS记录</title>
    <link href="http://yoursite.com/2018/07/18/%E6%90%AD%E5%BB%BAVPN%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/07/18/搭建VPN记录/</id>
    <published>2018-07-18T11:43:42.000Z</published>
    <updated>2018-07-20T06:07:54.940Z</updated>
    
    <content type="html"><![CDATA[<p>通过Stack Overflow搜索到一个靠谱点的搭建VPS方法，完成搭建，现整理如下：</p><h4 id="一、服务器端安装"><a href="#一、服务器端安装" class="headerlink" title="一、服务器端安装"></a>一、服务器端安装</h4><h5 id="1、软件安装"><a href="#1、软件安装" class="headerlink" title="1、软件安装"></a>1、软件安装</h5><p>Debian / Ubuntu:<br>　　apt-get install python-pip<br>　　pip install shadowsocks</p><p>CentOS:<br>　　yum install python-setuptools &amp;&amp; easy_install pip<br>　　pip install shadowsocks</p><p>Windows:<br>　　See [Install Server on Windows]<br><a id="more"></a></p><h5 id="2、账号配置及常用命令"><a href="#2、账号配置及常用命令" class="headerlink" title="2、账号配置及常用命令"></a>2、账号配置及常用命令</h5><p>启动：<br>　　ssserver -p 443 -k password -m aes-256-cfb<br>后台启动：<br>　　sudo ssserver -p 443 -k password -m aes-256-cfb –user nobody -d start<br>停止：<br>　　sudo ssserver -d stop<br>检查log日志：<br>　　sudo less /var/log/shadowsocks.log</p><h4 id="二、客户端安装wiki"><a href="#二、客户端安装wiki" class="headerlink" title="二、客户端安装wiki"></a>二、客户端安装wiki</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Android]:           https://github.com/shadowsocks/shadowsocks-android</span><br><span class="line">[Build Status]:      https://img.shields.io/travis/shadowsocks/shadowsocks/master.svg?style=flat</span><br><span class="line">[Configuration]:     https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File</span><br><span class="line">[Coverage Status]:   https://jenkins.shadowvpn.org/result/shadowsocks</span><br><span class="line">[Coverage]:          https://jenkins.shadowvpn.org/job/Shadowsocks/ws/PYENV/py34/label/linux/htmlcov/index.html</span><br><span class="line">[Debian sid]:        https://packages.debian.org/unstable/python/shadowsocks</span><br><span class="line">[iOS]:               https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help</span><br><span class="line">[Issue Tracker]:     https://github.com/shadowsocks/shadowsocks/issues?state=open</span><br><span class="line">[Install Server on Windows]: https://github.com/shadowsocks/shadowsocks/wiki/Install-Shadowsocks-Server-on-Windows</span><br><span class="line">[Mailing list]:      https://groups.google.com/group/shadowsocks</span><br><span class="line">[OpenWRT]:           https://github.com/shadowsocks/openwrt-shadowsocks</span><br><span class="line">[OS X]:              https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help</span><br><span class="line">[PyPI]:              https://pypi.python.org/pypi/shadowsocks</span><br><span class="line">[PyPI version]:      https://img.shields.io/pypi/v/shadowsocks.svg?style=flat</span><br><span class="line">[Travis CI]:         https://travis-ci.org/shadowsocks/shadowsocks</span><br><span class="line">[Troubleshooting]:   https://github.com/shadowsocks/shadowsocks/wiki/Troubleshooting</span><br><span class="line">[Wiki]:              https://github.com/shadowsocks/shadowsocks/wiki</span><br><span class="line">[Windows]:           https://github.com/shadowsocks/shadowsocks-csharp</span><br></pre></td></tr></table></figure><h4 id="三、报错集锦"><a href="#三、报错集锦" class="headerlink" title="三、报错集锦"></a>三、报错集锦</h4><h5 id="1、启动服务的时候报："><a href="#1、启动服务的时候报：" class="headerlink" title="1、启动服务的时候报："></a>1、启动服务的时候报：</h5><blockquote><p>AttributeError: /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol</p></blockquote><p>这个问题是由于在openssl1.1.0版本中，废弃了<code>EVP_CIPHER_CTX_cleanup</code>函数，如官网中所说：</p><blockquote><p>EVP_CIPHER_CTX was made opaque in OpenSSL 1.1.0. As a result, EVP_CIPHER_CTX_reset() appeared and EVP_CIPHER_CTX_cleanup() disappeared.<br>EVP_CIPHER_CTX_init() remains as an alias for EVP_CIPHER_CTX_reset().</p></blockquote><p><strong>修改方法：</strong></p><blockquote><p>(1) 用vim打开文件：vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py (该路径请根据自己的系统情况自行修改，如果不知道该文件在哪里的话，可以使用find命令查找文件位置)<br>(2) 跳转到52行（shadowsocks2.8.2版本，其他版本搜索一下cleanup）<br>(3) 进入编辑模式<br>(4) 将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)<br>　　改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)<br>(5) 再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)<br>　　改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)<br>(6) 保存并退出<br>(7) 启动shadowsocks服务：service shadowsocks start 或 sslocal -c ss配置文件目录<br>(8) 问题解决</p></blockquote><p><strong>插曲：</strong><br>在 Vultr 上面购买的“东京”服务器用来搭建VPN，刚开始购买的是 $2.5/month，上面标注的是 only ipv6，服务器启动后，才发现国内目前还没有普及ipv6，ping都不通，在阿里云服务器上开启ipv6，然后再ping仍然不通。 应该是网络运营商方面没有开启ipv6，所以都出不去，才ping不通。迫不得已，又删除掉服务器，重新购买了 $5/month 的服务器，搭建完毕。</p><p><em>下面查看电脑是否支持IPV6访问：</em><br>登陆<code>http://test-ipv6.com/</code>（如果能上网的话）<br>根据网站给出的信息，判断是否支持IPv6。<br><img src="/uploads/2018/07/vpn_01.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过Stack Overflow搜索到一个靠谱点的搭建VPS方法，完成搭建，现整理如下：&lt;/p&gt;
&lt;h4 id=&quot;一、服务器端安装&quot;&gt;&lt;a href=&quot;#一、服务器端安装&quot; class=&quot;headerlink&quot; title=&quot;一、服务器端安装&quot;&gt;&lt;/a&gt;一、服务器端安装&lt;/h4&gt;&lt;h5 id=&quot;1、软件安装&quot;&gt;&lt;a href=&quot;#1、软件安装&quot; class=&quot;headerlink&quot; title=&quot;1、软件安装&quot;&gt;&lt;/a&gt;1、软件安装&lt;/h5&gt;&lt;p&gt;Debian / Ubuntu:&lt;br&gt;　　apt-get install python-pip&lt;br&gt;　　pip install shadowsocks&lt;/p&gt;
&lt;p&gt;CentOS:&lt;br&gt;　　yum install python-setuptools &amp;amp;&amp;amp; easy_install pip&lt;br&gt;　　pip install shadowsocks&lt;/p&gt;
&lt;p&gt;Windows:&lt;br&gt;　　See [Install Server on Windows]&lt;br&gt;
    
    </summary>
    
    
      <category term="VPS" scheme="http://yoursite.com/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>面试 - 数据库相关问题</title>
    <link href="http://yoursite.com/2018/06/11/%E9%9D%A2%E8%AF%95%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/06/11/面试 - 数据库相关问题/</id>
    <published>2018-06-11T09:58:07.000Z</published>
    <updated>2018-07-20T06:07:54.755Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、什么是索引-SQL-Server-2000里有什么类型的索引"><a href="#1、什么是索引-SQL-Server-2000里有什么类型的索引" class="headerlink" title="1、什么是索引?SQL Server 2000里有什么类型的索引?"></a>1、什么是索引?SQL Server 2000里有什么类型的索引?</h5><p>任何有经验的数据库开发人员都应该能够很轻易地回答这个问题。一些经验不太多的开发人员能够回答这个问题，但是有些地方会说不清楚。<br>简单地说，索引是一个数据结构，用来快速访问数据库表格或者视图里的数据。在SQL Server里，它们有两种形式:聚集索引和非聚集索引。聚集索引在索引的叶级保存数据。这意味着不论聚集索引里有表格的哪个(或哪些)字段，这些字段都会按顺序被保存在表格。由于存在这种排序，所以每个表格只会有一个聚集索引。非聚集索引在索引的叶级有一个行标识符。这个行标识符是一个指向磁盘上数据的指针。它允许每个表格有多个非聚集索引。</p><a id="more"></a><h5 id="2、什么是主键-什么是外键"><a href="#2、什么是主键-什么是外键" class="headerlink" title="2、什么是主键?什么是外键?"></a>2、什么是主键?什么是外键?</h5><p>主键是表格里的(一个或多个)字段，只用来定义表格里的行;主键里的值总是唯一的。外键是一个用来建立两个表格之间关系的约束。这种关系一般都涉及一个表格里的主键字段与另外一个表格(尽管可能是同一个表格)里的一系列相连的字段。那么这些相连的字段就是外键。</p><h5 id="3、什么是触发器-SQL-Server-2000有什么不同类型的触发器"><a href="#3、什么是触发器-SQL-Server-2000有什么不同类型的触发器" class="headerlink" title="3、什么是触发器?SQL Server 2000有什么不同类型的触发器?"></a>3、什么是触发器?SQL Server 2000有什么不同类型的触发器?</h5><p>让未来的数据库开发人员知道可用的触发器类型以及如何实现它们是非常有益的。<br>触发器是一种专用类型的存储过程，它被捆绑到SQL Server 2000的表格或者视图上。在SQL Server 2000里，有INSTEAD-OF和AFTER两种触发器。INSTEAD-OF触发器是替代数据操控语言(Data Manipulation Language，DML)语句对表格执行语句的存储过程。例如，如果我有一个用于TableA的INSTEAD-OF-UPDATE触发器，同时对这个表格执行一个更新语句，那么INSTEAD-OF-UPDATE触发器里的代码会执行，而不是我执行的更新语句则不会执行操作。<br>AFTER触发器要在DML语句在数据库里使用之后才执行。这些类型的触发器对于监视发生在数据库表格里的数据变化十分好用。</p><p>您如何确一个带有名为Fld1字段的TableB表格里只具有Fld1字段里的那些值，而这些值同时在名为TableA的表格的Fld1字段里?<br>这个与关系相关的问题有两个可能的答案。第一个答案(而且是您希望听到的答案)是使用外键限制。外键限制用来维护引用的完整性。它被用来确保表格里的字段只保存有已经在不同的(或者相同的)表格里的另一个字段里定义了的值。这个字段就是候选键(通常是另外一个表格的主键)。<br>另外一种答案是触发器。触发器可以被用来保证以另外一种方式实现与限制相同的作用，但是它非常难设置与维护，而且性能一般都很糟糕。由于这个原因，微软建议开发人员使用外键限制而不是触发器来维护引用的完整性。</p><h5 id="4、对一个投入使用的在线事务处理表格有过多索引需要有什么样的性能考虑"><a href="#4、对一个投入使用的在线事务处理表格有过多索引需要有什么样的性能考虑" class="headerlink" title="4、对一个投入使用的在线事务处理表格有过多索引需要有什么样的性能考虑?"></a>4、对一个投入使用的在线事务处理表格有过多索引需要有什么样的性能考虑?</h5><p>你正在寻找进行与数据操控有关的应聘人员。对一个表格的索引越多，数据库引擎用来更新、插入或者删除数据所需要的时间就越多，因为在数据操控发生的时候索引也必须要维护。</p><h5 id="5、你可以用什么来确保表格里的字段只接受特定范围里的值"><a href="#5、你可以用什么来确保表格里的字段只接受特定范围里的值" class="headerlink" title="5、你可以用什么来确保表格里的字段只接受特定范围里的值?"></a>5、你可以用什么来确保表格里的字段只接受特定范围里的值?</h5><p>这个问题可以用多种方式来回答，但是只有一个答案是“好”答案。您希望听到的回答是Check限制，它在数据库表格里被定义，用来限制输入该列的值。<br>触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求触发器在表格里被定义，这可能会在某些情况下影响到性能。因此，微软建议使用Check限制而不是其他的方式来限制域的完整性。</p><h5 id="6、对关系型数据库而言，索引是相当重要的概念，请回答有关索引几个问题"><a href="#6、对关系型数据库而言，索引是相当重要的概念，请回答有关索引几个问题" class="headerlink" title="6、对关系型数据库而言，索引是相当重要的概念，请回答有关索引几个问题:"></a>6、对关系型数据库而言，索引是相当重要的概念，请回答有关索引几个问题:</h5><p>a) 索引的目的是什么?<br>b) 索引对数据库系统的负面影响是什么?<br>c) 为数据表建立索引的原则有哪些?<br>d) 什么情况下不宜建立索引?</p><p>答：<br>索引的目的：</p><ol><li>快速访问数据表中的特定信息，提高检索速度</li><li>创建唯一性索引，保证数据库表中每一行数据的唯一性</li><li>加速表和表之间的连接</li><li>使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</li></ol><p>负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改的时候索引也要动态维护，这样就降低了数据的维护速度。</p><p>建立索引的原则：</p><ol><li>在最频繁使用的、用以缩小查询范围的字段上建立索引</li><li>在平频繁使用的、需要排序的字段上建立索引</li></ol><p>什么情况下不宜建立索引：</p><ol><li>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引</li><li>对于一些特殊的数据类型，不宜建立索引，比如文本字段(text)等。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1、什么是索引-SQL-Server-2000里有什么类型的索引&quot;&gt;&lt;a href=&quot;#1、什么是索引-SQL-Server-2000里有什么类型的索引&quot; class=&quot;headerlink&quot; title=&quot;1、什么是索引?SQL Server 2000里有什么类型的索引?&quot;&gt;&lt;/a&gt;1、什么是索引?SQL Server 2000里有什么类型的索引?&lt;/h5&gt;&lt;p&gt;任何有经验的数据库开发人员都应该能够很轻易地回答这个问题。一些经验不太多的开发人员能够回答这个问题，但是有些地方会说不清楚。&lt;br&gt;简单地说，索引是一个数据结构，用来快速访问数据库表格或者视图里的数据。在SQL Server里，它们有两种形式:聚集索引和非聚集索引。聚集索引在索引的叶级保存数据。这意味着不论聚集索引里有表格的哪个(或哪些)字段，这些字段都会按顺序被保存在表格。由于存在这种排序，所以每个表格只会有一个聚集索引。非聚集索引在索引的叶级有一个行标识符。这个行标识符是一个指向磁盘上数据的指针。它允许每个表格有多个非聚集索引。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试 - php易混淆题集锦</title>
    <link href="http://yoursite.com/2018/06/11/%E9%9D%A2%E8%AF%95%20-%20php%E6%98%93%E6%B7%B7%E6%B7%86%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://yoursite.com/2018/06/11/面试 - php易混淆题集锦/</id>
    <published>2018-06-11T08:55:20.000Z</published>
    <updated>2018-07-21T10:22:41.689Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-写出如下程序的输出结果（考点：变量判空）"><a href="#1-写出如下程序的输出结果（考点：变量判空）" class="headerlink" title="1. 写出如下程序的输出结果（考点：变量判空）"></a>1. 写出如下程序的输出结果（考点：变量判空）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$a1 = null;</span><br><span class="line">$a2 = false;</span><br><span class="line">$a3 = 0;</span><br><span class="line">$a4 = &apos;&apos;;</span><br><span class="line">$a5 = &apos;0&apos;;</span><br><span class="line">$a6 = &apos;null&apos;;</span><br><span class="line">$a7 = array();</span><br><span class="line">$a8 = array(array());</span><br><span class="line"></span><br><span class="line">echo empty($a1) ? &apos;true&apos; : &apos;false&apos;;             //true</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a2) ? &apos;true&apos; : &apos;false&apos;;             //true</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a3) ? &apos;true&apos; : &apos;false&apos;;             //true</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a4) ? &apos;true&apos; : &apos;false&apos;;             //true</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a5) ? &apos;true&apos; : &apos;false&apos;;             //false  true</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a6) ? &apos;true&apos; : &apos;false&apos;;             //false</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a7) ? &apos;true&apos; : &apos;false&apos;;             //true</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo empty($a8) ? &apos;true&apos; : &apos;false&apos;;             //true  false</span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h5 id="2-写出如下程序的输出结果（考点：变量引用）"><a href="#2-写出如下程序的输出结果（考点：变量引用）" class="headerlink" title="2. 写出如下程序的输出结果（考点：变量引用）"></a>2. 写出如下程序的输出结果（考点：变量引用）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$test = &apos;aaaaaa&apos;;</span><br><span class="line">$abc = &amp;$test;</span><br><span class="line">unset($test);</span><br><span class="line"></span><br><span class="line">echo $abc;              //aaaaaa</span><br><span class="line">echo $test;             //undefined valiable</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure><hr><h5 id="3-写出如下程序的输出结果（考点：静态变量）"><a href="#3-写出如下程序的输出结果（考点：静态变量）" class="headerlink" title="3. 写出如下程序的输出结果（考点：静态变量）"></a>3. 写出如下程序的输出结果（考点：静态变量）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$count = 5;</span><br><span class="line">function get_count()&#123;</span><br><span class="line">        static $count = 0;</span><br><span class="line">        return $count++;</span><br><span class="line">&#125;</span><br><span class="line">echo $count;            //5</span><br><span class="line">++$count;</span><br><span class="line"></span><br><span class="line">echo get_count();       //0</span><br><span class="line">echo get_count();       //1</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure><hr><h5 id="4-写出如下程序的输出结果（考点：全局变量作用域）"><a href="#4-写出如下程序的输出结果（考点：全局变量作用域）" class="headerlink" title="4. 写出如下程序的输出结果（考点：全局变量作用域）"></a>4. 写出如下程序的输出结果（考点：全局变量作用域）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS[&apos;var1&apos;] = 5;</span><br><span class="line">$var2 = 1;</span><br><span class="line">function get_value()&#123;</span><br><span class="line">        global $var2;</span><br><span class="line">        $var1 = 0;</span><br><span class="line">        return $var2++;</span><br><span class="line">&#125;</span><br><span class="line">get_value();</span><br><span class="line"></span><br><span class="line">echo $var1;     //5</span><br><span class="line">echo $var2;     //2</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure><p><strong>全局变量的作用域问题：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function destroy_foo() </span><br><span class="line">&#123;</span><br><span class="line">        global $foo;</span><br><span class="line">        unset($foo);</span><br><span class="line">        // unset($GLOBALS[&apos;foo&apos;]);//清除全局变量$foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$foo = &apos;bar&apos;;</span><br><span class="line">destroy_foo();</span><br><span class="line">echo $foo;      //bar</span><br></pre></td></tr></table></figure></p><p>unset($foo) 的作用是清除函数内的 $foo变量，并没有清除全局变量的$foo，因此执行此函数后，变量仍存在。想要彻底清除$foo，需要清除掉全局变量里的$foo值。</p><hr><h5 id="5-写出如下程序的输出结果（考点：unset对于数组的作用）"><a href="#5-写出如下程序的输出结果（考点：unset对于数组的作用）" class="headerlink" title="5. 写出如下程序的输出结果（考点：unset对于数组的作用）"></a>5. 写出如下程序的输出结果（考点：unset对于数组的作用）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function get_arr($arr)&#123;</span><br><span class="line">        unset($arr[0]);</span><br><span class="line">&#125;</span><br><span class="line">function get_arr2(&amp;$arr)&#123;</span><br><span class="line">        unset($arr[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr1 = array(1, 2);</span><br><span class="line">$arr2 = array(1, 2);</span><br><span class="line"></span><br><span class="line">get_arr($arr1);</span><br><span class="line">get_arr2($arr2);</span><br><span class="line"></span><br><span class="line">echo count($arr1);      //2</span><br><span class="line">echo count($arr2);      //1</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;hr/&gt;&quot;;</span><br></pre></td></tr></table></figure><hr><h5 id="6-字符串强制转换为整型为0"><a href="#6-字符串强制转换为整型为0" class="headerlink" title="6. 字符串强制转换为整型为0"></a>6. 字符串强制转换为整型为0</h5><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;a1&quot;  =&gt; 0  //首字母a为字符，强制转换为整型为0</span><br><span class="line">&quot;1a&quot;  =&gt; 1      //首字母1为数字，强制转换为整型为1</span><br></pre></td></tr></table></figure></p><hr><h5 id="7-amp-与-amp-amp-的区别"><a href="#7-amp-与-amp-amp-的区别" class="headerlink" title="7. &amp; 与 &amp;&amp; 的区别"></a>7. &amp; 与 &amp;&amp; 的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;$b = 10;</span><br><span class="line"></span><br><span class="line">if($a &lt; 4 &amp;&amp; (++$a &gt; 10))&#123;&#125;</span><br><span class="line">if($b &lt; 4 &amp; (++$b &gt; 10))&#123;&#125;</span><br><span class="line"></span><br><span class="line">echo $a;</span><br><span class="line">echo $b;</span><br></pre></td></tr></table></figure><p>&amp; 是按位与操作符，两边都为 1 则为 1。左侧为false，也会运行右侧的代码。<br>&amp;&amp; 是逻辑与操作符，左侧为false，不运行右侧的代码。<br>相同点：都可进行 and 判断。</p><hr><h5 id="8-unset对于数组的作用"><a href="#8-unset对于数组的作用" class="headerlink" title="8. unset对于数组的作用"></a>8. unset对于数组的作用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$arr = array(</span><br><span class="line">        1=&gt; &apos;a&apos;,</span><br><span class="line">        2=&gt; &apos;bb&apos;,</span><br><span class="line">        3=&gt; &apos;c&apos;,</span><br><span class="line">        4=&gt; &apos;dd&apos;</span><br><span class="line">        );</span><br><span class="line">foreach($arr as $k=&gt;&amp;$v)&#123;</span><br><span class="line">        if($k == 3)&#123;</span><br><span class="line">                $v = &apos;x&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        // unset($v);   //保持键4 的值不变</span><br><span class="line">&#125;</span><br><span class="line">foreach($arr as $k=&gt;$v)&#123;</span><br><span class="line">        echo &quot;&#123;$k&#125;\t&#123;$v&#125;&lt;br/&gt;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：array(‘a’, ‘bb’, ‘x’, ‘x’);<br><em>为什么结果是这样？</em><br>　　因为满足条件语句之后，就把数组的值指向了’x’的内存地址了。因此后面的数组索引都是指向了’x’。<br><em>怎么能让 键4 的值不变？</em><br>　　使用 unset($v) 来清除 指针。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-写出如下程序的输出结果（考点：变量判空）&quot;&gt;&lt;a href=&quot;#1-写出如下程序的输出结果（考点：变量判空）&quot; class=&quot;headerlink&quot; title=&quot;1. 写出如下程序的输出结果（考点：变量判空）&quot;&gt;&lt;/a&gt;1. 写出如下程序的输出结果（考点：变量判空）&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$a1 = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a2 = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a3 = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a4 = &amp;apos;&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a5 = &amp;apos;0&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a6 = &amp;apos;null&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a7 = array();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$a8 = array(array());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a1) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a2) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a3) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a4) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a5) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //false  true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a6) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a7) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;br/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo empty($a8) ? &amp;apos;true&amp;apos; : &amp;apos;false&amp;apos;;             //true  false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;&amp;lt;hr/&amp;gt;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之netstat</title>
    <link href="http://yoursite.com/2018/06/11/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bnetstat/"/>
    <id>http://yoursite.com/2018/06/11/Linux命令之netstat/</id>
    <published>2018-06-11T08:06:20.000Z</published>
    <updated>2018-07-20T06:07:54.826Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat命令各个参数说明如下：</span><br><span class="line">-a : 显示全部端口</span><br><span class="line">　　-t : 指明显示TCP端口</span><br><span class="line">　　-u : 指明显示UDP端口</span><br><span class="line">　　-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)</span><br><span class="line">　　-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。</span><br><span class="line">　　-n : 不进行DNS轮询，显示IP(可以加速操作)</span><br></pre></td></tr></table></figure><a id="more"></a><p>即可显示当前服务器上所有端口及进程服务，于grep结合可查看某个具体端口及服务情况··<br><code>netstat -ntlp   //查看当前所有tcp端口·</code><br><code>netstat -ntulp |grep 80   //查看所有80端口使用情况·</code><br><code>netstat -an | grep 3306   //查看所有3306端口使用情况·</code></p><p><strong>查看一台服务器上面哪些服务及端口</strong><br><code>netstat  -lanp</code></p><p><strong>查看一个服务有几个端口。比如要查看mysqld</strong><br><code>ps -ef |grep mysqld</code></p><p><strong>查看某一端口的连接数量,比如3306端口</strong><br><code>netstat -pnt |grep :3306 |wc</code></p><p><strong>查看某一端口的连接客户端IP 比如3306端口</strong><br><code>netstat -anp |grep 3306</code></p><p><code>netstat -an 查看网络端口</code></p><p><code>lsof -i :port，使用lsof -i :port就能看见所指定端口运行的程序，同时还有当前连接。</code></p><p><code>nmap 端口扫描</code><br><code>netstat -nupl  (UDP类型的端口)</code><br><code>netstat -ntpl  (TCP类型的端口)</code><br><code>netstat -anp 显示系统端口使用情况</code></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;netstat命令各个参数说明如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	-a : 显示全部端口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-t : 指明显示TCP端口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-u : 指明显示UDP端口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　-n : 不进行DNS轮询，显示IP(可以加速操作)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
